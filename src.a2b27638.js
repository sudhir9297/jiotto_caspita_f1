// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/webgi/dist/examples/runtime/bundle.m.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeNormalsCaptureHelper = exports.CubeCamera = exports.ContactShadowGroundPlugin = exports.ConeGeometry = exports.ConeBufferGeometry = exports.CompressedTextureLoader = exports.CompressedTexture = exports.Compress = exports.ColorManagement = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CircleBufferGeometry = exports.CineonToneMapping = exports.CatmullRomCurve3 = exports.CapsuleGeometry = exports.CapsuleBufferGeometry = exports.CanvasTexture = exports.CanvasSnipperPlugin = exports.CanvasSnipper = exports.CanvasRecorderPlugin = exports.CanvasRecorder = exports.CameraViewPlugin = exports.CameraView = exports.CameraHelper = exports.CameraController = exports.Camera = exports.Cache = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxSelectionWidget = exports.BoxHelper = exports.BoxGeometry = exports.BoxBufferGeometry = exports.Box3Helper = exports.Box3B = exports.Box3 = exports.Box2 = exports.BooleanKeyframeTrack = exports.Bone = exports.BloomPlugin = exports.BlobLoader = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BaseRenderer = exports.BaseGroundPlugin = exports.BackSide = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.AsyncZlib = exports.AsyncZipDeflate = exports.AsyncUnzlib = exports.AsyncUnzipInflate = exports.AsyncInflate = exports.AsyncGzip = exports.AsyncGunzip = exports.AsyncDeflate = exports.AsyncDecompress = exports.AsyncCompress = exports.AssetManagerPlugin = exports.AssetManagerBasicPopupPlugin = exports.AssetImporter = exports.AssetExporterPlugin = exports.AssetExporter = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnisotropyPlugin = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AmbientLightProbe = exports.AmbientLight2 = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.AddBlendPass = exports.AViewerPlugin = exports.ARTouchInputHelper = exports.ARPlugin = exports.ARPlacementBox = exports.AMaterialManager = exports.ACESFilmicToneMapping = void 0;
exports.GLTFMaterialsLightMapExtensionName = exports.GLTFMaterialsBumpMapExtensionName = exports.GLTFMaterialsAlphaMapExtensionName = exports.GLTFLoader2 = exports.GLTFExporter2 = exports.GLTFDracoExporter = exports.GLTFDracoExportPlugin = exports.GLTFAnimationPlugin = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = exports.GBufferPlugin = exports.FullScreenPlugin = exports.Frustum = exports.FrontSide = exports.FramebufferTexture = exports.FrameFadePlugin = exports.FontLoader = exports.Font = exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.FlatShading = exports.FileLoader = exports.FSShadowMaterial = exports.FBXLoadPlugin = exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EncodeUTF8 = exports.EllipseCurve = exports.EffectComposer2 = exports.EdgesGeometry = exports.EasingFunctions = exports.EXRLoadPlugin = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DropzonePlugin = exports.Dropzone = exports.DoubleSide = exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight2 = exports.DirectionalLight = exports.DiamondPlugin = exports.DiamondMaterial = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthOfFieldPlugin = exports.DepthOfFieldPass = exports.DepthFormat = exports.Deflate = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.Decompress = exports.DecodeUTF8 = exports.DebugPlugin = exports.DataUtils = exports.DataUrlLoader = exports.DataTextureLoader = exports.DataTexture3D = exports.DataTexture2DArray = exports.DataTexture = exports.DataArrayTexture = exports.Data3DTexture = exports.Damper = exports.DRACOLoader2 = exports.DECAY_MILLISECONDS = exports.Cylindrical = exports.CylinderGeometry = exports.CylinderBufferGeometry = exports.CustomToneMapping = exports.CustomBumpMapPlugin = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = void 0;
exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = exports.MaterialPreviewGenerator = exports.MaterialManager = exports.MaterialLoader = exports.MaterialLibraryPlugin = exports.MaterialLibraryBasePlugin = exports.MaterialExtender = exports.MaterialConfiguratorPlugin = exports.MaterialConfiguratorBasePlugin = exports.Material = exports.MTLLoader2 = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearInterpolant = exports.LinearFilter = exports.LinearEncoding = exports.LineSegments = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.Layers = exports.LatheGeometry = exports.LatheBufferGeometry = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = exports.KTXLoadPlugin = exports.KTX2LoadPlugin = exports.KHR_TEXTURE_BASISU = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.Inflate = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.Importer = exports.ImmediateRenderObject = exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = exports.HierarchyUiPlugin = exports.HemisphereLightProbe = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.HDRiGroundPlugin = exports.Gzip = exports.Gunzip = exports.Group = exports.GroundPlugin = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GenericFilterPlugin = exports.GenericBlendTexturePass = exports.GLTFWriter2 = exports.GLTFMeshOptPlugin = void 0;
exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.ProgressivePlugin = exports.PositionalAudio = exports.PopmotionPlugin = exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointLightHelper = exports.PointLight = exports.PlaneHelper = exports.PlaneGeometry = exports.PlaneBufferGeometry = exports.Plane = exports.PickingPlugin = exports.PerspectiveCamera = exports.Path = exports.ParametricGeometry = exports.ParallaxMappingPlugin = exports.PMREMGeneratorPlugin = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OrthographicCamera = exports.OrbitControls2 = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.OctahedronBufferGeometry = exports.ObjectSpaceNormalMap = exports.ObjectRotationPlugin = exports.ObjectProcessorMap = exports.ObjectPicker = exports.ObjectLoader2 = exports.ObjectLoader = exports.Object3DModel = exports.Object3D = exports.ObjMtlLoadPlugin = exports.OBJLoader2 = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalCaptureMaterial = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoiseBumpMaterialPlugin = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MultiFilterPlugin = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial2 = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial = void 0;
exports.TOUCH = exports.SwitchNodePlugin = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight2 = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereSelectionWidget = exports.SphereGeometry = exports.SphereBufferGeometry = exports.Sphere = exports.Source = exports.SmoothShading = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.SimpleViewerUi = exports.SimpleTextPlugin = exports.SimpleTextExporter = exports.SimpleJSONLoader = exports.SimpleJSONExporter = exports.SimpleEventDispatcher = exports.SimpleDataSource = exports.SimpleBackgroundEnvUiPlugin = exports.SimpleAssetList = exports.ShortType = exports.ShapeUtils = exports.ShapeTubeExtrudePlugin = exports.ShapePath = exports.ShapeGeometry = exports.ShapeBufferGeometry = exports.Shape = exports.ShadowMaterial = exports.ShadowMapBaker = exports.ShaderPass2 = exports.ShaderMaterialEncodingSupport = exports.ShaderMaterial = exports.ShaderLib = exports.ShaderChunk = exports.SerializableOrbitControls = exports.SelectionWidget = exports.Scene = exports.STLLoadPlugin = exports.SSRPlugin = exports.SSContactShadows = exports.SSAOPlugin = exports.SRGBColorSpace = exports.SETTLING_TIME = exports.RootScene = exports.RingGeometry = exports.RingBufferGeometry = exports.Rhino3dmLoader2 = exports.Rhino3dmLoadPlugin = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.Reflector2 = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RandomizedDirectionalLightPlugin = exports.RandomizedDirectionalLight = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBFormat = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = void 0;
exports.beforeWrite = exports.beforeRead = exports.beforeMain = exports.basePlacements = exports.autoScaleObject3D = exports.auto = exports.arrow = exports.applyStyles = exports.animateTarget = exports.animateSet = exports.animatePromise = exports.animateObject = exports.animateAsync = exports.animate = exports.afterWrite = exports.afterRead = exports.afterMain = exports.addZipLoader = exports.addRGBELoader = exports.addGLTFLoader = exports.addGLTFExporter = exports.addDracoLoader = exports.addBasePlugins = exports._SRGBAFormat = exports.Zlib = exports.ZipPassThrough = exports.ZipLoader = exports.ZipDeflate = exports.Zip = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.WebGiViewerElement = exports.WebGLUtils = exports.WebGLRenderer = exports.WebGLRenderTarget = exports.WebGLMultisampleRenderTarget = exports.WebGLMultipleRenderTargets = exports.WebGLCubeRenderTarget = exports.WebGLArrayRenderTarget = exports.WebGL3DRenderTarget = exports.WebGL1Renderer = exports.ViewerState = exports.ViewerApp = exports.VideoTexture = exports.VelocityBufferPlugin = exports.VectorKeyframeTrack = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.Unzlib = exports.UnzipPassThrough = exports.UnzipInflate = exports.Unzip = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.UniformsGroup = exports.Uniform = exports.Uncharted2Tonemapping = exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.UVMapping = exports.TweakpaneWrapper = exports.TweakpaneUiPlugin = exports.TubeShapeGeometry = exports.TubeGeometry = exports.TubeBufferGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TransformControls2 = exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = exports.TorusGeometry = exports.TorusBufferGeometry = exports.TonemapPlugin = exports.TonemapPass = exports.ThreeMaterialLoader = exports.ThinFilmLayerPlugin = exports.TextureLoader = exports.Texture = exports.TextSVGOptions = exports.TextGeometry = exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = exports.TemporalAAPlugin = exports.TangentSpaceNormalMap = void 0;
exports.patchShaderEncodingSupport = exports.parseFileExtension = exports.onChange = exports.offset = exports.now = exports.modifierPhases = exports.mobileAndTabletCheck = exports.matDefine = exports.makeTextSvg = exports.makeSetterForAnimObject = exports.makeSetterFor = exports.makeFilter = exports.makeColorSvgCircle = exports.makeColorSvg = exports.main = exports.lerpAngle2 = exports.lerpAngle = exports.left = exports.isPropertyWritable = exports.isAnimatableType = exports.inflateSync = exports.inflate = exports.includesAll = exports.imageUrlToImageData = exports.imageToCanvas = exports.imageBitmapToBase64 = exports.iModelIgnoredUserData = exports.iMaterialIgnoredUserData = exports.iGeometryIgnoredUserData = exports.htmlToSvg = exports.htmlToPng = exports.htmlToCanvas = exports.html = exports.hide = exports.gzipSync = exports.gzip = exports.gunzipSync = exports.gunzip = exports.glsl = exports.getUrlQueryParam = exports.getTextureEncodingFromMap = exports.getTextureDataType = exports.getTexelEncodingFunction = exports.getTexelEncoding = exports.getTexelDecodingFunction = exports.getTexelDecoding2 = exports.getTexelDecoding = exports.getPropertyDescriptor = exports.getOrCall = exports.getKeyByValue = exports.getFilenameFromPath = exports.getEncodingComponents = exports.generateUiFolder = exports.generateUiConfig = exports.fontFormatExtensionMap = exports.flip = exports.flattenUiConfig = exports.extractAnimationKey = exports.eventListeners = exports.escapeRegExp = exports.envMapBackground = exports.end = exports.embedUrlRefs = exports.downloadFile = exports.downloadBlob = exports.diamondMaterialPropList = exports.detectOverflow = exports.deserializers = exports.deserializeObject = exports.deflateSync = exports.deflate = exports.deepAccessObject = exports.decompressSync = exports.decompress = exports.dataTextureFromVec4 = exports.dataTextureFromColor = exports.css = exports.createStyles = exports.createScriptFromURL = exports.createRenderTargetKey = exports.createPopperLite = exports.createPopperBase = exports.createPopper = exports.createImage = exports.createDiv = exports.createCanvasElement = exports.copyProps = exports.copyObjectUserData = exports.copyMaterialUserData = exports.computeStyles = exports.computeScreenSpaceBoundingBox = exports.computeOffsetMatrix = exports.compressSync = exports.compress = exports.combineDofShader = exports.clippingParents = exports.cRGBMToLinear = exports.cLinearToRGBM = exports.bottom = exports.blobToDataURL = void 0;
exports.zlibSync = exports.zlib = exports.zipSync = exports.zip = exports.writeFile = exports.write = exports.webgiObject3DExtrasExtension = exports.webgiMaterialExtrasExtension = exports.webgiLightExtrasExtension = exports.viewport = exports.viewerGLTFExtension = exports.verifyPermission = exports.variationPlacements = exports.vRGBMToLinear = exports.vLinearToRGBM = exports.uploadFile = exports.unzlibSync = exports.unzlib = exports.unzipSync = exports.unzip = exports.uniform = exports.uiVector = exports.uiToggle = exports.uiSlider = exports.uiMonitor = exports.uiInput = exports.uiImage = exports.uiFolder = exports.uiDropdown = exports.uiConfig = exports.uiColor = exports.uiButton = exports.top = exports.toTitleCase = exports.toIndexedGeometry = exports.timeout = exports.syncAnimSetUi = exports.svgUrl = exports.svgToPng = exports.svgToCanvas = exports.strToU8 = exports.strFromU8 = exports.start = exports.standardMaterialPropList = exports.sphericalFromObject = exports.snapObject = exports.slerp = exports.shaderReplaceString = exports.setupSandboxWebGiEditor = exports.setupObject3dModel = exports.setupIModel = exports.setupCoreWebGiViewer = exports.setUrlQueryParam = exports.setThreeRendererMode = exports.setMeshMaterial = exports.setMeshGeometry = exports.serializers = exports.serializeObject = exports.serialize = exports.serializable = exports.safeSetProperty = exports.sRGBEncoding = exports.rotateDuplicatedMesh = exports.right = exports.replaceAll = exports.removeDuplicateGeometries = exports.reference = exports.read = exports.processViewer = exports.preventOverflow = exports.popperOffsets = exports.popperGenerator = exports.popper = exports.placements = exports.physicalMaterialPropList = exports.pathJoin = void 0;

/*! For license information please see bundle.m.js.LICENSE.txt */
var __webpackgi_modules__ = {
  798: function (e, t, n) {
    var r = n(352),
        i = n.n(r)()(function (e) {
      return e[1];
    });
    i.push([e.id, "#assetManagerPopup{z-index:300;position:absolute;bottom:2rem;right:2rem;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);color:#fff;background-blend-mode:luminosity;background-color:#28223CAA;padding:1.5rem;font-size:1rem;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:80vw;max-height:80vh;overflow-y:scroll;border-radius:.5rem;height:-webkit-max-content;height:-moz-max-content;height:max-content}#assetManagerPopupClose{position:absolute;top:0;right:0;padding:.5rem;cursor:pointer}#assetManagerPopupContent{padding-top:.5rem}.processState{font-weight:bold}", ""]), t.Z = i;
  },
  898: function (e, t, n) {
    var r = n(352),
        i = n.n(r)()(function (e) {
      return e[1];
    });
    i.push([e.id, ':root{--tp-blade-unit-size: 24px;--tp-element-border-radius: 0.25rem;--tp-base-background-color: #28223C;--tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);--tp-button-background-color: hsla(230, 10%, 80%, 1.00);--tp-button-background-color-active: hsla(230, 10%, 95%, 1.00);--tp-button-background-color-focus: hsla(230, 10%, 90%, 1.00);--tp-button-background-color-hover: hsla(230, 10%, 85%, 1.00);--tp-button-foreground-color: hsla(230, 20%, 11%, 1.00);--tp-container-background-color: hsla(230, 25%, 16%, 0.65);--tp-container-background-color-active: hsla(230, 25%, 31%, 0.65);--tp-container-background-color-focus: hsla(230, 25%, 26%, 0.65);--tp-container-background-color-hover: hsla(230, 25%, 21%, 0.65);--tp-container-foreground-color: hsl(240, 10%, 92%);--tp-groove-foreground-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color-active: hsla(230, 28%, 23%, 1.00);--tp-input-background-color-focus: hsla(230, 28%, 18%, 1.00);--tp-input-background-color-hover: hsla(230, 20%, 13%, 1.00);--tp-input-foreground-color: hsla(230, 10%, 80%, 1.00);--tp-monitor-background-color: hsla(230, 20%, 8%, 1.00);--tp-monitor-foreground-color: hsla(230, 12%, 48%, 1.00);--tp-label-foreground-color: #E4E2ED;--tp-font-family: "Inter"}.tp-fldv{margin-top:.25rem;margin-bottom:.25rem;background-blend-mode:luminosity;position:relative}.tp-fldv .tp-fldv{margin-top:.5rem;margin-bottom:.5rem}.tp-fldv .tp-brkv{background-color:rgba(32,32,50,.85)}.tp-fldv .tp-fldv .tp-brkv{background-color:rgba(32,32,50,.25) !important}.tp-fldv-expanded>.tp-fldv_b{background-color:rgba(32,32,50,.8) !important}.tp-fldv_b{height:calc(var(--bld-us)*1.5 + 4px) !important;font-size:.85rem !important}.tp-fldv_b+.tp-brkv .tp-fldv_b{height:calc(var(--bld-us)*1.1 + 4px) !important;font-size:.65rem !important}.tp-lblv_l{font-size:.7rem !important;font-weight:400 !important}.tp-txtv_i{font-size:.7rem !important;font-weight:400 !important}.tp-fldv_t{font-weight:400 !important;padding-left:1.5rem !important}.tp-fldv_m{right:auto !important;left:.75rem;opacity:1 !important}.pluginOptionsButton{position:absolute;right:0;top:.75rem;padding-left:.5rem;padding-right:.5rem;height:-webkit-min-content;height:-moz-min-content;height:min-content;background:transparent;color:#eee;border:none}', ""]), t.Z = i;
  },
  927: function (e, t, n) {
    n.d(t, {
      LY2: function () {
        return ne;
      },
      bGH: function () {
        return T;
      },
      NDo: function () {
        return J;
      },
      gSk: function () {
        return Ct;
      },
      WMw: function () {
        return y;
      },
      OTo: function () {
        return Le;
      },
      Se2: function () {
        return V;
      },
      cum: function () {
        return sn;
      },
      Mig: function () {
        return qp;
      },
      i_9: function () {
        return ph;
      },
      m7l: function () {
        return bp;
      },
      sYA: function () {
        return Ap;
      },
      Xcj: function () {
        return jh;
      },
      mzJ: function () {
        return Nh;
      },
      ZZA: function () {
        return op;
      },
      T__: function () {
        return Mc;
      },
      HkE: function () {
        return nl;
      },
      tGC: function () {
        return Pd;
      },
      BbS: function () {
        return Sh;
      },
      kqm: function () {
        return Rh;
      },
      Hmr: function () {
        return lh;
      },
      SJI: function () {
        return wh;
      },
      mTL: function () {
        return ch;
      },
      y8_: function () {
        return Dd;
      },
      _Li: function () {
        return _;
      },
      z81: function () {
        return Ft;
      },
      _MY: function () {
        return u;
      },
      N$j: function () {
        return Gl;
      },
      _YM: function () {
        return hp;
      },
      TUj: function () {
        return $h;
      },
      ZzF: function () {
        return pr;
      },
      GQ: function () {
        return Ed;
      },
      nvb: function () {
        return ps;
      },
      DvJ: function () {
        return ps;
      },
      fQA: function () {
        return Td;
      },
      TlE: function () {
        return Ai;
      },
      u9r: function () {
        return Wi;
      },
      s4_: function () {
        return th;
      },
      T95: function () {
        return Me;
      },
      CtF: function () {
        return yp;
      },
      V1s: function () {
        return ms;
      },
      Rki: function () {
        return wd;
      },
      ROQ: function () {
        return yc;
      },
      YN5: function () {
        return Wc;
      },
      BVQ: function () {
        return Wc;
      },
      YT8: function () {
        return kc;
      },
      YGz: function () {
        return te;
      },
      trn: function () {
        return Kc;
      },
      zf8: function () {
        return Kc;
      },
      uWy: function () {
        return pe;
      },
      SUY: function () {
        return mh;
      },
      Ilk: function () {
        return Xn;
      },
      R2R: function () {
        return dp;
      },
      epp: function () {
        return jn;
      },
      EB7: function () {
        return xc;
      },
      DqL: function () {
        return Cp;
      },
      _3: function () {
        return qc;
      },
      b_z: function () {
        return qc;
      },
      _am: function () {
        return bs;
      },
      fY$: function () {
        return se;
      },
      vxC: function () {
        return oe;
      },
      BtG: function () {
        return xs;
      },
      cBK: function () {
        return kp;
      },
      g8_: function () {
        return ce;
      },
      AXT: function () {
        return Lc;
      },
      yj7: function () {
        return Ic;
      },
      dYG: function () {
        return lp;
      },
      tm_: function () {
        return a;
      },
      S2y: function () {
        return l;
      },
      B02: function () {
        return c;
      },
      PeU: function () {
        return o;
      },
      Hyl: function () {
        return wc;
      },
      Wqd: function () {
        return Vc;
      },
      Xaj: function () {
        return M;
      },
      dZ3: function () {
        return re;
      },
      m_w: function () {
        return Xc;
      },
      fHI: function () {
        return Xc;
      },
      LBq: function () {
        return Zh;
      },
      JUT: function () {
        return ir;
      },
      p3g: function () {
        return nr;
      },
      IEO: function () {
        return Hl;
      },
      CN8: function () {
        return Yd;
      },
      zob: function () {
        return Zd;
      },
      yxD: function () {
        return Pp;
      },
      A5E: function () {
        return Vd;
      },
      jfJ: function () {
        return Xt;
      },
      T_J: function () {
        return Yt;
      },
      tEQ: function () {
        return Sp;
      },
      qkB: function () {
        return Be;
      },
      brP: function () {
        return je;
      },
      $YQ: function () {
        return ol;
      },
      Ox3: function () {
        return Xp;
      },
      cBI: function () {
        return bd;
      },
      cU9: function () {
        return up;
      },
      DT1: function () {
        return Zc;
      },
      Kgo: function () {
        return Zc;
      },
      ehD: function () {
        return m;
      },
      fSK: function () {
        return F;
      },
      Vdb: function () {
        return U;
      },
      l8J: function () {
        return dn;
      },
      dj0: function () {
        return an;
      },
      QM0: function () {
        return un;
      },
      TOt: function () {
        return tu;
      },
      Ny0: function () {
        return Sc;
      },
      eD: function () {
        return W;
      },
      jwo: function () {
        return Qt;
      },
      dSO: function () {
        return ae;
      },
      Bf4: function () {
        return le;
      },
      USm: function () {
        return Yr;
      },
      pBf: function () {
        return vn;
      },
      $Vf: function () {
        return ku;
      },
      O7d: function () {
        return ku;
      },
      hH6: function () {
        return Ep;
      },
      esl: function () {
        return g;
      },
      e62: function () {
        return Ii;
      },
      a$l: function () {
        return Fi;
      },
      OM3: function () {
        return Ni;
      },
      VzW: function () {
        return Re;
      },
      ybr: function () {
        return dl;
      },
      yo9: function () {
        return hl;
      },
      Zxw: function () {
        return Kd;
      },
      JfN: function () {
        return Wd;
      },
      Wzm: function () {
        return bc;
      },
      Wl3: function () {
        return f;
      },
      iWj: function () {
        return Cs;
      },
      ylh: function () {
        return Wh;
      },
      v9Y: function () {
        return _n;
      },
      LSk: function () {
        return mn;
      },
      w$m: function () {
        return X;
      },
      ksN: function () {
        return K;
      },
      j4z: function () {
        return rn;
      },
      OAl: function () {
        return tn;
      },
      VLJ: function () {
        return fd;
      },
      ZAu: function () {
        return rl;
      },
      cLu: function () {
        return ke;
      },
      vmT: function () {
        return Lp;
      },
      Qpg: function () {
        return dd;
      },
      So8: function () {
        return uh;
      },
      Wjw: function () {
        return Du;
      },
      cJO: function () {
        return Du;
      },
      QRU: function () {
        return oh;
      },
      S3k: function () {
        return Rp;
      },
      PpQ: function () {
        return Yn;
      },
      AHu: function () {
        return Xd;
      },
      ZRs: function () {
        return Kt;
      },
      oqc: function () {
        return qt;
      },
      lb7: function () {
        return ql;
      },
      L5s: function () {
        return eh;
      },
      $TI: function () {
        return Hh;
      },
      SPe: function () {
        return Ql;
      },
      aVm: function () {
        return Pi;
      },
      j87: function () {
        return Oi;
      },
      RNb: function () {
        return Ci;
      },
      Kz5: function () {
        return Ae;
      },
      vpT: function () {
        return _l;
      },
      kB5: function () {
        return gl;
      },
      _C8: function () {
        return ap;
      },
      Syv: function () {
        return yt;
      },
      NMF: function () {
        return wt;
      },
      pIN: function () {
        return St;
      },
      eMJ: function () {
        return Zt;
      },
      x5V: function () {
        return Ht;
      },
      tUh: function () {
        return pp;
      },
      z8B: function () {
        return Fl;
      },
      GZb: function () {
        return Hc;
      },
      p7y: function () {
        return Hc;
      },
      S9g: function () {
        return Zr;
      },
      Zr5: function () {
        return G;
      },
      vCF: function () {
        return H;
      },
      yt0: function () {
        return en;
      },
      uXU: function () {
        return $t;
      },
      _kC: function () {
        return Op;
      },
      lk7: function () {
        return Jp;
      },
      x12: function () {
        return oc;
      },
      Zzh: function () {
        return td;
      },
      nls: function () {
        return ec;
      },
      g_z: function () {
        return Fc;
      },
      U7: function () {
        return Nc;
      },
      FT0: function () {
        return Qu;
      },
      blk: function () {
        return uc;
      },
      ejS: function () {
        return cc;
      },
      rnI: function () {
        return Dt;
      },
      wem: function () {
        return ve;
      },
      lfu: function () {
        return cp;
      },
      FDw: function () {
        return we;
      },
      lRj: function () {
        return xe;
      },
      D1R: function () {
        return ye;
      },
      qyh: function () {
        return be;
      },
      GUF: function () {
        return Vt;
      },
      EoG: function () {
        return Q;
      },
      aNw: function () {
        return Mp;
      },
      Zp0: function () {
        return Qp;
      },
      lLk: function () {
        return wp;
      },
      jAl: function () {
        return vt;
      },
      uEv: function () {
        return xt;
      },
      YKA: function () {
        return bt;
      },
      cRx: function () {
        return Ue;
      },
      Y8D: function () {
        return Ne;
      },
      RsA: function () {
        return i;
      },
      F5T: function () {
        return Si;
      },
      u7G: function () {
        return $p;
      },
      M8C: function () {
        return kn;
      },
      Vkp: function () {
        return Dn;
      },
      yGw: function () {
        return Br;
      },
      Sm8: function () {
        return R;
      },
      Kj0: function () {
        return cs;
      },
      vBJ: function () {
        return Mi;
      },
      lRF: function () {
        return Za;
      },
      Lun: function () {
        return Ja;
      },
      YBo: function () {
        return Ju;
      },
      kaV: function () {
        return $u;
      },
      RSm: function () {
        return Zu;
      },
      xoR: function () {
        return qu;
      },
      EJi: function () {
        return Xu;
      },
      Wid: function () {
        return Ku;
      },
      IKL: function () {
        return Yu;
      },
      r_: function () {
        return C;
      },
      OoA: function () {
        return he;
      },
      qhX: function () {
        return Z;
      },
      M5h: function () {
        return S;
      },
      Ns1: function () {
        return Y;
      },
      TyD: function () {
        return de;
      },
      vZf: function () {
        return ge;
      },
      HTd: function () {
        return _e;
      },
      aH4: function () {
        return me;
      },
      YLQ: function () {
        return fe;
      },
      BVF: function () {
        return z;
      },
      MyG: function () {
        return Jt;
      },
      jFi: function () {
        return b;
      },
      aCh: function () {
        return jt;
      },
      uL9: function () {
        return $;
      },
      IFH: function () {
        return At;
      },
      bdR: function () {
        return x;
      },
      M6v: function () {
        return q;
      },
      RvT: function () {
        return nn;
      },
      dUE: function () {
        return fp;
      },
      Tme: function () {
        return ui;
      },
      Gql: function () {
        return nh;
      },
      PA7: function () {
        return Bt;
      },
      REq: function () {
        return Ou;
      },
      pQR: function () {
        return Ou;
      },
      ghN: function () {
        return P;
      },
      Hy8: function () {
        return N;
      },
      Wpd: function () {
        return B;
      },
      LgZ: function () {
        return I;
      },
      iWC: function () {
        return O;
      },
      iKG: function () {
        return zs;
      },
      _iA: function () {
        return p;
      },
      ntZ: function () {
        return h;
      },
      anP: function () {
        return Ys;
      },
      jjw: function () {
        return Gd;
      },
      y$t: function () {
        return Gc;
      },
      cPb: function () {
        return gs;
      },
      JOQ: function () {
        return Ts;
      },
      BKK: function () {
        return Ps;
      },
      _12: function () {
        return Ps;
      },
      tJx: function () {
        return Ad;
      },
      cek: function () {
        return Wp;
      },
      xG9: function () {
        return cd;
      },
      woe: function () {
        return mc;
      },
      UY4: function () {
        return pc;
      },
      aq0: function () {
        return _d;
      },
      ujx: function () {
        return Yc;
      },
      Uol: function () {
        return Yc;
      },
      VYz: function () {
        return Ch;
      },
      iUV: function () {
        return Fh;
      },
      tf: function () {
        return kh;
      },
      ZQ6: function () {
        return Uc;
      },
      mXe: function () {
        return Bc;
      },
      _fP: function () {
        return ar;
      },
      iLg: function () {
        return mp;
      },
      zbs: function () {
        return _p;
      },
      UZH: function () {
        return r;
      },
      mSO: function () {
        return Nt;
      },
      wk1: function () {
        return Fe;
      },
      E2K: function () {
        return We;
      },
      FUD: function () {
        return ft;
      },
      pKu: function () {
        return pt;
      },
      GG6: function () {
        return ht;
      },
      Gih: function () {
        return dt;
      },
      iiP: function () {
        return _t;
      },
      SvJ: function () {
        return mt;
      },
      ptH: function () {
        return rt;
      },
      jZA: function () {
        return it;
      },
      y2t: function () {
        return st;
      },
      gi4: function () {
        return ot;
      },
      Djp: function () {
        return at;
      },
      BG$: function () {
        return lt;
      },
      NYV: function () {
        return ct;
      },
      xJs: function () {
        return ut;
      },
      bsb: function () {
        return gt;
      },
      ekQ: function () {
        return nt;
      },
      CaW: function () {
        return Qe;
      },
      eaV: function () {
        return $e;
      },
      BFQ: function () {
        return Xe;
      },
      v3W: function () {
        return qe;
      },
      ILR: function () {
        return Ye;
      },
      UCm: function () {
        return Ie;
      },
      Inb: function () {
        return It;
      },
      LgE: function () {
        return Lt;
      },
      fto: function () {
        return et;
      },
      l0P: function () {
        return tt;
      },
      vCx: function () {
        return Je;
      },
      _AM: function () {
        return Ze;
      },
      wuA: function () {
        return Ke;
      },
      av9: function () {
        return Ge;
      },
      CtA: function () {
        return He;
      },
      FIo: function () {
        return Wu;
      },
      zHn: function () {
        return Ur;
      },
      iMs: function () {
        return Kh;
      },
      T_f: function () {
        return Yp;
      },
      hEm: function () {
        return ze;
      },
      D9w: function () {
        return Ve;
      },
      CdI: function () {
        return ee;
      },
      rpg: function () {
        return ue;
      },
      ce8: function () {
        return Wt;
      },
      rOj: function () {
        return A;
      },
      V4E: function () {
        return Lu;
      },
      o8S: function () {
        return Lu;
      },
      KI_: function () {
        return zt;
      },
      xsS: function () {
        return fl;
      },
      WdD: function () {
        return Ds;
      },
      Vj0: function () {
        return Ls;
      },
      jyz: function () {
        return _s;
      },
      Tn7: function () {
        return Hu;
      },
      bnF: function () {
        return nu;
      },
      HW6: function () {
        return Iu;
      },
      oa8: function () {
        return Iu;
      },
      T_1: function () {
        return Od;
      },
      iDF: function () {
        return Au;
      },
      iAb: function () {
        return Te;
      },
      OdW: function () {
        return Xl;
      },
      _YX: function () {
        return ad;
      },
      TUv: function () {
        return Vl;
      },
      wcA: function () {
        return v;
      },
      Hw6: function () {
        return Zn;
      },
      aLr: function () {
        return kr;
      },
      Aip: function () {
        return Fu;
      },
      xo$: function () {
        return Fu;
      },
      $V: function () {
        return Yh;
      },
      lDi: function () {
        return Zp;
      },
      gti: function () {
        return jc;
      },
      PMe: function () {
        return jp;
      },
      FvO: function () {
        return rd;
      },
      jyi: function () {
        return Dl;
      },
      xeV: function () {
        return vl;
      },
      k74: function () {
        return L;
      },
      RlZ: function () {
        return j;
      },
      KhW: function () {
        return D;
      },
      HgB: function () {
        return hn;
      },
      W2J: function () {
        return on;
      },
      JWc: function () {
        return cn;
      },
      u37: function () {
        return _h;
      },
      Z6B: function () {
        return fn;
      },
      QZ1: function () {
        return ln;
      },
      Ir4: function () {
        return pn;
      },
      NwF: function () {
        return gp;
      },
      Wbm: function () {
        return E;
      },
      N4l: function () {
        return w;
      },
      QmN: function () {
        return s;
      },
      IOt: function () {
        return Ut;
      },
      L5g: function () {
        return Nu;
      },
      H$k: function () {
        return Nu;
      },
      MP$: function () {
        return Hd;
      },
      xEZ: function () {
        return Qn;
      },
      dpR: function () {
        return Dp;
      },
      Cne: function () {
        return Uu;
      },
      XvJ: function () {
        return Uu;
      },
      XZw: function () {
        return Bu;
      },
      FE5: function () {
        return Bu;
      },
      CJI: function () {
        return yi;
      },
      z$h: function () {
        return Pt;
      },
      UlW: function () {
        return kt;
      },
      WwZ: function () {
        return Rt;
      },
      Lcc: function () {
        return ju;
      },
      WXh: function () {
        return ju;
      },
      xfE: function () {
        return ie;
      },
      qlB: function () {
        return Di;
      },
      lCJ: function () {
        return Li;
      },
      WTc: function () {
        return Ri;
      },
      rAo: function () {
        return ki;
      },
      xWb: function () {
        return zh;
      },
      gH0: function () {
        return Gh;
      },
      rBU: function () {
        return Os;
      },
      rDY: function () {
        return fs;
      },
      ywz: function () {
        return Se;
      },
      wJv: function () {
        return Oe;
      },
      JQ4: function () {
        return Ce;
      },
      k0A: function () {
        return Pe;
      },
      irR: function () {
        return De;
      },
      LsT: function () {
        return Ee;
      },
      dwk: function () {
        return d;
      },
      FM8: function () {
        return Pn;
      },
      Pa4: function () {
        return lr;
      },
      Ltg: function () {
        return er;
      },
      yC1: function () {
        return vp;
      },
      fO1: function () {
        return vc;
      },
      b5g: function () {
        return pl;
      },
      Ywn: function () {
        return sr;
      },
      GVz: function () {
        return rr;
      },
      oAp: function () {
        return ys;
      },
      kFz: function () {
        return or;
      },
      p7A: function () {
        return qd;
      },
      dd2: function () {
        return tr;
      },
      CP7: function () {
        return ul;
      },
      fQK: function () {
        return tl;
      },
      Uk6: function () {
        return zu;
      },
      _sL: function () {
        return Et;
      },
      Pnf: function () {
        return Mt;
      },
      c8b: function () {
        return k;
      },
      _lf: function () {
        return Tt;
      },
      ad5: function () {
        return Gt;
      },
      L_r: function () {
        return gn;
      },
      knz: function () {
        return Ot;
      }
    });
    const r = "143dev",
          i = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2
    },
          s = {
      ROTATE: 0,
      PAN: 1,
      DOLLY_PAN: 2,
      DOLLY_ROTATE: 3
    },
          o = 0,
          a = 1,
          l = 2,
          c = 3,
          u = 0,
          p = 1,
          h = 2,
          d = 3,
          f = 0,
          _ = 1,
          m = 2,
          g = 1,
          v = 2,
          b = 0,
          x = 1,
          y = 2,
          w = 3,
          S = 4,
          M = 5,
          T = 100,
          E = 101,
          A = 102,
          C = 103,
          R = 104,
          k = 200,
          P = 201,
          D = 202,
          O = 203,
          L = 204,
          I = 205,
          F = 206,
          N = 207,
          U = 208,
          B = 209,
          j = 210,
          z = 0,
          V = 1,
          G = 2,
          H = 3,
          W = 4,
          K = 5,
          X = 6,
          q = 7,
          Y = 0,
          Z = 1,
          J = 2,
          $ = 0,
          Q = 1,
          ee = 2,
          te = 3,
          ne = 4,
          re = 5,
          ie = 300,
          se = 301,
          oe = 302,
          ae = 303,
          le = 304,
          ce = 306,
          ue = 1e3,
          pe = 1001,
          he = 1002,
          de = 1003,
          fe = 1004,
          _e = 1004,
          me = 1005,
          ge = 1005,
          ve = 1006,
          be = 1007,
          xe = 1007,
          ye = 1008,
          we = 1008,
          Se = 1009,
          Me = 1010,
          Te = 1011,
          Ee = 1012,
          Ae = 1013,
          Ce = 1014,
          Re = 1015,
          ke = 1016,
          Pe = 1017,
          De = 1018,
          Oe = 1020,
          Le = 1021,
          Ie = 1022,
          Fe = 1023,
          Ne = 1024,
          Ue = 1025,
          Be = 1026,
          je = 1027,
          ze = 1028,
          Ve = 1029,
          Ge = 1030,
          He = 1031,
          We = 1033,
          Ke = 33776,
          Xe = 33777,
          qe = 33778,
          Ye = 33779,
          Ze = 35840,
          Je = 35841,
          $e = 35842,
          Qe = 35843,
          et = 36196,
          tt = 37492,
          nt = 37496,
          rt = 37808,
          it = 37809,
          st = 37810,
          ot = 37811,
          at = 37812,
          lt = 37813,
          ct = 37814,
          ut = 37815,
          pt = 37816,
          ht = 37817,
          dt = 37818,
          ft = 37819,
          _t = 37820,
          mt = 37821,
          gt = 36492,
          vt = 2200,
          bt = 2201,
          xt = 2202,
          yt = 2300,
          wt = 2301,
          St = 2302,
          Mt = 2400,
          Tt = 2401,
          Et = 2402,
          At = 2500,
          Ct = 2501,
          Rt = 0,
          kt = 1,
          Pt = 2,
          Dt = 3e3,
          Ot = 3001,
          Lt = 3004,
          It = 3005,
          Ft = 3200,
          Nt = 3201,
          Ut = 0,
          Bt = 1,
          jt = "",
          zt = "srgb",
          Vt = "srgb-linear",
          Gt = 0,
          Ht = 7680,
          Wt = 7681,
          Kt = 7682,
          Xt = 7683,
          qt = 34055,
          Yt = 34056,
          Zt = 5386,
          Jt = 512,
          $t = 513,
          Qt = 514,
          en = 515,
          tn = 516,
          nn = 517,
          rn = 518,
          sn = 519,
          on = 35044,
          an = 35048,
          ln = 35040,
          cn = 35045,
          un = 35049,
          pn = 35041,
          hn = 35046,
          dn = 35050,
          fn = 35042,
          _n = "100",
          mn = "300 es",
          gn = 1035;

    class vn {
      addEventListener(e, t) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
      }

      hasEventListener(e, t) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[e] && -1 !== n[e].indexOf(t);
      }

      removeEventListener(e, t) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[e];

        if (void 0 !== n) {
          const e = n.indexOf(t);
          -1 !== e && n.splice(e, 1);
        }
      }

      dispatchEvent(e) {
        if (void 0 === this._listeners) return;
        const t = this._listeners[e.type];

        if (void 0 !== t) {
          e.target = this;
          const n = t.slice(0);

          for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);

          e.target = null;
        }
      }

    }

    const bn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    let xn = 1234567;
    const yn = Math.PI / 180,
          wn = 180 / Math.PI;

    function Sn() {
      const e = 4294967295 * Math.random() | 0,
            t = 4294967295 * Math.random() | 0,
            n = 4294967295 * Math.random() | 0,
            r = 4294967295 * Math.random() | 0;
      return (bn[255 & e] + bn[e >> 8 & 255] + bn[e >> 16 & 255] + bn[e >> 24 & 255] + "-" + bn[255 & t] + bn[t >> 8 & 255] + "-" + bn[t >> 16 & 15 | 64] + bn[t >> 24 & 255] + "-" + bn[63 & n | 128] + bn[n >> 8 & 255] + "-" + bn[n >> 16 & 255] + bn[n >> 24 & 255] + bn[255 & r] + bn[r >> 8 & 255] + bn[r >> 16 & 255] + bn[r >> 24 & 255]).toLowerCase();
    }

    function Mn(e, t, n) {
      return Math.max(t, Math.min(n, e));
    }

    function Tn(e, t) {
      return (e % t + t) % t;
    }

    function En(e, t, n) {
      return (1 - n) * e + n * t;
    }

    function An(e) {
      return 0 == (e & e - 1) && 0 !== e;
    }

    function Cn(e) {
      return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
    }

    function Rn(e) {
      return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
    }

    var kn = Object.freeze({
      __proto__: null,
      DEG2RAD: yn,
      RAD2DEG: wn,
      generateUUID: Sn,
      clamp: Mn,
      euclideanModulo: Tn,
      mapLinear: function (e, t, n, r, i) {
        return r + (e - t) * (i - r) / (n - t);
      },
      inverseLerp: function (e, t, n) {
        return e !== t ? (n - e) / (t - e) : 0;
      },
      lerp: En,
      damp: function (e, t, n, r) {
        return En(e, t, 1 - Math.exp(-n * r));
      },
      pingpong: function (e, t = 1) {
        return t - Math.abs(Tn(e, 2 * t) - t);
      },
      smoothstep: function (e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
      },
      smootherstep: function (e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
      },
      randInt: function (e, t) {
        return e + Math.floor(Math.random() * (t - e + 1));
      },
      randFloat: function (e, t) {
        return e + Math.random() * (t - e);
      },
      randFloatSpread: function (e) {
        return e * (.5 - Math.random());
      },
      seededRandom: function (e) {
        void 0 !== e && (xn = e);
        let t = xn += 1831565813;
        return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296;
      },
      degToRad: function (e) {
        return e * yn;
      },
      radToDeg: function (e) {
        return e * wn;
      },
      isPowerOfTwo: An,
      ceilPowerOfTwo: Cn,
      floorPowerOfTwo: Rn,
      setQuaternionFromProperEuler: function (e, t, n, r, i) {
        const s = Math.cos,
              o = Math.sin,
              a = s(n / 2),
              l = o(n / 2),
              c = s((t + r) / 2),
              u = o((t + r) / 2),
              p = s((t - r) / 2),
              h = o((t - r) / 2),
              d = s((r - t) / 2),
              f = o((r - t) / 2);

        switch (i) {
          case "XYX":
            e.set(a * u, l * p, l * h, a * c);
            break;

          case "YZY":
            e.set(l * h, a * u, l * p, a * c);
            break;

          case "ZXZ":
            e.set(l * p, l * h, a * u, a * c);
            break;

          case "XZX":
            e.set(a * u, l * f, l * d, a * c);
            break;

          case "YXY":
            e.set(l * d, a * u, l * f, a * c);
            break;

          case "ZYZ":
            e.set(l * f, l * d, a * u, a * c);
            break;

          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
        }
      },
      normalize: function (e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;

          case Uint16Array:
            return Math.round(65535 * e);

          case Uint8Array:
            return Math.round(255 * e);

          case Int16Array:
            return Math.round(32767 * e);

          case Int8Array:
            return Math.round(127 * e);

          default:
            throw new Error("Invalid component type.");
        }
      },
      denormalize: function (e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;

          case Uint16Array:
            return e / 65535;

          case Uint8Array:
            return e / 255;

          case Int16Array:
            return Math.max(e / 32767, -1);

          case Int8Array:
            return Math.max(e / 127, -1);

          default:
            throw new Error("Invalid component type.");
        }
      }
    });

    class Pn {
      constructor(e = 0, t = 0) {
        Pn.prototype.isVector2 = !0, this.x = e, this.y = t;
      }

      get width() {
        return this.x;
      }

      set width(e) {
        this.x = e;
      }

      get height() {
        return this.y;
      }

      set height(e) {
        this.y = e;
      }

      set(e, t) {
        return this.x = e, this.y = t, this;
      }

      setScalar(e) {
        return this.x = e, this.y = e, this;
      }

      setX(e) {
        return this.x = e, this;
      }

      setY(e) {
        return this.y = e, this;
      }

      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;

          case 1:
            this.y = t;
            break;

          default:
            throw new Error("index is out of range: " + e);
        }

        return this;
      }

      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          default:
            throw new Error("index is out of range: " + e);
        }
      }

      clone() {
        return new this.constructor(this.x, this.y);
      }

      copy(e) {
        return this.x = e.x, this.y = e.y, this;
      }

      add(e) {
        return this.x += e.x, this.y += e.y, this;
      }

      addScalar(e) {
        return this.x += e, this.y += e, this;
      }

      addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this;
      }

      addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this;
      }

      sub(e) {
        return this.x -= e.x, this.y -= e.y, this;
      }

      subScalar(e) {
        return this.x -= e, this.y -= e, this;
      }

      subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this;
      }

      multiply(e) {
        return this.x *= e.x, this.y *= e.y, this;
      }

      multiplyScalar(e) {
        return this.x *= e, this.y *= e, this;
      }

      divide(e) {
        return this.x /= e.x, this.y /= e.y, this;
      }

      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }

      applyMatrix3(e) {
        const t = this.x,
              n = this.y,
              r = e.elements;
        return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
      }

      min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
      }

      max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
      }

      clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
      }

      clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
      }

      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
      }

      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      }

      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      }

      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }

      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
      }

      negate() {
        return this.x = -this.x, this.y = -this.y, this;
      }

      dot(e) {
        return this.x * e.x + this.y * e.y;
      }

      cross(e) {
        return this.x * e.y - this.y * e.x;
      }

      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }

      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }

      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }

      normalize() {
        return this.divideScalar(this.length() || 1);
      }

      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }

      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }

      distanceToSquared(e) {
        const t = this.x - e.x,
              n = this.y - e.y;
        return t * t + n * n;
      }

      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
      }

      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }

      lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
      }

      lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
      }

      equals(e) {
        return e.x === this.x && e.y === this.y;
      }

      fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this;
      }

      toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e;
      }

      fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this;
      }

      rotateAround(e, t) {
        const n = Math.cos(t),
              r = Math.sin(t),
              i = this.x - e.x,
              s = this.y - e.y;
        return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this;
      }

      random() {
        return this.x = Math.random(), this.y = Math.random(), this;
      }

      *[Symbol.iterator]() {
        yield this.x, yield this.y;
      }

    }

    class Dn {
      constructor() {
        Dn.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }

      set(e, t, n, r, i, s, o, a, l) {
        const c = this.elements;
        return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this;
      }

      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }

      copy(e) {
        const t = this.elements,
              n = e.elements;
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
      }

      extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
      }

      setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
      }

      multiply(e) {
        return this.multiplyMatrices(this, e);
      }

      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }

      multiplyMatrices(e, t) {
        const n = e.elements,
              r = t.elements,
              i = this.elements,
              s = n[0],
              o = n[3],
              a = n[6],
              l = n[1],
              c = n[4],
              u = n[7],
              p = n[2],
              h = n[5],
              d = n[8],
              f = r[0],
              _ = r[3],
              m = r[6],
              g = r[1],
              v = r[4],
              b = r[7],
              x = r[2],
              y = r[5],
              w = r[8];
        return i[0] = s * f + o * g + a * x, i[3] = s * _ + o * v + a * y, i[6] = s * m + o * b + a * w, i[1] = l * f + c * g + u * x, i[4] = l * _ + c * v + u * y, i[7] = l * m + c * b + u * w, i[2] = p * f + h * g + d * x, i[5] = p * _ + h * v + d * y, i[8] = p * m + h * b + d * w, this;
      }

      multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
      }

      determinant() {
        const e = this.elements,
              t = e[0],
              n = e[1],
              r = e[2],
              i = e[3],
              s = e[4],
              o = e[5],
              a = e[6],
              l = e[7],
              c = e[8];
        return t * s * c - t * o * l - n * i * c + n * o * a + r * i * l - r * s * a;
      }

      invert() {
        const e = this.elements,
              t = e[0],
              n = e[1],
              r = e[2],
              i = e[3],
              s = e[4],
              o = e[5],
              a = e[6],
              l = e[7],
              c = e[8],
              u = c * s - o * l,
              p = o * a - c * i,
              h = l * i - s * a,
              d = t * u + n * p + r * h;
        if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const f = 1 / d;
        return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (o * n - r * s) * f, e[3] = p * f, e[4] = (c * t - r * a) * f, e[5] = (r * i - o * t) * f, e[6] = h * f, e[7] = (n * a - l * t) * f, e[8] = (s * t - n * i) * f, this;
      }

      transpose() {
        let e;
        const t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
      }

      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }

      transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
      }

      setUvTransform(e, t, n, r, i, s, o) {
        const a = Math.cos(i),
              l = Math.sin(i);
        return this.set(n * a, n * l, -n * (a * s + l * o) + s + e, -r * l, r * a, -r * (-l * s + a * o) + o + t, 0, 0, 1), this;
      }

      scale(e, t) {
        const n = this.elements;
        return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this;
      }

      rotate(e) {
        const t = Math.cos(e),
              n = Math.sin(e),
              r = this.elements,
              i = r[0],
              s = r[3],
              o = r[6],
              a = r[1],
              l = r[4],
              c = r[7];
        return r[0] = t * i + n * a, r[3] = t * s + n * l, r[6] = t * o + n * c, r[1] = -n * i + t * a, r[4] = -n * s + t * l, r[7] = -n * o + t * c, this;
      }

      translate(e, t) {
        const n = this.elements;
        return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this;
      }

      equals(e) {
        const t = this.elements,
              n = e.elements;

        for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;

        return !0;
      }

      fromArray(e, t = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];

        return this;
      }

      toArray(e = [], t = 0) {
        const n = this.elements;
        return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
      }

      clone() {
        return new this.constructor().fromArray(this.elements);
      }

    }

    function On(e) {
      for (let t = e.length - 1; t >= 0; --t) if (e[t] > 65535) return !0;

      return !1;
    }

    const Ln = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray: Uint8ClampedArray,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array
    };

    function In(e, t) {
      return new Ln[e](t);
    }

    function Fn(e) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", e);
    }

    function Nn(e) {
      return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
    }

    function Un(e) {
      return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055;
    }

    const Bn = {
      [zt]: {
        [Vt]: Nn
      },
      [Vt]: {
        [zt]: Un
      }
    },
          jn = {
      legacyMode: !0,

      get workingColorSpace() {
        return Vt;
      },

      set workingColorSpace(e) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      },

      convert: function (e, t, n) {
        if (this.legacyMode || t === n || !t || !n) return e;

        if (Bn[t] && void 0 !== Bn[t][n]) {
          const r = Bn[t][n];
          return e.r = r(e.r), e.g = r(e.g), e.b = r(e.b), e;
        }

        throw new Error("Unsupported color space conversion.");
      },
      fromWorkingColorSpace: function (e, t) {
        return this.convert(e, this.workingColorSpace, t);
      },
      toWorkingColorSpace: function (e, t) {
        return this.convert(e, t, this.workingColorSpace);
      }
    },
          zn = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    },
          Vn = {
      r: 0,
      g: 0,
      b: 0
    },
          Gn = {
      h: 0,
      s: 0,
      l: 0
    },
          Hn = {
      h: 0,
      s: 0,
      l: 0
    };

    function Wn(e, t, n) {
      return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e;
    }

    function Kn(e, t) {
      return t.r = e.r, t.g = e.g, t.b = e.b, t;
    }

    class Xn {
      constructor(e, t, n) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n);
      }

      set(e) {
        return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this;
      }

      setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this;
      }

      setHex(e, t = zt) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, jn.toWorkingColorSpace(this, t), this;
      }

      setRGB(e, t, n, r = Vt) {
        return this.r = e, this.g = t, this.b = n, jn.toWorkingColorSpace(this, r), this;
      }

      setHSL(e, t, n, r = Vt) {
        if (e = Tn(e, 1), t = Mn(t, 0, 1), n = Mn(n, 0, 1), 0 === t) this.r = this.g = this.b = n;else {
          const r = n <= .5 ? n * (1 + t) : n + t - n * t,
                i = 2 * n - r;
          this.r = Wn(i, r, e + 1 / 3), this.g = Wn(i, r, e), this.b = Wn(i, r, e - 1 / 3);
        }
        return jn.toWorkingColorSpace(this, r), this;
      }

      setStyle(e, t = zt) {
        function n(t) {
          void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
        }

        let r;

        if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
          let e;
          const i = r[1],
                s = r[2];

          switch (i) {
            case "rgb":
            case "rgba":
              if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, jn.toWorkingColorSpace(this, t), n(e[4]), this;
              if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, jn.toWorkingColorSpace(this, t), n(e[4]), this;
              break;

            case "hsl":
            case "hsla":
              if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                const r = parseFloat(e[1]) / 360,
                      i = parseInt(e[2], 10) / 100,
                      s = parseInt(e[3], 10) / 100;
                return n(e[4]), this.setHSL(r, i, s, t);
              }

          }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
          const e = r[1],
                n = e.length;
          if (3 === n) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, jn.toWorkingColorSpace(this, t), this;
          if (6 === n) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, jn.toWorkingColorSpace(this, t), this;
        }

        return e && e.length > 0 ? this.setColorName(e, t) : this;
      }

      setColorName(e, t = zt) {
        const n = zn[e.toLowerCase()];
        return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
      }

      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }

      copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this;
      }

      copySRGBToLinear(e) {
        return this.r = Nn(e.r), this.g = Nn(e.g), this.b = Nn(e.b), this;
      }

      copyLinearToSRGB(e) {
        return this.r = Un(e.r), this.g = Un(e.g), this.b = Un(e.b), this;
      }

      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }

      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }

      getHex(e = zt) {
        return jn.fromWorkingColorSpace(Kn(this, Vn), e), Mn(255 * Vn.r, 0, 255) << 16 ^ Mn(255 * Vn.g, 0, 255) << 8 ^ Mn(255 * Vn.b, 0, 255) << 0;
      }

      getHexString(e = zt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6);
      }

      getHSL(e, t = Vt) {
        jn.fromWorkingColorSpace(Kn(this, Vn), t);
        const n = Vn.r,
              r = Vn.g,
              i = Vn.b,
              s = Math.max(n, r, i),
              o = Math.min(n, r, i);
        let a, l;
        const c = (o + s) / 2;
        if (o === s) a = 0, l = 0;else {
          const e = s - o;

          switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
            case n:
              a = (r - i) / e + (r < i ? 6 : 0);
              break;

            case r:
              a = (i - n) / e + 2;
              break;

            case i:
              a = (n - r) / e + 4;
          }

          a /= 6;
        }
        return e.h = a, e.s = l, e.l = c, e;
      }

      getRGB(e, t = Vt) {
        return jn.fromWorkingColorSpace(Kn(this, Vn), t), e.r = Vn.r, e.g = Vn.g, e.b = Vn.b, e;
      }

      getStyle(e = zt) {
        return jn.fromWorkingColorSpace(Kn(this, Vn), e), e !== zt ? `color(${e} ${Vn.r} ${Vn.g} ${Vn.b})` : `rgb(${255 * Vn.r | 0},${255 * Vn.g | 0},${255 * Vn.b | 0})`;
      }

      offsetHSL(e, t, n) {
        return this.getHSL(Gn), Gn.h += e, Gn.s += t, Gn.l += n, this.setHSL(Gn.h, Gn.s, Gn.l), this;
      }

      add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this;
      }

      addColors(e, t) {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
      }

      addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this;
      }

      sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
      }

      multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
      }

      multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this;
      }

      lerp(e, t) {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
      }

      lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
      }

      lerpHSL(e, t) {
        this.getHSL(Gn), e.getHSL(Hn);
        const n = En(Gn.h, Hn.h, t),
              r = En(Gn.s, Hn.s, t),
              i = En(Gn.l, Hn.l, t);
        return this.setHSL(n, r, i), this;
      }

      equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
      }

      fromArray(e, t = 0) {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
      }

      toArray(e = [], t = 0) {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
      }

      fromBufferAttribute(e, t) {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
      }

      toJSON() {
        return this.getHex();
      }

      *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b;
      }

    }

    let qn;
    Xn.NAMES = zn;

    class Yn {
      static getDataURL(e) {
        if (/^data:/i.test(e.src)) return e.src;
        if ("undefined" == typeof HTMLCanvasElement) return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;else {
          void 0 === qn && (qn = Fn("canvas")), qn.width = e.width, qn.height = e.height;
          const n = qn.getContext("2d");
          e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = qn;
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png");
      }

      static sRGBToLinear(e) {
        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
          const t = Fn("canvas");
          t.width = e.width, t.height = e.height;
          const n = t.getContext("2d");
          n.drawImage(e, 0, 0, e.width, e.height);
          const r = n.getImageData(0, 0, e.width, e.height),
                i = r.data;

          for (let e = 0; e < i.length; e++) i[e] = 255 * Nn(i[e] / 255);

          return n.putImageData(r, 0, 0), t;
        }

        if (e.data) {
          const t = e.data.slice(0);

          for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Nn(t[e] / 255)) : t[e] = Nn(t[e]);

          return {
            data: t,
            width: e.width,
            height: e.height
          };
        }

        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
      }

    }

    class Zn {
      constructor(e = null) {
        this.isSource = !0, this.uuid = Sn(), this.data = e, this.version = 0;
      }

      set needsUpdate(e) {
        !0 === e && this.version++;
      }

      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
        const n = {
          uuid: this.uuid,
          url: ""
        },
              r = this.data;

        if (null !== r) {
          let e;

          if (Array.isArray(r)) {
            e = [];

            for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(Jn(r[t].image)) : e.push(Jn(r[t]));
          } else e = Jn(r);

          n.url = e;
        }

        return t || (e.images[this.uuid] = n), n;
      }

    }

    function Jn(e) {
      return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Yn.getDataURL(e) : e.data ? {
        data: Array.from(e.data),
        width: e.width,
        height: e.height,
        type: e.data.constructor.name
      } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }

    let $n = 0;

    class Qn extends vn {
      constructor(e = Qn.DEFAULT_IMAGE, t = Qn.DEFAULT_MAPPING, n = pe, r = pe, i = ve, s = ye, o = Fe, a = Se, l = 1, c = Dt) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
          value: $n++
        }), this.uuid = Sn(), this.name = "", this.source = new Zn(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new Pn(0, 0), this.repeat = new Pn(1, 1), this.center = new Pn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Dn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
      }

      get image() {
        return this.source.data;
      }

      set image(e) {
        this.source.data = e;
      }

      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
      }

      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(e).uuid,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
      }

      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }

      transformUv(e) {
        if (this.mapping !== ie) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
          case ue:
            e.x = e.x - Math.floor(e.x);
            break;

          case pe:
            e.x = e.x < 0 ? 0 : 1;
            break;

          case he:
            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
        }
        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
          case ue:
            e.y = e.y - Math.floor(e.y);
            break;

          case pe:
            e.y = e.y < 0 ? 0 : 1;
            break;

          case he:
            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
        }
        return this.flipY && (e.y = 1 - e.y), e;
      }

      set needsUpdate(e) {
        !0 === e && (this.version++, this.source.needsUpdate = !0);
      }

    }

    Qn.DEFAULT_IMAGE = null, Qn.DEFAULT_MAPPING = ie;

    class er {
      constructor(e = 0, t = 0, n = 0, r = 1) {
        er.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r;
      }

      get width() {
        return this.z;
      }

      set width(e) {
        this.z = e;
      }

      get height() {
        return this.w;
      }

      set height(e) {
        this.w = e;
      }

      set(e, t, n, r) {
        return this.x = e, this.y = t, this.z = n, this.w = r, this;
      }

      setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this;
      }

      setX(e) {
        return this.x = e, this;
      }

      setY(e) {
        return this.y = e, this;
      }

      setZ(e) {
        return this.z = e, this;
      }

      setW(e) {
        return this.w = e, this;
      }

      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;

          case 1:
            this.y = t;
            break;

          case 2:
            this.z = t;
            break;

          case 3:
            this.w = t;
            break;

          default:
            throw new Error("index is out of range: " + e);
        }

        return this;
      }

      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          case 3:
            return this.w;

          default:
            throw new Error("index is out of range: " + e);
        }
      }

      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }

      copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this;
      }

      add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
      }

      addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this;
      }

      addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
      }

      addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
      }

      sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
      }

      subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
      }

      subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
      }

      multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
      }

      multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
      }

      applyMatrix4(e) {
        const t = this.x,
              n = this.y,
              r = this.z,
              i = this.w,
              s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i, this;
      }

      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }

      setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
      }

      setAxisAngleFromRotationMatrix(e) {
        let t, n, r, i;
        const s = .01,
              o = .1,
              a = e.elements,
              l = a[0],
              c = a[4],
              u = a[8],
              p = a[1],
              h = a[5],
              d = a[9],
              f = a[2],
              _ = a[6],
              m = a[10];

        if (Math.abs(c - p) < s && Math.abs(u - f) < s && Math.abs(d - _) < s) {
          if (Math.abs(c + p) < o && Math.abs(u + f) < o && Math.abs(d + _) < o && Math.abs(l + h + m - 3) < o) return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          const e = (l + 1) / 2,
                a = (h + 1) / 2,
                g = (m + 1) / 2,
                v = (c + p) / 4,
                b = (u + f) / 4,
                x = (d + _) / 4;
          return e > a && e > g ? e < s ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(e), r = v / n, i = b / n) : a > g ? a < s ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(a), n = v / r, i = x / r) : g < s ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(g), n = b / i, r = x / i), this.set(n, r, i, t), this;
        }

        let g = Math.sqrt((_ - d) * (_ - d) + (u - f) * (u - f) + (p - c) * (p - c));
        return Math.abs(g) < .001 && (g = 1), this.x = (_ - d) / g, this.y = (u - f) / g, this.z = (p - c) / g, this.w = Math.acos((l + h + m - 1) / 2), this;
      }

      min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
      }

      max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
      }

      clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
      }

      clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
      }

      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
      }

      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
      }

      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
      }

      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
      }

      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
      }

      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
      }

      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
      }

      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }

      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }

      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }

      normalize() {
        return this.divideScalar(this.length() || 1);
      }

      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }

      lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
      }

      lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
      }

      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
      }

      fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
      }

      toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
      }

      fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
      }

      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
      }

      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
      }

    }

    class tr extends vn {
      constructor(e, t, n = {}) {
        super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new er(0, 0, e, t), this.scissorTest = !1, this.viewport = new er(0, 0, e, t);
        const r = {
          width: e,
          height: t,
          depth: 1
        };
        this.texture = new Qn(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ve, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0;
      }

      setSize(e, t, n = 1) {
        this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Zn(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
      }

      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }

    }

    class nr extends Qn {
      constructor(e = null, t = 1, n = 1, r = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
          data: e,
          width: t,
          height: n,
          depth: r
        }, this.magFilter = de, this.minFilter = de, this.wrapR = pe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
      }

    }

    class rr extends tr {
      constructor(e, t, n) {
        super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new nr(null, e, t, n), this.texture.isRenderTargetTexture = !0;
      }

    }

    class ir extends Qn {
      constructor(e = null, t = 1, n = 1, r = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
          data: e,
          width: t,
          height: n,
          depth: r
        }, this.magFilter = de, this.minFilter = de, this.wrapR = pe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
      }

    }

    class sr extends tr {
      constructor(e, t, n) {
        super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new ir(null, e, t, n), this.texture.isRenderTargetTexture = !0;
      }

    }

    class or extends tr {
      constructor(e, t, n, r = {}) {
        super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
        const i = this.texture;
        this.texture = [];

        for (let e = 0; e < n; e++) this.texture[e] = i.clone(), this.texture[e].isRenderTargetTexture = !0;
      }

      setSize(e, t, n = 1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
          this.width = e, this.height = t, this.depth = n;

          for (let r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;

          this.dispose();
        }

        return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
      }

      copy(e) {
        this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;

        for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;

        return this;
      }

    }

    class ar {
      constructor(e = 0, t = 0, n = 0, r = 1) {
        this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r;
      }

      static slerpFlat(e, t, n, r, i, s, o) {
        let a = n[r + 0],
            l = n[r + 1],
            c = n[r + 2],
            u = n[r + 3];
        const p = i[s + 0],
              h = i[s + 1],
              d = i[s + 2],
              f = i[s + 3];
        if (0 === o) return e[t + 0] = a, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = u);
        if (1 === o) return e[t + 0] = p, e[t + 1] = h, e[t + 2] = d, void (e[t + 3] = f);

        if (u !== f || a !== p || l !== h || c !== d) {
          let e = 1 - o;
          const t = a * p + l * h + c * d + u * f,
                n = t >= 0 ? 1 : -1,
                r = 1 - t * t;

          if (r > Number.EPSILON) {
            const i = Math.sqrt(r),
                  s = Math.atan2(i, t * n);
            e = Math.sin(e * s) / i, o = Math.sin(o * s) / i;
          }

          const i = o * n;

          if (a = a * e + p * i, l = l * e + h * i, c = c * e + d * i, u = u * e + f * i, e === 1 - o) {
            const e = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
            a *= e, l *= e, c *= e, u *= e;
          }
        }

        e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u;
      }

      static multiplyQuaternionsFlat(e, t, n, r, i, s) {
        const o = n[r],
              a = n[r + 1],
              l = n[r + 2],
              c = n[r + 3],
              u = i[s],
              p = i[s + 1],
              h = i[s + 2],
              d = i[s + 3];
        return e[t] = o * d + c * u + a * h - l * p, e[t + 1] = a * d + c * p + l * u - o * h, e[t + 2] = l * d + c * h + o * p - a * u, e[t + 3] = c * d - o * u - a * p - l * h, e;
      }

      get x() {
        return this._x;
      }

      set x(e) {
        this._x = e, this._onChangeCallback();
      }

      get y() {
        return this._y;
      }

      set y(e) {
        this._y = e, this._onChangeCallback();
      }

      get z() {
        return this._z;
      }

      set z(e) {
        this._z = e, this._onChangeCallback();
      }

      get w() {
        return this._w;
      }

      set w(e) {
        this._w = e, this._onChangeCallback();
      }

      set(e, t, n, r) {
        return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this;
      }

      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }

      copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
      }

      setFromEuler(e, t) {
        if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const n = e._x,
              r = e._y,
              i = e._z,
              s = e._order,
              o = Math.cos,
              a = Math.sin,
              l = o(n / 2),
              c = o(r / 2),
              u = o(i / 2),
              p = a(n / 2),
              h = a(r / 2),
              d = a(i / 2);

        switch (s) {
          case "XYZ":
            this._x = p * c * u + l * h * d, this._y = l * h * u - p * c * d, this._z = l * c * d + p * h * u, this._w = l * c * u - p * h * d;
            break;

          case "YXZ":
            this._x = p * c * u + l * h * d, this._y = l * h * u - p * c * d, this._z = l * c * d - p * h * u, this._w = l * c * u + p * h * d;
            break;

          case "ZXY":
            this._x = p * c * u - l * h * d, this._y = l * h * u + p * c * d, this._z = l * c * d + p * h * u, this._w = l * c * u - p * h * d;
            break;

          case "ZYX":
            this._x = p * c * u - l * h * d, this._y = l * h * u + p * c * d, this._z = l * c * d - p * h * u, this._w = l * c * u + p * h * d;
            break;

          case "YZX":
            this._x = p * c * u + l * h * d, this._y = l * h * u + p * c * d, this._z = l * c * d - p * h * u, this._w = l * c * u - p * h * d;
            break;

          case "XZY":
            this._x = p * c * u - l * h * d, this._y = l * h * u - p * c * d, this._z = l * c * d + p * h * u, this._w = l * c * u + p * h * d;
            break;

          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s);
        }

        return !1 !== t && this._onChangeCallback(), this;
      }

      setFromAxisAngle(e, t) {
        const n = t / 2,
              r = Math.sin(n);
        return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
      }

      setFromRotationMatrix(e) {
        const t = e.elements,
              n = t[0],
              r = t[4],
              i = t[8],
              s = t[1],
              o = t[5],
              a = t[9],
              l = t[2],
              c = t[6],
              u = t[10],
              p = n + o + u;

        if (p > 0) {
          const e = .5 / Math.sqrt(p + 1);
          this._w = .25 / e, this._x = (c - a) * e, this._y = (i - l) * e, this._z = (s - r) * e;
        } else if (n > o && n > u) {
          const e = 2 * Math.sqrt(1 + n - o - u);
          this._w = (c - a) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (i + l) / e;
        } else if (o > u) {
          const e = 2 * Math.sqrt(1 + o - n - u);
          this._w = (i - l) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (a + c) / e;
        } else {
          const e = 2 * Math.sqrt(1 + u - n - o);
          this._w = (s - r) / e, this._x = (i + l) / e, this._y = (a + c) / e, this._z = .25 * e;
        }

        return this._onChangeCallback(), this;
      }

      setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
      }

      angleTo(e) {
        return 2 * Math.acos(Math.abs(Mn(this.dot(e), -1, 1)));
      }

      rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (0 === n) return this;
        const r = Math.min(1, t / n);
        return this.slerp(e, r), this;
      }

      identity() {
        return this.set(0, 0, 0, 1);
      }

      invert() {
        return this.conjugate();
      }

      conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
      }

      dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
      }

      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }

      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }

      normalize() {
        let e = this.length();
        return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
      }

      multiply(e) {
        return this.multiplyQuaternions(this, e);
      }

      premultiply(e) {
        return this.multiplyQuaternions(e, this);
      }

      multiplyQuaternions(e, t) {
        const n = e._x,
              r = e._y,
              i = e._z,
              s = e._w,
              o = t._x,
              a = t._y,
              l = t._z,
              c = t._w;
        return this._x = n * c + s * o + r * l - i * a, this._y = r * c + s * a + i * o - n * l, this._z = i * c + s * l + n * a - r * o, this._w = s * c - n * o - r * a - i * l, this._onChangeCallback(), this;
      }

      slerp(e, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(e);
        const n = this._x,
              r = this._y,
              i = this._z,
              s = this._w;
        let o = s * e._w + n * e._x + r * e._y + i * e._z;
        if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this;
        const a = 1 - o * o;

        if (a <= Number.EPSILON) {
          const e = 1 - t;
          return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this._onChangeCallback(), this;
        }

        const l = Math.sqrt(a),
              c = Math.atan2(l, o),
              u = Math.sin((1 - t) * c) / l,
              p = Math.sin(t * c) / l;
        return this._w = s * u + this._w * p, this._x = n * u + this._x * p, this._y = r * u + this._y * p, this._z = i * u + this._z * p, this._onChangeCallback(), this;
      }

      slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n);
      }

      random() {
        const e = Math.random(),
              t = Math.sqrt(1 - e),
              n = Math.sqrt(e),
              r = 2 * Math.PI * Math.random(),
              i = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r));
      }

      equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
      }

      fromArray(e, t = 0) {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
      }

      toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
      }

      fromBufferAttribute(e, t) {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
      }

      _onChange(e) {
        return this._onChangeCallback = e, this;
      }

      _onChangeCallback() {}

      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
      }

    }

    class lr {
      constructor(e = 0, t = 0, n = 0) {
        lr.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
      }

      set(e, t, n) {
        return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this;
      }

      setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this;
      }

      setX(e) {
        return this.x = e, this;
      }

      setY(e) {
        return this.y = e, this;
      }

      setZ(e) {
        return this.z = e, this;
      }

      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;

          case 1:
            this.y = t;
            break;

          case 2:
            this.z = t;
            break;

          default:
            throw new Error("index is out of range: " + e);
        }

        return this;
      }

      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          default:
            throw new Error("index is out of range: " + e);
        }
      }

      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }

      copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this;
      }

      add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this;
      }

      addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this;
      }

      addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
      }

      addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
      }

      sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
      }

      subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this;
      }

      subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
      }

      multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
      }

      multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this;
      }

      multiplyVectors(e, t) {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
      }

      applyEuler(e) {
        return this.applyQuaternion(ur.setFromEuler(e));
      }

      applyAxisAngle(e, t) {
        return this.applyQuaternion(ur.setFromAxisAngle(e, t));
      }

      applyMatrix3(e) {
        const t = this.x,
              n = this.y,
              r = this.z,
              i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this;
      }

      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }

      applyMatrix4(e) {
        const t = this.x,
              n = this.y,
              r = this.z,
              i = e.elements,
              s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
        return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s, this;
      }

      applyQuaternion(e) {
        const t = this.x,
              n = this.y,
              r = this.z,
              i = e.x,
              s = e.y,
              o = e.z,
              a = e.w,
              l = a * t + s * r - o * n,
              c = a * n + o * t - i * r,
              u = a * r + i * n - s * t,
              p = -i * t - s * n - o * r;
        return this.x = l * a + p * -i + c * -o - u * -s, this.y = c * a + p * -s + u * -i - l * -o, this.z = u * a + p * -o + l * -s - c * -i, this;
      }

      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
      }

      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
      }

      transformDirection(e) {
        const t = this.x,
              n = this.y,
              r = this.z,
              i = e.elements;
        return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize();
      }

      divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
      }

      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }

      min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
      }

      max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
      }

      clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
      }

      clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
      }

      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
      }

      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
      }

      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
      }

      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
      }

      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
      }

      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
      }

      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }

      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }

      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }

      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }

      normalize() {
        return this.divideScalar(this.length() || 1);
      }

      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }

      lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
      }

      lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
      }

      cross(e) {
        return this.crossVectors(this, e);
      }

      crossVectors(e, t) {
        const n = e.x,
              r = e.y,
              i = e.z,
              s = t.x,
              o = t.y,
              a = t.z;
        return this.x = r * a - i * o, this.y = i * s - n * a, this.z = n * o - r * s, this;
      }

      projectOnVector(e) {
        const t = e.lengthSq();
        if (0 === t) return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n);
      }

      projectOnPlane(e) {
        return cr.copy(this).projectOnVector(e), this.sub(cr);
      }

      reflect(e) {
        return this.sub(cr.copy(e).multiplyScalar(2 * this.dot(e)));
      }

      angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Mn(n, -1, 1));
      }

      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }

      distanceToSquared(e) {
        const t = this.x - e.x,
              n = this.y - e.y,
              r = this.z - e.z;
        return t * t + n * n + r * r;
      }

      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
      }

      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }

      setFromSphericalCoords(e, t, n) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this;
      }

      setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
      }

      setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
      }

      setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this;
      }

      setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
              n = this.setFromMatrixColumn(e, 1).length(),
              r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = n, this.z = r, this;
      }

      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, 4 * t);
      }

      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, 3 * t);
      }

      setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this;
      }

      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
      }

      fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
      }

      toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
      }

      fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
      }

      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
      }

      randomDirection() {
        const e = 2 * (Math.random() - .5),
              t = Math.random() * Math.PI * 2,
              n = Math.sqrt(1 - e ** 2);
        return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
      }

      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
      }

    }

    const cr = new lr(),
          ur = new ar();

    class pr {
      constructor(e = new lr(1 / 0, 1 / 0, 1 / 0), t = new lr(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = e, this.max = t;
      }

      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }

      setFromArray(e) {
        let t = 1 / 0,
            n = 1 / 0,
            r = 1 / 0,
            i = -1 / 0,
            s = -1 / 0,
            o = -1 / 0;

        for (let a = 0, l = e.length; a < l; a += 3) {
          const l = e[a],
                c = e[a + 1],
                u = e[a + 2];
          l < t && (t = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > o && (o = u);
        }

        return this.min.set(t, n, r), this.max.set(i, s, o), this;
      }

      setFromBufferAttribute(e) {
        let t = 1 / 0,
            n = 1 / 0,
            r = 1 / 0,
            i = -1 / 0,
            s = -1 / 0,
            o = -1 / 0;

        for (let a = 0, l = e.count; a < l; a++) {
          const l = e.getX(a),
                c = e.getY(a),
                u = e.getZ(a);
          l < t && (t = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > o && (o = u);
        }

        return this.min.set(t, n, r), this.max.set(i, s, o), this;
      }

      setFromPoints(e) {
        this.makeEmpty();

        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);

        return this;
      }

      setFromCenterAndSize(e, t) {
        const n = dr.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }

      setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t);
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }

      makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
      }

      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }

      getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
      }

      getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
      }

      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }

      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }

      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }

      expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (void 0 !== n) if (t && null != n.attributes && void 0 !== n.attributes.position) {
          const t = n.attributes.position;

          for (let n = 0, r = t.count; n < r; n++) dr.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld), this.expandByPoint(dr);
        } else null === n.boundingBox && n.computeBoundingBox(), fr.copy(n.boundingBox), fr.applyMatrix4(e.matrixWorld), this.union(fr);
        const r = e.children;

        for (let e = 0, n = r.length; e < n; e++) this.expandByObject(r[e], t);

        return this;
      }

      containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
      }

      containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
      }

      getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
      }

      intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
      }

      intersectsSphere(e) {
        return this.clampPoint(e.center, dr), dr.distanceToSquared(e.center) <= e.radius * e.radius;
      }

      intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
      }

      intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(yr), wr.subVectors(this.max, yr), _r.subVectors(e.a, yr), mr.subVectors(e.b, yr), gr.subVectors(e.c, yr), vr.subVectors(mr, _r), br.subVectors(gr, mr), xr.subVectors(_r, gr);
        let t = [0, -vr.z, vr.y, 0, -br.z, br.y, 0, -xr.z, xr.y, vr.z, 0, -vr.x, br.z, 0, -br.x, xr.z, 0, -xr.x, -vr.y, vr.x, 0, -br.y, br.x, 0, -xr.y, xr.x, 0];
        return !!Tr(t, _r, mr, gr, wr) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Tr(t, _r, mr, gr, wr) && (Sr.crossVectors(vr, br), t = [Sr.x, Sr.y, Sr.z], Tr(t, _r, mr, gr, wr)));
      }

      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }

      distanceToPoint(e) {
        return dr.copy(e).clamp(this.min, this.max).sub(e).length();
      }

      getBoundingSphere(e) {
        return this.getCenter(e.center), e.radius = .5 * this.getSize(dr).length(), e;
      }

      intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
      }

      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }

      applyMatrix4(e) {
        return this.isEmpty() || (hr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), hr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), hr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), hr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), hr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), hr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), hr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), hr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(hr)), this;
      }

      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }

      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }

    }

    const hr = [new lr(), new lr(), new lr(), new lr(), new lr(), new lr(), new lr(), new lr()],
          dr = new lr(),
          fr = new pr(),
          _r = new lr(),
          mr = new lr(),
          gr = new lr(),
          vr = new lr(),
          br = new lr(),
          xr = new lr(),
          yr = new lr(),
          wr = new lr(),
          Sr = new lr(),
          Mr = new lr();

    function Tr(e, t, n, r, i) {
      for (let s = 0, o = e.length - 3; s <= o; s += 3) {
        Mr.fromArray(e, s);
        const o = i.x * Math.abs(Mr.x) + i.y * Math.abs(Mr.y) + i.z * Math.abs(Mr.z),
              a = t.dot(Mr),
              l = n.dot(Mr),
              c = r.dot(Mr);
        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1;
      }

      return !0;
    }

    const Er = new pr(),
          Ar = new lr(),
          Cr = new lr(),
          Rr = new lr();

    class kr {
      constructor(e = new lr(), t = -1) {
        this.center = e, this.radius = t;
      }

      set(e, t) {
        return this.center.copy(e), this.radius = t, this;
      }

      setFromPoints(e, t) {
        const n = this.center;
        void 0 !== t ? n.copy(t) : Er.setFromPoints(e).getCenter(n);
        let r = 0;

        for (let t = 0, i = e.length; t < i; t++) r = Math.max(r, n.distanceToSquared(e[t]));

        return this.radius = Math.sqrt(r), this;
      }

      copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this;
      }

      isEmpty() {
        return this.radius < 0;
      }

      makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this;
      }

      containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
      }

      distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
      }

      intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
      }

      intersectsBox(e) {
        return e.intersectsSphere(this);
      }

      intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
      }

      clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
      }

      getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
      }

      applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
      }

      translate(e) {
        return this.center.add(e), this;
      }

      expandByPoint(e) {
        Rr.subVectors(e, this.center);
        const t = Rr.lengthSq();

        if (t > this.radius * this.radius) {
          const e = Math.sqrt(t),
                n = .5 * (e - this.radius);
          this.center.add(Rr.multiplyScalar(n / e)), this.radius += n;
        }

        return this;
      }

      union(e) {
        return !0 === this.center.equals(e.center) ? Cr.set(0, 0, 1).multiplyScalar(e.radius) : Cr.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Ar.copy(e.center).add(Cr)), this.expandByPoint(Ar.copy(e.center).sub(Cr)), this;
      }

      equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    const Pr = new lr(),
          Dr = new lr(),
          Or = new lr(),
          Lr = new lr(),
          Ir = new lr(),
          Fr = new lr(),
          Nr = new lr();

    class Ur {
      constructor(e = new lr(), t = new lr(0, 0, -1)) {
        this.origin = e, this.direction = t;
      }

      set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
      }

      copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
      }

      at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin);
      }

      lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
      }

      recast(e) {
        return this.origin.copy(this.at(e, Pr)), this;
      }

      closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin);
      }

      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }

      distanceSqToPoint(e) {
        const t = Pr.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Pr.copy(this.direction).multiplyScalar(t).add(this.origin), Pr.distanceToSquared(e));
      }

      distanceSqToSegment(e, t, n, r) {
        Dr.copy(e).add(t).multiplyScalar(.5), Or.copy(t).sub(e).normalize(), Lr.copy(this.origin).sub(Dr);
        const i = .5 * e.distanceTo(t),
              s = -this.direction.dot(Or),
              o = Lr.dot(this.direction),
              a = -Lr.dot(Or),
              l = Lr.lengthSq(),
              c = Math.abs(1 - s * s);
        let u, p, h, d;
        if (c > 0) {
          if (u = s * a - o, p = s * o - a, d = i * c, u >= 0) {
            if (p >= -d) {
              if (p <= d) {
                const e = 1 / c;
                u *= e, p *= e, h = u * (u + s * p + 2 * o) + p * (s * u + p + 2 * a) + l;
              } else p = i, u = Math.max(0, -(s * p + o)), h = -u * u + p * (p + 2 * a) + l;
            } else p = -i, u = Math.max(0, -(s * p + o)), h = -u * u + p * (p + 2 * a) + l;
          } else p <= -d ? (u = Math.max(0, -(-s * i + o)), p = u > 0 ? -i : Math.min(Math.max(-i, -a), i), h = -u * u + p * (p + 2 * a) + l) : p <= d ? (u = 0, p = Math.min(Math.max(-i, -a), i), h = p * (p + 2 * a) + l) : (u = Math.max(0, -(s * i + o)), p = u > 0 ? i : Math.min(Math.max(-i, -a), i), h = -u * u + p * (p + 2 * a) + l);
        } else p = s > 0 ? -i : i, u = Math.max(0, -(s * p + o)), h = -u * u + p * (p + 2 * a) + l;
        return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(Or).multiplyScalar(p).add(Dr), h;
      }

      intersectSphere(e, t) {
        Pr.subVectors(e.center, this.origin);
        const n = Pr.dot(this.direction),
              r = Pr.dot(Pr) - n * n,
              i = e.radius * e.radius;
        if (r > i) return null;
        const s = Math.sqrt(i - r),
              o = n - s,
              a = n + s;
        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, t) : this.at(o, t);
      }

      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }

      distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null;
      }

      intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return null === n ? null : this.at(n, t);
      }

      intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return 0 === t || e.normal.dot(this.direction) * t < 0;
      }

      intersectBox(e, t) {
        let n, r, i, s, o, a;
        const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              u = 1 / this.direction.z,
              p = this.origin;
        return l >= 0 ? (n = (e.min.x - p.x) * l, r = (e.max.x - p.x) * l) : (n = (e.max.x - p.x) * l, r = (e.min.x - p.x) * l), c >= 0 ? (i = (e.min.y - p.y) * c, s = (e.max.y - p.y) * c) : (i = (e.max.y - p.y) * c, s = (e.min.y - p.y) * c), n > s || i > r ? null : ((i > n || n != n) && (n = i), (s < r || r != r) && (r = s), u >= 0 ? (o = (e.min.z - p.z) * u, a = (e.max.z - p.z) * u) : (o = (e.max.z - p.z) * u, a = (e.min.z - p.z) * u), n > a || o > r ? null : ((o > n || n != n) && (n = o), (a < r || r != r) && (r = a), r < 0 ? null : this.at(n >= 0 ? n : r, t)));
      }

      intersectsBox(e) {
        return null !== this.intersectBox(e, Pr);
      }

      intersectTriangle(e, t, n, r, i) {
        Ir.subVectors(t, e), Fr.subVectors(n, e), Nr.crossVectors(Ir, Fr);
        let s,
            o = this.direction.dot(Nr);

        if (o > 0) {
          if (r) return null;
          s = 1;
        } else {
          if (!(o < 0)) return null;
          s = -1, o = -o;
        }

        Lr.subVectors(this.origin, e);
        const a = s * this.direction.dot(Fr.crossVectors(Lr, Fr));
        if (a < 0) return null;
        const l = s * this.direction.dot(Ir.cross(Lr));
        if (l < 0) return null;
        if (a + l > o) return null;
        const c = -s * Lr.dot(Nr);
        return c < 0 ? null : this.at(c / o, i);
      }

      applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
      }

      equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction);
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    class Br {
      constructor() {
        Br.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      set(e, t, n, r, i, s, o, a, l, c, u, p, h, d, f, _) {
        const m = this.elements;
        return m[0] = e, m[4] = t, m[8] = n, m[12] = r, m[1] = i, m[5] = s, m[9] = o, m[13] = a, m[2] = l, m[6] = c, m[10] = u, m[14] = p, m[3] = h, m[7] = d, m[11] = f, m[15] = _, this;
      }

      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }

      clone() {
        return new Br().fromArray(this.elements);
      }

      copy(e) {
        const t = this.elements,
              n = e.elements;
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
      }

      copyPosition(e) {
        const t = this.elements,
              n = e.elements;
        return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
      }

      setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
      }

      extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
      }

      makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
      }

      extractRotation(e) {
        const t = this.elements,
              n = e.elements,
              r = 1 / jr.setFromMatrixColumn(e, 0).length(),
              i = 1 / jr.setFromMatrixColumn(e, 1).length(),
              s = 1 / jr.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
      }

      makeRotationFromEuler(e) {
        const t = this.elements,
              n = e.x,
              r = e.y,
              i = e.z,
              s = Math.cos(n),
              o = Math.sin(n),
              a = Math.cos(r),
              l = Math.sin(r),
              c = Math.cos(i),
              u = Math.sin(i);

        if ("XYZ" === e.order) {
          const e = s * c,
                n = s * u,
                r = o * c,
                i = o * u;
          t[0] = a * c, t[4] = -a * u, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -o * a, t[2] = i - e * l, t[6] = r + n * l, t[10] = s * a;
        } else if ("YXZ" === e.order) {
          const e = a * c,
                n = a * u,
                r = l * c,
                i = l * u;
          t[0] = e + i * o, t[4] = r * o - n, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -o, t[2] = n * o - r, t[6] = i + e * o, t[10] = s * a;
        } else if ("ZXY" === e.order) {
          const e = a * c,
                n = a * u,
                r = l * c,
                i = l * u;
          t[0] = e - i * o, t[4] = -s * u, t[8] = r + n * o, t[1] = n + r * o, t[5] = s * c, t[9] = i - e * o, t[2] = -s * l, t[6] = o, t[10] = s * a;
        } else if ("ZYX" === e.order) {
          const e = s * c,
                n = s * u,
                r = o * c,
                i = o * u;
          t[0] = a * c, t[4] = r * l - n, t[8] = e * l + i, t[1] = a * u, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = o * a, t[10] = s * a;
        } else if ("YZX" === e.order) {
          const e = s * a,
                n = s * l,
                r = o * a,
                i = o * l;
          t[0] = a * c, t[4] = i - e * u, t[8] = r * u + n, t[1] = u, t[5] = s * c, t[9] = -o * c, t[2] = -l * c, t[6] = n * u + r, t[10] = e - i * u;
        } else if ("XZY" === e.order) {
          const e = s * a,
                n = s * l,
                r = o * a,
                i = o * l;
          t[0] = a * c, t[4] = -u, t[8] = l * c, t[1] = e * u + i, t[5] = s * c, t[9] = n * u - r, t[2] = r * u - n, t[6] = o * c, t[10] = i * u + e;
        }

        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
      }

      makeRotationFromQuaternion(e) {
        return this.compose(Vr, e, Gr);
      }

      lookAt(e, t, n) {
        const r = this.elements;
        return Kr.subVectors(e, t), 0 === Kr.lengthSq() && (Kr.z = 1), Kr.normalize(), Hr.crossVectors(n, Kr), 0 === Hr.lengthSq() && (1 === Math.abs(n.z) ? Kr.x += 1e-4 : Kr.z += 1e-4, Kr.normalize(), Hr.crossVectors(n, Kr)), Hr.normalize(), Wr.crossVectors(Kr, Hr), r[0] = Hr.x, r[4] = Wr.x, r[8] = Kr.x, r[1] = Hr.y, r[5] = Wr.y, r[9] = Kr.y, r[2] = Hr.z, r[6] = Wr.z, r[10] = Kr.z, this;
      }

      multiply(e) {
        return this.multiplyMatrices(this, e);
      }

      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }

      multiplyMatrices(e, t) {
        const n = e.elements,
              r = t.elements,
              i = this.elements,
              s = n[0],
              o = n[4],
              a = n[8],
              l = n[12],
              c = n[1],
              u = n[5],
              p = n[9],
              h = n[13],
              d = n[2],
              f = n[6],
              _ = n[10],
              m = n[14],
              g = n[3],
              v = n[7],
              b = n[11],
              x = n[15],
              y = r[0],
              w = r[4],
              S = r[8],
              M = r[12],
              T = r[1],
              E = r[5],
              A = r[9],
              C = r[13],
              R = r[2],
              k = r[6],
              P = r[10],
              D = r[14],
              O = r[3],
              L = r[7],
              I = r[11],
              F = r[15];
        return i[0] = s * y + o * T + a * R + l * O, i[4] = s * w + o * E + a * k + l * L, i[8] = s * S + o * A + a * P + l * I, i[12] = s * M + o * C + a * D + l * F, i[1] = c * y + u * T + p * R + h * O, i[5] = c * w + u * E + p * k + h * L, i[9] = c * S + u * A + p * P + h * I, i[13] = c * M + u * C + p * D + h * F, i[2] = d * y + f * T + _ * R + m * O, i[6] = d * w + f * E + _ * k + m * L, i[10] = d * S + f * A + _ * P + m * I, i[14] = d * M + f * C + _ * D + m * F, i[3] = g * y + v * T + b * R + x * O, i[7] = g * w + v * E + b * k + x * L, i[11] = g * S + v * A + b * P + x * I, i[15] = g * M + v * C + b * D + x * F, this;
      }

      multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
      }

      determinant() {
        const e = this.elements,
              t = e[0],
              n = e[4],
              r = e[8],
              i = e[12],
              s = e[1],
              o = e[5],
              a = e[9],
              l = e[13],
              c = e[2],
              u = e[6],
              p = e[10],
              h = e[14];
        return e[3] * (+i * a * u - r * l * u - i * o * p + n * l * p + r * o * h - n * a * h) + e[7] * (+t * a * h - t * l * p + i * s * p - r * s * h + r * l * c - i * a * c) + e[11] * (+t * l * u - t * o * h - i * s * u + n * s * h + i * o * c - n * l * c) + e[15] * (-r * o * c - t * a * u + t * o * p + r * s * u - n * s * p + n * a * c);
      }

      transpose() {
        const e = this.elements;
        let t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
      }

      setPosition(e, t, n) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this;
      }

      invert() {
        const e = this.elements,
              t = e[0],
              n = e[1],
              r = e[2],
              i = e[3],
              s = e[4],
              o = e[5],
              a = e[6],
              l = e[7],
              c = e[8],
              u = e[9],
              p = e[10],
              h = e[11],
              d = e[12],
              f = e[13],
              _ = e[14],
              m = e[15],
              g = u * _ * l - f * p * l + f * a * h - o * _ * h - u * a * m + o * p * m,
              v = d * p * l - c * _ * l - d * a * h + s * _ * h + c * a * m - s * p * m,
              b = c * f * l - d * u * l + d * o * h - s * f * h - c * o * m + s * u * m,
              x = d * u * a - c * f * a - d * o * p + s * f * p + c * o * _ - s * u * _,
              y = t * g + n * v + r * b + i * x;
        if (0 === y) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / y;
        return e[0] = g * w, e[1] = (f * p * i - u * _ * i - f * r * h + n * _ * h + u * r * m - n * p * m) * w, e[2] = (o * _ * i - f * a * i + f * r * l - n * _ * l - o * r * m + n * a * m) * w, e[3] = (u * a * i - o * p * i - u * r * l + n * p * l + o * r * h - n * a * h) * w, e[4] = v * w, e[5] = (c * _ * i - d * p * i + d * r * h - t * _ * h - c * r * m + t * p * m) * w, e[6] = (d * a * i - s * _ * i - d * r * l + t * _ * l + s * r * m - t * a * m) * w, e[7] = (s * p * i - c * a * i + c * r * l - t * p * l - s * r * h + t * a * h) * w, e[8] = b * w, e[9] = (d * u * i - c * f * i - d * n * h + t * f * h + c * n * m - t * u * m) * w, e[10] = (s * f * i - d * o * i + d * n * l - t * f * l - s * n * m + t * o * m) * w, e[11] = (c * o * i - s * u * i - c * n * l + t * u * l + s * n * h - t * o * h) * w, e[12] = x * w, e[13] = (c * f * r - d * u * r + d * n * p - t * f * p - c * n * _ + t * u * _) * w, e[14] = (d * o * r - s * f * r - d * n * a + t * f * a + s * n * _ - t * o * _) * w, e[15] = (s * u * r - c * o * r + c * n * a - t * u * a - s * n * p + t * o * p) * w, this;
      }

      scale(e) {
        const t = this.elements,
              n = e.x,
              r = e.y,
              i = e.z;
        return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this;
      }

      getMaxScaleOnAxis() {
        const e = this.elements,
              t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
              n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
              r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, r));
      }

      makeTranslation(e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
      }

      makeRotationX(e) {
        const t = Math.cos(e),
              n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
      }

      makeRotationY(e) {
        const t = Math.cos(e),
              n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
      }

      makeRotationZ(e) {
        const t = Math.cos(e),
              n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }

      makeRotationAxis(e, t) {
        const n = Math.cos(t),
              r = Math.sin(t),
              i = 1 - n,
              s = e.x,
              o = e.y,
              a = e.z,
              l = i * s,
              c = i * o;
        return this.set(l * s + n, l * o - r * a, l * a + r * o, 0, l * o + r * a, c * o + n, c * a - r * s, 0, l * a - r * o, c * a + r * s, i * a * a + n, 0, 0, 0, 0, 1), this;
      }

      makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      }

      makeShear(e, t, n, r, i, s) {
        return this.set(1, n, i, 0, e, 1, s, 0, t, r, 1, 0, 0, 0, 0, 1), this;
      }

      compose(e, t, n) {
        const r = this.elements,
              i = t._x,
              s = t._y,
              o = t._z,
              a = t._w,
              l = i + i,
              c = s + s,
              u = o + o,
              p = i * l,
              h = i * c,
              d = i * u,
              f = s * c,
              _ = s * u,
              m = o * u,
              g = a * l,
              v = a * c,
              b = a * u,
              x = n.x,
              y = n.y,
              w = n.z;

        return r[0] = (1 - (f + m)) * x, r[1] = (h + b) * x, r[2] = (d - v) * x, r[3] = 0, r[4] = (h - b) * y, r[5] = (1 - (p + m)) * y, r[6] = (_ + g) * y, r[7] = 0, r[8] = (d + v) * w, r[9] = (_ - g) * w, r[10] = (1 - (p + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
      }

      decompose(e, t, n) {
        const r = this.elements;
        let i = jr.set(r[0], r[1], r[2]).length();
        const s = jr.set(r[4], r[5], r[6]).length(),
              o = jr.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], zr.copy(this);
        const a = 1 / i,
              l = 1 / s,
              c = 1 / o;
        return zr.elements[0] *= a, zr.elements[1] *= a, zr.elements[2] *= a, zr.elements[4] *= l, zr.elements[5] *= l, zr.elements[6] *= l, zr.elements[8] *= c, zr.elements[9] *= c, zr.elements[10] *= c, t.setFromRotationMatrix(zr), n.x = i, n.y = s, n.z = o, this;
      }

      makePerspective(e, t, n, r, i, s) {
        const o = this.elements,
              a = 2 * i / (t - e),
              l = 2 * i / (n - r),
              c = (t + e) / (t - e),
              u = (n + r) / (n - r),
              p = -(s + i) / (s - i),
              h = -2 * s * i / (s - i);
        return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = p, o[14] = h, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
      }

      makeOrthographic(e, t, n, r, i, s) {
        const o = this.elements,
              a = 1 / (t - e),
              l = 1 / (n - r),
              c = 1 / (s - i),
              u = (t + e) * a,
              p = (n + r) * l,
              h = (s + i) * c;
        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -p, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -h, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
      }

      equals(e) {
        const t = this.elements,
              n = e.elements;

        for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;

        return !0;
      }

      fromArray(e, t = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];

        return this;
      }

      toArray(e = [], t = 0) {
        const n = this.elements;
        return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
      }

    }

    const jr = new lr(),
          zr = new Br(),
          Vr = new lr(0, 0, 0),
          Gr = new lr(1, 1, 1),
          Hr = new lr(),
          Wr = new lr(),
          Kr = new lr(),
          Xr = new Br(),
          qr = new ar();

    class Yr {
      constructor(e = 0, t = 0, n = 0, r = Yr.DefaultOrder) {
        this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r;
      }

      get x() {
        return this._x;
      }

      set x(e) {
        this._x = e, this._onChangeCallback();
      }

      get y() {
        return this._y;
      }

      set y(e) {
        this._y = e, this._onChangeCallback();
      }

      get z() {
        return this._z;
      }

      set z(e) {
        this._z = e, this._onChangeCallback();
      }

      get order() {
        return this._order;
      }

      set order(e) {
        this._order = e, this._onChangeCallback();
      }

      set(e, t, n, r = this._order) {
        return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this;
      }

      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }

      copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
      }

      setFromRotationMatrix(e, t = this._order, n = !0) {
        const r = e.elements,
              i = r[0],
              s = r[4],
              o = r[8],
              a = r[1],
              l = r[5],
              c = r[9],
              u = r[2],
              p = r[6],
              h = r[10];

        switch (t) {
          case "XYZ":
            this._y = Math.asin(Mn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, h), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(p, l), this._z = 0);
            break;

          case "YXZ":
            this._x = Math.asin(-Mn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, h), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, i), this._z = 0);
            break;

          case "ZXY":
            this._x = Math.asin(Mn(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-u, h), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, i));
            break;

          case "ZYX":
            this._y = Math.asin(-Mn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(p, h), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-s, l));
            break;

          case "YZX":
            this._z = Math.asin(Mn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, h));
            break;

          case "XZY":
            this._z = Math.asin(-Mn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, h), this._y = 0);
            break;

          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
        }

        return this._order = t, !0 === n && this._onChangeCallback(), this;
      }

      setFromQuaternion(e, t, n) {
        return Xr.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Xr, t, n);
      }

      setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
      }

      reorder(e) {
        return qr.setFromEuler(this), this.setFromQuaternion(qr, e);
      }

      equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
      }

      fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this;
      }

      toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
      }

      _onChange(e) {
        return this._onChangeCallback = e, this;
      }

      _onChangeCallback() {}

      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
      }

      toVector3() {
        console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
      }

    }

    Yr.DefaultOrder = "XYZ", Yr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];

    class Zr {
      constructor() {
        this.mask = 1;
      }

      set(e) {
        this.mask = (1 << e | 0) >>> 0;
      }

      enable(e) {
        this.mask |= 1 << e | 0;
      }

      enableAll() {
        this.mask = -1;
      }

      toggle(e) {
        this.mask ^= 1 << e | 0;
      }

      disable(e) {
        this.mask &= ~(1 << e | 0);
      }

      disableAll() {
        this.mask = 0;
      }

      test(e) {
        return 0 != (this.mask & e.mask);
      }

      isEnabled(e) {
        return 0 != (this.mask & (1 << e | 0));
      }

    }

    let Jr = 0;
    const $r = new lr(),
          Qr = new ar(),
          ei = new Br(),
          ti = new lr(),
          ni = new lr(),
          ri = new lr(),
          ii = new ar(),
          si = new lr(1, 0, 0),
          oi = new lr(0, 1, 0),
          ai = new lr(0, 0, 1),
          li = {
      type: "added"
    },
          ci = {
      type: "removed"
    };

    class ui extends vn {
      constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
          value: Jr++
        }), this.uuid = Sn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ui.DefaultUp.clone();
        const e = new lr(),
              t = new Yr(),
              n = new ar(),
              r = new lr(1, 1, 1);
        t._onChange(function () {
          n.setFromEuler(t, !1);
        }), n._onChange(function () {
          t.setFromQuaternion(n, void 0, !1);
        }), Object.defineProperties(this, {
          position: {
            configurable: !0,
            enumerable: !0,
            value: e
          },
          rotation: {
            configurable: !0,
            enumerable: !0,
            value: t
          },
          quaternion: {
            configurable: !0,
            enumerable: !0,
            value: n
          },
          scale: {
            configurable: !0,
            enumerable: !0,
            value: r
          },
          modelViewMatrix: {
            value: new Br()
          },
          normalMatrix: {
            value: new Dn()
          }
        }), this.matrix = new Br(), this.matrixWorld = new Br(), this.matrixAutoUpdate = ui.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Zr(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
      }

      onBeforeRender(e, t, n, r, i, s) {
        this.dispatchEvent({
          type: "beforeRender",
          renderer: e,
          scene: t,
          camera: n,
          geometry: r,
          material: i,
          group: s
        });
      }

      onAfterRender() {}

      applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
      }

      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }

      setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      }

      setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
      }

      setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
      }

      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }

      rotateOnAxis(e, t) {
        return Qr.setFromAxisAngle(e, t), this.quaternion.multiply(Qr), this;
      }

      rotateOnWorldAxis(e, t) {
        return Qr.setFromAxisAngle(e, t), this.quaternion.premultiply(Qr), this;
      }

      rotateX(e) {
        return this.rotateOnAxis(si, e);
      }

      rotateY(e) {
        return this.rotateOnAxis(oi, e);
      }

      rotateZ(e) {
        return this.rotateOnAxis(ai, e);
      }

      translateOnAxis(e, t) {
        return $r.copy(e).applyQuaternion(this.quaternion), this.position.add($r.multiplyScalar(t)), this;
      }

      translateX(e) {
        return this.translateOnAxis(si, e);
      }

      translateY(e) {
        return this.translateOnAxis(oi, e);
      }

      translateZ(e) {
        return this.translateOnAxis(ai, e);
      }

      localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld);
      }

      worldToLocal(e) {
        return e.applyMatrix4(ei.copy(this.matrixWorld).invert());
      }

      lookAt(e, t, n) {
        e.isVector3 ? ti.copy(e) : ti.set(e, t, n);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1), ni.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ei.lookAt(ni, ti, this.up) : ei.lookAt(ti, ni, this.up), this.quaternion.setFromRotationMatrix(ei), r && (ei.extractRotation(r.matrixWorld), Qr.setFromRotationMatrix(ei), this.quaternion.premultiply(Qr.invert()));
      }

      add(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);

          return this;
        }

        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(li)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
      }

      remove(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);

          return this;
        }

        const t = this.children.indexOf(e);
        return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(ci)), this;
      }

      removeFromParent() {
        const e = this.parent;
        return null !== e && e.remove(this), this;
      }

      clear() {
        for (let e = 0; e < this.children.length; e++) {
          const t = this.children[e];
          t.parent = null, t.dispatchEvent(ci);
        }

        return this.children.length = 0, this;
      }

      attach(e) {
        return this.updateWorldMatrix(!0, !1), ei.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), ei.multiply(e.parent.matrixWorld)), e.applyMatrix4(ei), this.add(e), e.updateWorldMatrix(!1, !0), this;
      }

      getObjectById(e) {
        return this.getObjectByProperty("id", e);
      }

      getObjectByName(e) {
        return this.getObjectByProperty("name", e);
      }

      getObjectByProperty(e, t) {
        if (this[e] === t) return this;

        for (let n = 0, r = this.children.length; n < r; n++) {
          const r = this.children[n].getObjectByProperty(e, t);
          if (void 0 !== r) return r;
        }
      }

      getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
      }

      getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ni, e, ri), e;
      }

      getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ni, ii, e), e;
      }

      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }

      raycast() {}

      traverse(e) {
        e(this);
        const t = this.children;

        for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e);
      }

      traverseVisible(e) {
        if (!1 === this.visible) return;
        e(this);
        const t = this.children;

        for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e);
      }

      traverseAncestors(e) {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e));
      }

      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
      }

      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
        const t = this.children;

        for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e);
      }

      updateWorldMatrix(e, t) {
        const n = this.parent;

        if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
          const e = this.children;

          for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0);
        }
      }

      toJSON(e) {
        const t = void 0 === e || "string" == typeof e,
              n = {};
        t && (e = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        }, n.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        });
        const r = {};

        function i(t, n) {
          return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
        }

        if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(e).uuid);else if (this.isMesh || this.isLine || this.isPoints) {
          r.geometry = i(e.geometries, this.geometry);
          const t = this.geometry.parameters;

          if (void 0 !== t && void 0 !== t.shapes) {
            const n = t.shapes;
            if (Array.isArray(n)) for (let t = 0, r = n.length; t < r; t++) {
              const r = n[t];
              i(e.shapes, r);
            } else i(e.shapes, n);
          }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
          const t = [];

          for (let n = 0, r = this.material.length; n < r; n++) t.push(i(e.materials, this.material[n]));

          r.material = t;
        } else r.material = i(e.materials, this.material);

        if (this.children.length > 0) {
          r.children = [];

          for (let t = 0; t < this.children.length; t++) r.children.push(this.children[t].toJSON(e).object);
        }

        if (this.animations.length > 0) {
          r.animations = [];

          for (let t = 0; t < this.animations.length; t++) {
            const n = this.animations[t];
            r.animations.push(i(e.animations, n));
          }
        }

        if (t) {
          const t = s(e.geometries),
                r = s(e.materials),
                i = s(e.textures),
                o = s(e.images),
                a = s(e.shapes),
                l = s(e.skeletons),
                c = s(e.animations),
                u = s(e.nodes);
          t.length > 0 && (n.geometries = t), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u);
        }

        return n.object = r, n;

        function s(e) {
          const t = [];

          for (const n in e) {
            const r = e[n];
            delete r.metadata, t.push(r);
          }

          return t;
        }
      }

      clone(e) {
        return new this.constructor().copy(this, e);
      }

      copy(e, t = !0) {
        this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = {};

        for (const [t, n] of Object.entries(e.userData)) this.userData[t] = !n || n && (n.isTexture || n.isObject3D) ? n : JSON.parse(JSON.stringify(n));

        if (!0 === t) for (let t = 0; t < e.children.length; t++) {
          const n = e.children[t];
          this.add(n.clone());
        }
        return this;
      }

    }

    ui.DefaultUp = new lr(0, 1, 0), ui.DefaultMatrixAutoUpdate = !0;

    const pi = new lr(),
          hi = new lr(),
          di = new lr(),
          fi = new lr(),
          _i = new lr(),
          mi = new lr(),
          gi = new lr(),
          vi = new lr(),
          bi = new lr(),
          xi = new lr();

    class yi {
      constructor(e = new lr(), t = new lr(), n = new lr()) {
        this.a = e, this.b = t, this.c = n;
      }

      static getNormal(e, t, n, r) {
        r.subVectors(n, t), pi.subVectors(e, t), r.cross(pi);
        const i = r.lengthSq();
        return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0);
      }

      static getBarycoord(e, t, n, r, i) {
        pi.subVectors(r, t), hi.subVectors(n, t), di.subVectors(e, t);
        const s = pi.dot(pi),
              o = pi.dot(hi),
              a = pi.dot(di),
              l = hi.dot(hi),
              c = hi.dot(di),
              u = s * l - o * o;
        if (0 === u) return i.set(-2, -1, -1);
        const p = 1 / u,
              h = (l * a - o * c) * p,
              d = (s * c - o * a) * p;
        return i.set(1 - h - d, d, h);
      }

      static containsPoint(e, t, n, r) {
        return this.getBarycoord(e, t, n, r, fi), fi.x >= 0 && fi.y >= 0 && fi.x + fi.y <= 1;
      }

      static getUV(e, t, n, r, i, s, o, a) {
        return this.getBarycoord(e, t, n, r, fi), a.set(0, 0), a.addScaledVector(i, fi.x), a.addScaledVector(s, fi.y), a.addScaledVector(o, fi.z), a;
      }

      static isFrontFacing(e, t, n, r) {
        return pi.subVectors(n, t), hi.subVectors(e, t), pi.cross(hi).dot(r) < 0;
      }

      set(e, t, n) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
      }

      setFromPointsAndIndices(e, t, n, r) {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
      }

      setFromAttributeAndIndices(e, t, n, r) {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this;
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
      }

      getArea() {
        return pi.subVectors(this.c, this.b), hi.subVectors(this.a, this.b), .5 * pi.cross(hi).length();
      }

      getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }

      getNormal(e) {
        return yi.getNormal(this.a, this.b, this.c, e);
      }

      getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
      }

      getBarycoord(e, t) {
        return yi.getBarycoord(e, this.a, this.b, this.c, t);
      }

      getUV(e, t, n, r, i) {
        return yi.getUV(e, this.a, this.b, this.c, t, n, r, i);
      }

      containsPoint(e) {
        return yi.containsPoint(e, this.a, this.b, this.c);
      }

      isFrontFacing(e) {
        return yi.isFrontFacing(this.a, this.b, this.c, e);
      }

      intersectsBox(e) {
        return e.intersectsTriangle(this);
      }

      closestPointToPoint(e, t) {
        const n = this.a,
              r = this.b,
              i = this.c;
        let s, o;
        _i.subVectors(r, n), mi.subVectors(i, n), vi.subVectors(e, n);

        const a = _i.dot(vi),
              l = mi.dot(vi);

        if (a <= 0 && l <= 0) return t.copy(n);
        bi.subVectors(e, r);

        const c = _i.dot(bi),
              u = mi.dot(bi);

        if (c >= 0 && u <= c) return t.copy(r);
        const p = a * u - c * l;
        if (p <= 0 && a >= 0 && c <= 0) return s = a / (a - c), t.copy(n).addScaledVector(_i, s);
        xi.subVectors(e, i);

        const h = _i.dot(xi),
              d = mi.dot(xi);

        if (d >= 0 && h <= d) return t.copy(i);
        const f = h * l - a * d;
        if (f <= 0 && l >= 0 && d <= 0) return o = l / (l - d), t.copy(n).addScaledVector(mi, o);

        const _ = c * d - h * u;

        if (_ <= 0 && u - c >= 0 && h - d >= 0) return gi.subVectors(i, r), o = (u - c) / (u - c + (h - d)), t.copy(r).addScaledVector(gi, o);
        const m = 1 / (_ + f + p);
        return s = f * m, o = p * m, t.copy(n).addScaledVector(_i, s).addScaledVector(mi, o);
      }

      equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
      }

    }

    let wi = 0;

    class Si extends vn {
      constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
          value: wi++
        }), this.uuid = Sn(), this.name = "", this.type = "Material", this.blending = x, this.side = f, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = L, this.blendDst = I, this.blendEquation = T, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = H, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = sn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ht, this.stencilZFail = Ht, this.stencilZPass = Ht, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
      }

      get alphaTest() {
        return this._alphaTest;
      }

      set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
      }

      onBuild() {}

      onBeforeRender() {}

      onBeforeCompile() {}

      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }

      setValues(e) {
        if (void 0 !== e) for (const t in e) {
          const n = e[t];

          if (void 0 === n) {
            console.warn("THREE.Material: '" + t + "' parameter is undefined.");
            continue;
          }

          if ("shading" === t) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === g;
            continue;
          }

          const r = this[t];
          void 0 !== r && (r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n);
        }
      }

      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        t && (e = {
          textures: {},
          images: {}
        });
        const n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };

        function r(e) {
          const t = [];

          for (const n in e) {
            const r = e[n];
            delete r.metadata, t.push(r);
          }

          return t;
        }

        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== x && (n.blending = this.blending), this.side !== f && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
          const t = r(e.textures),
                i = r(e.images);
          t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i);
        }

        return n;
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;

        if (null !== t) {
          const e = t.length;
          n = new Array(e);

          for (let r = 0; r !== e; ++r) n[r] = t[r].clone();
        }

        this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = {};

        for (const [t, n] of Object.entries(e.userData)) this.userData[t] = !n || n && (n.isTexture || n.isObject3D) ? n : JSON.parse(JSON.stringify(n));

        return this;
      }

      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }

      set needsUpdate(e) {
        !0 === e && this.version++;
      }

    }

    class Mi extends Si {
      constructor(e) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Xn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Y, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
      }

    }

    const Ti = new lr(),
          Ei = new Pn();

    class Ai {
      constructor(e, t, n) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = on, this.updateRange = {
          offset: 0,
          count: -1
        }, this.version = 0;
      }

      onUploadCallback() {}

      set needsUpdate(e) {
        !0 === e && this.version++;
      }

      setUsage(e) {
        return this.usage = e, this;
      }

      copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
      }

      copyAt(e, t, n) {
        e *= this.itemSize, n *= t.itemSize;

        for (let r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];

        return this;
      }

      copyArray(e) {
        return this.array.set(e), this;
      }

      copyColorsArray(e) {
        const t = this.array;
        let n = 0;

        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new Xn()), t[n++] = i.r, t[n++] = i.g, t[n++] = i.b;
        }

        return this;
      }

      copyVector2sArray(e) {
        const t = this.array;
        let n = 0;

        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new Pn()), t[n++] = i.x, t[n++] = i.y;
        }

        return this;
      }

      copyVector3sArray(e) {
        const t = this.array;
        let n = 0;

        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new lr()), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z;
        }

        return this;
      }

      copyVector4sArray(e) {
        const t = this.array;
        let n = 0;

        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new er()), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z, t[n++] = i.w;
        }

        return this;
      }

      applyMatrix3(e) {
        if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++) Ei.fromBufferAttribute(this, t), Ei.applyMatrix3(e), this.setXY(t, Ei.x, Ei.y);else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyMatrix3(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
        return this;
      }

      applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyMatrix4(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);

        return this;
      }

      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyNormalMatrix(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);

        return this;
      }

      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.transformDirection(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);

        return this;
      }

      set(e, t = 0) {
        return this.array.set(e, t), this;
      }

      getX(e) {
        return this.array[e * this.itemSize];
      }

      setX(e, t) {
        return this.array[e * this.itemSize] = t, this;
      }

      getY(e) {
        return this.array[e * this.itemSize + 1];
      }

      setY(e, t) {
        return this.array[e * this.itemSize + 1] = t, this;
      }

      getZ(e) {
        return this.array[e * this.itemSize + 2];
      }

      setZ(e, t) {
        return this.array[e * this.itemSize + 2] = t, this;
      }

      getW(e) {
        return this.array[e * this.itemSize + 3];
      }

      setW(e, t) {
        return this.array[e * this.itemSize + 3] = t, this;
      }

      setXY(e, t, n) {
        return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this;
      }

      setXYZ(e, t, n, r) {
        return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this;
      }

      setXYZW(e, t, n, r, i) {
        return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this;
      }

      onUpload(e) {
        return this.onUploadCallback = e, this;
      }

      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }

      toJSON() {
        const e = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized
        };
        return "" !== this.name && (e.name = this.name), this.usage !== on && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e;
      }

    }

    class Ci extends Ai {
      constructor(e, t, n) {
        super(new Int8Array(e), t, n);
      }

    }

    class Ri extends Ai {
      constructor(e, t, n) {
        super(new Uint8Array(e), t, n);
      }

    }

    class ki extends Ai {
      constructor(e, t, n) {
        super(new Uint8ClampedArray(e), t, n);
      }

    }

    class Pi extends Ai {
      constructor(e, t, n) {
        super(new Int16Array(e), t, n);
      }

    }

    class Di extends Ai {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
      }

    }

    class Oi extends Ai {
      constructor(e, t, n) {
        super(new Int32Array(e), t, n);
      }

    }

    class Li extends Ai {
      constructor(e, t, n) {
        super(new Uint32Array(e), t, n);
      }

    }

    class Ii extends Ai {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
      }

    }

    class Fi extends Ai {
      constructor(e, t, n) {
        super(new Float32Array(e), t, n);
      }

    }

    class Ni extends Ai {
      constructor(e, t, n) {
        super(new Float64Array(e), t, n);
      }

    }

    let Ui = 0;
    const Bi = new Br(),
          ji = new ui(),
          zi = new lr(),
          Vi = new pr(),
          Gi = new pr(),
          Hi = new lr();

    class Wi extends vn {
      constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
          value: Ui++
        }), this.uuid = Sn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
          start: 0,
          count: 1 / 0
        }, this.userData = {};
      }

      getIndex() {
        return this.index;
      }

      setIndex(e) {
        return Array.isArray(e) ? this.index = new (On(e) ? Li : Di)(e, 1) : this.index = e, this;
      }

      getAttribute(e) {
        return this.attributes[e];
      }

      setAttribute(e, t) {
        return this.attributes[e] = t, this;
      }

      deleteAttribute(e) {
        return delete this.attributes[e], this;
      }

      hasAttribute(e) {
        return void 0 !== this.attributes[e];
      }

      addGroup(e, t, n = 0) {
        this.groups.push({
          start: e,
          count: t,
          materialIndex: n
        });
      }

      clearGroups() {
        this.groups = [];
      }

      setDrawRange(e, t) {
        this.drawRange.start = e, this.drawRange.count = t;
      }

      applyMatrix4(e) {
        const t = this.attributes.position;
        void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
        const n = this.attributes.normal;

        if (void 0 !== n) {
          const t = new Dn().getNormalMatrix(e);
          n.applyNormalMatrix(t), n.needsUpdate = !0;
        }

        const r = this.attributes.tangent;
        return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
      }

      applyQuaternion(e) {
        return Bi.makeRotationFromQuaternion(e), this.applyMatrix4(Bi), this;
      }

      rotateX(e) {
        return Bi.makeRotationX(e), this.applyMatrix4(Bi), this;
      }

      rotateY(e) {
        return Bi.makeRotationY(e), this.applyMatrix4(Bi), this;
      }

      rotateZ(e) {
        return Bi.makeRotationZ(e), this.applyMatrix4(Bi), this;
      }

      translate(e, t, n) {
        return Bi.makeTranslation(e, t, n), this.applyMatrix4(Bi), this;
      }

      scale(e, t, n) {
        return Bi.makeScale(e, t, n), this.applyMatrix4(Bi), this;
      }

      lookAt(e) {
        return ji.lookAt(e), ji.updateMatrix(), this.applyMatrix4(ji.matrix), this;
      }

      center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(zi).negate(), this.translate(zi.x, zi.y, zi.z), this;
      }

      setFromPoints(e) {
        const t = [];

        for (let n = 0, r = e.length; n < r; n++) {
          const r = e[n];
          t.push(r.x, r.y, r.z || 0);
        }

        return this.setAttribute("position", new Fi(t, 3)), this;
      }

      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new pr());
        const e = this.attributes.position,
              t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new lr(-1 / 0, -1 / 0, -1 / 0), new lr(1 / 0, 1 / 0, 1 / 0));

        if (void 0 !== e) {
          if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            Vi.setFromBufferAttribute(n), this.morphTargetsRelative ? (Hi.addVectors(this.boundingBox.min, Vi.min), this.boundingBox.expandByPoint(Hi), Hi.addVectors(this.boundingBox.max, Vi.max), this.boundingBox.expandByPoint(Hi)) : (this.boundingBox.expandByPoint(Vi.min), this.boundingBox.expandByPoint(Vi.max));
          }
        } else this.boundingBox.makeEmpty();

        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }

      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new kr());
        const e = this.attributes.position,
              t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new lr(), 1 / 0);

        if (e) {
          const n = this.boundingSphere.center;
          if (Vi.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            Gi.setFromBufferAttribute(n), this.morphTargetsRelative ? (Hi.addVectors(Vi.min, Gi.min), Vi.expandByPoint(Hi), Hi.addVectors(Vi.max, Gi.max), Vi.expandByPoint(Hi)) : (Vi.expandByPoint(Gi.min), Vi.expandByPoint(Gi.max));
          }
          Vi.getCenter(n);
          let r = 0;

          for (let t = 0, i = e.count; t < i; t++) Hi.fromBufferAttribute(e, t), r = Math.max(r, n.distanceToSquared(Hi));

          if (t) for (let i = 0, s = t.length; i < s; i++) {
            const s = t[i],
                  o = this.morphTargetsRelative;

            for (let t = 0, i = s.count; t < i; t++) Hi.fromBufferAttribute(s, t), o && (zi.fromBufferAttribute(e, t), Hi.add(zi)), r = Math.max(r, n.distanceToSquared(Hi));
          }
          this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }

      computeTangents() {
        const e = this.index,
              t = this.attributes;
        if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const n = e.array,
              r = t.position.array,
              i = t.normal.array,
              s = t.uv.array,
              o = r.length / 3;
        !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ai(new Float32Array(4 * o), 4));
        const a = this.getAttribute("tangent").array,
              l = [],
              c = [];

        for (let e = 0; e < o; e++) l[e] = new lr(), c[e] = new lr();

        const u = new lr(),
              p = new lr(),
              h = new lr(),
              d = new Pn(),
              f = new Pn(),
              _ = new Pn(),
              m = new lr(),
              g = new lr();

        function v(e, t, n) {
          u.fromArray(r, 3 * e), p.fromArray(r, 3 * t), h.fromArray(r, 3 * n), d.fromArray(s, 2 * e), f.fromArray(s, 2 * t), _.fromArray(s, 2 * n), p.sub(u), h.sub(u), f.sub(d), _.sub(d);
          const i = 1 / (f.x * _.y - _.x * f.y);
          isFinite(i) && (m.copy(p).multiplyScalar(_.y).addScaledVector(h, -f.y).multiplyScalar(i), g.copy(h).multiplyScalar(f.x).addScaledVector(p, -_.x).multiplyScalar(i), l[e].add(m), l[t].add(m), l[n].add(m), c[e].add(g), c[t].add(g), c[n].add(g));
        }

        let b = this.groups;
        0 === b.length && (b = [{
          start: 0,
          count: n.length
        }]);

        for (let e = 0, t = b.length; e < t; ++e) {
          const t = b[e],
                r = t.start;

          for (let e = r, i = r + t.count; e < i; e += 3) v(n[e + 0], n[e + 1], n[e + 2]);
        }

        const x = new lr(),
              y = new lr(),
              w = new lr(),
              S = new lr();

        function M(e) {
          w.fromArray(i, 3 * e), S.copy(w);
          const t = l[e];
          x.copy(t), x.sub(w.multiplyScalar(w.dot(t))).normalize(), y.crossVectors(S, t);
          const n = y.dot(c[e]) < 0 ? -1 : 1;
          a[4 * e] = x.x, a[4 * e + 1] = x.y, a[4 * e + 2] = x.z, a[4 * e + 3] = n;
        }

        for (let e = 0, t = b.length; e < t; ++e) {
          const t = b[e],
                r = t.start;

          for (let e = r, i = r + t.count; e < i; e += 3) M(n[e + 0]), M(n[e + 1]), M(n[e + 2]);
        }
      }

      computeVertexNormals() {
        const e = this.index,
              t = this.getAttribute("position");

        if (void 0 !== t) {
          let n = this.getAttribute("normal");
          if (void 0 === n) n = new Ai(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
          const r = new lr(),
                i = new lr(),
                s = new lr(),
                o = new lr(),
                a = new lr(),
                l = new lr(),
                c = new lr(),
                u = new lr();
          if (e) for (let p = 0, h = e.count; p < h; p += 3) {
            const h = e.getX(p + 0),
                  d = e.getX(p + 1),
                  f = e.getX(p + 2);
            r.fromBufferAttribute(t, h), i.fromBufferAttribute(t, d), s.fromBufferAttribute(t, f), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), o.fromBufferAttribute(n, h), a.fromBufferAttribute(n, d), l.fromBufferAttribute(n, f), o.add(c), a.add(c), l.add(c), n.setXYZ(h, o.x, o.y, o.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z);
          } else for (let e = 0, o = t.count; e < o; e += 3) r.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
          this.normalizeNormals(), n.needsUpdate = !0;
        }
      }

      merge(e, t) {
        if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
        void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const n = this.attributes;

        for (const r in n) {
          if (void 0 === e.attributes[r]) continue;
          const i = n[r].array,
                s = e.attributes[r],
                o = s.array,
                a = s.itemSize * t,
                l = Math.min(o.length, i.length - a);

          for (let e = 0, t = a; e < l; e++, t++) i[t] = o[e];
        }

        return this;
      }

      normalizeNormals() {
        const e = this.attributes.normal;

        for (let t = 0, n = e.count; t < n; t++) Hi.fromBufferAttribute(e, t), Hi.normalize(), e.setXYZ(t, Hi.x, Hi.y, Hi.z);
      }

      toNonIndexed() {
        function e(e, t) {
          const n = e.array,
                r = e.itemSize,
                i = e.normalized,
                s = new n.constructor(t.length * r);
          let o = 0,
              a = 0;

          for (let i = 0, l = t.length; i < l; i++) {
            o = e.isInterleavedBufferAttribute ? t[i] * e.data.stride + e.offset : t[i] * r;

            for (let e = 0; e < r; e++) s[a++] = n[o++];
          }

          return new Ai(s, r, i);
        }

        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const t = new Wi(),
              n = this.index.array,
              r = this.attributes;

        for (const i in r) {
          const s = e(r[i], n);
          t.setAttribute(i, s);
        }

        const i = this.morphAttributes;

        for (const r in i) {
          const s = [],
                o = i[r];

          for (let t = 0, r = o.length; t < r; t++) {
            const r = e(o[t], n);
            s.push(r);
          }

          t.morphAttributes[r] = s;
        }

        t.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;

        for (let e = 0, n = s.length; e < n; e++) {
          const n = s[e];
          t.addGroup(n.start, n.count, n.materialIndex);
        }

        return t;
      }

      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };

        if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
          const t = this.parameters;

          for (const n in t) void 0 !== t[n] && (e[n] = t[n]);

          return e;
        }

        e.data = {
          attributes: {}
        };
        const t = this.index;
        null !== t && (e.data.index = {
          type: t.array.constructor.name,
          array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;

        for (const t in n) {
          const r = n[t];
          e.data.attributes[t] = r.toJSON(e.data);
        }

        const r = {};
        let i = !1;

        for (const t in this.morphAttributes) {
          const n = this.morphAttributes[t],
                s = [];

          for (let t = 0, r = n.length; t < r; t++) {
            const r = n[t];
            s.push(r.toJSON(e.data));
          }

          s.length > 0 && (r[t] = s, i = !0);
        }

        i && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const s = this.groups;
        s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
        const o = this.boundingSphere;
        return null !== o && (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius
        }), e;
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        null !== n && this.setIndex(n.clone(t));
        const r = e.attributes;

        for (const e in r) {
          const n = r[e];
          this.setAttribute(e, n.clone(t));
        }

        const i = e.morphAttributes;

        for (const e in i) {
          const n = [],
                r = i[e];

          for (let e = 0, i = r.length; e < i; e++) n.push(r[e].clone(t));

          this.morphAttributes[e] = n;
        }

        this.morphTargetsRelative = e.morphTargetsRelative;
        const s = e.groups;

        for (let e = 0, t = s.length; e < t; e++) {
          const t = s[e];
          this.addGroup(t.start, t.count, t.materialIndex);
        }

        const o = e.boundingBox;
        null !== o && (this.boundingBox = o.clone());
        const a = e.boundingSphere;
        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this;
      }

      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }

    }

    const Ki = new Br(),
          Xi = new Ur(),
          qi = new kr(),
          Yi = new lr(),
          Zi = new lr(),
          Ji = new lr(),
          $i = new lr(),
          Qi = new lr(),
          es = new lr(),
          ts = new lr(),
          ns = new lr(),
          rs = new lr(),
          is = new Pn(),
          ss = new Pn(),
          os = new Pn(),
          as = new lr(),
          ls = new lr();

    class cs extends ui {
      constructor(e = new Wi(), t = new Mi()) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
      }

      copy(e, t) {
        return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
      }

      updateMorphTargets() {
        const e = this.geometry.morphAttributes,
              t = Object.keys(e);

        if (t.length > 0) {
          const n = e[t[0]];

          if (void 0 !== n) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};

            for (let e = 0, t = n.length; e < t; e++) {
              const t = n[e].name || String(e);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e;
            }
          }
        }
      }

      raycast(e, t) {
        const n = this.geometry,
              r = this.material,
              i = this.matrixWorld;
        if (void 0 === r) return;
        if (null === n.boundingSphere && n.computeBoundingSphere(), qi.copy(n.boundingSphere), qi.applyMatrix4(i), !1 === e.ray.intersectsSphere(qi)) return;
        if (Ki.copy(i).invert(), Xi.copy(e.ray).applyMatrix4(Ki), null !== n.boundingBox && !1 === Xi.intersectsBox(n.boundingBox)) return;
        let s;
        const o = n.index,
              a = n.attributes.position,
              l = n.morphAttributes.position,
              c = n.morphTargetsRelative,
              u = n.attributes.uv,
              p = n.attributes.uv2,
              h = n.groups,
              d = n.drawRange;
        if (null !== o) {
          if (Array.isArray(r)) for (let n = 0, i = h.length; n < i; n++) {
            const i = h[n],
                  f = r[i.materialIndex];

            for (let n = Math.max(i.start, d.start), r = Math.min(o.count, Math.min(i.start + i.count, d.start + d.count)); n < r; n += 3) {
              const r = o.getX(n),
                    h = o.getX(n + 1),
                    d = o.getX(n + 2);
              s = us(this, f, e, Xi, a, l, c, u, p, r, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, t.push(s));
            }
          } else for (let n = Math.max(0, d.start), i = Math.min(o.count, d.start + d.count); n < i; n += 3) {
            const i = o.getX(n),
                  h = o.getX(n + 1),
                  d = o.getX(n + 2);
            s = us(this, r, e, Xi, a, l, c, u, p, i, h, d), s && (s.faceIndex = Math.floor(n / 3), t.push(s));
          }
        } else if (void 0 !== a) if (Array.isArray(r)) for (let n = 0, i = h.length; n < i; n++) {
          const i = h[n],
                o = r[i.materialIndex];

          for (let n = Math.max(i.start, d.start), r = Math.min(a.count, Math.min(i.start + i.count, d.start + d.count)); n < r; n += 3) s = us(this, o, e, Xi, a, l, c, u, p, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, t.push(s));
        } else for (let n = Math.max(0, d.start), i = Math.min(a.count, d.start + d.count); n < i; n += 3) s = us(this, r, e, Xi, a, l, c, u, p, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s));
      }

    }

    function us(e, t, n, r, i, s, o, a, l, c, u, p) {
      Yi.fromBufferAttribute(i, c), Zi.fromBufferAttribute(i, u), Ji.fromBufferAttribute(i, p);
      const h = e.morphTargetInfluences;

      if (s && h) {
        ts.set(0, 0, 0), ns.set(0, 0, 0), rs.set(0, 0, 0);

        for (let e = 0, t = s.length; e < t; e++) {
          const t = h[e],
                n = s[e];
          0 !== t && ($i.fromBufferAttribute(n, c), Qi.fromBufferAttribute(n, u), es.fromBufferAttribute(n, p), o ? (ts.addScaledVector($i, t), ns.addScaledVector(Qi, t), rs.addScaledVector(es, t)) : (ts.addScaledVector($i.sub(Yi), t), ns.addScaledVector(Qi.sub(Zi), t), rs.addScaledVector(es.sub(Ji), t)));
        }

        Yi.add(ts), Zi.add(ns), Ji.add(rs);
      }

      e.isSkinnedMesh && (e.boneTransform(c, Yi), e.boneTransform(u, Zi), e.boneTransform(p, Ji));

      const d = function (e, t, n, r, i, s, o, a) {
        let l;
        if (l = t.side === _ ? r.intersectTriangle(o, s, i, !0, a) : r.intersectTriangle(i, s, o, t.side !== m, a), null === l) return null;
        ls.copy(a), ls.applyMatrix4(e.matrixWorld);
        const c = n.ray.origin.distanceTo(ls);
        return c < n.near || c > n.far ? null : {
          distance: c,
          point: ls.clone(),
          object: e
        };
      }(e, t, n, r, Yi, Zi, Ji, as);

      if (d) {
        a && (is.fromBufferAttribute(a, c), ss.fromBufferAttribute(a, u), os.fromBufferAttribute(a, p), d.uv = yi.getUV(as, Yi, Zi, Ji, is, ss, os, new Pn())), l && (is.fromBufferAttribute(l, c), ss.fromBufferAttribute(l, u), os.fromBufferAttribute(l, p), d.uv2 = yi.getUV(as, Yi, Zi, Ji, is, ss, os, new Pn()));
        const e = {
          a: c,
          b: u,
          c: p,
          normal: new lr(),
          materialIndex: 0
        };
        yi.getNormal(Yi, Zi, Ji, e.normal), d.face = e;
      }

      return d;
    }

    class ps extends Wi {
      constructor(e = 1, t = 1, n = 1, r = 1, i = 1, s = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
          width: e,
          height: t,
          depth: n,
          widthSegments: r,
          heightSegments: i,
          depthSegments: s
        };
        const o = this;
        r = Math.floor(r), i = Math.floor(i), s = Math.floor(s);
        const a = [],
              l = [],
              c = [],
              u = [];
        let p = 0,
            h = 0;

        function d(e, t, n, r, i, s, d, f, _, m, g) {
          const v = s / _,
                b = d / m,
                x = s / 2,
                y = d / 2,
                w = f / 2,
                S = _ + 1,
                M = m + 1;
          let T = 0,
              E = 0;
          const A = new lr();

          for (let s = 0; s < M; s++) {
            const o = s * b - y;

            for (let a = 0; a < S; a++) {
              const p = a * v - x;
              A[e] = p * r, A[t] = o * i, A[n] = w, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(a / _), u.push(1 - s / m), T += 1;
            }
          }

          for (let e = 0; e < m; e++) for (let t = 0; t < _; t++) {
            const n = p + t + S * e,
                  r = p + t + S * (e + 1),
                  i = p + (t + 1) + S * (e + 1),
                  s = p + (t + 1) + S * e;
            a.push(n, r, s), a.push(r, i, s), E += 6;
          }

          o.addGroup(h, E, g), h += E, p += T;
        }

        d("z", "y", "x", -1, -1, n, t, e, s, i, 0), d("z", "y", "x", 1, -1, n, t, -e, s, i, 1), d("x", "z", "y", 1, 1, e, n, t, r, s, 2), d("x", "z", "y", 1, -1, e, n, -t, r, s, 3), d("x", "y", "z", 1, -1, e, t, n, r, i, 4), d("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(a), this.setAttribute("position", new Fi(l, 3)), this.setAttribute("normal", new Fi(c, 3)), this.setAttribute("uv", new Fi(u, 2));
      }

      static fromJSON(e) {
        return new ps(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
      }

    }

    function hs(e) {
      const t = {};

      for (const n in e) {
        t[n] = {};

        for (const r in e[n]) {
          const i = e[n][r];
          i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i;
        }
      }

      return t;
    }

    function ds(e) {
      const t = {};

      for (let n = 0; n < e.length; n++) {
        const r = hs(e[n]);

        for (const e in r) t[e] = r[e];
      }

      return t;
    }

    const fs = {
      clone: hs,
      merge: ds
    };

    class _s extends Si {
      constructor(e) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
      }

      copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = hs(e.uniforms), this.uniformsGroups = function (e) {
          const t = [];

          for (let n = 0; n < e.length; n++) t.push(e[n].clone());

          return t;
        }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
      }

      toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion, t.uniforms = {};

        for (const n in this.uniforms) {
          const r = this.uniforms[n].value;
          r && r.isTexture ? t.uniforms[n] = {
            type: "t",
            value: r.toJSON(e).uuid
          } : r && r.isColor ? t.uniforms[n] = {
            type: "c",
            value: r.getHex()
          } : r && r.isVector2 ? t.uniforms[n] = {
            type: "v2",
            value: r.toArray()
          } : r && r.isVector3 ? t.uniforms[n] = {
            type: "v3",
            value: r.toArray()
          } : r && r.isVector4 ? t.uniforms[n] = {
            type: "v4",
            value: r.toArray()
          } : r && r.isMatrix3 ? t.uniforms[n] = {
            type: "m3",
            value: r.toArray()
          } : r && r.isMatrix4 ? t.uniforms[n] = {
            type: "m4",
            value: r.toArray()
          } : t.uniforms[n] = {
            value: r
          };
        }

        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
        const n = {};

        for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);

        return Object.keys(n).length > 0 && (t.extensions = n), t;
      }

    }

    class ms extends ui {
      constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Br(), this.projectionMatrix = new Br(), this.projectionMatrixInverse = new Br();
      }

      copy(e, t) {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
      }

      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
      }

      updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }

      updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    class gs extends ms {
      constructor(e = 50, t = 1, n = .1, r = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
      }

      copy(e, t) {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
      }

      setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = 2 * wn * Math.atan(t), this.updateProjectionMatrix();
      }

      getFocalLength() {
        const e = Math.tan(.5 * yn * this.fov);
        return .5 * this.getFilmHeight() / e;
      }

      getEffectiveFOV() {
        return 2 * wn * Math.atan(Math.tan(.5 * yn * this.fov) / this.zoom);
      }

      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }

      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }

      setViewOffset(e, t, n, r, i, s) {
        this.aspect = e / t, null === this.view && (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix();
      }

      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      }

      updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(.5 * yn * this.fov) / this.zoom,
            n = 2 * t,
            r = this.aspect * n,
            i = -.5 * r;
        const s = this.view;

        if (null !== this.view && this.view.enabled) {
          const e = s.fullWidth,
                o = s.fullHeight;
          i += s.offsetX * r / e, t -= s.offsetY * n / o, r *= s.width / e, n *= s.height / o;
        }

        const o = this.filmOffset;
        0 !== o && (i += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }

      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
      }

    }

    const vs = 90;

    class bs extends ui {
      constructor(e, t, n) {
        if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = n;
        const r = new gs(vs, 1, e, t);
        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new lr(1, 0, 0)), this.add(r);
        const i = new gs(vs, 1, e, t);
        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new lr(-1, 0, 0)), this.add(i);
        const s = new gs(vs, 1, e, t);
        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new lr(0, 1, 0)), this.add(s);
        const o = new gs(vs, 1, e, t);
        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new lr(0, -1, 0)), this.add(o);
        const a = new gs(vs, 1, e, t);
        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new lr(0, 0, 1)), this.add(a);
        const l = new gs(vs, 1, e, t);
        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new lr(0, 0, -1)), this.add(l);
      }

      update(e, t) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget,
              [r, i, s, o, a, l] = this.children,
              c = e.getRenderTarget(),
              u = e.toneMapping,
              p = e.xr.enabled;
        e.toneMapping = $, e.xr.enabled = !1;
        const h = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, i), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, a), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(c), e.toneMapping = u, e.xr.enabled = p, n.texture.needsPMREMUpdate = !0;
      }

    }

    class xs extends Qn {
      constructor(e, t, n, r, i, s, o, a, l, c) {
        super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : se, n, r, i, s, o, a, l, c), this.isCubeTexture = !0, this.flipY = !1;
      }

      get images() {
        return this.image;
      }

      set images(e) {
        this.image = e;
      }

    }

    class ys extends tr {
      constructor(e, t = {}) {
        super(e, e, t), this.isWebGLCubeRenderTarget = !0;
        const n = {
          width: e,
          height: e,
          depth: 1
        },
              r = [n, n, n, n, n, n];
        this.texture = new xs(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : ve;
      }

      fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        const n = {
          tEquirect: {
            value: null
          }
        },
              r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
              s = new ps(5, 5, 5),
              o = new _s({
          name: "CubemapFromEquirect",
          uniforms: hs(n),
          vertexShader: r,
          fragmentShader: i,
          side: _,
          blending: b
        });
        o.uniforms.tEquirect.value = t;
        const a = new cs(s, o),
              l = t.minFilter;
        return t.minFilter === ye && (t.minFilter = ve), new bs(1, 10, this).update(e, a), t.minFilter = l, a.geometry.dispose(), a.material.dispose(), this;
      }

      clear(e, t, n, r) {
        const i = e.getRenderTarget();

        for (let i = 0; i < 6; i++) e.setRenderTarget(this, i), e.clear(t, n, r);

        e.setRenderTarget(i);
      }

    }

    const ws = new lr(),
          Ss = new lr(),
          Ms = new Dn();

    class Ts {
      constructor(e = new lr(1, 0, 0), t = 0) {
        this.isPlane = !0, this.normal = e, this.constant = t;
      }

      set(e, t) {
        return this.normal.copy(e), this.constant = t, this;
      }

      setComponents(e, t, n, r) {
        return this.normal.set(e, t, n), this.constant = r, this;
      }

      setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
      }

      setFromCoplanarPoints(e, t, n) {
        const r = ws.subVectors(n, t).cross(Ss.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this;
      }

      copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this;
      }

      normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this;
      }

      negate() {
        return this.constant *= -1, this.normal.negate(), this;
      }

      distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
      }

      distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
      }

      projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
      }

      intersectLine(e, t) {
        const n = e.delta(ws),
              r = this.normal.dot(n);
        if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
        const i = -(e.start.dot(this.normal) + this.constant) / r;
        return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start);
      }

      intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
              n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0;
      }

      intersectsBox(e) {
        return e.intersectsPlane(this);
      }

      intersectsSphere(e) {
        return e.intersectsPlane(this);
      }

      coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
      }

      applyMatrix4(e, t) {
        const n = t || Ms.getNormalMatrix(e),
              r = this.coplanarPoint(ws).applyMatrix4(e),
              i = this.normal.applyMatrix3(n).normalize();
        return this.constant = -r.dot(i), this;
      }

      translate(e) {
        return this.constant -= e.dot(this.normal), this;
      }

      equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    const Es = new kr(),
          As = new lr();

    class Cs {
      constructor(e = new Ts(), t = new Ts(), n = new Ts(), r = new Ts(), i = new Ts(), s = new Ts()) {
        this.planes = [e, t, n, r, i, s];
      }

      set(e, t, n, r, i, s) {
        const o = this.planes;
        return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this;
      }

      copy(e) {
        const t = this.planes;

        for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);

        return this;
      }

      setFromProjectionMatrix(e) {
        const t = this.planes,
              n = e.elements,
              r = n[0],
              i = n[1],
              s = n[2],
              o = n[3],
              a = n[4],
              l = n[5],
              c = n[6],
              u = n[7],
              p = n[8],
              h = n[9],
              d = n[10],
              f = n[11],
              _ = n[12],
              m = n[13],
              g = n[14],
              v = n[15];
        return t[0].setComponents(o - r, u - a, f - p, v - _).normalize(), t[1].setComponents(o + r, u + a, f + p, v + _).normalize(), t[2].setComponents(o + i, u + l, f + h, v + m).normalize(), t[3].setComponents(o - i, u - l, f - h, v - m).normalize(), t[4].setComponents(o - s, u - c, f - d, v - g).normalize(), t[5].setComponents(o + s, u + c, f + d, v + g).normalize(), this;
      }

      intersectsObject(e) {
        const t = e.geometry;
        return null === t.boundingSphere && t.computeBoundingSphere(), Es.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Es);
      }

      intersectsSprite(e) {
        return Es.center.set(0, 0, 0), Es.radius = .7071067811865476, Es.applyMatrix4(e.matrixWorld), this.intersectsSphere(Es);
      }

      intersectsSphere(e) {
        const t = this.planes,
              n = e.center,
              r = -e.radius;

        for (let e = 0; e < 6; e++) if (t[e].distanceToPoint(n) < r) return !1;

        return !0;
      }

      intersectsBox(e) {
        const t = this.planes;

        for (let n = 0; n < 6; n++) {
          const r = t[n];
          if (As.x = r.normal.x > 0 ? e.max.x : e.min.x, As.y = r.normal.y > 0 ? e.max.y : e.min.y, As.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(As) < 0) return !1;
        }

        return !0;
      }

      containsPoint(e) {
        const t = this.planes;

        for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;

        return !0;
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    function Rs() {
      let e = null,
          t = !1,
          n = null,
          r = null;

      function i(t, s) {
        n(t, s), r = e.requestAnimationFrame(i);
      }

      return {
        start: function () {
          !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0);
        },
        stop: function () {
          e.cancelAnimationFrame(r), t = !1;
        },
        setAnimationLoop: function (e) {
          n = e;
        },
        setContext: function (t) {
          e = t;
        }
      };
    }

    function ks(e, t) {
      const n = t.isWebGL2,
            r = new WeakMap();
      return {
        get: function (e) {
          return e.isInterleavedBufferAttribute && (e = e.data), r.get(e);
        },
        remove: function (t) {
          t.isInterleavedBufferAttribute && (t = t.data);
          const n = r.get(t);
          n && (e.deleteBuffer(n.buffer), r.delete(t));
        },
        update: function (t, i) {
          if (t.isGLBufferAttribute) {
            const e = r.get(t);
            return void ((!e || e.version < t.version) && r.set(t, {
              buffer: t.buffer,
              type: t.type,
              bytesPerElement: t.elementSize,
              version: t.version
            }));
          }

          t.isInterleavedBufferAttribute && (t = t.data);
          const s = r.get(t);
          void 0 === s ? r.set(t, function (t, r) {
            const i = t.array,
                  s = t.usage,
                  o = e.createBuffer();
            let a;
            if (e.bindBuffer(r, o), e.bufferData(r, i, s), t.onUploadCallback(), i instanceof Float32Array) a = 5126;else if (i instanceof Uint16Array) {
              if (t.isFloat16BufferAttribute) {
                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                a = 5131;
              } else a = 5123;
            } else if (i instanceof Int16Array) a = 5122;else if (i instanceof Uint32Array) a = 5125;else if (i instanceof Int32Array) a = 5124;else if (i instanceof Int8Array) a = 5120;else if (i instanceof Uint8Array) a = 5121;else {
              if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
              a = 5121;
            }
            return {
              buffer: o,
              type: a,
              bytesPerElement: i.BYTES_PER_ELEMENT,
              version: t.version
            };
          }(t, i)) : s.version < t.version && (function (t, r, i) {
            const s = r.array,
                  o = r.updateRange;
            e.bindBuffer(i, t), -1 === o.count ? e.bufferSubData(i, 0, s) : (n ? e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1);
          }(s.buffer, t, i), s.version = t.version);
        }
      };
    }

    class Ps extends Wi {
      constructor(e = 1, t = 1, n = 1, r = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
          width: e,
          height: t,
          widthSegments: n,
          heightSegments: r
        };
        const i = e / 2,
              s = t / 2,
              o = Math.floor(n),
              a = Math.floor(r),
              l = o + 1,
              c = a + 1,
              u = e / o,
              p = t / a,
              h = [],
              d = [],
              f = [],
              _ = [];

        for (let e = 0; e < c; e++) {
          const t = e * p - s;

          for (let n = 0; n < l; n++) {
            const r = n * u - i;
            d.push(r, -t, 0), f.push(0, 0, 1), _.push(n / o), _.push(1 - e / a);
          }
        }

        for (let e = 0; e < a; e++) for (let t = 0; t < o; t++) {
          const n = t + l * e,
                r = t + l * (e + 1),
                i = t + 1 + l * (e + 1),
                s = t + 1 + l * e;
          h.push(n, r, s), h.push(r, i, s);
        }

        this.setIndex(h), this.setAttribute("position", new Fi(d, 3)), this.setAttribute("normal", new Fi(f, 3)), this.setAttribute("uv", new Fi(_, 2));
      }

      static fromJSON(e) {
        return new Ps(e.width, e.height, e.widthSegments, e.heightSegments);
      }

    }

    const Ds = {
      alphamap_fragment: "#ifdef USE_ALPHAMAP\n\t#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1\n\tdiffuseColor.a *= 1.0-texture2D( alphaMap, vUv ).g;\n\t#else\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\t#endif\n#endif",
      alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
      alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
      aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
      aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      begin_vertex: "vec3 transformed = vec3( position );",
      beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
      iridescence_fragment: "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",
      bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
      cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}",
      envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\treflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 transformDirection1( in vec3 dir, in mat4 matrix ) {\n\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\t}\n\tmat4 rotationMatrix(vec3 axis, float angle) {\n\t\taxis = normalize(axis);\n\t\tfloat s = sin(angle);\n\t\tfloat c = cos(angle);\n\t\tfloat oc = 1.0 - c;\n\t\treturn mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n\t\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n\t\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t\t\t\t0.0,                                0.0,                                0.0,                                1.0);\n\t}\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform float envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif",
      envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tworldNormal = transformDirection1(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\treflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
      envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
      fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
      lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
      lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
      lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
      lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
      lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
      lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
      lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
      logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
      morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
      morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
      morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
      normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
      normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
      normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
      clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
      clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
      clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
      iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
      output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\ndiffuseColor.a = min(max(diffuseColor.a, 0.), 1.);\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
      premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
      shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
      skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
      transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn transmissionSamplerMapTexelToLinear ( texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n\t\t#else\n\t\t\treturn transmissionSamplerMapTexelToLinear ( texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
      uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
      uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
      uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
      uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
      uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
      uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
      worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nuniform bool flipX;\nuniform bool flipY;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;\n    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
      meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
      meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
    },
          Os = {
      common: {
        diffuse: {
          value: new Xn(16777215)
        },
        opacity: {
          value: 1
        },
        map: {
          value: null
        },
        uvTransform: {
          value: new Dn()
        },
        uv2Transform: {
          value: new Dn()
        },
        alphaMap: {
          value: null
        },
        alphaTest: {
          value: 0
        }
      },
      specularmap: {
        specularMap: {
          value: null
        }
      },
      envmap: {
        envMap: {
          value: null
        },
        envMapRotation: {
          value: 0
        },
        flipEnvMap: {
          value: -1
        },
        reflectivity: {
          value: 1
        },
        ior: {
          value: 1.5
        },
        refractionRatio: {
          value: .98
        }
      },
      aomap: {
        aoMap: {
          value: null
        },
        aoMapIntensity: {
          value: 1
        }
      },
      lightmap: {
        lightMap: {
          value: null
        },
        lightMapIntensity: {
          value: 1
        }
      },
      emissivemap: {
        emissiveMap: {
          value: null
        }
      },
      bumpmap: {
        bumpMap: {
          value: null
        },
        bumpScale: {
          value: 1
        }
      },
      normalmap: {
        normalMap: {
          value: null
        },
        normalScale: {
          value: new Pn(1, 1)
        }
      },
      displacementmap: {
        displacementMap: {
          value: null
        },
        displacementScale: {
          value: 1
        },
        displacementBias: {
          value: 0
        }
      },
      roughnessmap: {
        roughnessMap: {
          value: null
        }
      },
      metalnessmap: {
        metalnessMap: {
          value: null
        }
      },
      gradientmap: {
        gradientMap: {
          value: null
        }
      },
      fog: {
        fogDensity: {
          value: 25e-5
        },
        fogNear: {
          value: 1
        },
        fogFar: {
          value: 2e3
        },
        fogColor: {
          value: new Xn(16777215)
        }
      },
      lights: {
        ambientLightColor: {
          value: []
        },
        lightProbe: {
          value: []
        },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {}
          }
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: {
          value: []
        },
        directionalShadowMatrix: {
          value: []
        },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          }
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotShadowMap: {
          value: []
        },
        spotShadowMatrix: {
          value: []
        },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          }
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: {
          value: []
        },
        pointShadowMatrix: {
          value: []
        },
        hemisphereLights: {
          value: [],
          properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          }
        },
        rectAreaLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          }
        },
        ltc_1: {
          value: null
        },
        ltc_2: {
          value: null
        }
      },
      points: {
        diffuse: {
          value: new Xn(16777215)
        },
        opacity: {
          value: 1
        },
        size: {
          value: 1
        },
        scale: {
          value: 1
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        alphaTest: {
          value: 0
        },
        uvTransform: {
          value: new Dn()
        }
      },
      sprite: {
        diffuse: {
          value: new Xn(16777215)
        },
        opacity: {
          value: 1
        },
        center: {
          value: new Pn(.5, .5)
        },
        rotation: {
          value: 0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        alphaTest: {
          value: 0
        },
        uvTransform: {
          value: new Dn()
        }
      }
    },
          Ls = {
      basic: {
        uniforms: ds([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.fog]),
        vertexShader: Ds.meshbasic_vert,
        fragmentShader: Ds.meshbasic_frag
      },
      lambert: {
        uniforms: ds([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.fog, Os.lights, {
          emissive: {
            value: new Xn(0)
          }
        }]),
        vertexShader: Ds.meshlambert_vert,
        fragmentShader: Ds.meshlambert_frag
      },
      phong: {
        uniforms: ds([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.fog, Os.lights, {
          emissive: {
            value: new Xn(0)
          },
          specular: {
            value: new Xn(1118481)
          },
          shininess: {
            value: 30
          }
        }]),
        vertexShader: Ds.meshphong_vert,
        fragmentShader: Ds.meshphong_frag
      },
      standard: {
        uniforms: ds([Os.common, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.roughnessmap, Os.metalnessmap, Os.fog, Os.lights, {
          emissive: {
            value: new Xn(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }]),
        vertexShader: Ds.meshphysical_vert,
        fragmentShader: Ds.meshphysical_frag
      },
      toon: {
        uniforms: ds([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.gradientmap, Os.fog, Os.lights, {
          emissive: {
            value: new Xn(0)
          }
        }]),
        vertexShader: Ds.meshtoon_vert,
        fragmentShader: Ds.meshtoon_frag
      },
      matcap: {
        uniforms: ds([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.fog, {
          matcap: {
            value: null
          }
        }]),
        vertexShader: Ds.meshmatcap_vert,
        fragmentShader: Ds.meshmatcap_frag
      },
      points: {
        uniforms: ds([Os.points, Os.fog]),
        vertexShader: Ds.points_vert,
        fragmentShader: Ds.points_frag
      },
      dashed: {
        uniforms: ds([Os.common, Os.fog, {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }]),
        vertexShader: Ds.linedashed_vert,
        fragmentShader: Ds.linedashed_frag
      },
      depth: {
        uniforms: ds([Os.common, Os.displacementmap]),
        vertexShader: Ds.depth_vert,
        fragmentShader: Ds.depth_frag
      },
      normal: {
        uniforms: ds([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Ds.meshnormal_vert,
        fragmentShader: Ds.meshnormal_frag
      },
      sprite: {
        uniforms: ds([Os.sprite, Os.fog]),
        vertexShader: Ds.sprite_vert,
        fragmentShader: Ds.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: {
            value: new Dn()
          },
          t2D: {
            value: null
          },
          flipX: {
            value: !1
          },
          flipY: {
            value: !1
          }
        },
        vertexShader: Ds.background_vert,
        fragmentShader: Ds.background_frag
      },
      cube: {
        uniforms: ds([Os.envmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Ds.cube_vert,
        fragmentShader: Ds.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: Ds.equirect_vert,
        fragmentShader: Ds.equirect_frag
      },
      distanceRGBA: {
        uniforms: ds([Os.common, Os.displacementmap, {
          referencePosition: {
            value: new lr()
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }]),
        vertexShader: Ds.distanceRGBA_vert,
        fragmentShader: Ds.distanceRGBA_frag
      },
      shadow: {
        uniforms: ds([Os.lights, Os.fog, {
          color: {
            value: new Xn(0)
          },
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Ds.shadow_vert,
        fragmentShader: Ds.shadow_frag
      }
    };

    function Is(e, t, n, r, i, s) {
      const o = new Xn(0);
      let a,
          l,
          c = !0 === i ? 0 : 1,
          u = null,
          p = 0,
          h = null;

      function d(e, t) {
        n.buffers.color.setClear(e.r, e.g, e.b, t, s);
      }

      return {
        getClearColor: function () {
          return o;
        },
        setClearColor: function (e, t = 1) {
          o.set(e), c = t, d(o, c);
        },
        getClearAlpha: function () {
          return c;
        },
        setClearAlpha: function (e) {
          c = e, d(o, c);
        },
        getPlaneMesh: function () {
          return a;
        },
        getBoxMesh: function () {
          return l;
        },
        getBoxMesh2: function () {
          return void 0 === l && (l = new cs(new ps(1, 1, 1), new _s({
            name: "BackgroundCubeMaterial",
            uniforms: hs(Ls.cube.uniforms),
            vertexShader: Ls.cube.vertexShader,
            fragmentShader: Ls.cube.fragmentShader,
            side: _,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function (e, t, n) {
            this.matrixWorld.copyPosition(n.matrixWorld);
          }, Object.defineProperty(l.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            }
          }), r.update(l)), l;
        },
        render: function (n, i) {
          let s = !1,
              m = !0 === i.isScene ? i.background : null;
          m && m.isTexture && (m = t.get(m));
          const g = e.xr,
                v = g.getSession && g.getSession();
          v && "additive" === v.environmentBlendMode && (m = null), null === m ? d(o, c) : m && m.isColor && (d(m, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.mapping === ce) ? (void 0 === l && (l = new cs(new ps(1, 1, 1), new _s({
            name: "BackgroundCubeMaterial",
            uniforms: hs(Ls.cube.uniforms),
            vertexShader: Ls.cube.vertexShader,
            fragmentShader: Ls.cube.fragmentShader,
            side: _,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function (e, t, n) {
            this.matrixWorld.copyPosition(n.matrixWorld);
          }, Object.defineProperty(l.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            }
          }), r.update(l)), l.material.uniforms.envMap.value = m, l.material.uniforms.envMapRotation.value = m.rotation || 0, l.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, u === m && p === m.version && h === e.toneMapping || (l.material.needsUpdate = !0, u = m, p = m.version, h = e.toneMapping), l.layers.enableAll(), n.unshift(l, l.geometry, l.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && (a = new cs(new Ps(2, 2), new _s({
            name: "BackgroundMaterial",
            uniforms: hs(Ls.background.uniforms),
            vertexShader: Ls.background.vertexShader,
            fragmentShader: Ls.background.fragmentShader,
            side: f,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            }
          }), r.update(a)), a.material.uniforms.t2D.value = m, a.material.uniforms.flipX.value = m.userData.flipX || !1, a.material.uniforms.flipY.value = m.userData.flipY || !1, !0 === m.matrixAutoUpdate && m.updateMatrix(), a.material.uniforms.uvTransform.value.copy(m.matrix), u === m && p === m.version && h === e.toneMapping || (a.material.needsUpdate = !0, u = m, p = m.version, h = e.toneMapping), a.layers.enableAll(), n.unshift(a, a.geometry, a.material, 0, 0, null));
        }
      };
    }

    function Fs(e, t, n, r) {
      const i = e.getParameter(34921),
            s = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
            o = r.isWebGL2 || null !== s,
            a = {},
            l = d(null);
      let c = l,
          u = !1;

      function p(t) {
        return r.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t);
      }

      function h(t) {
        return r.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t);
      }

      function d(e) {
        const t = [],
              n = [],
              r = [];

        for (let e = 0; e < i; e++) t[e] = 0, n[e] = 0, r[e] = 0;

        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: t,
          enabledAttributes: n,
          attributeDivisors: r,
          object: e,
          attributes: {},
          index: null
        };
      }

      function f() {
        const e = c.newAttributes;

        for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
      }

      function _(e) {
        m(e, 0);
      }

      function m(n, i) {
        const s = c.newAttributes,
              o = c.enabledAttributes,
              a = c.attributeDivisors;
        s[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), a[n] !== i && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), a[n] = i);
      }

      function g() {
        const t = c.newAttributes,
              n = c.enabledAttributes;

        for (let r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0);
      }

      function v(t, n, i, s, o, a) {
        !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, s, o, a) : e.vertexAttribIPointer(t, n, i, o, a);
      }

      function b() {
        x(), u = !0, c !== l && (c = l, p(c.object));
      }

      function x() {
        l.geometry = null, l.program = null, l.wireframe = !1;
      }

      return {
        setup: function (i, l, h, b, x) {
          let y = !1;

          if (o) {
            const t = function (t, n, i) {
              const o = !0 === i.wireframe;
              let l = a[t.id];
              void 0 === l && (l = {}, a[t.id] = l);
              let c = l[n.id];
              void 0 === c && (c = {}, l[n.id] = c);
              let u = c[o];
              return void 0 === u && (u = d(r.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[o] = u), u;
            }(b, h, l);

            c !== t && (c = t, p(c.object)), y = function (e, t, n, r) {
              const i = c.attributes,
                    s = t.attributes;
              let o = 0;
              const a = n.getAttributes();

              for (const t in a) if (a[t].location >= 0) {
                const n = i[t];
                let r = s[t];
                if (void 0 === r && ("instanceMatrix" === t && e.instanceMatrix && (r = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (r = e.instanceColor)), void 0 === n) return !0;
                if (n.attribute !== r) return !0;
                if (r && n.data !== r.data) return !0;
                o++;
              }

              return c.attributesNum !== o || c.index !== r;
            }(i, b, h, x), y && function (e, t, n, r) {
              const i = {},
                    s = t.attributes;
              let o = 0;
              const a = n.getAttributes();

              for (const t in a) if (a[t].location >= 0) {
                let n = s[t];
                void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                const r = {};
                r.attribute = n, n && n.data && (r.data = n.data), i[t] = r, o++;
              }

              c.attributes = i, c.attributesNum = o, c.index = r;
            }(i, b, h, x);
          } else {
            const e = !0 === l.wireframe;
            c.geometry === b.id && c.program === h.id && c.wireframe === e || (c.geometry = b.id, c.program = h.id, c.wireframe = e, y = !0);
          }

          null !== x && n.update(x, 34963), (y || u) && (u = !1, function (i, s, o, a) {
            if (!1 === r.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
            f();
            const l = a.attributes,
                  c = o.getAttributes(),
                  u = s.defaultAttributeValues;

            for (const t in c) {
              const r = c[t];

              if (r.location >= 0) {
                let s = l[t];

                if (void 0 === s && ("instanceMatrix" === t && i.instanceMatrix && (s = i.instanceMatrix), "instanceColor" === t && i.instanceColor && (s = i.instanceColor)), void 0 !== s) {
                  const t = s.normalized,
                        o = s.itemSize,
                        l = n.get(s);
                  if (void 0 === l) continue;
                  const c = l.buffer,
                        u = l.type,
                        p = l.bytesPerElement;

                  if (s.isInterleavedBufferAttribute) {
                    const n = s.data,
                          l = n.stride,
                          h = s.offset;

                    if (n.isInstancedInterleavedBuffer) {
                      for (let e = 0; e < r.locationSize; e++) m(r.location + e, n.meshPerAttribute);

                      !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count);
                    } else for (let e = 0; e < r.locationSize; e++) _(r.location + e);

                    e.bindBuffer(34962, c);

                    for (let e = 0; e < r.locationSize; e++) v(r.location + e, o / r.locationSize, u, t, l * p, (h + o / r.locationSize * e) * p);
                  } else {
                    if (s.isInstancedBufferAttribute) {
                      for (let e = 0; e < r.locationSize; e++) m(r.location + e, s.meshPerAttribute);

                      !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count);
                    } else for (let e = 0; e < r.locationSize; e++) _(r.location + e);

                    e.bindBuffer(34962, c);

                    for (let e = 0; e < r.locationSize; e++) v(r.location + e, o / r.locationSize, u, t, o * p, o / r.locationSize * e * p);
                  }
                } else if (void 0 !== u) {
                  const n = u[t];
                  if (void 0 !== n) switch (n.length) {
                    case 2:
                      e.vertexAttrib2fv(r.location, n);
                      break;

                    case 3:
                      e.vertexAttrib3fv(r.location, n);
                      break;

                    case 4:
                      e.vertexAttrib4fv(r.location, n);
                      break;

                    default:
                      e.vertexAttrib1fv(r.location, n);
                  }
                }
              }
            }

            g();
          }(i, l, h, b), null !== x && e.bindBuffer(34963, n.get(x).buffer));
        },
        reset: b,
        resetDefaultState: x,
        dispose: function () {
          b();

          for (const e in a) {
            const t = a[e];

            for (const e in t) {
              const n = t[e];

              for (const e in n) h(n[e].object), delete n[e];

              delete t[e];
            }

            delete a[e];
          }
        },
        releaseStatesOfGeometry: function (e) {
          if (void 0 === a[e.id]) return;
          const t = a[e.id];

          for (const e in t) {
            const n = t[e];

            for (const e in n) h(n[e].object), delete n[e];

            delete t[e];
          }

          delete a[e.id];
        },
        releaseStatesOfProgram: function (e) {
          for (const t in a) {
            const n = a[t];
            if (void 0 === n[e.id]) continue;
            const r = n[e.id];

            for (const e in r) h(r[e].object), delete r[e];

            delete n[e.id];
          }
        },
        initAttributes: f,
        enableAttribute: _,
        disableUnusedAttributes: g
      };
    }

    function Ns(e, t, n, r) {
      const i = r.isWebGL2;
      let s;
      this.setMode = function (e) {
        s = e;
      }, this.render = function (t, r) {
        e.drawArrays(s, t, r), n.update(r, s, 1);
      }, this.renderInstances = function (r, o, a) {
        if (0 === a) return;
        let l, c;
        if (i) l = e, c = "drawArraysInstanced";else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l[c](s, r, o, a), n.update(o, s, a);
      };
    }

    function Us(e, t, n) {
      let r;

      function i(t) {
        if ("highp" === t) {
          if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
          t = "mediump";
        }

        return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
      }

      const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
      let o = void 0 !== n.precision ? n.precision : "highp";
      const a = i(o);
      a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);

      const l = s || t.has("WEBGL_draw_buffers"),
            c = !0 === n.logarithmicDepthBuffer,
            u = e.getParameter(34930),
            p = e.getParameter(35660),
            h = e.getParameter(3379),
            d = e.getParameter(34076),
            f = e.getParameter(34921),
            _ = e.getParameter(36347),
            m = e.getParameter(36348),
            g = e.getParameter(36349),
            v = p > 0,
            b = s || t.has("OES_texture_float");

      return {
        isWebGL2: s,
        drawBuffers: l,
        getMaxAnisotropy: function () {
          if (void 0 !== r) return r;

          if (!0 === t.has("EXT_texture_filter_anisotropic")) {
            const n = t.get("EXT_texture_filter_anisotropic");
            r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else r = 0;

          return r;
        },
        getMaxPrecision: i,
        precision: o,
        logarithmicDepthBuffer: c,
        maxTextures: u,
        maxVertexTextures: p,
        maxTextureSize: h,
        maxCubemapSize: d,
        maxAttributes: f,
        maxVertexUniforms: _,
        maxVaryings: m,
        maxFragmentUniforms: g,
        vertexTextures: v,
        floatFragmentTextures: b,
        floatVertexTextures: v && b,
        maxSamples: s ? e.getParameter(36183) : 0
      };
    }

    function Bs(e) {
      const t = this;
      let n = null,
          r = 0,
          i = !1,
          s = !1;
      const o = new Ts(),
            a = new Dn(),
            l = {
        value: null,
        needsUpdate: !1
      };

      function c() {
        l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0;
      }

      function u(e, n, r, i) {
        const s = null !== e ? e.length : 0;
        let c = null;

        if (0 !== s) {
          if (c = l.value, !0 !== i || null === c) {
            const t = r + 4 * s,
                  i = n.matrixWorldInverse;
            a.getNormalMatrix(i), (null === c || c.length < t) && (c = new Float32Array(t));

            for (let t = 0, n = r; t !== s; ++t, n += 4) o.copy(e[t]).applyMatrix4(i, a), o.normal.toArray(c, n), c[n + 3] = o.constant;
          }

          l.value = c, l.needsUpdate = !0;
        }

        return t.numPlanes = s, t.numIntersection = 0, c;
      }

      this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, s) {
        const o = 0 !== e.length || t || 0 !== r || i;
        return i = t, n = u(e, s, 0), r = e.length, o;
      }, this.beginShadows = function () {
        s = !0, u(null);
      }, this.endShadows = function () {
        s = !1, c();
      }, this.setState = function (t, o, a) {
        const p = t.clippingPlanes,
              h = t.clipIntersection,
              d = t.clipShadows,
              f = e.get(t);
        if (!i || null === p || 0 === p.length || s && !d) s ? u(null) : c();else {
          const e = s ? 0 : r,
                t = 4 * e;
          let i = f.clippingState || null;
          l.value = i, i = u(p, o, t, a);

          for (let e = 0; e !== t; ++e) i[e] = n[e];

          f.clippingState = i, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += e;
        }
      };
    }

    function js(e) {
      let t = new WeakMap();

      function n(e, t) {
        return t === ae ? e.mapping = se : t === le && (e.mapping = oe), e;
      }

      function r(e) {
        const n = e.target;
        n.removeEventListener("dispose", r);
        const i = t.get(n);
        void 0 !== i && (t.delete(n), i.dispose());
      }

      return {
        get: function (i) {
          if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
            const s = i.mapping;

            if (s === ae || s === le) {
              if (t.has(i)) {
                const e = t.get(i).texture;
                return e.rotation = i.rotation, n(e, i.mapping);
              }

              {
                const s = i.image;

                if (s && s.height > 0) {
                  const o = new ys(s.height / 2);
                  return o.fromEquirectangularTexture(e, i), o.texture.rotation = i.rotation, t.set(i, o), i.addEventListener("dispose", r), n(o.texture, i.mapping);
                }

                return null;
              }
            }
          }

          return i;
        },
        dispose: function () {
          t = new WeakMap();
        }
      };
    }

    Ls.physical = {
      uniforms: ds([Ls.standard.uniforms, {
        clearcoat: {
          value: 0
        },
        clearcoatMap: {
          value: null
        },
        clearcoatRoughness: {
          value: 0
        },
        clearcoatRoughnessMap: {
          value: null
        },
        clearcoatNormalScale: {
          value: new Pn(1, 1)
        },
        clearcoatNormalMap: {
          value: null
        },
        iridescence: {
          value: 0
        },
        iridescenceMap: {
          value: null
        },
        iridescenceIOR: {
          value: 1.3
        },
        iridescenceThicknessMinimum: {
          value: 100
        },
        iridescenceThicknessMaximum: {
          value: 400
        },
        iridescenceThicknessMap: {
          value: null
        },
        sheen: {
          value: 0
        },
        sheenColor: {
          value: new Xn(0)
        },
        sheenColorMap: {
          value: null
        },
        sheenRoughness: {
          value: 1
        },
        sheenRoughnessMap: {
          value: null
        },
        transmission: {
          value: 0
        },
        transmissionMap: {
          value: null
        },
        transmissionSamplerSize: {
          value: new Pn()
        },
        transmissionSamplerMap: {
          value: null
        },
        thickness: {
          value: 0
        },
        thicknessMap: {
          value: null
        },
        attenuationDistance: {
          value: 0
        },
        attenuationColor: {
          value: new Xn(0)
        },
        specularIntensity: {
          value: 1
        },
        specularIntensityMap: {
          value: null
        },
        specularColor: {
          value: new Xn(1, 1, 1)
        },
        specularColorMap: {
          value: null
        }
      }]),
      vertexShader: Ds.meshphysical_vert,
      fragmentShader: Ds.meshphysical_frag
    };

    class zs extends ms {
      constructor(e = -1, t = 1, n = 1, r = -1, i = .1, s = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix();
      }

      copy(e, t) {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this;
      }

      setViewOffset(e, t, n, r, i, s) {
        null === this.view && (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix();
      }

      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      }

      updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
              t = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              r = (this.top + this.bottom) / 2;
        let i = n - e,
            s = n + e,
            o = r + t,
            a = r - t;

        if (null !== this.view && this.view.enabled) {
          const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          i += e * this.view.offsetX, s = i + e * this.view.width, o -= t * this.view.offsetY, a = o - t * this.view.height;
        }

        this.projectionMatrix.makeOrthographic(i, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }

      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t;
      }

    }

    const Vs = [.125, .215, .35, .446, .526, .582],
          Gs = new zs(),
          Hs = new Xn();
    let Ws = null;
    const Ks = (1 + Math.sqrt(5)) / 2,
          Xs = 1 / Ks,
          qs = [new lr(1, 1, 1), new lr(-1, 1, 1), new lr(1, 1, -1), new lr(-1, 1, -1), new lr(0, Ks, Xs), new lr(0, Ks, -Xs), new lr(Xs, 0, Ks), new lr(-Xs, 0, Ks), new lr(Ks, Xs, 0), new lr(-Ks, Xs, 0)];

    class Ys {
      constructor(e) {
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
      }

      fromScene(e, t = 0, n = .1, r = 100) {
        Ws = this._renderer.getRenderTarget(), this._setSize(256);

        const i = this._allocateTargets();

        return i.depthBuffer = !0, this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i;
      }

      fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t);
      }

      fromCubemap(e, t = null) {
        return this._fromTexture(e, t);
      }

      compileCubemapShader() {
        null === this._cubemapMaterial && (this._cubemapMaterial = Qs(), this._compileMaterial(this._cubemapMaterial));
      }

      compileEquirectangularShader() {
        null === this._equirectMaterial && (this._equirectMaterial = $s(), this._compileMaterial(this._equirectMaterial));
      }

      dispose() {
        this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
      }

      _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
      }

      _dispose() {
        null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();

        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
      }

      _cleanup(e) {
        this._renderer.setRenderTarget(Ws), e.scissorTest = !1, Js(e, 0, 0, e.width, e.height);
      }

      _fromTexture(e, t) {
        e.mapping === se || e.mapping === oe ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Ws = this._renderer.getRenderTarget();

        const n = t || this._allocateTargets();

        return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
      }

      _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
              t = 4 * this._cubeSize,
              n = {
          magFilter: ve,
          minFilter: ve,
          generateMipmaps: !1,
          type: ke,
          format: Fe,
          encoding: Dt,
          depthBuffer: !1
        },
              r = Zs(e, t, n);

        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
          null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Zs(e, t, n);
          const {
            _lodMax: r
          } = this;
          ({
            sizeLods: this._sizeLods,
            lodPlanes: this._lodPlanes,
            sigmas: this._sigmas
          } = function (e) {
            const t = [],
                  n = [],
                  r = [];
            let i = e;
            const s = e - 4 + 1 + Vs.length;

            for (let o = 0; o < s; o++) {
              const s = Math.pow(2, i);
              n.push(s);
              let a = 1 / s;
              o > e - 4 ? a = Vs[o - e + 4 - 1] : 0 === o && (a = 0), r.push(a);
              const l = 1 / (s - 2),
                    c = -l,
                    u = 1 + l,
                    p = [c, c, u, c, u, u, c, c, u, u, c, u],
                    h = 6,
                    d = 6,
                    f = 3,
                    _ = 2,
                    m = 1,
                    g = new Float32Array(f * d * h),
                    v = new Float32Array(_ * d * h),
                    b = new Float32Array(m * d * h);

              for (let e = 0; e < h; e++) {
                const t = e % 3 * 2 / 3 - 1,
                      n = e > 2 ? 0 : -1,
                      r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                g.set(r, f * d * e), v.set(p, _ * d * e);
                const i = [e, e, e, e, e, e];
                b.set(i, m * d * e);
              }

              const x = new Wi();
              x.setAttribute("position", new Ai(g, f)), x.setAttribute("uv", new Ai(v, _)), x.setAttribute("faceIndex", new Ai(b, m)), t.push(x), i > 4 && i--;
            }

            return {
              lodPlanes: t,
              sizeLods: n,
              sigmas: r
            };
          }(r)), this._blurMaterial = function (e, t, n) {
            const r = new Float32Array(20),
                  i = new lr(0, 1, 0);
            return new _s({
              name: "SphericalGaussianBlur",
              defines: {
                n: 20,
                CUBEUV_TEXEL_WIDTH: 1 / t,
                CUBEUV_TEXEL_HEIGHT: 1 / n,
                CUBEUV_MAX_MIP: `${e}.0`
              },
              uniforms: {
                envMap: {
                  value: null
                },
                samples: {
                  value: 1
                },
                weights: {
                  value: r
                },
                latitudinal: {
                  value: !1
                },
                dTheta: {
                  value: 0
                },
                mipInt: {
                  value: 0
                },
                poleAxis: {
                  value: i
                }
              },
              vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
              fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
              blending: b,
              depthTest: !1,
              depthWrite: !1
            });
          }(r, e, t);
        }

        return r;
      }

      _compileMaterial(e) {
        const t = new cs(this._lodPlanes[0], e);

        this._renderer.compile(t, Gs);
      }

      _sceneToCubeUV(e, t, n, r) {
        const i = new gs(90, 1, t, n),
              s = [1, -1, 1, 1, 1, 1],
              o = [1, 1, 1, -1, -1, -1],
              a = this._renderer,
              l = a.autoClear,
              c = a.toneMapping;
        a.getClearColor(Hs), a.toneMapping = $, a.autoClear = !1;
        const u = new Mi({
          name: "PMREM.Background",
          side: _,
          depthWrite: !1,
          depthTest: !1
        }),
              p = new cs(new ps(), u);
        let h = !1;
        const d = e.background;
        d ? d.isColor && (u.color.copy(d), e.background = null, h = !0) : (u.color.copy(Hs), h = !0);

        for (let t = 0; t < 6; t++) {
          const n = t % 3;
          0 === n ? (i.up.set(0, s[t], 0), i.lookAt(o[t], 0, 0)) : 1 === n ? (i.up.set(0, 0, s[t]), i.lookAt(0, o[t], 0)) : (i.up.set(0, s[t], 0), i.lookAt(0, 0, o[t]));
          const l = this._cubeSize;
          Js(r, n * l, t > 2 ? l : 0, l, l), a.setRenderTarget(r), h && a.render(p, i), a.render(e, i);
        }

        p.geometry.dispose(), p.material.dispose(), a.toneMapping = c, a.autoClear = l, e.background = d;
      }

      _textureToCubeUV(e, t) {
        const n = this._renderer,
              r = e.mapping === se || e.mapping === oe;
        r ? (null === this._cubemapMaterial && (this._cubemapMaterial = Qs()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = $s());
        const i = r ? this._cubemapMaterial : this._equirectMaterial,
              s = new cs(this._lodPlanes[0], i);
        i.uniforms.envMap.value = e;
        const o = this._cubeSize;
        Js(t, 0, 0, 3 * o, 2 * o), n.setRenderTarget(t), n.render(s, Gs);
      }

      _applyPMREM(e) {
        const t = this._renderer,
              n = t.autoClear;
        t.autoClear = !1;

        for (let t = 1; t < this._lodPlanes.length; t++) {
          const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
                r = qs[(t - 1) % qs.length];

          this._blur(e, t - 1, t, n, r);
        }

        t.autoClear = n;
      }

      _blur(e, t, n, r, i) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(e, s, t, n, r, "latitudinal", i), this._halfBlur(s, e, n, n, r, "longitudinal", i);
      }

      _halfBlur(e, t, n, r, i, s, o) {
        const a = this._renderer,
              l = this._blurMaterial;
        "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = new cs(this._lodPlanes[r], l),
              u = l.uniforms,
              p = this._sizeLods[n] - 1,
              h = isFinite(i) ? Math.PI / (2 * p) : 2 * Math.PI / 39,
              d = i / h,
              f = isFinite(i) ? 1 + Math.floor(3 * d) : 20;
        f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
        const _ = [];
        let m = 0;

        for (let e = 0; e < 20; ++e) {
          const t = e / d,
                n = Math.exp(-t * t / 2);
          _.push(n), 0 === e ? m += n : e < f && (m += 2 * n);
        }

        for (let e = 0; e < _.length; e++) _[e] = _[e] / m;

        u.envMap.value = e.texture, u.samples.value = f, u.weights.value = _, u.latitudinal.value = "latitudinal" === s, o && (u.poleAxis.value = o);
        const {
          _lodMax: g
        } = this;
        u.dTheta.value = h, u.mipInt.value = g - n;
        const v = this._sizeLods[r];
        Js(t, 3 * v * (r > g - 4 ? r - g + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), a.setRenderTarget(t), a.render(c, Gs);
      }

    }

    function Zs(e, t, n) {
      const r = new tr(e, t, n);
      return r.texture.mapping = ce, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r;
    }

    function Js(e, t, n, r, i) {
      e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i);
    }

    function $s() {
      return new _s({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: {
            value: null
          }
        },
        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
        blending: b,
        depthTest: !1,
        depthWrite: !1
      });
    }

    function Qs() {
      return new _s({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          }
        },
        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
        blending: b,
        depthTest: !1,
        depthWrite: !1
      });
    }

    function eo(e) {
      let t = new WeakMap(),
          n = null;

      function r(e) {
        const n = e.target;
        n.removeEventListener("dispose", r);
        const i = t.get(n);
        void 0 !== i && (t.delete(n), i.dispose());
      }

      return {
        get: function (i) {
          if (i && i.isTexture) {
            const s = i.mapping,
                  o = s === ae || s === le,
                  a = s === se || s === oe;

            if (o || a) {
              if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                i.needsPMREMUpdate = !1;
                let r = t.get(i);
                return null === n && (n = new Ys(e)), r = o ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r), t.set(i, r), r.texture;
              }

              if (t.has(i)) return t.get(i).texture;
              {
                const s = i.image;

                if (o && s && s.height > 0 || a && s && function (e) {
                  let t = 0;

                  for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;

                  return 6 === t;
                }(s)) {
                  null === n && (n = new Ys(e));
                  const s = o ? n.fromEquirectangular(i) : n.fromCubemap(i);
                  return t.set(i, s), i.addEventListener("dispose", r), s.texture;
                }

                return null;
              }
            }
          }

          return i;
        },
        dispose: function () {
          t = new WeakMap(), null !== n && (n.dispose(), n = null);
        }
      };
    }

    function to(e) {
      const t = {};

      function n(n) {
        if (void 0 !== t[n]) return t[n];
        let r;

        switch (n) {
          case "WEBGL_depth_texture":
            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;

          case "EXT_texture_filter_anisotropic":
            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;

          case "WEBGL_compressed_texture_s3tc":
            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;

          case "WEBGL_compressed_texture_pvrtc":
            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;

          default:
            r = e.getExtension(n);
        }

        return t[n] = r, r;
      }

      return {
        has: function (e) {
          return null !== n(e);
        },
        init: function (e) {
          e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture");
        },
        get: function (e) {
          const t = n(e);
          return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t;
        }
      };
    }

    function no(e, t, n, r) {
      const i = {},
            s = new WeakMap();

      function o(e) {
        const a = e.target;
        null !== a.index && t.remove(a.index);

        for (const e in a.attributes) t.remove(a.attributes[e]);

        a.removeEventListener("dispose", o), delete i[a.id];
        const l = s.get(a);
        l && (t.remove(l), s.delete(a)), r.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--;
      }

      function a(e) {
        const n = [],
              r = e.index,
              i = e.attributes.position;
        let o = 0;

        if (null !== r) {
          const e = r.array;
          o = r.version;

          for (let t = 0, r = e.length; t < r; t += 3) {
            const r = e[t + 0],
                  i = e[t + 1],
                  s = e[t + 2];
            n.push(r, i, i, s, s, r);
          }
        } else {
          const e = i.array;
          o = i.version;

          for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
            const e = t + 0,
                  r = t + 1,
                  i = t + 2;
            n.push(e, r, r, i, i, e);
          }
        }

        const a = new (On(n) ? Li : Di)(n, 1);
        a.version = o;
        const l = s.get(e);
        l && t.remove(l), s.set(e, a);
      }

      return {
        get: function (e, t) {
          return !0 === i[t.id] || (t.addEventListener("dispose", o), i[t.id] = !0, n.memory.geometries++), t;
        },
        update: function (e) {
          const n = e.attributes;

          for (const e in n) t.update(n[e], 34962);

          const r = e.morphAttributes;

          for (const e in r) {
            const n = r[e];

            for (let e = 0, r = n.length; e < r; e++) t.update(n[e], 34962);
          }
        },
        getWireframeAttribute: function (e) {
          const t = s.get(e);

          if (t) {
            const n = e.index;
            null !== n && t.version < n.version && a(e);
          } else a(e);

          return s.get(e);
        }
      };
    }

    function ro(e, t, n, r) {
      const i = r.isWebGL2;
      let s, o, a;
      this.setMode = function (e) {
        s = e;
      }, this.setIndex = function (e) {
        o = e.type, a = e.bytesPerElement;
      }, this.render = function (t, r) {
        e.drawElements(s, r, o, t * a), n.update(r, s, 1);
      }, this.renderInstances = function (r, l, c) {
        if (0 === c) return;
        let u, p;
        if (i) u = e, p = "drawElementsInstanced";else if (u = t.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        u[p](s, l, o, r * a, c), n.update(l, s, c);
      };
    }

    function io(e) {
      const t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
      };
      return {
        memory: {
          geometries: 0,
          textures: 0
        },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function () {
          t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
        },
        update: function (e, n, r) {
          switch (t.calls++, n) {
            case 4:
              t.triangles += r * (e / 3);
              break;

            case 1:
              t.lines += r * (e / 2);
              break;

            case 3:
              t.lines += r * (e - 1);
              break;

            case 2:
              t.lines += r * e;
              break;

            case 0:
              t.points += r * e;
              break;

            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        }
      };
    }

    function so(e, t) {
      return e[0] - t[0];
    }

    function oo(e, t) {
      return Math.abs(t[1]) - Math.abs(e[1]);
    }

    function ao(e, t) {
      let n = 1;
      const r = t.isInterleavedBufferAttribute ? t.data.array : t.array;
      r instanceof Int8Array ? n = 127 : r instanceof Uint8Array ? n = 255 : r instanceof Uint16Array ? n = 65535 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), e.divideScalar(n);
    }

    function lo(e, t, n) {
      const r = {},
            i = new Float32Array(8),
            s = new WeakMap(),
            o = new er(),
            a = [];

      for (let e = 0; e < 8; e++) a[e] = [e, 0];

      return {
        update: function (l, c, u, p) {
          const h = l.morphTargetInfluences;

          if (!0 === t.isWebGL2) {
            const r = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                  i = void 0 !== r ? r.length : 0;
            let a = s.get(c);

            if (void 0 === a || a.count !== i) {
              void 0 !== a && a.texture.dispose();
              const e = void 0 !== c.morphAttributes.position,
                    n = void 0 !== c.morphAttributes.normal,
                    r = void 0 !== c.morphAttributes.color,
                    l = c.morphAttributes.position || [],
                    u = c.morphAttributes.normal || [],
                    p = c.morphAttributes.color || [];
              let h = 0;
              !0 === e && (h = 1), !0 === n && (h = 2), !0 === r && (h = 3);
              let d = c.attributes.position.count * h,
                  f = 1;
              d > t.maxTextureSize && (f = Math.ceil(d / t.maxTextureSize), d = t.maxTextureSize);

              const _ = new Float32Array(d * f * 4 * i),
                    m = new nr(_, d, f, i);

              m.type = Re, m.needsUpdate = !0;
              const g = 4 * h;

              for (let t = 0; t < i; t++) {
                const i = l[t],
                      s = u[t],
                      a = p[t],
                      c = d * f * 4 * t;

                for (let t = 0; t < i.count; t++) {
                  const l = t * g;
                  !0 === e && (o.fromBufferAttribute(i, t), !0 === i.normalized && ao(o, i), _[c + l + 0] = o.x, _[c + l + 1] = o.y, _[c + l + 2] = o.z, _[c + l + 3] = 0), !0 === n && (o.fromBufferAttribute(s, t), !0 === s.normalized && ao(o, s), _[c + l + 4] = o.x, _[c + l + 5] = o.y, _[c + l + 6] = o.z, _[c + l + 7] = 0), !0 === r && (o.fromBufferAttribute(a, t), !0 === a.normalized && ao(o, a), _[c + l + 8] = o.x, _[c + l + 9] = o.y, _[c + l + 10] = o.z, _[c + l + 11] = 4 === a.itemSize ? o.w : 1);
                }
              }

              a = {
                count: i,
                texture: m,
                size: new Pn(d, f)
              }, s.set(c, a), c.addEventListener("dispose", function e() {
                m.dispose(), s.delete(c), c.removeEventListener("dispose", e);
              });
            }

            let l = 0;

            for (let e = 0; e < h.length; e++) l += h[e];

            const u = c.morphTargetsRelative ? 1 : 1 - l;
            p.getUniforms().setValue(e, "morphTargetBaseInfluence", u), p.getUniforms().setValue(e, "morphTargetInfluences", h), p.getUniforms().setValue(e, "morphTargetsTexture", a.texture, n), p.getUniforms().setValue(e, "morphTargetsTextureSize", a.size);
          } else {
            const t = void 0 === h ? 0 : h.length;
            let n = r[c.id];

            if (void 0 === n || n.length !== t) {
              n = [];

              for (let e = 0; e < t; e++) n[e] = [e, 0];

              r[c.id] = n;
            }

            for (let e = 0; e < t; e++) {
              const t = n[e];
              t[0] = e, t[1] = h[e];
            }

            n.sort(oo);

            for (let e = 0; e < 8; e++) e < t && n[e][1] ? (a[e][0] = n[e][0], a[e][1] = n[e][1]) : (a[e][0] = Number.MAX_SAFE_INTEGER, a[e][1] = 0);

            a.sort(so);
            const s = c.morphAttributes.position,
                  o = c.morphAttributes.normal;
            let l = 0;

            for (let e = 0; e < 8; e++) {
              const t = a[e],
                    n = t[0],
                    r = t[1];
              n !== Number.MAX_SAFE_INTEGER && r ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]), o && c.getAttribute("morphNormal" + e) !== o[n] && c.setAttribute("morphNormal" + e, o[n]), i[e] = r, l += r) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), o && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), i[e] = 0);
            }

            const u = c.morphTargetsRelative ? 1 : 1 - l;
            p.getUniforms().setValue(e, "morphTargetBaseInfluence", u), p.getUniforms().setValue(e, "morphTargetInfluences", i);
          }
        }
      };
    }

    function co(e, t, n, r) {
      let i = new WeakMap();

      function s(e) {
        const t = e.target;
        t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor);
      }

      return {
        update: function (e) {
          const o = r.render.frame,
                a = e.geometry,
                l = t.get(e, a);
          return i.get(l) !== o && (t.update(l), i.set(l, o)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l;
        },
        dispose: function () {
          i = new WeakMap();
        }
      };
    }

    const uo = new Qn(),
          po = new nr(),
          ho = new ir(),
          fo = new xs(),
          _o = [],
          mo = [],
          go = new Float32Array(16),
          vo = new Float32Array(9),
          bo = new Float32Array(4);

    function xo(e, t, n) {
      const r = e[0];
      if (r <= 0 || r > 0) return e;
      const i = t * n;
      let s = _o[i];

      if (void 0 === s && (s = new Float32Array(i), _o[i] = s), 0 !== t) {
        r.toArray(s, 0);

        for (let r = 1, i = 0; r !== t; ++r) i += n, e[r].toArray(s, i);
      }

      return s;
    }

    function yo(e, t) {
      if (e.length !== t.length) return !1;

      for (let n = 0, r = e.length; n < r; n++) if (e[n] !== t[n]) return !1;

      return !0;
    }

    function wo(e, t) {
      for (let n = 0, r = t.length; n < r; n++) e[n] = t[n];
    }

    function So(e, t) {
      let n = mo[t];
      void 0 === n && (n = new Int32Array(t), mo[t] = n);

      for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();

      return n;
    }

    function Mo(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t);
    }

    function To(e, t) {
      const n = this.cache;
      if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);else {
        if (yo(n, t)) return;
        e.uniform2fv(this.addr, t), wo(n, t);
      }
    }

    function Eo(e, t) {
      const n = this.cache;
      if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);else {
        if (yo(n, t)) return;
        e.uniform3fv(this.addr, t), wo(n, t);
      }
    }

    function Ao(e, t) {
      const n = this.cache;
      if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);else {
        if (yo(n, t)) return;
        e.uniform4fv(this.addr, t), wo(n, t);
      }
    }

    function Co(e, t) {
      const n = this.cache,
            r = t.elements;

      if (void 0 === r) {
        if (yo(n, t)) return;
        e.uniformMatrix2fv(this.addr, !1, t), wo(n, t);
      } else {
        if (yo(n, r)) return;
        bo.set(r), e.uniformMatrix2fv(this.addr, !1, bo), wo(n, r);
      }
    }

    function Ro(e, t) {
      const n = this.cache,
            r = t.elements;

      if (void 0 === r) {
        if (yo(n, t)) return;
        e.uniformMatrix3fv(this.addr, !1, t), wo(n, t);
      } else {
        if (yo(n, r)) return;
        vo.set(r), e.uniformMatrix3fv(this.addr, !1, vo), wo(n, r);
      }
    }

    function ko(e, t) {
      const n = this.cache,
            r = t.elements;

      if (void 0 === r) {
        if (yo(n, t)) return;
        e.uniformMatrix4fv(this.addr, !1, t), wo(n, t);
      } else {
        if (yo(n, r)) return;
        go.set(r), e.uniformMatrix4fv(this.addr, !1, go), wo(n, r);
      }
    }

    function Po(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t);
    }

    function Do(e, t) {
      const n = this.cache;
      yo(n, t) || (e.uniform2iv(this.addr, t), wo(n, t));
    }

    function Oo(e, t) {
      const n = this.cache;
      yo(n, t) || (e.uniform3iv(this.addr, t), wo(n, t));
    }

    function Lo(e, t) {
      const n = this.cache;
      yo(n, t) || (e.uniform4iv(this.addr, t), wo(n, t));
    }

    function Io(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t);
    }

    function Fo(e, t) {
      const n = this.cache;
      yo(n, t) || (e.uniform2uiv(this.addr, t), wo(n, t));
    }

    function No(e, t) {
      const n = this.cache;
      yo(n, t) || (e.uniform3uiv(this.addr, t), wo(n, t));
    }

    function Uo(e, t) {
      const n = this.cache;
      yo(n, t) || (e.uniform4uiv(this.addr, t), wo(n, t));
    }

    function Bo(e, t, n) {
      const r = this.cache,
            i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(t || uo, i);
    }

    function jo(e, t, n) {
      const r = this.cache,
            i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || ho, i);
    }

    function zo(e, t, n) {
      const r = this.cache,
            i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || fo, i);
    }

    function Vo(e, t, n) {
      const r = this.cache,
            i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || po, i);
    }

    function Go(e, t) {
      e.uniform1fv(this.addr, t);
    }

    function Ho(e, t) {
      const n = xo(t, this.size, 2);
      e.uniform2fv(this.addr, n);
    }

    function Wo(e, t) {
      const n = xo(t, this.size, 3);
      e.uniform3fv(this.addr, n);
    }

    function Ko(e, t) {
      const n = xo(t, this.size, 4);
      e.uniform4fv(this.addr, n);
    }

    function Xo(e, t) {
      const n = xo(t, this.size, 4);
      e.uniformMatrix2fv(this.addr, !1, n);
    }

    function qo(e, t) {
      const n = xo(t, this.size, 9);
      e.uniformMatrix3fv(this.addr, !1, n);
    }

    function Yo(e, t) {
      const n = xo(t, this.size, 16);
      e.uniformMatrix4fv(this.addr, !1, n);
    }

    function Zo(e, t) {
      e.uniform1iv(this.addr, t);
    }

    function Jo(e, t) {
      e.uniform2iv(this.addr, t);
    }

    function $o(e, t) {
      e.uniform3iv(this.addr, t);
    }

    function Qo(e, t) {
      e.uniform4iv(this.addr, t);
    }

    function ea(e, t) {
      e.uniform1uiv(this.addr, t);
    }

    function ta(e, t) {
      e.uniform2uiv(this.addr, t);
    }

    function na(e, t) {
      e.uniform3uiv(this.addr, t);
    }

    function ra(e, t) {
      e.uniform4uiv(this.addr, t);
    }

    function ia(e, t, n) {
      const r = t.length,
            i = So(n, r);
      e.uniform1iv(this.addr, i);

      for (let e = 0; e !== r; ++e) n.setTexture2D(t[e] || uo, i[e]);
    }

    function sa(e, t, n) {
      const r = t.length,
            i = So(n, r);
      e.uniform1iv(this.addr, i);

      for (let e = 0; e !== r; ++e) n.setTexture3D(t[e] || ho, i[e]);
    }

    function oa(e, t, n) {
      const r = t.length,
            i = So(n, r);
      e.uniform1iv(this.addr, i);

      for (let e = 0; e !== r; ++e) n.setTextureCube(t[e] || fo, i[e]);
    }

    function aa(e, t, n) {
      const r = t.length,
            i = So(n, r);
      e.uniform1iv(this.addr, i);

      for (let e = 0; e !== r; ++e) n.setTexture2DArray(t[e] || po, i[e]);
    }

    class la {
      constructor(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) {
          switch (e) {
            case 5126:
              return Mo;

            case 35664:
              return To;

            case 35665:
              return Eo;

            case 35666:
              return Ao;

            case 35674:
              return Co;

            case 35675:
              return Ro;

            case 35676:
              return ko;

            case 5124:
            case 35670:
              return Po;

            case 35667:
            case 35671:
              return Do;

            case 35668:
            case 35672:
              return Oo;

            case 35669:
            case 35673:
              return Lo;

            case 5125:
              return Io;

            case 36294:
              return Fo;

            case 36295:
              return No;

            case 36296:
              return Uo;

            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Bo;

            case 35679:
            case 36299:
            case 36307:
              return jo;

            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return zo;

            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Vo;
          }
        }(t.type);
      }

    }

    class ca {
      constructor(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) {
          switch (e) {
            case 5126:
              return Go;

            case 35664:
              return Ho;

            case 35665:
              return Wo;

            case 35666:
              return Ko;

            case 35674:
              return Xo;

            case 35675:
              return qo;

            case 35676:
              return Yo;

            case 5124:
            case 35670:
              return Zo;

            case 35667:
            case 35671:
              return Jo;

            case 35668:
            case 35672:
              return $o;

            case 35669:
            case 35673:
              return Qo;

            case 5125:
              return ea;

            case 36294:
              return ta;

            case 36295:
              return na;

            case 36296:
              return ra;

            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return ia;

            case 35679:
            case 36299:
            case 36307:
              return sa;

            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return oa;

            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return aa;
          }
        }(t.type);
      }

    }

    class ua {
      constructor(e) {
        this.id = e, this.seq = [], this.map = {};
      }

      setValue(e, t, n) {
        const r = this.seq;

        for (let i = 0, s = r.length; i !== s; ++i) {
          const s = r[i];
          s.setValue(e, t[s.id], n);
        }
      }

    }

    const pa = /(\w+)(\])?(\[|\.)?/g;

    function ha(e, t) {
      e.seq.push(t), e.map[t.id] = t;
    }

    function da(e, t, n) {
      const r = e.name,
            i = r.length;

      for (pa.lastIndex = 0;;) {
        const s = pa.exec(r),
              o = pa.lastIndex;
        let a = s[1];
        const l = "]" === s[2],
              c = s[3];

        if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === i) {
          ha(n, void 0 === c ? new la(a, e, t) : new ca(a, e, t));
          break;
        }

        {
          let e = n.map[a];
          void 0 === e && (e = new ua(a), ha(n, e)), n = e;
        }
      }
    }

    class fa {
      constructor(e, t) {
        this.seq = [], this.map = {};
        const n = e.getProgramParameter(t, 35718);

        for (let r = 0; r < n; ++r) {
          const n = e.getActiveUniform(t, r);
          da(n, e.getUniformLocation(t, n.name), this);
        }
      }

      setValue(e, t, n, r) {
        const i = this.map[t];
        void 0 !== i && i.setValue(e, n, r);
      }

      setOptional(e, t, n) {
        const r = t[n];
        void 0 !== r && this.setValue(e, n, r);
      }

      static upload(e, t, n, r) {
        for (let i = 0, s = t.length; i !== s; ++i) {
          const s = t[i],
                o = n[s.id];
          !1 !== o.needsUpdate && s.setValue(e, o.value, r);
        }
      }

      static seqWithValue(e, t) {
        const n = [];

        for (let r = 0, i = e.length; r !== i; ++r) {
          const i = e[r];
          i.id in t && n.push(i);
        }

        return n;
      }

    }

    function _a(e, t, n) {
      const r = e.createShader(t);
      return e.shaderSource(r, n), e.compileShader(r), r;
    }

    let ma = 0;

    function ga(e) {
      switch (e) {
        case Dt:
          return ["Linear", "( value )"];

        case Ot:
          return ["sRGB", "( value )"];

        case It:
          return ["RGBM", "( value, 16.0 )"];

        default:
          return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"];
      }
    }

    function va(e, t, n) {
      const r = e.getShaderParameter(t, 35713),
            i = e.getShaderInfoLog(t).trim();
      if (r && "" === i) return "";
      const s = /ERROR: 0:(\d+)/.exec(i);

      if (s) {
        const r = parseInt(s[1]);
        return n.toUpperCase() + "\n\n" + i + "\n\n" + function (e, t) {
          const n = e.split("\n"),
                r = [],
                i = Math.max(t - 6, 0),
                s = Math.min(t + 6, n.length);

          for (let e = i; e < s; e++) {
            const i = e + 1;
            r.push(`${i === t ? ">" : " "} ${i}: ${n[e]}`);
          }

          return r.join("\n");
        }(e.getShaderSource(t), r);
      }

      return i;
    }

    function ba(e, t) {
      const n = ga(t);
      return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
    }

    function xa(e, t) {
      const n = ga(t);
      return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
    }

    function ya(e, t) {
      let n;

      switch (t) {
        case Q:
          n = "Linear";
          break;

        case ee:
          n = "Reinhard";
          break;

        case te:
          n = "OptimizedCineon";
          break;

        case ne:
          n = "ACESFilmic";
          break;

        case re:
          n = "Custom";
          break;

        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear";
      }

      return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
    }

    function wa(e) {
      return "" !== e;
    }

    function Sa(e, t) {
      return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
    }

    function Ma(e, t) {
      return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
    }

    const Ta = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Ea(e) {
      return e.replace(Ta, Aa);
    }

    function Aa(e, t) {
      const n = Ds[t];
      if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
      return Ea(n);
    }

    const Ca = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          Ra = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function ka(e) {
      return e.replace(Ra, Da).replace(Ca, Pa);
    }

    function Pa(e, t, n, r) {
      return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Da(0, t, n, r);
    }

    function Da(e, t, n, r) {
      let i = "";

      for (let e = parseInt(t); e < parseInt(n); e++) i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);

      return i;
    }

    function Oa(e) {
      let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
      return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t;
    }

    function La(e, t, n, r) {
      const i = e.getContext(),
            s = n.defines;
      let o = n.vertexShader,
          a = n.fragmentShader;

      const l = function (e) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return e.shadowMapType === p ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === h ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === d && (t = "SHADOWMAP_TYPE_VSM"), t;
      }(n),
            c = function (e) {
        let t = "ENVMAP_TYPE_CUBE";
        if (e.envMap) switch (e.envMapMode) {
          case se:
          case oe:
            t = "ENVMAP_TYPE_CUBE";
            break;

          case ce:
            t = "ENVMAP_TYPE_CUBE_UV";
        }
        return t;
      }(n),
            u = function (e) {
        let t = "ENVMAP_MODE_REFLECTION";
        return e.envMap && e.envMapMode === oe && (t = "ENVMAP_MODE_REFRACTION"), t;
      }(n),
            f = function (e) {
        let t = "ENVMAP_BLENDING_NONE";
        if (e.envMap) switch (e.combine) {
          case Y:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;

          case Z:
            t = "ENVMAP_BLENDING_MIX";
            break;

          case J:
            t = "ENVMAP_BLENDING_ADD";
        }
        return t;
      }(n),
            _ = function (e) {
        const t = e.envMapCubeUVHeight;
        if (null === t) return null;
        const n = Math.log2(t) - 2,
              r = 1 / t;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
          texelHeight: r,
          maxMip: n
        };
      }(n),
            m = n.isWebGL2 ? "" : function (e) {
        return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(wa).join("\n");
      }(n),
            g = function (e) {
        const t = [];

        for (const n in e) {
          const r = e[n];
          !1 !== r && t.push("#define " + n + " " + r);
        }

        return t.join("\n");
      }(s),
            v = i.createProgram();

      let b,
          x,
          y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
      n.isRawShaderMaterial ? (b = [g].filter(wa).join("\n"), b.length > 0 && (b += "\n"), x = [m, g].filter(wa).join("\n"), x.length > 0 && (x += "\n")) : (b = [Oa(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(wa).join("\n"), x = [m, Oa(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + f : "", _ ? "#define CUBEUV_TEXEL_WIDTH " + _.texelWidth : "", _ ? "#define CUBEUV_TEXEL_HEIGHT " + _.texelHeight : "", _ ? "#define CUBEUV_MAX_MIP " + _.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== $ ? "#define TONE_MAPPING" : "", n.toneMapping !== $ ? Ds.tonemapping_pars_fragment : "", n.toneMapping !== $ ? ya("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Ds.encodings_pars_fragment, xa("linearToOutputTexel", n.outputEncoding), n.transmissionSamplerMapEncoding ? ba("transmissionSamplerMapTexelToLinear", n.transmissionSamplerMapEncoding) : "", n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(wa).join("\n")), o = Ea(o), o = Sa(o, n), o = Ma(o, n), a = Ea(a), a = Sa(a, n), a = Ma(a, n), o = ka(o), a = ka(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", b = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + b, x = ["#define varying in", n.glslVersion === mn ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === mn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);

      const w = y + x + a,
            S = _a(i, 35633, y + b + o),
            M = _a(i, 35632, w);

      if (i.attachShader(v, S), i.attachShader(v, M), void 0 !== n.index0AttributeName ? i.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(v, 0, "position"), i.linkProgram(v), e.debug.checkShaderErrors) {
        const e = i.getProgramInfoLog(v).trim(),
              t = i.getShaderInfoLog(S).trim(),
              n = i.getShaderInfoLog(M).trim();
        let r = !0,
            s = !0;

        if (!1 === i.getProgramParameter(v, 35714)) {
          r = !1;
          const t = va(i, S, "vertex"),
                n = va(i, M, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n);
        } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (s = !1);

        s && (this.diagnostics = {
          runnable: r,
          programLog: e,
          vertexShader: {
            log: t,
            prefix: b
          },
          fragmentShader: {
            log: n,
            prefix: x
          }
        });
      }

      let T, E;
      return i.deleteShader(S), i.deleteShader(M), this.getUniforms = function () {
        return void 0 === T && (T = new fa(i, v)), T;
      }, this.getAttributes = function () {
        return void 0 === E && (E = function (e, t) {
          const n = {},
                r = e.getProgramParameter(t, 35721);

          for (let i = 0; i < r; i++) {
            const r = e.getActiveAttrib(t, i),
                  s = r.name;
            let o = 1;
            35674 === r.type && (o = 2), 35675 === r.type && (o = 3), 35676 === r.type && (o = 4), n[s] = {
              type: r.type,
              location: e.getAttribLocation(t, s),
              locationSize: o
            };
          }

          return n;
        }(i, v)), E;
      }, this.destroy = function () {
        r.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0;
      }, this.name = n.shaderName, this.id = ma++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = S, this.fragmentShader = M, this;
    }

    let Ia = 0;

    class Fa {
      constructor() {
        this.shaderCache = new Map(), this.materialCache = new Map();
      }

      update(e) {
        const t = e.vertexShader,
              n = e.fragmentShader,
              r = this._getShaderStage(t),
              i = this._getShaderStage(n),
              s = this._getShaderCacheForMaterial(e);

        return !1 === s.has(r) && (s.add(r), r.usedTimes++), !1 === s.has(i) && (s.add(i), i.usedTimes++), this;
      }

      remove(e) {
        const t = this.materialCache.get(e);

        for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);

        return this.materialCache.delete(e), this;
      }

      getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
      }

      getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
      }

      dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
      }

      _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        return !1 === t.has(e) && t.set(e, new Set()), t.get(e);
      }

      _getShaderStage(e) {
        const t = this.shaderCache;

        if (!1 === t.has(e)) {
          const n = new Na(e);
          t.set(e, n);
        }

        return t.get(e);
      }

    }

    class Na {
      constructor(e) {
        this.id = Ia++, this.code = e, this.usedTimes = 0;
      }

    }

    function Ua(e, t, n, r, i, s, o) {
      const a = new Zr(),
            l = new Fa(),
            c = [],
            u = i.isWebGL2,
            p = i.logarithmicDepthBuffer,
            h = i.vertexTextures;
      let d = i.precision;
      const f = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      };
      return {
        getParameters: function (s, a, c, g, v) {
          const b = g.fog,
                y = v.geometry,
                w = s.isMeshStandardMaterial ? g.environment : null,
                S = (s.isMeshStandardMaterial ? n : t).get(s.envMap || w),
                M = S && S.mapping === ce ? S.image.height : null,
                T = f[s.type];
          null !== s.precision && (d = i.getMaxPrecision(s.precision), d !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", d, "instead."));
          const E = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                A = void 0 !== E ? E.length : 0;
          let C,
              R,
              k,
              P,
              D = 0;

          if (void 0 !== y.morphAttributes.position && (D = 1), void 0 !== y.morphAttributes.normal && (D = 2), void 0 !== y.morphAttributes.color && (D = 3), T) {
            const e = Ls[T];
            C = e.vertexShader, R = e.fragmentShader;
          } else C = s.vertexShader, R = s.fragmentShader, l.update(s), k = l.getVertexShaderID(s), P = l.getFragmentShaderID(s);

          const O = e.getRenderTarget(),
                L = e.userData && e.userData.transmissionRenderTarget,
                I = s.alphaTest > 0,
                F = s.clearcoat > 0,
                N = s.iridescence > 0;
          return {
            isWebGL2: u,
            shaderID: T,
            shaderName: s.type,
            vertexShader: C,
            fragmentShader: R,
            defines: s.defines,
            customVertexShaderID: k,
            customFragmentShaderID: P,
            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
            glslVersion: s.glslVersion,
            precision: d,
            instancing: !0 === v.isInstancedMesh,
            instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
            supportsVertexTextures: h,
            outputEncoding: null === O ? e.outputEncoding : !0 === O.isXRRenderTarget || O.texture.encoding !== Ot ? O.texture.encoding : Dt,
            map: !!s.map,
            matcap: !!s.matcap,
            envMap: !!S,
            envMapMode: S && S.mapping,
            envMapCubeUVHeight: M,
            lightMap: !!s.lightMap,
            aoMap: !!s.aoMap,
            emissiveMap: !!s.emissiveMap,
            bumpMap: !!s.bumpMap,
            normalMap: !!s.normalMap,
            objectSpaceNormalMap: s.normalMapType === Bt,
            tangentSpaceNormalMap: s.normalMapType === Ut,
            decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === Ot,
            clearcoat: F,
            clearcoatMap: F && !!s.clearcoatMap,
            clearcoatRoughnessMap: F && !!s.clearcoatRoughnessMap,
            clearcoatNormalMap: F && !!s.clearcoatNormalMap,
            iridescence: N,
            iridescenceMap: N && !!s.iridescenceMap,
            iridescenceThicknessMap: N && !!s.iridescenceThicknessMap,
            displacementMap: !!s.displacementMap,
            roughnessMap: !!s.roughnessMap,
            metalnessMap: !!s.metalnessMap,
            specularMap: !!s.specularMap,
            specularIntensityMap: !!s.specularIntensityMap,
            specularColorMap: !!s.specularColorMap,
            opaque: !1 === s.transparent && s.blending === x && !(s.transmission > 0),
            alphaMap: !!s.alphaMap,
            alphaTest: I,
            gradientMap: !!s.gradientMap,
            sheen: s.sheen > 0,
            sheenColorMap: !!s.sheenColorMap,
            sheenRoughnessMap: !!s.sheenRoughnessMap,
            transmission: s.transmission > 0,
            transmissionMap: !!s.transmissionMap,
            transmissionSamplerMapEncoding: L ? L.texture.encoding : Dt,
            thicknessMap: !!s.thicknessMap,
            combine: s.combine,
            vertexTangents: !!s.normalMap && !!y.attributes.tangent,
            vertexColors: s.vertexColors,
            vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
            vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
            uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
            fog: !!b,
            useFog: !0 === s.fog,
            fogExp2: b && b.isFogExp2,
            flatShading: !!s.flatShading,
            sizeAttenuation: s.sizeAttenuation,
            logarithmicDepthBuffer: p,
            skinning: !0 === v.isSkinnedMesh,
            morphTargets: void 0 !== y.morphAttributes.position,
            morphNormals: void 0 !== y.morphAttributes.normal,
            morphColors: void 0 !== y.morphAttributes.color,
            morphTargetsCount: A,
            morphTextureStride: D,
            numDirLights: a.directional.length,
            numPointLights: a.point.length,
            numSpotLights: a.spot.length,
            numRectAreaLights: a.rectArea.length,
            numHemiLights: a.hemi.length,
            numDirLightShadows: a.directionalShadowMap.length,
            numPointLightShadows: a.pointShadowMap.length,
            numSpotLightShadows: a.spotShadowMap.length,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: s.dithering,
            shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: s.toneMapped ? e.toneMapping : $,
            physicallyCorrectLights: e.physicallyCorrectLights,
            premultipliedAlpha: s.premultipliedAlpha,
            doubleSided: s.side === m,
            flipSided: s.side === _,
            useDepthPacking: !!s.depthPacking,
            depthPacking: s.depthPacking || 0,
            index0AttributeName: s.index0AttributeName,
            extensionDerivatives: s.extensions && s.extensions.derivatives,
            extensionFragDepth: s.extensions && s.extensions.fragDepth,
            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
            extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: u || r.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"),
            customProgramCacheKey: s.customProgramCacheKey()
          };
        },
        getProgramCacheKey: function (t) {
          const n = [];
          if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]);
          return !1 === t.isRawShaderMaterial && (function (e, t) {
            e.push(t.precision), e.push(t.outputEncoding), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking);
          }(n, t), function (e, t) {
            a.disableAll(), t.isWebGL2 && a.enable(0), t.supportsVertexTextures && a.enable(1), t.instancing && a.enable(2), t.instancingColor && a.enable(3), t.map && a.enable(4), t.matcap && a.enable(5), t.envMap && a.enable(6), t.lightMap && a.enable(7), t.aoMap && a.enable(8), t.emissiveMap && a.enable(9), t.bumpMap && a.enable(10), t.normalMap && a.enable(11), t.objectSpaceNormalMap && a.enable(12), t.tangentSpaceNormalMap && a.enable(13), t.clearcoat && a.enable(14), t.clearcoatMap && a.enable(15), t.clearcoatRoughnessMap && a.enable(16), t.clearcoatNormalMap && a.enable(17), t.iridescence && a.enable(18), t.iridescenceMap && a.enable(19), t.iridescenceThicknessMap && a.enable(20), t.displacementMap && a.enable(21), t.specularMap && a.enable(22), t.roughnessMap && a.enable(23), t.metalnessMap && a.enable(24), t.gradientMap && a.enable(25), t.alphaMap && a.enable(26), t.alphaTest && a.enable(27), t.vertexColors && a.enable(28), t.vertexAlphas && a.enable(29), t.vertexUvs && a.enable(30), t.vertexTangents && a.enable(31), t.uvsVertexOnly && a.enable(32), t.fog && a.enable(33), e.push(a.mask), a.disableAll(), t.useFog && a.enable(0), t.flatShading && a.enable(1), t.logarithmicDepthBuffer && a.enable(2), t.skinning && a.enable(3), t.morphTargets && a.enable(4), t.morphNormals && a.enable(5), t.morphColors && a.enable(6), t.premultipliedAlpha && a.enable(7), t.shadowMapEnabled && a.enable(8), t.physicallyCorrectLights && a.enable(9), t.doubleSided && a.enable(10), t.flipSided && a.enable(11), t.useDepthPacking && a.enable(12), t.dithering && a.enable(13), t.specularIntensityMap && a.enable(14), t.specularColorMap && a.enable(15), t.transmission && a.enable(16), t.transmissionMap && a.enable(17), t.thicknessMap && a.enable(18), t.sheen && a.enable(19), t.sheenColorMap && a.enable(20), t.sheenRoughnessMap && a.enable(21), t.decodeVideoTexture && a.enable(22), t.opaque && a.enable(23), e.push(a.mask);
          }(n, t), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), n.join();
        },
        getUniforms: function (e) {
          const t = f[e.type];
          let n;

          if (t) {
            const e = Ls[t];
            n = fs.clone(e.uniforms);
          } else n = e.uniforms;

          return n;
        },
        acquireProgram: function (t, n) {
          let r;

          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];

            if (t.cacheKey === n) {
              r = t, ++r.usedTimes;
              break;
            }
          }

          return void 0 === r && (r = new La(e, n, t, s), c.push(r)), r;
        },
        releaseProgram: function (e) {
          if (0 == --e.usedTimes) {
            const t = c.indexOf(e);
            c[t] = c[c.length - 1], c.pop(), e.destroy();
          }
        },
        releaseShaderCache: function (e) {
          l.remove(e);
        },
        programs: c,
        dispose: function () {
          l.dispose();
        }
      };
    }

    function Ba() {
      let e = new WeakMap();
      return {
        get: function (t) {
          let n = e.get(t);
          return void 0 === n && (n = {}, e.set(t, n)), n;
        },
        remove: function (t) {
          e.delete(t);
        },
        update: function (t, n, r) {
          e.get(t)[n] = r;
        },
        dispose: function () {
          e = new WeakMap();
        }
      };
    }

    function ja(e, t) {
      return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
    }

    function za(e, t) {
      return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
    }

    function Va() {
      const e = [];
      let t = 0;
      const n = [],
            r = [],
            i = [];

      function s(n, r, i, s, o, a) {
        let l = e[t];
        return void 0 === l ? (l = {
          id: n.id,
          object: n,
          geometry: r,
          material: i,
          groupOrder: s,
          renderOrder: n.renderOrder,
          z: o,
          group: a
        }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = o, l.group = a), t++, l;
      }

      return {
        opaque: n,
        transmissive: r,
        transparent: i,
        init: function () {
          t = 0, n.length = 0, r.length = 0, i.length = 0;
        },
        push: function (e, t, o, a, l, c) {
          const u = s(e, t, o, a, l, c);
          o.transmission > 0 ? r.push(u) : !0 === o.transparent ? i.push(u) : n.push(u);
        },
        unshift: function (e, t, o, a, l, c) {
          const u = s(e, t, o, a, l, c);
          o.transmission > 0 ? r.unshift(u) : !0 === o.transparent ? i.unshift(u) : n.unshift(u);
        },
        finish: function () {
          for (let n = t, r = e.length; n < r; n++) {
            const t = e[n];
            if (null === t.id) break;
            t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null;
          }
        },
        sort: function (e, t) {
          n.length > 1 && n.sort(e || ja), r.length > 1 && r.sort(t || za), i.length > 1 && i.sort(t || za);
        }
      };
    }

    function Ga() {
      let e = new WeakMap();
      return {
        get: function (t, n) {
          let r;
          return !1 === e.has(t) ? (r = new Va(), e.set(t, [r])) : n >= e.get(t).length ? (r = new Va(), e.get(t).push(r)) : r = e.get(t)[n], r;
        },
        dispose: function () {
          e = new WeakMap();
        }
      };
    }

    function Ha() {
      const e = {};
      return {
        get: function (t) {
          if (void 0 !== e[t.id]) return e[t.id];
          let n;

          switch (t.type) {
            case "DirectionalLight":
              n = {
                direction: new lr(),
                color: new Xn()
              };
              break;

            case "SpotLight":
              n = {
                position: new lr(),
                direction: new lr(),
                color: new Xn(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0
              };
              break;

            case "PointLight":
              n = {
                position: new lr(),
                color: new Xn(),
                distance: 0,
                decay: 0
              };
              break;

            case "HemisphereLight":
              n = {
                direction: new lr(),
                skyColor: new Xn(),
                groundColor: new Xn()
              };
              break;

            case "RectAreaLight":
              n = {
                color: new Xn(),
                position: new lr(),
                halfWidth: new lr(),
                halfHeight: new lr()
              };
          }

          return e[t.id] = n, n;
        }
      };
    }

    let Wa = 0;

    function Ka(e, t) {
      return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
    }

    function Xa(e, t) {
      const n = new Ha(),
            r = function () {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let n;

            switch (t.type) {
              case "DirectionalLight":
              case "SpotLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Pn()
                };
                break;

              case "PointLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Pn(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
            }

            return e[t.id] = n, n;
          }
        };
      }(),
            i = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
      };

      for (let e = 0; e < 9; e++) i.probe.push(new lr());

      const s = new lr(),
            o = new Br(),
            a = new Br();
      return {
        setup: function (s, o) {
          let a = 0,
              l = 0,
              c = 0;

          for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);

          let u = 0,
              p = 0,
              h = 0,
              d = 0,
              f = 0,
              _ = 0,
              m = 0,
              g = 0;
          s.sort(Ka);
          const v = !0 !== o ? Math.PI : 1;

          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e],
                  o = t.color,
                  b = t.intensity,
                  x = t.distance,
                  y = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
            if (t.isAmbientLight) a += o.r * b * v, l += o.g * b * v, c += o.b * b * v;else if (t.isLightProbe) for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(t.sh.coefficients[e], b);else if (t.isDirectionalLight) {
              const e = n.get(t);

              if (e.color.copy(t.color).multiplyScalar(t.intensity * v), t.castShadow) {
                const e = t.shadow,
                      n = r.get(t);
                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.directionalShadow[u] = n, i.directionalShadowMap[u] = y, i.directionalShadowMatrix[u] = t.shadow.matrix, _++;
              }

              i.directional[u] = e, u++;
            } else if (t.isSpotLight) {
              const e = n.get(t);

              if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(o).multiplyScalar(b * v), e.distance = x, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                const e = t.shadow,
                      n = r.get(t);
                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.spotShadow[h] = n, i.spotShadowMap[h] = y, i.spotShadowMatrix[h] = t.shadow.matrix, g++;
              }

              i.spot[h] = e, h++;
            } else if (t.isRectAreaLight) {
              const e = n.get(t);
              e.color.copy(o).multiplyScalar(b), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), i.rectArea[d] = e, d++;
            } else if (t.isPointLight) {
              const e = n.get(t);

              if (e.color.copy(t.color).multiplyScalar(t.intensity * v), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                const e = t.shadow,
                      n = r.get(t);
                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, i.pointShadow[p] = n, i.pointShadowMap[p] = y, i.pointShadowMatrix[p] = t.shadow.matrix, m++;
              }

              i.point[p] = e, p++;
            } else if (t.isHemisphereLight) {
              const e = n.get(t);
              e.skyColor.copy(t.color).multiplyScalar(b * v), e.groundColor.copy(t.groundColor).multiplyScalar(b * v), i.hemi[f] = e, f++;
            }
          }

          d > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Os.LTC_FLOAT_1, i.rectAreaLTC2 = Os.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Os.LTC_HALF_1, i.rectAreaLTC2 = Os.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = a, i.ambient[1] = l, i.ambient[2] = c;
          const b = i.hash;
          b.directionalLength === u && b.pointLength === p && b.spotLength === h && b.rectAreaLength === d && b.hemiLength === f && b.numDirectionalShadows === _ && b.numPointShadows === m && b.numSpotShadows === g || (i.directional.length = u, i.spot.length = h, i.rectArea.length = d, i.point.length = p, i.hemi.length = f, i.directionalShadow.length = _, i.directionalShadowMap.length = _, i.pointShadow.length = m, i.pointShadowMap.length = m, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = _, i.pointShadowMatrix.length = m, i.spotShadowMatrix.length = g, b.directionalLength = u, b.pointLength = p, b.spotLength = h, b.rectAreaLength = d, b.hemiLength = f, b.numDirectionalShadows = _, b.numPointShadows = m, b.numSpotShadows = g, i.version = Wa++);
        },
        setupView: function (e, t) {
          let n = 0,
              r = 0,
              l = 0,
              c = 0,
              u = 0;
          const p = t.matrixWorldInverse;

          for (let t = 0, h = e.length; t < h; t++) {
            const h = e[t];

            if (h.isDirectionalLight) {
              const e = i.directional[n];
              e.direction.setFromMatrixPosition(h.matrixWorld), s.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(p), n++;
            } else if (h.isSpotLight) {
              const e = i.spot[l];
              e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(p), e.direction.setFromMatrixPosition(h.matrixWorld), s.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(p), l++;
            } else if (h.isRectAreaLight) {
              const e = i.rectArea[c];
              e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(p), a.identity(), o.copy(h.matrixWorld), o.premultiply(p), a.extractRotation(o), e.halfWidth.set(.5 * h.width, 0, 0), e.halfHeight.set(0, .5 * h.height, 0), e.halfWidth.applyMatrix4(a), e.halfHeight.applyMatrix4(a), c++;
            } else if (h.isPointLight) {
              const e = i.point[r];
              e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(p), r++;
            } else if (h.isHemisphereLight) {
              const e = i.hemi[u];
              e.direction.setFromMatrixPosition(h.matrixWorld), e.direction.transformDirection(p), u++;
            }
          }
        },
        state: i
      };
    }

    function qa(e, t) {
      const n = new Xa(e, t),
            r = [],
            i = [];
      return {
        init: function () {
          r.length = 0, i.length = 0;
        },
        state: {
          lightsArray: r,
          shadowsArray: i,
          lights: n
        },
        setupLights: function (e) {
          n.setup(r, e);
        },
        setupLightsView: function (e) {
          n.setupView(r, e);
        },
        pushLight: function (e) {
          r.push(e);
        },
        pushShadow: function (e) {
          i.push(e);
        }
      };
    }

    function Ya(e, t) {
      let n = new WeakMap();
      return {
        get: function (r, i = 0) {
          let s;
          return !1 === n.has(r) ? (s = new qa(e, t), n.set(r, [s])) : i >= n.get(r).length ? (s = new qa(e, t), n.get(r).push(s)) : s = n.get(r)[i], s;
        },
        dispose: function () {
          n = new WeakMap();
        }
      };
    }

    class Za extends Si {
      constructor(e) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Ft, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
      }

    }

    class Ja extends Si {
      constructor(e) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new lr(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
      }

    }

    function $a(e, t, n) {
      let r = new Cs();
      const i = new Pn(),
            s = new Pn(),
            o = new er(),
            a = new Za({
        depthPacking: Nt
      }),
            l = new Ja(),
            c = {},
            u = n.maxTextureSize,
            h = {
        0: _,
        1: f,
        2: m
      },
            g = new _s({
        defines: {
          VSM_SAMPLES: 8
        },
        uniforms: {
          shadow_pass: {
            value: null
          },
          resolution: {
            value: new Pn()
          },
          radius: {
            value: 4
          }
        },
        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
      }),
            v = g.clone();
      v.defines.HORIZONTAL_PASS = 1;
      const x = new Wi();
      x.setAttribute("position", new Ai(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
      const y = new cs(x, g),
            w = this;

      function S(n, r) {
        const s = t.update(y);
        g.defines.VSM_SAMPLES !== n.blurSamples && (g.defines.VSM_SAMPLES = n.blurSamples, v.defines.VSM_SAMPLES = n.blurSamples, g.needsUpdate = !0, v.needsUpdate = !0), null === n.mapPass && (n.mapPass = new tr(i.x, i.y)), g.uniforms.shadow_pass.value = n.map.texture, g.uniforms.resolution.value = n.mapSize, g.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, s, g, y, null), v.uniforms.shadow_pass.value = n.mapPass.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, s, v, y, null);
      }

      function M(t, n, r, i, s, o) {
        let u = null;
        const p = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;

        if (u = void 0 !== p ? p : !0 === r.isPointLight ? l : a, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
          const e = u.uuid,
                t = n.uuid;
          let r = c[e];
          void 0 === r && (r = {}, c[e] = r);
          let i = r[t];
          void 0 === i && (i = u.clone(), r[t] = i), u = i;
        }

        return u.visible = n.visible, u.wireframe = n.wireframe, u.side = o === d ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], u.alphaMap = n.alphaMap, u.alphaTest = n.alphaTest, u.clipShadows = n.clipShadows, u.clippingPlanes = n.clippingPlanes, u.clipIntersection = n.clipIntersection, u.displacementMap = n.displacementMap, u.displacementScale = n.displacementScale, u.displacementBias = n.displacementBias, u.wireframeLinewidth = n.wireframeLinewidth, u.linewidth = n.linewidth, !0 === r.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(r.matrixWorld), u.nearDistance = i, u.farDistance = s), u;
      }

      function T(n, i, s, o, a) {
        if (!1 === n.visible) return;

        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === d) && (!n.frustumCulled || r.intersectsObject(n))) {
          n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
          const r = t.update(n),
                i = n.material;

          if (Array.isArray(i)) {
            const t = r.groups;

            for (let l = 0, c = t.length; l < c; l++) {
              const c = t[l],
                    u = i[c.materialIndex];

              if (u && u.visible) {
                const t = M(n, u, o, s.near, s.far, a);
                e.renderBufferDirect(s, null, r, t, n, c);
              }
            }
          } else if (i.visible) {
            const t = M(n, i, o, s.near, s.far, a);
            e.renderBufferDirect(s, null, r, t, n, null);
          }
        }

        const l = n.children;

        for (let e = 0, t = l.length; e < t; e++) T(l[e], i, s, o, a);
      }

      this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = p, this.render = function (t, n, a) {
        if (!1 === w.enabled) return;
        if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
        if (0 === t.length) return;
        const l = e.getRenderTarget(),
              c = e.getActiveCubeFace(),
              p = e.getActiveMipmapLevel(),
              h = e.state;
        h.setBlending(b), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);

        for (let l = 0, c = t.length; l < c; l++) {
          const c = t[l],
                p = c.shadow;

          if (void 0 === p) {
            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
            continue;
          }

          if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
          i.copy(p.mapSize);
          const f = p.getFrameExtents();

          if (i.multiply(f), s.copy(p.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / f.x), i.x = s.x * f.x, p.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / f.y), i.y = s.y * f.y, p.mapSize.y = s.y)), null === p.map) {
            const e = this.type !== d ? {
              minFilter: de,
              magFilter: de
            } : {};
            p.map = new tr(i.x, i.y, e), p.map.texture.name = c.name + ".shadowMap", p.camera.updateProjectionMatrix();
          }

          e.setRenderTarget(p.map), e.clear();

          const _ = p.getViewportCount();

          for (let e = 0; e < _; e++) {
            const t = p.getViewport(e);
            o.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), h.viewport(o), p.updateMatrices(c, e), r = p.getFrustum(), T(n, a, p.camera, c, this.type);
          }

          !0 !== p.isPointLightShadow && this.type === d && S(p, a), p.needsUpdate = !1;
        }

        w.needsUpdate = !1, e.setRenderTarget(l, c, p);
      };
    }

    function Qa(e, t, n) {
      const r = n.isWebGL2,
            i = new function () {
        let t = !1;
        const n = new er();
        let r = null;
        const i = new er(0, 0, 0, 0);
        return {
          setMask: function (n) {
            r === n || t || (e.colorMask(n, n, n, n), r = n);
          },
          setLocked: function (e) {
            t = e;
          },
          setClear: function (t, r, s, o, a) {
            !0 === a && (t *= o, r *= o, s *= o), n.set(t, r, s, o), !1 === i.equals(n) && (e.clearColor(t, r, s, o), i.copy(n));
          },
          reset: function () {
            t = !1, r = null, i.set(-1, 0, 0, 0);
          }
        };
      }(),
            s = new function () {
        let t = !1,
            n = null,
            r = null,
            i = null;
        return {
          setTest: function (e) {
            e ? ye(2929) : we(2929);
          },
          setMask: function (r) {
            n === r || t || (e.depthMask(r), n = r);
          },
          setFunc: function (t) {
            if (r !== t) {
              if (t) switch (t) {
                case z:
                  e.depthFunc(512);
                  break;

                case V:
                  e.depthFunc(519);
                  break;

                case G:
                  e.depthFunc(513);
                  break;

                case H:
                  e.depthFunc(515);
                  break;

                case W:
                  e.depthFunc(514);
                  break;

                case K:
                  e.depthFunc(518);
                  break;

                case X:
                  e.depthFunc(516);
                  break;

                case q:
                  e.depthFunc(517);
                  break;

                default:
                  e.depthFunc(515);
              } else e.depthFunc(515);
              r = t;
            }
          },
          setLocked: function (e) {
            t = e;
          },
          setClear: function (t) {
            i !== t && (e.clearDepth(t), i = t);
          },
          reset: function () {
            t = !1, n = null, r = null, i = null;
          }
        };
      }(),
            c = new function () {
        let t = !1,
            n = null,
            r = null,
            i = null,
            s = null,
            o = null,
            a = null,
            l = null,
            c = null;
        return {
          setTest: function (e) {
            t || (e ? ye(2960) : we(2960));
          },
          setMask: function (r) {
            n === r || t || (e.stencilMask(r), n = r);
          },
          setFunc: function (t, n, o) {
            r === t && i === n && s === o || (e.stencilFunc(t, n, o), r = t, i = n, s = o);
          },
          setOp: function (t, n, r) {
            o === t && a === n && l === r || (e.stencilOp(t, n, r), o = t, a = n, l = r);
          },
          setLocked: function (e) {
            t = e;
          },
          setClear: function (t) {
            c !== t && (e.clearStencil(t), c = t);
          },
          reset: function () {
            t = !1, n = null, r = null, i = null, s = null, o = null, a = null, l = null, c = null;
          }
        };
      }(),
            u = new WeakMap(),
            p = new WeakMap();
      let h = {},
          d = {},
          f = new WeakMap(),
          g = [],
          v = null,
          Y = !1,
          Z = null,
          J = null,
          $ = null,
          Q = null,
          ee = null,
          te = null,
          ne = null,
          re = !1,
          ie = null,
          se = null,
          oe = null,
          ae = null,
          le = null;
      const ce = e.getParameter(35661);
      let ue = !1,
          pe = 0;
      const he = e.getParameter(7938);
      -1 !== he.indexOf("WebGL") ? (pe = parseFloat(/^WebGL (\d)/.exec(he)[1]), ue = pe >= 1) : -1 !== he.indexOf("OpenGL ES") && (pe = parseFloat(/^OpenGL ES (\d)/.exec(he)[1]), ue = pe >= 2);
      let de = null,
          fe = {};

      const _e = e.getParameter(3088),
            me = e.getParameter(2978),
            ge = new er().fromArray(_e),
            ve = new er().fromArray(me);

      function be(t, n, r) {
        const i = new Uint8Array(4),
              s = e.createTexture();
        e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);

        for (let t = 0; t < r; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, i);

        return s;
      }

      const xe = {};

      function ye(t) {
        !0 !== h[t] && (e.enable(t), h[t] = !0);
      }

      function we(t) {
        !1 !== h[t] && (e.disable(t), h[t] = !1);
      }

      xe[3553] = be(3553, 3553, 1), xe[34067] = be(34067, 34069, 6), i.setClear(0, 0, 0, 1), s.setClear(1), c.setClear(0), ye(2929), s.setFunc(H), Ee(!1), Ae(a), ye(2884), Te(b);
      const Se = {
        [T]: 32774,
        [E]: 32778,
        [A]: 32779
      };
      if (r) Se[C] = 32775, Se[R] = 32776;else {
        const e = t.get("EXT_blend_minmax");
        null !== e && (Se[C] = e.MIN_EXT, Se[R] = e.MAX_EXT);
      }
      const Me = {
        [k]: 0,
        [P]: 1,
        [D]: 768,
        [L]: 770,
        [j]: 776,
        [U]: 774,
        [F]: 772,
        [O]: 769,
        [I]: 771,
        [B]: 775,
        [N]: 773
      };

      function Te(t, n, r, i, s, o, a, l) {
        if (t !== b) {
          if (!1 === Y && (ye(3042), Y = !0), t === M) s = s || n, o = o || r, a = a || i, n === J && s === ee || (e.blendEquationSeparate(Se[n], Se[s]), J = n, ee = s), r === $ && i === Q && o === te && a === ne || (e.blendFuncSeparate(Me[r], Me[i], Me[o], Me[a]), $ = r, Q = i, te = o, ne = a), Z = t, re = null;else if (t !== Z || l !== re) {
            if (J === T && ee === T || (e.blendEquation(32774), J = T, ee = T), l) switch (t) {
              case x:
                e.blendFuncSeparate(1, 771, 1, 771);
                break;

              case y:
                e.blendFunc(1, 1);
                break;

              case w:
                e.blendFuncSeparate(0, 769, 0, 1);
                break;

              case S:
                e.blendFuncSeparate(0, 768, 0, 770);
                break;

              default:
                console.error("THREE.WebGLState: Invalid blending: ", t);
            } else switch (t) {
              case x:
                e.blendFuncSeparate(770, 771, 1, 771);
                break;

              case y:
                e.blendFunc(770, 1);
                break;

              case w:
                e.blendFuncSeparate(0, 769, 0, 1);
                break;

              case S:
                e.blendFunc(0, 768);
                break;

              default:
                console.error("THREE.WebGLState: Invalid blending: ", t);
            }
            $ = null, Q = null, te = null, ne = null, Z = t, re = l;
          }
        } else !0 === Y && (we(3042), Y = !1);
      }

      function Ee(t) {
        ie !== t && (t ? e.frontFace(2304) : e.frontFace(2305), ie = t);
      }

      function Ae(t) {
        t !== o ? (ye(2884), t !== se && (t === a ? e.cullFace(1029) : t === l ? e.cullFace(1028) : e.cullFace(1032))) : we(2884), se = t;
      }

      function Ce(t, n, r) {
        t ? (ye(32823), ae === n && le === r || (e.polygonOffset(n, r), ae = n, le = r)) : we(32823);
      }

      function Re(t) {
        void 0 === t && (t = 33984 + ce - 1), de !== t && (e.activeTexture(t), de = t);
      }

      return {
        buffers: {
          color: i,
          depth: s,
          stencil: c
        },
        enable: ye,
        disable: we,
        bindFramebuffer: function (t, n) {
          return d[t] !== n && (e.bindFramebuffer(t, n), d[t] = n, r && (36009 === t && (d[36160] = n), 36160 === t && (d[36009] = n)), !0);
        },
        drawBuffers: function (r, i) {
          let s = g,
              o = !1;
          if (r) {
            if (s = f.get(i), void 0 === s && (s = [], f.set(i, s)), r.isWebGLMultipleRenderTargets) {
              const e = r.texture;

              if (s.length !== e.length || 36064 !== s[0]) {
                for (let t = 0, n = e.length; t < n; t++) s[t] = 36064 + t;

                s.length = e.length, o = !0;
              }
            } else 36064 !== s[0] && (s[0] = 36064, o = !0);
          } else 1029 !== s[0] && (s[0] = 1029, o = !0);
          o && (n.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
        },
        useProgram: function (t) {
          return v !== t && (e.useProgram(t), v = t, !0);
        },
        setBlending: Te,
        setMaterial: function (e, t) {
          e.side === m ? we(2884) : ye(2884);
          let n = e.side === _;
          t && (n = !n), Ee(n), e.blending === x && !1 === e.transparent ? Te(b) : Te(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), i.setMask(e.colorWrite);
          const r = e.stencilWrite;
          c.setTest(r), r && (c.setMask(e.stencilWriteMask), c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Ce(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? ye(32926) : we(32926);
        },
        setFlipSided: Ee,
        setCullFace: Ae,
        setLineWidth: function (t) {
          t !== oe && (ue && e.lineWidth(t), oe = t);
        },
        setPolygonOffset: Ce,
        setScissorTest: function (e) {
          e ? ye(3089) : we(3089);
        },
        activeTexture: Re,
        bindTexture: function (t, n) {
          null === de && Re();
          let r = fe[de];
          void 0 === r && (r = {
            type: void 0,
            texture: void 0
          }, fe[de] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || xe[t]), r.type = t, r.texture = n);
        },
        unbindTexture: function () {
          const t = fe[de];
          void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0);
        },
        compressedTexImage2D: function () {
          try {
            e.compressedTexImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage2D: function () {
          try {
            e.texImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage3D: function () {
          try {
            e.texImage3D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        updateUBOMapping: function (t, n) {
          let r = p.get(n);
          void 0 === r && (r = new WeakMap(), p.set(n, r));
          let i = r.get(t);
          void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i));
        },
        uniformBlockBinding: function (t, n) {
          const r = p.get(n).get(t);
          u.get(t) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), u.set(t, r));
        },
        texStorage2D: function () {
          try {
            e.texStorage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texStorage3D: function () {
          try {
            e.texStorage3D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texSubImage2D: function () {
          try {
            e.texSubImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texSubImage3D: function () {
          try {
            e.texSubImage3D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        compressedTexSubImage2D: function () {
          try {
            e.compressedTexSubImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        scissor: function (t) {
          !1 === ge.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), ge.copy(t));
        },
        viewport: function (t) {
          !1 === ve.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ve.copy(t));
        },
        reset: function () {
          e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === r && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), h = {}, de = null, fe = {}, d = {}, f = new WeakMap(), g = [], v = null, Y = !1, Z = null, J = null, $ = null, Q = null, ee = null, te = null, ne = null, re = !1, ie = null, se = null, oe = null, ae = null, le = null, ge.set(0, 0, e.canvas.width, e.canvas.height), ve.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), s.reset(), c.reset();
        }
      };
    }

    function el(e, t, n, r, i, s, o) {
      const a = i.isWebGL2,
            l = i.maxTextures,
            c = i.maxCubemapSize,
            u = i.maxTextureSize,
            p = i.maxSamples,
            h = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
            d = /OculusBrowser/g.test(navigator.userAgent),
            f = new WeakMap();

      let _;

      const m = new WeakMap();
      let g = !1;

      try {
        g = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (e) {}

      function v(e, t) {
        return g ? new OffscreenCanvas(e, t) : Fn("canvas");
      }

      function b(e, t, n, r) {
        let i = 1;

        if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
          if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
            const r = t ? Rn : Math.floor,
                  s = r(i * e.width),
                  o = r(i * e.height);
            void 0 === _ && (_ = v(s, o));
            const a = n ? v(s, o) : _;
            return a.width = s, a.height = o, a.getContext("2d").drawImage(e, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + o + ")."), a;
          }

          return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e;
        }

        return e;
      }

      function x(e) {
        return An(e.width) && An(e.height);
      }

      function y(e, t) {
        return e.generateMipmaps && t && e.minFilter !== de && e.minFilter !== ve;
      }

      function w(t) {
        e.generateMipmap(t);
      }

      function S(n, r, i, s, o = !1) {
        if (!1 === a) return r;

        if (null !== n) {
          if (void 0 !== e[n]) return e[n];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'");
        }

        let l = r;
        return 6403 === r && (5126 === i && (l = 33326), 5131 === i && (l = 33325), 5121 === i && (l = 33321)), 33319 === r && (5126 === i && (l = 33328), 5131 === i && (l = 33327), 5121 === i && (l = 33323)), 6408 === r && (5126 === i && (l = 34836), 5131 === i && (l = 34842), 5121 === i && (l = s === Ot && !1 === o ? 35907 : 32856), 32819 === i && (l = 32854), 32820 === i && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || t.get("EXT_color_buffer_float"), l;
      }

      function M(e, t, n) {
        return !0 === y(e, n) || e.isFramebufferTexture && e.minFilter !== de && e.minFilter !== ve ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1;
      }

      function T(e) {
        return e === de || e === fe || e === me ? 9728 : 9729;
      }

      function E(e) {
        const t = e.target;
        t.removeEventListener("dispose", E), function (e) {
          const t = r.get(e);
          if (void 0 === t.__webglInit) return;
          const n = e.source,
                i = m.get(n);

          if (i) {
            const r = i[t.__cacheKey];
            r.usedTimes--, 0 === r.usedTimes && C(e), 0 === Object.keys(i).length && m.delete(n);
          }

          r.remove(e);
        }(t), t.isVideoTexture && f.delete(t);
      }

      function A(t) {
        const n = t.target;
        n.removeEventListener("dispose", A), function (t) {
          const n = t.texture,
                i = r.get(t),
                s = r.get(n);
          if (void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), o.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++) e.deleteFramebuffer(i.__webglFramebuffer[t]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t]);else {
            if (e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer) for (let t = 0; t < i.__webglColorRenderbuffer.length; t++) i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
            i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
          }
          if (t.isWebGLMultipleRenderTargets) for (let t = 0, i = n.length; t < i; t++) {
            const i = r.get(n[t]);
            i.__webglTexture && (e.deleteTexture(i.__webglTexture), o.memory.textures--), r.remove(n[t]);
          }
          r.remove(n), r.remove(t);
        }(n);
      }

      function C(t) {
        const n = r.get(t);
        e.deleteTexture(n.__webglTexture);
        const i = t.source;
        delete m.get(i)[n.__cacheKey], o.memory.textures--;
      }

      let R = 0;

      function k(e, t) {
        const i = r.get(e);

        if (e.isVideoTexture && function (e) {
          const t = o.render.frame;
          f.get(e) !== t && (f.set(e, t), e.update());
        }(e), !1 === e.isRenderTargetTexture && e.version > 0 && i.__version !== e.version) {
          const n = e.image;
          if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else {
            if (!1 !== n.complete) return void I(i, e, t);
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          }
        }

        n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture);
      }

      const P = {
        [ue]: 10497,
        [pe]: 33071,
        [he]: 33648
      },
            D = {
        [de]: 9728,
        [fe]: 9984,
        [me]: 9986,
        [ve]: 9729,
        [be]: 9985,
        [ye]: 9987
      };

      function O(n, s, o) {
        if (o ? (e.texParameteri(n, 10242, P[s.wrapS]), e.texParameteri(n, 10243, P[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, P[s.wrapR]), e.texParameteri(n, 10240, D[s.magFilter]), e.texParameteri(n, 10241, D[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), s.wrapS === pe && s.wrapT === pe || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, T(s.magFilter)), e.texParameteri(n, 10241, T(s.minFilter)), s.minFilter !== de && s.minFilter !== ve && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
          const o = t.get("EXT_texture_filter_anisotropic");
          if (s.type === Re && !1 === t.has("OES_texture_float_linear")) return;
          if (!1 === a && s.type === ke && !1 === t.has("OES_texture_half_float_linear")) return;
          (s.anisotropy > 1 || r.get(s).__currentAnisotropy) && (e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy);
        }
      }

      function L(t, n) {
        let r = !1;
        void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", E));
        const i = n.source;
        let s = m.get(i);
        void 0 === s && (s = {}, m.set(i, s));

        const a = function (e) {
          const t = [];
          return t.push(e.wrapS), t.push(e.wrapT), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.encoding), t.join();
        }(n);

        if (a !== t.__cacheKey) {
          void 0 === s[a] && (s[a] = {
            texture: e.createTexture(),
            usedTimes: 0
          }, o.memory.textures++, r = !0), s[a].usedTimes++;
          const i = s[t.__cacheKey];
          void 0 !== i && (s[t.__cacheKey].usedTimes--, 0 === i.usedTimes && C(n)), t.__cacheKey = a, t.__webglTexture = s[a].texture;
        }

        return r;
      }

      function I(t, r, i) {
        let o = 3553;
        r.isDataArrayTexture && (o = 35866), r.isData3DTexture && (o = 32879);
        const l = L(t, r),
              c = r.source;

        if (n.activeTexture(33984 + i), n.bindTexture(o, t.__webglTexture), c.version !== c.__currentVersion || !0 === l) {
          e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);

          const t = function (e) {
            return !a && (e.wrapS !== pe || e.wrapT !== pe || e.minFilter !== de && e.minFilter !== ve);
          }(r) && !1 === x(r.image);

          let i = b(r.image, t, !1, u);
          i = z(r, i);
          const p = x(i) || a,
                h = s.convert(r.format, r.encoding);

          let d,
              f = s.convert(r.type),
              _ = S(r.internalFormat, h, f, r.encoding, r.isVideoTexture);

          O(o, r, p);
          const m = r.mipmaps,
                g = a && !0 !== r.isVideoTexture,
                v = void 0 === c.__currentVersion || !0 === l,
                T = M(r, i, p);
          if (r.isDepthTexture) _ = 6402, a ? _ = r.type === Re ? 36012 : r.type === Ce ? 33190 : r.type === Oe ? 35056 : 33189 : r.type === Re && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Be && 6402 === _ && r.type !== Ee && r.type !== Ce && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Ce, f = s.convert(r.type)), r.format === je && 6402 === _ && (_ = 34041, r.type !== Oe && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Oe, f = s.convert(r.type))), v && (g ? n.texStorage2D(3553, 1, _, i.width, i.height) : n.texImage2D(3553, 0, _, i.width, i.height, 0, h, f, null));else if (r.isDataTexture) {
            if (m.length > 0 && p) {
              g && v && n.texStorage2D(3553, T, _, m[0].width, m[0].height);

              for (let e = 0, t = m.length; e < t; e++) d = m[e], g ? n.texSubImage2D(3553, e, 0, 0, d.width, d.height, h, f, d.data) : n.texImage2D(3553, e, _, d.width, d.height, 0, h, f, d.data);

              r.generateMipmaps = !1;
            } else g ? (v && n.texStorage2D(3553, T, _, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, i.width, i.height, h, f, i.data)) : n.texImage2D(3553, 0, _, i.width, i.height, 0, h, f, i.data);
          } else if (r.isCompressedTexture) {
            g && v && n.texStorage2D(3553, T, _, m[0].width, m[0].height);

            for (let e = 0, t = m.length; e < t; e++) d = m[e], r.format !== Fe ? null !== h ? g ? n.compressedTexSubImage2D(3553, e, 0, 0, d.width, d.height, h, d.data) : n.compressedTexImage2D(3553, e, _, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : g ? n.texSubImage2D(3553, e, 0, 0, d.width, d.height, h, f, d.data) : n.texImage2D(3553, e, _, d.width, d.height, 0, h, f, d.data);
          } else if (r.isDataArrayTexture) g ? (v && n.texStorage3D(35866, T, _, i.width, i.height, i.depth), n.texSubImage3D(35866, 0, 0, 0, 0, i.width, i.height, i.depth, h, f, i.data)) : n.texImage3D(35866, 0, _, i.width, i.height, i.depth, 0, h, f, i.data);else if (r.isData3DTexture) g ? (v && n.texStorage3D(32879, T, _, i.width, i.height, i.depth), n.texSubImage3D(32879, 0, 0, 0, 0, i.width, i.height, i.depth, h, f, i.data)) : n.texImage3D(32879, 0, _, i.width, i.height, i.depth, 0, h, f, i.data);else if (r.isFramebufferTexture) {
            if (v) if (g) n.texStorage2D(3553, T, _, i.width, i.height);else {
              let e = i.width,
                  t = i.height;

              for (let r = 0; r < T; r++) n.texImage2D(3553, r, _, e, t, 0, h, f, null), e >>= 1, t >>= 1;
            }
          } else if (m.length > 0 && p) {
            g && v && n.texStorage2D(3553, T, _, m[0].width, m[0].height);

            for (let e = 0, t = m.length; e < t; e++) d = m[e], g ? n.texSubImage2D(3553, e, 0, 0, h, f, d) : n.texImage2D(3553, e, _, h, f, d);

            r.generateMipmaps = !1;
          } else g ? (v && n.texStorage2D(3553, T, _, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, h, f, i)) : n.texImage2D(3553, 0, _, h, f, i);
          y(r, p) && w(o), c.__currentVersion = c.version, r.onUpdate && r.onUpdate(r);
        }

        t.__version = r.version;
      }

      function F(t, i, o, a, l) {
        const c = s.convert(o.format, o.encoding),
              u = s.convert(o.type),
              p = S(o.internalFormat, c, u, o.encoding);
        r.get(i).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, p, i.width, i.height, i.depth, 0, c, u, null) : n.texImage2D(l, 0, p, i.width, i.height, 0, c, u, null)), n.bindFramebuffer(36160, t), j(i) ? h.framebufferTexture2DMultisampleEXT(36160, a, l, r.get(o).__webglTexture, 0, B(i)) : e.framebufferTexture2D(36160, a, l, r.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null);
      }

      function N(t, n, r) {
        if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
          let i = 33189;

          if (r || j(n)) {
            const t = n.depthTexture;
            t && t.isDepthTexture && (t.type === Re ? i = 36012 : t.type === Ce && (i = 33190));
            const r = B(n);
            j(n) ? h.renderbufferStorageMultisampleEXT(36161, r, i, n.width, n.height) : e.renderbufferStorageMultisample(36161, r, i, n.width, n.height);
          } else e.renderbufferStorage(36161, i, n.width, n.height);

          e.framebufferRenderbuffer(36160, 36096, 36161, t);
        } else if (n.depthBuffer && n.stencilBuffer) {
          const i = B(n);
          r && !1 === j(n) ? e.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height) : j(n) ? h.renderbufferStorageMultisampleEXT(36161, i, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t);
        } else {
          const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];

          for (let i = 0; i < t.length; i++) {
            const o = t[i],
                  a = s.convert(o.format, o.encoding),
                  l = s.convert(o.type),
                  c = S(o.internalFormat, a, l, o.encoding),
                  u = B(n);
            r && !1 === j(n) ? e.renderbufferStorageMultisample(36161, u, c, n.width, n.height) : j(n) ? h.renderbufferStorageMultisampleEXT(36161, u, c, n.width, n.height) : e.renderbufferStorage(36161, c, n.width, n.height);
          }
        }

        e.bindRenderbuffer(36161, null);
      }

      function U(t) {
        const i = r.get(t),
              s = !0 === t.isWebGLCubeRenderTarget;

        if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
          if (s) throw new Error("target.depthTexture not supported in Cube render targets");
          !function (t, i) {
            if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (n.bindFramebuffer(36160, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), k(i.depthTexture, 0);

            const s = r.get(i.depthTexture).__webglTexture,
                  o = B(i);

            if (i.depthTexture.format === Be) j(i) ? h.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);else {
              if (i.depthTexture.format !== je) throw new Error("Unknown depthTexture format");
              j(i) ? h.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : e.framebufferTexture2D(36160, 33306, 3553, s, 0);
            }
          }(i.__webglFramebuffer, t);
        } else if (s) {
          i.__webglDepthbuffer = [];

          for (let r = 0; r < 6; r++) n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = e.createRenderbuffer(), N(i.__webglDepthbuffer[r], t, !1);
        } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), N(i.__webglDepthbuffer, t, !1);

        n.bindFramebuffer(36160, null);
      }

      function B(e) {
        return Math.min(p, e.samples);
      }

      function j(e) {
        const n = r.get(e);
        return a && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture;
      }

      function z(e, n) {
        const r = e.encoding,
              i = e.format,
              s = e.type;
        return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === gn || r !== Dt && (r === Ot ? !1 === a ? !0 === t.has("EXT_sRGB") && i === Fe ? (e.format = gn, e.minFilter = ve, e.generateMipmaps = !1) : n = Yn.sRGBToLinear(n) : i === Fe && s === Se || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : r === RGBM16Encoding || console.error("THREE.WebGLTextures: Unsupported texture encoding:", r)), n;
      }

      this.allocateTextureUnit = function () {
        const e = R;
        return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), R += 1, e;
      }, this.resetTextureUnits = function () {
        R = 0;
      }, this.setTexture2D = k, this.setTexture2DArray = function (e, t) {
        const i = r.get(e);
        e.version > 0 && i.__version !== e.version ? I(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, i.__webglTexture));
      }, this.setTexture3D = function (e, t) {
        const i = r.get(e);
        e.version > 0 && i.__version !== e.version ? I(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, i.__webglTexture));
      }, this.setTextureCube = function (t, i) {
        const o = r.get(t);
        t.version > 0 && o.__version !== t.version ? function (t, r, i) {
          if (6 !== r.image.length) return;
          const o = L(t, r),
                l = r.source;

          if (n.activeTexture(33984 + i), n.bindTexture(34067, t.__webglTexture), l.version !== l.__currentVersion || !0 === o) {
            e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
            const t = r.isCompressedTexture || r.image[0].isCompressedTexture,
                  i = r.image[0] && r.image[0].isDataTexture,
                  u = [];

            for (let e = 0; e < 6; e++) u[e] = t || i ? i ? r.image[e].image : r.image[e] : b(r.image[e], !1, !0, c), u[e] = z(r, u[e]);

            const p = u[0],
                  h = x(p) || a,
                  d = s.convert(r.format, r.encoding),
                  f = s.convert(r.type),
                  _ = S(r.internalFormat, d, f, r.encoding),
                  m = a && !0 !== r.isVideoTexture,
                  g = void 0 === l.__currentVersion || !0 === o;

            let v,
                T = M(r, p, h);

            if (O(34067, r, h), t) {
              m && g && n.texStorage2D(34067, T, _, p.width, p.height);

              for (let e = 0; e < 6; e++) {
                v = u[e].mipmaps;

                for (let t = 0; t < v.length; t++) {
                  const i = v[t];
                  r.format !== Fe ? null !== d ? m ? n.compressedTexSubImage2D(34069 + e, t, 0, 0, i.width, i.height, d, i.data) : n.compressedTexImage2D(34069 + e, t, _, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : m ? n.texSubImage2D(34069 + e, t, 0, 0, i.width, i.height, d, f, i.data) : n.texImage2D(34069 + e, t, _, i.width, i.height, 0, d, f, i.data);
                }
              }
            } else {
              v = r.mipmaps, m && g && (v.length > 0 && T++, n.texStorage2D(34067, T, _, u[0].width, u[0].height));

              for (let e = 0; e < 6; e++) if (i) {
                m ? n.texSubImage2D(34069 + e, 0, 0, 0, u[e].width, u[e].height, d, f, u[e].data) : n.texImage2D(34069 + e, 0, _, u[e].width, u[e].height, 0, d, f, u[e].data);

                for (let t = 0; t < v.length; t++) {
                  const r = v[t].image[e].image;
                  m ? n.texSubImage2D(34069 + e, t + 1, 0, 0, r.width, r.height, d, f, r.data) : n.texImage2D(34069 + e, t + 1, _, r.width, r.height, 0, d, f, r.data);
                }
              } else {
                m ? n.texSubImage2D(34069 + e, 0, 0, 0, d, f, u[e]) : n.texImage2D(34069 + e, 0, _, d, f, u[e]);

                for (let t = 0; t < v.length; t++) {
                  const r = v[t];
                  m ? n.texSubImage2D(34069 + e, t + 1, 0, 0, d, f, r.image[e]) : n.texImage2D(34069 + e, t + 1, _, d, f, r.image[e]);
                }
              }
            }

            y(r, h) && w(34067), l.__currentVersion = l.version, r.onUpdate && r.onUpdate(r);
          }

          t.__version = r.version;
        }(o, t, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture));
      }, this.rebindTextures = function (e, t, n) {
        const i = r.get(e);
        void 0 !== t && F(i.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && U(e);
      }, this.setupRenderTarget = function (t) {
        const l = t.texture,
              c = r.get(t),
              u = r.get(l);
        t.addEventListener("dispose", A), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, o.memory.textures++);
        const p = !0 === t.isWebGLCubeRenderTarget,
              h = !0 === t.isWebGLMultipleRenderTargets,
              d = x(t) || a;

        if (p) {
          c.__webglFramebuffer = [];

          for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer();
        } else {
          if (c.__webglFramebuffer = e.createFramebuffer(), h) if (i.drawBuffers) {
            const n = t.texture;

            for (let t = 0, i = n.length; t < i; t++) {
              const i = r.get(n[t]);
              void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), o.memory.textures++);
            }
          } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");

          if (a && t.samples > 0 && !1 === j(t)) {
            const r = h ? l : [l];
            c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer);

            for (let n = 0; n < r.length; n++) {
              const i = r[n];
              c.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer[n]);
              const o = s.convert(i.format, i.encoding),
                    a = s.convert(i.type),
                    l = S(i.internalFormat, o, a, i.encoding),
                    u = B(t);
              e.renderbufferStorageMultisample(36161, u, l, t.width, t.height), e.framebufferRenderbuffer(36160, 36064 + n, 36161, c.__webglColorRenderbuffer[n]);
            }

            e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), N(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null);
          }
        }

        if (p) {
          n.bindTexture(34067, u.__webglTexture), O(34067, l, d);

          for (let e = 0; e < 6; e++) F(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);

          y(l, d) && w(34067), n.unbindTexture();
        } else if (h) {
          const e = t.texture;

          for (let i = 0, s = e.length; i < s; i++) {
            const s = e[i],
                  o = r.get(s);
            n.bindTexture(3553, o.__webglTexture), O(3553, s, d), F(c.__webglFramebuffer, t, s, 36064 + i, 3553), y(s, d) && w(3553);
          }

          n.unbindTexture();
        } else {
          let e = 3553;
          (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (a ? e = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(e, u.__webglTexture), O(e, l, d), F(c.__webglFramebuffer, t, l, 36064, e), y(l, d) && w(e), n.unbindTexture();
        }

        t.depthBuffer && U(t);
      }, this.updateRenderTargetMipmap = function (e) {
        const t = x(e) || a,
              i = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];

        for (let s = 0, o = i.length; s < o; s++) {
          const o = i[s];

          if (y(o, t)) {
            const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                  i = r.get(o).__webglTexture;

            n.bindTexture(t, i), w(t), n.unbindTexture();
          }
        }
      }, this.updateMultisampleRenderTarget = function (t) {
        if (a && t.samples > 0 && !1 === j(t)) {
          const i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
                s = t.width,
                o = t.height;
          let a = 16384;
          const l = [],
                c = t.stencilBuffer ? 33306 : 36096,
                u = r.get(t),
                p = !0 === t.isWebGLMultipleRenderTargets;
          if (p) for (let t = 0; t < i.length; t++) n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, null), n.bindFramebuffer(36160, u.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
          n.bindFramebuffer(36008, u.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, u.__webglFramebuffer);

          for (let n = 0; n < i.length; n++) {
            l.push(36064 + n), t.depthBuffer && l.push(c);
            const h = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;

            if (!1 === h && (t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024)), p && e.framebufferRenderbuffer(36008, 36064, 36161, u.__webglColorRenderbuffer[n]), !0 === h && (e.invalidateFramebuffer(36008, [c]), e.invalidateFramebuffer(36009, [c])), p) {
              const t = r.get(i[n]).__webglTexture;

              e.framebufferTexture2D(36009, 36064, 3553, t, 0);
            }

            e.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, 9728), d && e.invalidateFramebuffer(36008, l);
          }

          if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), p) for (let t = 0; t < i.length; t++) {
            n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, u.__webglColorRenderbuffer[t]);

            const s = r.get(i[t]).__webglTexture;

            n.bindFramebuffer(36160, u.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, s, 0);
          }
          n.bindFramebuffer(36009, u.__webglMultisampledFramebuffer);
        }
      }, this.setupDepthRenderbuffer = U, this.setupFrameBufferTexture = F, this.useMultisampledRTT = j;
    }

    function tl(e, t, n) {
      const r = n.isWebGL2;
      return {
        convert: function (n, i = null) {
          let s;
          if (n === Se) return 5121;
          if (n === Pe) return 32819;
          if (n === De) return 32820;
          if (n === Me) return 5120;
          if (n === Te) return 5122;
          if (n === Ee) return 5123;
          if (n === Ae) return 5124;
          if (n === Ce) return 5125;
          if (n === Re) return 5126;
          if (n === ke) return r ? 5131 : (s = t.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
          if (n === Le) return 6406;
          if (n === Fe) return 6408;
          if (n === Ne) return 6409;
          if (n === Ue) return 6410;
          if (n === Be) return 6402;
          if (n === je) return 34041;
          if (n === ze) return 6403;
          if (n === Ie) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
          if (n === gn) return s = t.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
          if (n === Ve) return 36244;
          if (n === Ge) return 33319;
          if (n === He) return 33320;
          if (n === We) return 36249;
          if (n === Ke || n === Xe || n === qe || n === Ye) if (i === Ot) {
            if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
            if (n === Ke) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (n === Xe) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (n === qe) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (n === Ye) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            if (s = t.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
            if (n === Ke) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === Xe) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === qe) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === Ye) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }

          if (n === Ze || n === Je || n === $e || n === Qe) {
            if (s = t.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
            if (n === Ze) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (n === Je) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (n === $e) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (n === Qe) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }

          if (n === et) return s = t.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;

          if (n === tt || n === nt) {
            if (s = t.get("WEBGL_compressed_texture_etc"), null === s) return null;
            if (n === tt) return i === Ot ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
            if (n === nt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
          }

          if (n === rt || n === it || n === st || n === ot || n === at || n === lt || n === ct || n === ut || n === pt || n === ht || n === dt || n === ft || n === _t || n === mt) {
            if (s = t.get("WEBGL_compressed_texture_astc"), null === s) return null;
            if (n === rt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (n === it) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (n === st) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (n === ot) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (n === at) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (n === lt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (n === ct) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (n === ut) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (n === pt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (n === ht) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (n === dt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (n === ft) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (n === _t) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (n === mt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
          }

          if (n === gt) {
            if (s = t.get("EXT_texture_compression_bptc"), null === s) return null;
            if (n === gt) return i === Ot ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          }

          return n === Oe ? r ? 34042 : (s = t.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null;
        }
      };
    }

    class nl extends gs {
      constructor(e = []) {
        super(), this.isArrayCamera = !0, this.cameras = e;
      }

    }

    class rl extends ui {
      constructor() {
        super(), this.isGroup = !0, this.type = "Group";
      }

    }

    const il = {
      type: "move"
    };

    class sl {
      constructor() {
        this._targetRay = null, this._grip = null, this._hand = null;
      }

      getHandSpace() {
        return null === this._hand && (this._hand = new rl(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
          pinching: !1
        }), this._hand;
      }

      getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new rl(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new lr(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new lr()), this._targetRay;
      }

      getGripSpace() {
        return null === this._grip && (this._grip = new rl(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new lr(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new lr()), this._grip;
      }

      dispatchEvent(e) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this;
      }

      disconnect(e) {
        return this.dispatchEvent({
          type: "disconnected",
          data: e
        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
      }

      update(e, t, n) {
        let r = null,
            i = null,
            s = null;
        const o = this._targetRay,
              a = this._grip,
              l = this._hand;

        if (e && "visible-blurred" !== t.session.visibilityState) {
          if (l && e.hand) {
            s = !0;

            for (const r of e.hand.values()) {
              const e = t.getJointPose(r, n);

              if (void 0 === l.joints[r.jointName]) {
                const e = new rl();
                e.matrixAutoUpdate = !1, e.visible = !1, l.joints[r.jointName] = e, l.add(e);
              }

              const i = l.joints[r.jointName];
              null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = e.radius), i.visible = null !== e;
            }

            const r = l.joints["index-finger-tip"],
                  i = l.joints["thumb-tip"],
                  o = r.position.distanceTo(i.position),
                  a = .02,
                  c = .005;
            l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this
            })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this
            }));
          } else null !== a && e.gripSpace && (i = t.getPose(e.gripSpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1));

          null !== o && (r = t.getPose(e.targetRaySpace, n), null === r && null !== i && (r = i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(il)));
        }

        return null !== o && (o.visible = null !== r), null !== a && (a.visible = null !== i), null !== l && (l.visible = null !== s), this;
      }

    }

    class ol extends Qn {
      constructor(e, t, n, r, i, s, o, a, l, c) {
        if ((c = void 0 !== c ? c : Be) !== Be && c !== je) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && c === Be && (n = Ce), void 0 === n && c === je && (n = Oe), super(null, r, i, s, o, a, c, n, l), this.isDepthTexture = !0, this.image = {
          width: e,
          height: t
        }, this.magFilter = void 0 !== o ? o : de, this.minFilter = void 0 !== a ? a : de, this.flipY = !1, this.generateMipmaps = !1;
      }

    }

    class al extends vn {
      constructor(e, t) {
        super();
        const n = this;
        let r = null,
            i = 1,
            s = null,
            o = "local-floor",
            a = null,
            l = null,
            c = null,
            u = null,
            p = null,
            h = null;
        const d = t.getContextAttributes();
        let f = null,
            _ = null;
        const m = [],
              g = [],
              v = new gs();
        v.layers.enable(1), v.viewport = new er();
        const b = new gs();
        b.layers.enable(2), b.viewport = new er();
        const x = [v, b],
              y = new nl();
        y.layers.enable(1), y.layers.enable(2);
        let w = null,
            S = null;

        function M(e) {
          const t = g.indexOf(e.inputSource);
          if (-1 === t) return;
          const n = m[t];
          void 0 !== n && n.dispatchEvent({
            type: e.type,
            data: e.inputSource
          });
        }

        function T() {
          r.removeEventListener("select", M), r.removeEventListener("selectstart", M), r.removeEventListener("selectend", M), r.removeEventListener("squeeze", M), r.removeEventListener("squeezestart", M), r.removeEventListener("squeezeend", M), r.removeEventListener("end", T), r.removeEventListener("inputsourceschange", E);

          for (let e = 0; e < m.length; e++) {
            const t = g[e];
            null !== t && (g[e] = null, m[e].disconnect(t));
          }

          w = null, S = null, e.setRenderTarget(f), p = null, u = null, c = null, r = null, _ = null, P.stop(), n.isPresenting = !1, n.dispatchEvent({
            type: "sessionend"
          });
        }

        function E(e) {
          for (let t = 0; t < e.removed.length; t++) {
            const n = e.removed[t],
                  r = g.indexOf(n);
            r >= 0 && (g[r] = null, m[r].dispatchEvent({
              type: "disconnected",
              data: n
            }));
          }

          for (let t = 0; t < e.added.length; t++) {
            const n = e.added[t];
            let r = g.indexOf(n);

            if (-1 === r) {
              for (let e = 0; e < m.length; e++) {
                if (e >= g.length) {
                  g.push(n), r = e;
                  break;
                }

                if (null === g[e]) {
                  g[e] = n, r = e;
                  break;
                }
              }

              if (-1 === r) break;
            }

            const i = m[r];
            i && i.dispatchEvent({
              type: "connected",
              data: n
            });
          }
        }

        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) {
          let t = m[e];
          return void 0 === t && (t = new sl(), m[e] = t), t.getTargetRaySpace();
        }, this.getControllerGrip = function (e) {
          let t = m[e];
          return void 0 === t && (t = new sl(), m[e] = t), t.getGripSpace();
        }, this.getHand = function (e) {
          let t = m[e];
          return void 0 === t && (t = new sl(), m[e] = t), t.getHandSpace();
        }, this.setFramebufferScaleFactor = function (e) {
          i = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }, this.setReferenceSpaceType = function (e) {
          o = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }, this.getReferenceSpace = function () {
          return a || s;
        }, this.setReferenceSpace = function (e) {
          a = e;
        }, this.getBaseLayer = function () {
          return null !== u ? u : p;
        }, this.getBinding = function () {
          return c;
        }, this.getFrame = function () {
          return h;
        }, this.getSession = function () {
          return r;
        }, this.setSession = async function (l) {
          if (r = l, null !== r) {
            if (f = e.getRenderTarget(), r.addEventListener("select", M), r.addEventListener("selectstart", M), r.addEventListener("selectend", M), r.addEventListener("squeeze", M), r.addEventListener("squeezestart", M), r.addEventListener("squeezeend", M), r.addEventListener("end", T), r.addEventListener("inputsourceschange", E), !0 !== d.xrCompatible && (await t.makeXRCompatible()), void 0 === r.renderState.layers || !1 === e.capabilities.isWebGL2) {
              const n = {
                antialias: void 0 !== r.renderState.layers || d.antialias,
                alpha: d.alpha,
                depth: d.depth,
                stencil: d.stencil,
                framebufferScaleFactor: i
              };
              p = new XRWebGLLayer(r, t, n), r.updateRenderState({
                baseLayer: p
              }), _ = new tr(p.framebufferWidth, p.framebufferHeight, {
                format: Fe,
                type: Se,
                encoding: e.outputEncoding
              });
            } else {
              let n = null,
                  s = null,
                  o = null;
              d.depth && (o = d.stencil ? 35056 : 33190, n = d.stencil ? je : Be, s = d.stencil ? Oe : Ce);
              const a = {
                colorFormat: 32856,
                depthFormat: o,
                scaleFactor: i
              };
              c = new XRWebGLBinding(r, t), u = c.createProjectionLayer(a), r.updateRenderState({
                layers: [u]
              }), _ = new tr(u.textureWidth, u.textureHeight, {
                format: Fe,
                type: Se,
                depthTexture: new ol(u.textureWidth, u.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                stencilBuffer: d.stencil,
                encoding: e.outputEncoding,
                samples: d.antialias ? 4 : 0
              }), e.properties.get(_).__ignoreDepthValues = u.ignoreDepthValues;
            }

            _.isXRRenderTarget = !0, this.setFoveation(1), a = null, s = await r.requestReferenceSpace(o), P.setContext(r), P.start(), n.isPresenting = !0, n.dispatchEvent({
              type: "sessionstart"
            });
          }
        };
        const A = new lr(),
              C = new lr();

        function R(e, t) {
          null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert();
        }

        this.updateCamera = function (e) {
          if (null === r) return;
          y.near = b.near = v.near = e.near, y.far = b.far = v.far = e.far, w === y.near && S === y.far || (r.updateRenderState({
            depthNear: y.near,
            depthFar: y.far
          }), w = y.near, S = y.far);
          const t = e.parent,
                n = y.cameras;
          R(y, t);

          for (let e = 0; e < n.length; e++) R(n[e], t);

          y.matrixWorld.decompose(y.position, y.quaternion, y.scale), e.position.copy(y.position), e.quaternion.copy(y.quaternion), e.scale.copy(y.scale), e.matrix.copy(y.matrix), e.matrixWorld.copy(y.matrixWorld);
          const i = e.children;

          for (let e = 0, t = i.length; e < t; e++) i[e].updateMatrixWorld(!0);

          2 === n.length ? function (e, t, n) {
            A.setFromMatrixPosition(t.matrixWorld), C.setFromMatrixPosition(n.matrixWorld);

            const r = A.distanceTo(C),
                  i = t.projectionMatrix.elements,
                  s = n.projectionMatrix.elements,
                  o = i[14] / (i[10] - 1),
                  a = i[14] / (i[10] + 1),
                  l = (i[9] + 1) / i[5],
                  c = (i[9] - 1) / i[5],
                  u = (i[8] - 1) / i[0],
                  p = (s[8] + 1) / s[0],
                  h = o * u,
                  d = o * p,
                  f = r / (-u + p),
                  _ = f * -u;

            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(_), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
            const m = o + f,
                  g = a + f,
                  v = h - _,
                  b = d + (r - _),
                  x = l * a / g * m,
                  y = c * a / g * m;
            e.projectionMatrix.makePerspective(v, b, x, y, m, g);
          }(y, v, b) : y.projectionMatrix.copy(v.projectionMatrix);
        }, this.getCamera = function () {
          return y;
        }, this.getFoveation = function () {
          return null !== u ? u.fixedFoveation : null !== p ? p.fixedFoveation : void 0;
        }, this.setFoveation = function (e) {
          null !== u && (u.fixedFoveation = e), null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = e);
        };
        let k = null;
        this.onPreAnimationFrameCallback = null;
        const P = new Rs();
        P.setAnimationLoop(function (t, r) {
          if (n.onPreAnimationFrameCallback && n.onPreAnimationFrameCallback(t, r), l = r.getViewerPose(a || s), h = r, null !== l) {
            const t = l.views;
            null !== p && (e.setRenderTargetFramebuffer(_, p.framebuffer), e.setRenderTarget(_));
            let n = !1;
            t.length !== y.cameras.length && (y.cameras.length = 0, n = !0);

            for (let r = 0; r < t.length; r++) {
              const i = t[r];
              let s = null;
              if (null !== p) s = p.getViewport(i);else {
                const t = c.getViewSubImage(u, i);
                s = t.viewport, 0 === r && (e.setRenderTargetTextures(_, t.colorTexture, u.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(_));
              }
              let o = x[r];
              void 0 === o && (o = new gs(), o.layers.enable(r), o.viewport = new er(), x[r] = o), o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === r && y.matrix.copy(o.matrix), !0 === n && y.cameras.push(o);
            }
          }

          for (let e = 0; e < m.length; e++) {
            const t = g[e],
                  n = m[e];
            null !== t && void 0 !== n && n.update(t, r, a || s);
          }

          k && k(t, r), h = null;
        }), this.setAnimationLoop = function (e) {
          k = e;
        }, this.dispose = function () {};
      }

    }

    function ll(e, t) {
      function n(n, r) {
        n.opacity.value = r.opacity, r.color && n.diffuse.value.copy(r.color), r.emissive && n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (n.map.value = r.map), r.alphaMap && (n.alphaMap.value = r.alphaMap), r.bumpMap && (n.bumpMap.value = r.bumpMap, n.bumpScale.value = r.bumpScale, r.side === _ && (n.bumpScale.value *= -1)), r.displacementMap && (n.displacementMap.value = r.displacementMap, n.displacementScale.value = r.displacementScale, n.displacementBias.value = r.displacementBias), r.emissiveMap && (n.emissiveMap.value = r.emissiveMap), r.normalMap && (n.normalMap.value = r.normalMap, n.normalScale.value.copy(r.normalScale), r.side === _ && n.normalScale.value.negate()), r.specularMap && (n.specularMap.value = r.specularMap), r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
        const i = t.get(r).envMap;

        if (i) {
          n.envMap.value = i;
          const e = t.get(r).environment || i;
          n.envMapRotation.value = e ? e.rotation : 0, n.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = r.reflectivity, n.ior.value = r.ior, n.refractionRatio.value = r.refractionRatio;
        }

        if (r.lightMap) {
          n.lightMap.value = r.lightMap;
          const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
          n.lightMapIntensity.value = r.lightMapIntensity * t;
        }

        let s, o;
        r.aoMap && (n.aoMap.value = r.aoMap, n.aoMapIntensity.value = r.aoMapIntensity), r.map ? s = r.map : r.specularMap ? s = r.specularMap : r.displacementMap ? s = r.displacementMap : r.normalMap ? s = r.normalMap : r.bumpMap ? s = r.bumpMap : r.roughnessMap ? s = r.roughnessMap : r.metalnessMap ? s = r.metalnessMap : r.alphaMap ? s = r.alphaMap : r.emissiveMap ? s = r.emissiveMap : r.clearcoatMap ? s = r.clearcoatMap : r.clearcoatNormalMap ? s = r.clearcoatNormalMap : r.clearcoatRoughnessMap ? s = r.clearcoatRoughnessMap : r.iridescenceMap ? s = r.iridescenceMap : r.iridescenceThicknessMap ? s = r.iridescenceThicknessMap : r.specularIntensityMap ? s = r.specularIntensityMap : r.specularColorMap ? s = r.specularColorMap : r.transmissionMap ? s = r.transmissionMap : r.thicknessMap ? s = r.thicknessMap : r.sheenColorMap ? s = r.sheenColorMap : r.sheenRoughnessMap && (s = r.sheenRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), n.uvTransform.value.copy(s.matrix)), r.aoMap ? o = r.aoMap : r.lightMap && (o = r.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), n.uv2Transform.value.copy(o.matrix));
      }

      return {
        refreshFogUniforms: function (e, t) {
          e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density);
        },
        refreshMaterialUniforms: function (e, r, i, s, o) {
          r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(e, r) : r.isMeshToonMaterial ? (n(e, r), function (e, t) {
            t.gradientMap && (e.gradientMap.value = t.gradientMap);
          }(e, r)) : r.isMeshPhongMaterial ? (n(e, r), function (e, t) {
            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4);
          }(e, r)) : r.isMeshStandardMaterial ? (n(e, r), function (e, n) {
            e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
          }(e, r), r.isMeshPhysicalMaterial && function (e, t, n) {
            e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === _ && e.clearcoatNormalScale.value.negate())), t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap)), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = n.texture, e.transmissionSamplerSize.value.set(n.width, n.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap);
          }(e, r, o)) : r.isMeshMatcapMaterial ? (n(e, r), function (e, t) {
            t.matcap && (e.matcap.value = t.matcap);
          }(e, r)) : r.isMeshDepthMaterial ? n(e, r) : r.isMeshDistanceMaterial ? (n(e, r), function (e, t) {
            e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance;
          }(e, r)) : r.isMeshNormalMaterial ? n(e, r) : r.isLineBasicMaterial ? (function (e, t) {
            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity;
          }(e, r), r.isLineDashedMaterial && function (e, t) {
            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale;
          }(e, r)) : r.isPointsMaterial ? function (e, t, n, r) {
            let i;
            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * r, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? i = t.map : t.alphaMap && (i = t.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix));
          }(e, r, i, s) : r.isSpriteMaterial ? function (e, t) {
            let n;
            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix));
          }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (void 0 !== r.transmission && (e.transmission && (e.transmission.value = r.transmission), e.transmissionSamplerMap && o && (e.transmissionSamplerMap.value = o ? o.texture : null), e.transmissionSamplerSize && o && e.transmissionSamplerSize.value.set(o.width, o.height)), r.uniformsNeedUpdate = !1);
        }
      };
    }

    function cl(e, t, n, r) {
      let i = {},
          s = {},
          o = [];
      const a = n.isWebGL2 ? e.getParameter(35375) : 0;

      function l(e, t, n) {
        const r = e.value;
        if (void 0 === n[t]) return n[t] = "number" == typeof r ? r : r.clone(), !0;

        if ("number" == typeof r) {
          if (n[t] !== r) return n[t] = r, !0;
        } else {
          const e = n[t];
          if (!1 === e.equals(r)) return e.copy(r), !0;
        }

        return !1;
      }

      function c(e) {
        const t = e.value,
              n = {
          boundary: 0,
          storage: 0
        };
        return "number" == typeof t ? (n.boundary = 4, n.storage = 4) : t.isVector2 ? (n.boundary = 8, n.storage = 8) : t.isVector3 || t.isColor ? (n.boundary = 16, n.storage = 12) : t.isVector4 ? (n.boundary = 16, n.storage = 16) : t.isMatrix3 ? (n.boundary = 48, n.storage = 48) : t.isMatrix4 ? (n.boundary = 64, n.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), n;
      }

      function u(t) {
        const n = t.target;
        n.removeEventListener("dispose", u);
        const r = o.indexOf(n.__bindingPointIndex);
        o.splice(r, 1), e.deleteBuffer(i[n.id]), delete i[n.id], delete s[n.id];
      }

      return {
        bind: function (e, t) {
          const n = t.program;
          r.uniformBlockBinding(e, n);
        },
        update: function (n, p) {
          let h = i[n.id];
          void 0 === h && (function (e) {
            const t = e.uniforms;
            let n = 0;
            let r = 0;

            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e],
                    s = c(i);

              if (i.__data = new Float32Array(s.storage / Float32Array.BYTES_PER_ELEMENT), i.__offset = n, e > 0) {
                r = n % 16;
                const e = 16 - r;
                0 !== r && e - s.boundary < 0 && (n += 16 - r, i.__offset = n);
              }

              n += s.storage;
            }

            r = n % 16, r > 0 && (n += 16 - r), e.__size = n, e.__cache = {};
          }(n), h = function (t) {
            const n = function () {
              for (let e = 0; e < a; e++) if (-1 === o.indexOf(e)) return o.push(e), e;

              return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
            }();

            t.__bindingPointIndex = n;
            const r = e.createBuffer(),
                  i = t.__size,
                  s = t.usage;
            return e.bindBuffer(35345, r), e.bufferData(35345, i, s), e.bindBuffer(35345, null), e.bindBufferBase(35345, n, r), r;
          }(n), i[n.id] = h, n.addEventListener("dispose", u));
          const d = p.program;
          r.updateUBOMapping(n, d);
          const f = t.render.frame;
          s[n.id] !== f && (function (t) {
            const n = i[t.id],
                  r = t.uniforms,
                  s = t.__cache;
            e.bindBuffer(35345, n);

            for (let t = 0, n = r.length; t < n; t++) {
              const n = r[t];

              if (!0 === l(n, t, s)) {
                const t = n.value,
                      r = n.__offset;
                "number" == typeof t ? (n.__data[0] = t, e.bufferSubData(35345, r, n.__data)) : (n.value.isMatrix3 ? (n.__data[0] = n.value.elements[0], n.__data[1] = n.value.elements[1], n.__data[2] = n.value.elements[2], n.__data[3] = n.value.elements[0], n.__data[4] = n.value.elements[3], n.__data[5] = n.value.elements[4], n.__data[6] = n.value.elements[5], n.__data[7] = n.value.elements[0], n.__data[8] = n.value.elements[6], n.__data[9] = n.value.elements[7], n.__data[10] = n.value.elements[8], n.__data[11] = n.value.elements[0]) : t.toArray(n.__data), e.bufferSubData(35345, r, n.__data));
              }
            }

            e.bindBuffer(35345, null);
          }(n), s[n.id] = f);
        },
        dispose: function () {
          for (const t in i) e.deleteBuffer(i[t]);

          o = [], i = {}, s = {};
        }
      };
    }

    function ul(e = {}) {
      this.isWebGLRenderer = !0;
      const t = void 0 !== e.canvas ? e.canvas : function () {
        const e = Fn("canvas");
        return e.style.display = "block", e;
      }(),
            n = void 0 !== e.context ? e.context : null,
            i = void 0 === e.depth || e.depth,
            s = void 0 === e.stencil || e.stencil,
            o = void 0 !== e.antialias && e.antialias,
            a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            c = void 0 !== e.powerPreference ? e.powerPreference : "default",
            u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
      let p;
      p = null !== n ? n.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
      let h = null,
          d = null;
      const g = [],
            v = [];
      this.domElement = t, this.debug = {
        checkShaderErrors: !0
      }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Dt, this.physicallyCorrectLights = !1, this.toneMapping = $, this.toneMappingExposure = 1, this.userData = {}, Object.defineProperties(this, {
        gammaFactor: {
          get: function () {
            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
          },
          set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          }
        }
      });
      const b = this;
      let x = !1,
          y = 0,
          w = 0,
          S = null,
          M = -1,
          T = null;
      const E = new er(),
            A = new er();
      let C = null,
          R = t.width,
          k = t.height,
          P = 1,
          D = null,
          O = null;
      const L = new er(0, 0, R, k),
            I = new er(0, 0, R, k);
      let F = !1;
      const N = new Cs();
      let U = !1,
          B = !1,
          j = null;
      const z = new Br(),
            V = new Pn(),
            G = new lr(),
            H = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
      };

      function W() {
        return null === S ? P : 1;
      }

      let K,
          X,
          q,
          Y,
          Z,
          J,
          Q,
          ee,
          te,
          ne,
          re,
          ie,
          se,
          oe,
          ae,
          le,
          ce,
          ue,
          pe,
          he,
          de,
          fe,
          _e,
          me,
          ge = n;

      function ve(e, n) {
        for (let r = 0; r < e.length; r++) {
          const i = e[r],
                s = t.getContext(i, n);
          if (null !== s) return s;
        }

        return null;
      }

      try {
        const e = {
          alpha: !0,
          depth: i,
          stencil: s,
          antialias: o,
          premultipliedAlpha: a,
          preserveDrawingBuffer: l,
          powerPreference: c,
          failIfMajorPerformanceCaveat: u
        };

        if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${r}`), t.addEventListener("webglcontextlost", we, !1), t.addEventListener("webglcontextrestored", Me, !1), t.addEventListener("webglcontextcreationerror", Te, !1), null === ge) {
          const t = ["webgl2", "webgl", "experimental-webgl"];
          if (!0 === b.isWebGL1Renderer && t.shift(), ge = ve(t, e), null === ge) throw ve(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }

        void 0 === ge.getShaderPrecisionFormat && (ge.getShaderPrecisionFormat = function () {
          return {
            rangeMin: 1,
            rangeMax: 1,
            precision: 1
          };
        });
      } catch (e) {
        throw console.error("THREE.WebGLRenderer: " + e.message), e;
      }

      function be() {
        K = new to(ge), X = new Us(ge, K, e), K.init(X), fe = new tl(ge, K, X), q = new Qa(ge, K, X), Y = new io(), Z = new Ba(), J = new el(ge, K, q, Z, X, fe, Y), Q = new js(b), ee = new eo(b), te = new ks(ge, X), _e = new Fs(ge, K, te, X), ne = new no(ge, te, Y, _e), re = new co(ge, ne, te, Y), pe = new lo(ge, X, J), le = new Bs(Z), ie = new Ua(b, Q, ee, K, X, _e, le), se = new ll(b, Z), oe = new Ga(), ae = new Ya(K, X), ue = new Is(b, Q, q, re, p, a), ce = new $a(b, re, X), me = new cl(ge, Y, X, q), he = new Ns(ge, K, Y, X), de = new ro(ge, K, Y, X), Y.programs = ie.programs, b.capabilities = X, b.extensions = K, b.properties = Z, b.renderLists = oe, b.shadowMap = ce, b.state = q, b.info = Y, b.background = ue, b.cubeuvmaps = ee;
      }

      be();
      const xe = new al(b, ge);

      function we(e) {
        e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0;
      }

      function Me() {
        console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
        const e = Y.autoReset,
              t = ce.enabled,
              n = ce.autoUpdate,
              r = ce.needsUpdate,
              i = ce.type;
        be(), Y.autoReset = e, ce.enabled = t, ce.autoUpdate = n, ce.needsUpdate = r, ce.type = i;
      }

      function Te(e) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage);
      }

      function Ee(e) {
        const t = e.target;
        t.removeEventListener("dispose", Ee), function (e) {
          (function (e) {
            const t = Z.get(e).programs;
            void 0 !== t && (t.forEach(function (e) {
              ie.releaseProgram(e);
            }), e.isShaderMaterial && ie.releaseShaderCache(e));
          })(e), Z.remove(e);
        }(t);
      }

      this.xr = xe, this.getContext = function () {
        return ge;
      }, this.getContextAttributes = function () {
        return ge.getContextAttributes();
      }, this.forceContextLoss = function () {
        const e = K.get("WEBGL_lose_context");
        e && e.loseContext();
      }, this.forceContextRestore = function () {
        const e = K.get("WEBGL_lose_context");
        e && e.restoreContext();
      }, this.getPixelRatio = function () {
        return P;
      }, this.setPixelRatio = function (e) {
        void 0 !== e && (P = e, this.setSize(R, k, !1));
      }, this.getSize = function (e) {
        return e.set(R, k);
      }, this.setSize = function (e, n, r) {
        xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e, k = n, t.width = Math.floor(e * P), t.height = Math.floor(n * P), !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n));
      }, this.getDrawingBufferSize = function (e) {
        return e.set(R * P, k * P).floor();
      }, this.setDrawingBufferSize = function (e, n, r) {
        R = e, k = n, P = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n);
      }, this.getCurrentViewport = function (e) {
        return e.copy(E);
      }, this.getViewport = function (e) {
        return e.copy(L);
      }, this.setViewport = function (e, t, n, r) {
        e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, r), q.viewport(E.copy(L).multiplyScalar(P).floor());
      }, this.getScissor = function (e) {
        return e.copy(I);
      }, this.setScissor = function (e, t, n, r) {
        e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, n, r), q.scissor(A.copy(I).multiplyScalar(P).floor());
      }, this.getScissorTest = function () {
        return F;
      }, this.setScissorTest = function (e) {
        q.setScissorTest(F = e);
      }, this.setOpaqueSort = function (e) {
        D = e;
      }, this.setTransparentSort = function (e) {
        O = e;
      }, this.getClearColor = function (e) {
        return e.copy(ue.getClearColor());
      }, this.setClearColor = function () {
        ue.setClearColor.apply(ue, arguments);
      }, this.getClearAlpha = function () {
        return ue.getClearAlpha();
      }, this.setClearAlpha = function () {
        ue.setClearAlpha.apply(ue, arguments);
      }, this.clear = function (e = !0, t = !0, n = !0) {
        let r = 0;
        e && (r |= 16384), t && (r |= 256), n && (r |= 1024), ge.clear(r);
      }, this.clearColor = function () {
        this.clear(!0, !1, !1);
      }, this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }, this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }, this.dispose = function () {
        t.removeEventListener("webglcontextlost", we, !1), t.removeEventListener("webglcontextrestored", Me, !1), t.removeEventListener("webglcontextcreationerror", Te, !1), oe.dispose(), ae.dispose(), Z.dispose(), Q.dispose(), ee.dispose(), re.dispose(), _e.dispose(), me.dispose(), ie.dispose(), xe.dispose(), xe.removeEventListener("sessionstart", Ce), xe.removeEventListener("sessionend", Pe), j && (j.dispose(), j = null), De.stop();
      }, this.renderBufferDirect = function (e, t, n, r, i, s) {
        null === t && (t = H);

        const o = i.isMesh && i.matrixWorld.determinant() < 0,
              a = function (e, t, n, r, i) {
          !0 !== t.isScene && (t = H), J.resetTextureUnits();

          const s = t.fog,
                o = r.isMeshStandardMaterial ? t.environment : null,
                a = null === S ? b.outputEncoding : !0 === S.isXRRenderTarget || S.texture.encoding && S.texture.encoding !== Ot ? S.texture.encoding : Dt,
                l = (r.isMeshStandardMaterial ? ee : Q).get(r.envMap || o),
                c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                u = !!r.normalMap && !!n.attributes.tangent,
                p = !!n.morphAttributes.position,
                h = !!n.morphAttributes.normal,
                f = !!n.morphAttributes.color,
                _ = r.toneMapped ? b.toneMapping : $,
                m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                g = void 0 !== m ? m.length : 0,
                v = Z.get(r),
                x = d.state.lights;

          if (!0 === U && (!0 === B || e !== T)) {
            const t = e === T && r.id === M;
            le.setState(r, e, t);
          }

          let y = !1;
          r.version === v.__version ? v.needsLights && v.lightsStateVersion !== x.state.version || v.outputEncoding !== a || i.isInstancedMesh && !1 === v.instancing ? y = !0 : i.isInstancedMesh || !0 !== v.instancing ? i.isSkinnedMesh && !1 === v.skinning ? y = !0 : i.isSkinnedMesh || !0 !== v.skinning ? v.envMap !== l || !0 === r.fog && v.fog !== s ? y = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === le.numPlanes && v.numIntersection === le.numIntersection ? (v.vertexAlphas !== c || v.vertexTangents !== u || v.morphTargets !== p || v.morphNormals !== h || v.morphColors !== f || v.toneMapping !== _ || !0 === X.isWebGL2 && v.morphTargetsCount !== g) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, v.__version = r.version);
          let w = v.currentProgram;
          !0 === y && (w = Ue(r, t, i));
          let E = !1,
              A = !1,
              C = !1;
          const R = w.getUniforms(),
                D = v.uniforms;

          if (q.useProgram(w.program) && (E = !0, A = !0, C = !0), r.id !== M && (M = r.id, A = !0), E || T !== e) {
            if (R.setValue(ge, "projectionMatrix", e.projectionMatrix), X.logarithmicDepthBuffer && R.setValue(ge, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), T !== e && (T = e, A = !0, C = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
              const t = R.map.cameraPosition;
              void 0 !== t && t.setValue(ge, G.setFromMatrixPosition(e.matrixWorld));
            }

            (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && R.setValue(ge, "isOrthographic", !0 === e.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && R.setValue(ge, "viewMatrix", e.matrixWorldInverse);
          }

          if (i.isSkinnedMesh) {
            R.setOptional(ge, i, "bindMatrix"), R.setOptional(ge, i, "bindMatrixInverse");
            const e = i.skeleton;
            e && (X.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), R.setValue(ge, "boneTexture", e.boneTexture, J), R.setValue(ge, "boneTextureSize", e.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
          }

          const O = n.morphAttributes;
          var L, I;
          (void 0 !== O.position || void 0 !== O.normal || void 0 !== O.color && !0 === X.isWebGL2) && pe.update(i, n, r, w), (A || v.receiveShadow !== i.receiveShadow) && (v.receiveShadow = i.receiveShadow, R.setValue(ge, "receiveShadow", i.receiveShadow)), A && (R.setValue(ge, "toneMappingExposure", b.toneMappingExposure), v.needsLights && (I = C, (L = D).ambientLightColor.needsUpdate = I, L.lightProbe.needsUpdate = I, L.directionalLights.needsUpdate = I, L.directionalLightShadows.needsUpdate = I, L.pointLights.needsUpdate = I, L.pointLightShadows.needsUpdate = I, L.spotLights.needsUpdate = I, L.spotLightShadows.needsUpdate = I, L.rectAreaLights.needsUpdate = I, L.hemisphereLights.needsUpdate = I), s && !0 === r.fog && se.refreshFogUniforms(D, s), se.refreshMaterialUniforms(D, r, P, k, b.userData.transmissionRenderTarget || j), fa.upload(ge, v.uniformsList, D, J)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (fa.upload(ge, v.uniformsList, D, J), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && R.setValue(ge, "center", i.center), R.setValue(ge, "modelViewMatrix", i.modelViewMatrix), R.setValue(ge, "normalMatrix", i.normalMatrix), R.setValue(ge, "modelMatrix", i.matrixWorld);
          const F = r.extraUniformsToUpload;

          if (F && Object.entries(F).forEach(([e, t]) => R.setValue(ge, e, t.value, J)), r.isShaderMaterial || r.isRawShaderMaterial) {
            const e = r.uniformsGroups;

            for (let t = 0, n = e.length; t < n; t++) if (X.isWebGL2) {
              const n = e[t];
              me.update(n, w), me.bind(n, w);
            } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }

          return w;
        }(e, t, n, r, i);

        q.setMaterial(r, o);
        let l = n.index;
        const c = n.attributes.position;

        if (null === l) {
          if (void 0 === c || 0 === c.count) return;
        } else if (0 === l.count) return;

        let u,
            p = 1;
        !0 === r.wireframe && (l = ne.getWireframeAttribute(n), p = 2), _e.setup(i, r, a, n, l);
        let h = he;
        null !== l && (u = te.get(l), h = de, h.setIndex(u));

        const f = null !== l ? l.count : c.count,
              _ = n.drawRange.start * p,
              m = n.drawRange.count * p,
              g = null !== s ? s.start * p : 0,
              v = null !== s ? s.count * p : 1 / 0,
              x = Math.max(_, g),
              y = Math.min(f, _ + m, g + v) - 1,
              w = Math.max(0, y - x + 1);

        if (0 !== w) {
          if (i.isMesh) !0 === r.wireframe ? (q.setLineWidth(r.wireframeLinewidth * W()), h.setMode(1)) : h.setMode(4);else if (i.isLine) {
            let e = r.linewidth;
            void 0 === e && (e = 1), q.setLineWidth(e * W()), i.isLineSegments ? h.setMode(1) : i.isLineLoop ? h.setMode(2) : h.setMode(3);
          } else i.isPoints ? h.setMode(0) : i.isSprite && h.setMode(4);
          if (i.isInstancedMesh) h.renderInstances(x, w, i.count);else if (n.isInstancedBufferGeometry) {
            const e = Math.min(n.instanceCount, n._maxInstanceCount);
            h.renderInstances(x, w, e);
          } else h.render(x, w);
        }
      }, this.compile = function (e, t) {
        d = ae.get(e), d.init(), v.push(d), e.traverseVisible(function (e) {
          e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e));
        }), d.setupLights(b.physicallyCorrectLights), e.traverse(function (t) {
          const n = t.material;
          if (n) if (Array.isArray(n)) for (let r = 0; r < n.length; r++) Ue(n[r], e, t);else Ue(n, e, t);
        }), v.pop(), d = null;
      };
      let Ae = null;

      function Ce() {
        De.stop();
      }

      function Pe() {
        De.start();
      }

      const De = new Rs();

      function Oe(e, t, n, r) {
        if (!1 === e.visible) return;
        if (e.layers.test(t.layers)) if (e.isGroup) n = e.renderOrder;else if (e.isLOD) !0 === e.autoUpdate && e.update(t);else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);else if (e.isSprite) {
          if (!e.frustumCulled || N.intersectsSprite(e)) {
            r && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
            const t = re.update(e),
                  i = e.material;
            i.visible && h.push(e, t, i, n, G.z, null);
          }
        } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== Y.render.frame && (e.skeleton.update(), e.skeleton.frame = Y.render.frame), !e.frustumCulled || N.intersectsObject(e))) {
          r && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
          const t = re.update(e),
                i = e.material;

          if (Array.isArray(i)) {
            const r = t.groups;

            for (let s = 0, o = r.length; s < o; s++) {
              const o = r[s],
                    a = i[o.materialIndex];
              a && a.visible && h.push(e, t, a, n, G.z, o);
            }
          } else i.visible && h.push(e, t, i, n, G.z, null);
        }
        const i = e.children;

        for (let e = 0, s = i.length; e < s; e++) Oe(i[e], t, n, r);
      }

      function Le(e, t, n, r) {
        const i = e.opaque,
              s = e.transmissive,
              a = e.transparent;
        d.setupLightsView(n), void 0 === b.userData.transmissionRender && !1 !== b.userData.renderTransmissionPass && s.length > 0 && function (e, t, n) {
          const r = X.isWebGL2;
          null === j && (j = new tr(1, 1, {
            generateMipmaps: !0,
            type: K.has("EXT_color_buffer_half_float") ? ke : Se,
            minFilter: ye,
            samples: r && !0 === o ? 4 : 0
          })), b.getDrawingBufferSize(V), r ? j.setSize(V.x, V.y) : j.setSize(Rn(V.x), Rn(V.y));
          const i = b.getRenderTarget();
          b.setRenderTarget(j), b.clear();
          const s = b.toneMapping;
          b.toneMapping = $, Ie(e, t, n), b.toneMapping = s, J.updateMultisampleRenderTarget(j), J.updateRenderTargetMipmap(j), b.setRenderTarget(i);
        }([...i, ...a], t, n), r && q.viewport(E.copy(r)), !1 !== b.userData.opaqueRender && i.length > 0 && Ie(i, t, n), !1 !== b.userData.transparentRender && a.length > 0 && Ie(a, t, n), !1 !== b.userData.transmissionRender && s.length > 0 && (j || (j = new tr(1, 1)), Ie(s, t, n)), q.buffers.depth.setTest(!0), q.buffers.depth.setMask(!0), q.buffers.color.setMask(!0), q.setPolygonOffset(!1);
      }

      function Ie(e, t, n) {
        const r = { ...b.userData
        };
        b.userData.opaqueRender = void 0, b.userData.transparentRender = void 0, b.userData.transmissionRender = void 0, b.userData.backgroundRender = void 0;
        const i = !0 === t.isScene ? t.overrideMaterial : null;

        for (let r = 0, s = e.length; r < s; r++) {
          const s = e[r],
                o = s.object,
                a = s.geometry,
                l = null === i ? s.material : i,
                c = s.group;
          o.layers.test(n.layers) && Ne(o, t, n, a, l, c);
        }

        Object.assign(b.userData, r);
      }

      function Ne(e, t, n, r, i, s) {
        e.onBeforeRender(b, t, n, r, i, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(b, t, n, r, e, s), !0 === i.transparent && i.side === m ? (i.side = _, i.needsUpdate = !0, b.renderBufferDirect(n, t, r, i, e, s), i.side = f, i.needsUpdate = !0, b.renderBufferDirect(n, t, r, i, e, s), i.side = m) : b.renderBufferDirect(n, t, r, i, e, s), e.onAfterRender(b, t, n, r, i, s);
      }

      function Ue(e, t, n) {
        !0 !== t.isScene && (t = H);
        const r = Z.get(e),
              i = d.state.lights,
              s = d.state.shadowsArray,
              o = i.state.version,
              a = ie.getParameters(e, i.state, s, t, n),
              l = ie.getProgramCacheKey(a);
        let c = r.programs;
        r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? ee : Q).get(e.envMap || r.environment), void 0 === c && (e.addEventListener("dispose", Ee), c = new Map(), r.programs = c);
        let u = c.get(l);

        if (void 0 !== u) {
          if (r.currentProgram === u && r.lightsStateVersion === o) return Be(e, a), u;
        } else a.uniforms = ie.getUniforms(e), e.onBuild(n, a, b), e.onBeforeCompile(a, b), u = ie.acquireProgram(a, l), c.set(l, u), r.uniforms = a.uniforms;

        const p = r.uniforms;
        (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (p.clippingPlanes = le.uniform), Be(e, a), r.needsLights = function (e) {
          return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights;
        }(e), r.lightsStateVersion = o, r.needsLights && (p.ambientLightColor.value = i.state.ambient, p.lightProbe.value = i.state.probe, p.directionalLights.value = i.state.directional, p.directionalLightShadows.value = i.state.directionalShadow, p.spotLights.value = i.state.spot, p.spotLightShadows.value = i.state.spotShadow, p.rectAreaLights.value = i.state.rectArea, p.ltc_1.value = i.state.rectAreaLTC1, p.ltc_2.value = i.state.rectAreaLTC2, p.pointLights.value = i.state.point, p.pointLightShadows.value = i.state.pointShadow, p.hemisphereLights.value = i.state.hemi, p.directionalShadowMap.value = i.state.directionalShadowMap, p.directionalShadowMatrix.value = i.state.directionalShadowMatrix, p.spotShadowMap.value = i.state.spotShadowMap, p.spotShadowMatrix.value = i.state.spotShadowMatrix, p.pointShadowMap.value = i.state.pointShadowMap, p.pointShadowMatrix.value = i.state.pointShadowMatrix);
        const h = u.getUniforms(),
              f = fa.seqWithValue(h.seq, p);
        return r.currentProgram = u, r.uniformsList = f, u;
      }

      function Be(e, t) {
        const n = Z.get(e);
        n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping;
      }

      De.setAnimationLoop(function (e) {
        Ae && Ae(e);
      }), "undefined" != typeof self && De.setContext(self), this.setAnimationLoop = function (e) {
        Ae = e, xe.setAnimationLoop(e), null === e ? De.stop() : De.start();
      }, xe.addEventListener("sessionstart", Ce), xe.addEventListener("sessionend", Pe), this.render = function (e, t) {
        if (void 0 === t || !0 === t.isCamera) {
          if (!0 !== x) {
            if (!0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === xe.enabled && !0 === xe.isPresenting && (!0 === xe.cameraAutoUpdate && xe.updateCamera(t), t = xe.getCamera()), !0 === e.isScene && e.onBeforeRender(b, e, t, S), d = ae.get(e, v.length), d.init(), v.push(d), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), N.setFromProjectionMatrix(z), B = this.localClippingEnabled, U = le.init(this.clippingPlanes, B, t), h = oe.get(e, g.length), h.init(), g.push(h), Oe(e, t, 0, b.sortObjects), h.finish(), !0 === b.sortObjects && h.sort(D, O), b.userData.shadowMapRender) {
              !0 === U && le.beginShadows();
              const n = d.state.shadowsArray;
              n.length > 0 && ce.render(n, e, t), !0 === U && le.endShadows();
            }

            if (!0 === this.info.autoReset && this.info.reset(), !1 !== b.userData.backgroundRender && ue.render(h, e), !1 !== b.userData.sceneRender) if (d.setupLights(b.physicallyCorrectLights), t.isArrayCamera) {
              const n = t.cameras;

              for (let t = 0, r = n.length; t < r; t++) {
                const r = n[t];
                Le(h, e, r, r.viewport);
              }
            } else Le(h, e, t);
            null !== S && (J.updateMultisampleRenderTarget(S), J.updateRenderTargetMipmap(S)), !0 === e.isScene && e.onAfterRender(b, e, t), _e.resetDefaultState(), M = -1, T = null, v.pop(), d = v.length > 0 ? v[v.length - 1] : null, g.pop(), h = g.length > 0 ? g[g.length - 1] : null;
          }
        } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      }, this.getActiveCubeFace = function () {
        return y;
      }, this.getActiveMipmapLevel = function () {
        return w;
      }, this.getRenderTarget = function () {
        return S;
      }, this.setRenderTargetTextures = function (e, t, n) {
        Z.get(e.texture).__webglTexture = t, Z.get(e.depthTexture).__webglTexture = n;
        const r = Z.get(e);
        r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === K.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1));
      }, this.setRenderTargetFramebuffer = function (e, t) {
        const n = Z.get(e);
        n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t;
      }, this.setRenderTarget = function (e, t = 0, n = 0) {
        S = e, y = t, w = n;
        let r = !0;

        if (e) {
          const t = Z.get(e);
          void 0 !== t.__useDefaultFramebuffer ? (q.bindFramebuffer(36160, null), r = !1) : void 0 === t.__webglFramebuffer ? J.setupRenderTarget(e) : t.__hasExternalTextures && J.rebindTextures(e, Z.get(e.texture).__webglTexture, Z.get(e.depthTexture).__webglTexture);
        }

        let i = null,
            s = !1,
            o = !1;

        if (e) {
          const n = e.texture;
          (n.isData3DTexture || n.isDataArrayTexture) && (o = !0);

          const r = Z.get(e).__webglFramebuffer;

          e.isWebGLCubeRenderTarget ? (i = r[t], s = !0) : i = X.isWebGL2 && e.samples > 0 && !1 === J.useMultisampledRTT(e) ? Z.get(e).__webglMultisampledFramebuffer : r, E.copy(e.viewport), A.copy(e.scissor), C = e.scissorTest;
        } else E.copy(L).multiplyScalar(P).floor(), A.copy(I).multiplyScalar(P).floor(), C = F;

        if (q.bindFramebuffer(36160, i) && X.drawBuffers && r && q.drawBuffers(e, i), q.viewport(E), q.scissor(A), q.setScissorTest(C), s) {
          const r = Z.get(e.texture);
          ge.framebufferTexture2D(36160, 36064, 34069 + t, r.__webglTexture, n);
        } else if (o) {
          const r = Z.get(e.texture),
                i = t || 0;
          ge.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i);
        }

        M = -1;
      }, this.readRenderTargetPixels = function (e, t, n, r, i, s, o) {
        if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");

        let a = Z.get(e).__webglFramebuffer;

        if (e.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
          q.bindFramebuffer(36160, a);

          try {
            const o = e.texture,
                  a = o.format,
                  l = o.type;
            if (a !== Fe && fe.convert(a) !== ge.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            const c = l === ke && (K.has("EXT_color_buffer_half_float") || X.isWebGL2 && K.has("EXT_color_buffer_float"));
            if (!(l === Se || fe.convert(l) === ge.getParameter(35738) || l === Re && (X.isWebGL2 || K.has("OES_texture_float") || K.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ge.readPixels(t, n, r, i, fe.convert(a), fe.convert(l), s);
          } finally {
            const e = null !== S ? Z.get(S).__webglFramebuffer : null;
            q.bindFramebuffer(36160, e);
          }
        }
      }, this.copyFramebufferToTexture = function (e, t, n = 0) {
        const r = Math.pow(2, -n),
              i = Math.floor(t.image.width * r),
              s = Math.floor(t.image.height * r);
        J.setTexture2D(t, 0), ge.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, i, s), q.unbindTexture();
      }, this.copyTextureToTexture = function (e, t, n, r = 0) {
        const i = t.image.width,
              s = t.image.height,
              o = fe.convert(n.format),
              a = fe.convert(n.type);
        J.setTexture2D(n, 0), ge.pixelStorei(37440, n.flipY), ge.pixelStorei(37441, n.premultiplyAlpha), ge.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? ge.texSubImage2D(3553, r, e.x, e.y, i, s, o, a, t.image.data) : t.isCompressedTexture ? ge.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : ge.texSubImage2D(3553, r, e.x, e.y, o, a, t.image), 0 === r && n.generateMipmaps && ge.generateMipmap(3553), q.unbindTexture();
      }, this.copyTextureToTexture3D = function (e, t, n, r, i = 0) {
        if (b.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const s = e.max.x - e.min.x + 1,
              o = e.max.y - e.min.y + 1,
              a = e.max.z - e.min.z + 1,
              l = fe.convert(r.format),
              c = fe.convert(r.type);
        let u;
        if (r.isData3DTexture) J.setTexture3D(r, 0), u = 32879;else {
          if (!r.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          J.setTexture2DArray(r, 0), u = 35866;
        }
        ge.pixelStorei(37440, r.flipY), ge.pixelStorei(37441, r.premultiplyAlpha), ge.pixelStorei(3317, r.unpackAlignment);

        const p = ge.getParameter(3314),
              h = ge.getParameter(32878),
              d = ge.getParameter(3316),
              f = ge.getParameter(3315),
              _ = ge.getParameter(32877),
              m = n.isCompressedTexture ? n.mipmaps[0] : n.image;

        ge.pixelStorei(3314, m.width), ge.pixelStorei(32878, m.height), ge.pixelStorei(3316, e.min.x), ge.pixelStorei(3315, e.min.y), ge.pixelStorei(32877, e.min.z), n.isDataTexture || n.isData3DTexture ? ge.texSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, c, m.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ge.compressedTexSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, m.data)) : ge.texSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, c, m), ge.pixelStorei(3314, p), ge.pixelStorei(32878, h), ge.pixelStorei(3316, d), ge.pixelStorei(3315, f), ge.pixelStorei(32877, _), 0 === i && r.generateMipmaps && ge.generateMipmap(u), q.unbindTexture();
      }, this.initTexture = function (e) {
        e.isCubeTexture ? J.setTextureCube(e, 0) : e.isData3DTexture ? J.setTexture3D(e, 0) : e.isDataArrayTexture ? J.setTexture2DArray(e, 0) : J.setTexture2D(e, 0), q.unbindTexture();
      }, this.resetState = function () {
        y = 0, w = 0, S = null, q.reset(), _e.reset();
      }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }

    class pl extends ul {}

    pl.prototype.isWebGL1Renderer = !0;

    class hl {
      constructor(e, t = 25e-5) {
        this.isFogExp2 = !0, this.name = "", this.color = new Xn(e), this.density = t;
      }

      clone() {
        return new hl(this.color, this.density);
      }

      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density
        };
      }

    }

    class dl {
      constructor(e, t = 1, n = 1e3) {
        this.isFog = !0, this.name = "", this.color = new Xn(e), this.near = t, this.far = n;
      }

      clone() {
        return new dl(this.color, this.near, this.far);
      }

      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      }

    }

    class fl extends ui {
      constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }));
      }

      copy(e, t) {
        return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
      }

      toJSON(e) {
        const t = super.toJSON(e);
        return null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
      }

    }

    class _l {
      constructor(e, t) {
        this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = on, this.updateRange = {
          offset: 0,
          count: -1
        }, this.version = 0, this.uuid = Sn();
      }

      onUploadCallback() {}

      set needsUpdate(e) {
        !0 === e && this.version++;
      }

      setUsage(e) {
        return this.usage = e, this;
      }

      copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
      }

      copyAt(e, t, n) {
        e *= this.stride, n *= t.stride;

        for (let r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];

        return this;
      }

      set(e, t = 0) {
        return this.array.set(e, t), this;
      }

      clone(e) {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Sn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
              n = new this.constructor(t, this.stride);
        return n.setUsage(this.usage), n;
      }

      onUpload(e) {
        return this.onUploadCallback = e, this;
      }

      toJSON(e) {
        return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Sn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }

    }

    const ml = new lr();

    class gl {
      constructor(e, t, n, r = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r;
      }

      get count() {
        return this.data.count;
      }

      get array() {
        return this.data.array;
      }

      set needsUpdate(e) {
        this.data.needsUpdate = e;
      }

      applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++) ml.fromBufferAttribute(this, t), ml.applyMatrix4(e), this.setXYZ(t, ml.x, ml.y, ml.z);

        return this;
      }

      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++) ml.fromBufferAttribute(this, t), ml.applyNormalMatrix(e), this.setXYZ(t, ml.x, ml.y, ml.z);

        return this;
      }

      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++) ml.fromBufferAttribute(this, t), ml.transformDirection(e), this.setXYZ(t, ml.x, ml.y, ml.z);

        return this;
      }

      setX(e, t) {
        return this.data.array[e * this.data.stride + this.offset] = t, this;
      }

      setY(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
      }

      setZ(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
      }

      setW(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
      }

      getX(e) {
        return this.data.array[e * this.data.stride + this.offset];
      }

      getY(e) {
        return this.data.array[e * this.data.stride + this.offset + 1];
      }

      getZ(e) {
        return this.data.array[e * this.data.stride + this.offset + 2];
      }

      getW(e) {
        return this.data.array[e * this.data.stride + this.offset + 3];
      }

      setXY(e, t, n) {
        return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
      }

      setXYZ(e, t, n, r) {
        return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this;
      }

      setXYZW(e, t, n, r, i) {
        return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this;
      }

      clone(e) {
        if (void 0 === e) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
          const e = [];

          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;

            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t]);
          }

          return new Ai(new this.array.constructor(e), this.itemSize, this.normalized);
        }

        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new gl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }

      toJSON(e) {
        if (void 0 === e) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
          const e = [];

          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;

            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t]);
          }

          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: e,
            normalized: this.normalized
          };
        }

        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }

    }

    class vl extends Si {
      constructor(e) {
        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Xn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
      }

    }

    let bl;
    const xl = new lr(),
          yl = new lr(),
          wl = new lr(),
          Sl = new Pn(),
          Ml = new Pn(),
          Tl = new Br(),
          El = new lr(),
          Al = new lr(),
          Cl = new lr(),
          Rl = new Pn(),
          kl = new Pn(),
          Pl = new Pn();

    class Dl extends ui {
      constructor(e) {
        if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === bl) {
          bl = new Wi();
          const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                t = new _l(e, 5);
          bl.setIndex([0, 1, 2, 0, 2, 3]), bl.setAttribute("position", new gl(t, 3, 0, !1)), bl.setAttribute("uv", new gl(t, 2, 3, !1));
        }

        this.geometry = bl, this.material = void 0 !== e ? e : new vl(), this.center = new Pn(.5, .5);
      }

      raycast(e, t) {
        null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), yl.setFromMatrixScale(this.matrixWorld), Tl.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), wl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && yl.multiplyScalar(-wl.z);
        const n = this.material.rotation;
        let r, i;
        0 !== n && (i = Math.cos(n), r = Math.sin(n));
        const s = this.center;
        Ol(El.set(-.5, -.5, 0), wl, s, yl, r, i), Ol(Al.set(.5, -.5, 0), wl, s, yl, r, i), Ol(Cl.set(.5, .5, 0), wl, s, yl, r, i), Rl.set(0, 0), kl.set(1, 0), Pl.set(1, 1);
        let o = e.ray.intersectTriangle(El, Al, Cl, !1, xl);
        if (null === o && (Ol(Al.set(-.5, .5, 0), wl, s, yl, r, i), kl.set(0, 1), o = e.ray.intersectTriangle(El, Cl, Al, !1, xl), null === o)) return;
        const a = e.ray.origin.distanceTo(xl);
        a < e.near || a > e.far || t.push({
          distance: a,
          point: xl.clone(),
          uv: yi.getUV(xl, El, Al, Cl, Rl, kl, Pl, new Pn()),
          face: null,
          object: this
        });
      }

      copy(e, t) {
        return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this;
      }

    }

    function Ol(e, t, n, r, i, s) {
      Sl.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (Ml.x = s * Sl.x - i * Sl.y, Ml.y = i * Sl.x + s * Sl.y) : Ml.copy(Sl), e.copy(t), e.x += Ml.x, e.y += Ml.y, e.applyMatrix4(Tl);
    }

    const Ll = new lr(),
          Il = new lr();

    class Fl extends ui {
      constructor() {
        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
          levels: {
            enumerable: !0,
            value: []
          },
          isLOD: {
            value: !0
          }
        }), this.autoUpdate = !0;
      }

      copy(e) {
        super.copy(e, !1);
        const t = e.levels;

        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          this.addLevel(n.object.clone(), n.distance);
        }

        return this.autoUpdate = e.autoUpdate, this;
      }

      addLevel(e, t = 0) {
        t = Math.abs(t);
        const n = this.levels;
        let r;

        for (r = 0; r < n.length && !(t < n[r].distance); r++);

        return n.splice(r, 0, {
          distance: t,
          object: e
        }), this.add(e), this;
      }

      getCurrentLevel() {
        return this._currentLevel;
      }

      getObjectForDistance(e) {
        const t = this.levels;

        if (t.length > 0) {
          let n, r;

          for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++);

          return t[n - 1].object;
        }

        return null;
      }

      raycast(e, t) {
        if (this.levels.length > 0) {
          Ll.setFromMatrixPosition(this.matrixWorld);
          const n = e.ray.origin.distanceTo(Ll);
          this.getObjectForDistance(n).raycast(e, t);
        }
      }

      update(e) {
        const t = this.levels;

        if (t.length > 1) {
          Ll.setFromMatrixPosition(e.matrixWorld), Il.setFromMatrixPosition(this.matrixWorld);
          const n = Ll.distanceTo(Il) / e.zoom;
          let r, i;

          for (t[0].object.visible = !0, r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;

          for (this._currentLevel = r - 1; r < i; r++) t[r].object.visible = !1;
        }
      }

      toJSON(e) {
        const t = super.toJSON(e);
        !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
        const n = this.levels;

        for (let e = 0, r = n.length; e < r; e++) {
          const r = n[e];
          t.object.levels.push({
            object: r.object.uuid,
            distance: r.distance
          });
        }

        return t;
      }

    }

    const Nl = new lr(),
          Ul = new er(),
          Bl = new er(),
          jl = new lr(),
          zl = new Br();

    class Vl extends cs {
      constructor(e, t) {
        super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Br(), this.bindMatrixInverse = new Br();
      }

      copy(e, t) {
        return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
      }

      bind(e, t) {
        this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
      }

      pose() {
        this.skeleton.pose();
      }

      normalizeSkinWeights() {
        const e = new er(),
              t = this.geometry.attributes.skinWeight;

        for (let n = 0, r = t.count; n < r; n++) {
          e.fromBufferAttribute(t, n);
          const r = 1 / e.manhattanLength();
          r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
        }
      }

      updateMatrixWorld(e) {
        super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }

      boneTransform(e, t) {
        const n = this.skeleton,
              r = this.geometry;
        Ul.fromBufferAttribute(r.attributes.skinIndex, e), Bl.fromBufferAttribute(r.attributes.skinWeight, e), Nl.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);

        for (let e = 0; e < 4; e++) {
          const r = Bl.getComponent(e);

          if (0 !== r) {
            const i = Ul.getComponent(e);
            zl.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(jl.copy(Nl).applyMatrix4(zl), r);
          }
        }

        return t.applyMatrix4(this.bindMatrixInverse);
      }

    }

    class Gl extends ui {
      constructor() {
        super(), this.isBone = !0, this.type = "Bone";
      }

    }

    class Hl extends Qn {
      constructor(e = null, t = 1, n = 1, r, i, s, o, a, l = de, c = de, u, p) {
        super(null, s, o, a, l, c, r, i, u, p), this.isDataTexture = !0, this.image = {
          data: e,
          width: t,
          height: n
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
      }

    }

    const Wl = new Br(),
          Kl = new Br();

    class Xl {
      constructor(e = [], t = []) {
        this.uuid = Sn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
      }

      init() {
        const e = this.bones,
              t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();else if (e.length !== t.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];

          for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Br());
        }
      }

      calculateInverses() {
        this.boneInverses.length = 0;

        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = new Br();
          this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t);
        }
      }

      pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t && t.matrixWorld.copy(this.boneInverses[e]).invert();
        }

        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
        }
      }

      update() {
        const e = this.bones,
              t = this.boneInverses,
              n = this.boneMatrices,
              r = this.boneTexture;

        for (let r = 0, i = e.length; r < i; r++) {
          const i = e[r] ? e[r].matrixWorld : Kl;
          Wl.multiplyMatrices(i, t[r]), Wl.toArray(n, 16 * r);
        }

        null !== r && (r.needsUpdate = !0);
      }

      clone() {
        return new Xl(this.bones, this.boneInverses);
      }

      computeBoneTexture() {
        let e = Math.sqrt(4 * this.bones.length);
        e = Cn(e), e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new Hl(t, e, e, Fe, Re);
        return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this;
      }

      getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
          const n = this.bones[t];
          if (n.name === e) return n;
        }
      }

      dispose() {
        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
      }

      fromJSON(e, t) {
        this.uuid = e.uuid;

        for (let n = 0, r = e.bones.length; n < r; n++) {
          const r = e.bones[n];
          let i = t[r];
          void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new Gl()), this.bones.push(i), this.boneInverses.push(new Br().fromArray(e.boneInverses[n]));
        }

        return this.init(), this;
      }

      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON"
          },
          bones: [],
          boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones,
              n = this.boneInverses;

        for (let r = 0, i = t.length; r < i; r++) {
          const i = t[r];
          e.bones.push(i.uuid);
          const s = n[r];
          e.boneInverses.push(s.toArray());
        }

        return e;
      }

    }

    class ql extends Ai {
      constructor(e, t, n, r = 1) {
        "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
      }

      copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
      }

    }

    const Yl = new Br(),
          Zl = new Br(),
          Jl = [],
          $l = new cs();

    class Ql extends cs {
      constructor(e, t, n) {
        super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new ql(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
      }

      copy(e, t) {
        return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
      }

      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, 3 * e);
      }

      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, 16 * e);
      }

      raycast(e, t) {
        const n = this.matrixWorld,
              r = this.count;
        if ($l.geometry = this.geometry, $l.material = this.material, void 0 !== $l.material) for (let i = 0; i < r; i++) {
          this.getMatrixAt(i, Yl), Zl.multiplyMatrices(n, Yl), $l.matrixWorld = Zl, $l.raycast(e, Jl);

          for (let e = 0, n = Jl.length; e < n; e++) {
            const n = Jl[e];
            n.instanceId = i, n.object = this, t.push(n);
          }

          Jl.length = 0;
        }
      }

      setColorAt(e, t) {
        null === this.instanceColor && (this.instanceColor = new ql(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e);
      }

      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, 16 * e);
      }

      updateMorphTargets() {}

      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }

    }

    class ec extends Si {
      constructor(e) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Xn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
      }

    }

    const tc = new lr(),
          nc = new lr(),
          rc = new Br(),
          ic = new Ur(),
          sc = new kr();

    class oc extends ui {
      constructor(e = new Wi(), t = new ec()) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
      }

      copy(e, t) {
        return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
      }

      computeLineDistances() {
        const e = this.geometry;

        if (null === e.index) {
          const t = e.attributes.position,
                n = [0];

          for (let e = 1, r = t.count; e < r; e++) tc.fromBufferAttribute(t, e - 1), nc.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += tc.distanceTo(nc);

          e.setAttribute("lineDistance", new Fi(n, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");

        return this;
      }

      raycast(e, t) {
        const n = this.geometry,
              r = this.matrixWorld,
              i = e.params.Line.threshold,
              s = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), sc.copy(n.boundingSphere), sc.applyMatrix4(r), sc.radius += i, !1 === e.ray.intersectsSphere(sc)) return;
        rc.copy(r).invert(), ic.copy(e.ray).applyMatrix4(rc);
        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o,
              l = new lr(),
              c = new lr(),
              u = new lr(),
              p = new lr(),
              h = this.isLineSegments ? 2 : 1,
              d = n.index,
              f = n.attributes.position;
        if (null !== d) for (let n = Math.max(0, s.start), r = Math.min(d.count, s.start + s.count) - 1; n < r; n += h) {
          const r = d.getX(n),
                i = d.getX(n + 1);
          if (l.fromBufferAttribute(f, r), c.fromBufferAttribute(f, i), ic.distanceSqToSegment(l, c, p, u) > a) continue;
          p.applyMatrix4(this.matrixWorld);
          const s = e.ray.origin.distanceTo(p);
          s < e.near || s > e.far || t.push({
            distance: s,
            point: u.clone().applyMatrix4(this.matrixWorld),
            index: n,
            face: null,
            faceIndex: null,
            object: this
          });
        } else for (let n = Math.max(0, s.start), r = Math.min(f.count, s.start + s.count) - 1; n < r; n += h) {
          if (l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1), ic.distanceSqToSegment(l, c, p, u) > a) continue;
          p.applyMatrix4(this.matrixWorld);
          const r = e.ray.origin.distanceTo(p);
          r < e.near || r > e.far || t.push({
            distance: r,
            point: u.clone().applyMatrix4(this.matrixWorld),
            index: n,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }

      updateMorphTargets() {
        const e = this.geometry.morphAttributes,
              t = Object.keys(e);

        if (t.length > 0) {
          const n = e[t[0]];

          if (void 0 !== n) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};

            for (let e = 0, t = n.length; e < t; e++) {
              const t = n[e].name || String(e);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e;
            }
          }
        }
      }

    }

    const ac = new lr(),
          lc = new lr();

    class cc extends oc {
      constructor(e, t) {
        super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
      }

      computeLineDistances() {
        const e = this.geometry;

        if (null === e.index) {
          const t = e.attributes.position,
                n = [];

          for (let e = 0, r = t.count; e < r; e += 2) ac.fromBufferAttribute(t, e), lc.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + ac.distanceTo(lc);

          e.setAttribute("lineDistance", new Fi(n, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");

        return this;
      }

    }

    class uc extends oc {
      constructor(e, t) {
        super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
      }

    }

    class pc extends Si {
      constructor(e) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Xn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
      }

    }

    const hc = new Br(),
          dc = new Ur(),
          fc = new kr(),
          _c = new lr();

    class mc extends ui {
      constructor(e = new Wi(), t = new pc()) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
      }

      copy(e, t) {
        return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
      }

      raycast(e, t) {
        const n = this.geometry,
              r = this.matrixWorld,
              i = e.params.Points.threshold,
              s = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), fc.copy(n.boundingSphere), fc.applyMatrix4(r), fc.radius += i, !1 === e.ray.intersectsSphere(fc)) return;
        hc.copy(r).invert(), dc.copy(e.ray).applyMatrix4(hc);
        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o,
              l = n.index,
              c = n.attributes.position;
        if (null !== l) for (let n = Math.max(0, s.start), i = Math.min(l.count, s.start + s.count); n < i; n++) {
          const i = l.getX(n);
          _c.fromBufferAttribute(c, i), gc(_c, i, a, r, e, t, this);
        } else for (let n = Math.max(0, s.start), i = Math.min(c.count, s.start + s.count); n < i; n++) _c.fromBufferAttribute(c, n), gc(_c, n, a, r, e, t, this);
      }

      updateMorphTargets() {
        const e = this.geometry.morphAttributes,
              t = Object.keys(e);

        if (t.length > 0) {
          const n = e[t[0]];

          if (void 0 !== n) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};

            for (let e = 0, t = n.length; e < t; e++) {
              const t = n[e].name || String(e);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e;
            }
          }
        }
      }

    }

    function gc(e, t, n, r, i, s, o) {
      const a = dc.distanceSqToPoint(e);

      if (a < n) {
        const n = new lr();
        dc.closestPointToPoint(e, n), n.applyMatrix4(r);
        const l = i.ray.origin.distanceTo(n);
        if (l < i.near || l > i.far) return;
        s.push({
          distance: l,
          distanceToRay: Math.sqrt(a),
          point: n,
          index: t,
          face: null,
          object: o
        });
      }
    }

    class vc extends Qn {
      constructor(e, t, n, r, i, s, o, a, l) {
        super(e, t, n, r, i, s, o, a, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : ve, this.magFilter = void 0 !== i ? i : ve, this.generateMipmaps = !1;
        const c = this;
        "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
          c.needsUpdate = !0, e.requestVideoFrameCallback(t);
        });
      }

      clone() {
        return new this.constructor(this.image).copy(this);
      }

      update() {
        const e = this.image;
        !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
      }

    }

    class bc extends Qn {
      constructor(e, t, n) {
        super({
          width: e,
          height: t
        }), this.isFramebufferTexture = !0, this.format = n, this.magFilter = de, this.minFilter = de, this.generateMipmaps = !1, this.needsUpdate = !0;
      }

    }

    class xc extends Qn {
      constructor(e, t, n, r, i, s, o, a, l, c, u, p) {
        super(null, s, o, a, l, c, r, i, u, p), this.isCompressedTexture = !0, this.image = {
          width: t,
          height: n
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
      }

    }

    class yc extends Qn {
      constructor(e, t, n, r, i, s, o, a, l) {
        super(e, t, n, r, i, s, o, a, l), this.isCanvasTexture = !0, this.needsUpdate = !0;
      }

    }

    class wc {
      constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200;
      }

      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }

      getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t);
      }

      getPoints(e = 5) {
        const t = [];

        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));

        return t;
      }

      getSpacedPoints(e = 5) {
        const t = [];

        for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));

        return t;
      }

      getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
      }

      getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n,
            r = this.getPoint(0),
            i = 0;
        t.push(0);

        for (let s = 1; s <= e; s++) n = this.getPoint(s / e), i += n.distanceTo(r), t.push(i), r = n;

        return this.cacheArcLengths = t, t;
      }

      updateArcLengths() {
        this.needsUpdate = !0, this.getLengths();
      }

      getUtoTmapping(e, t) {
        const n = this.getLengths();
        let r = 0;
        const i = n.length;
        let s;
        s = t || e * n[i - 1];
        let o,
            a = 0,
            l = i - 1;

        for (; a <= l;) if (r = Math.floor(a + (l - a) / 2), o = n[r] - s, o < 0) a = r + 1;else {
          if (!(o > 0)) {
            l = r;
            break;
          }

          l = r - 1;
        }

        if (r = l, n[r] === s) return r / (i - 1);
        const c = n[r];
        return (r + (s - c) / (n[r + 1] - c)) / (i - 1);
      }

      getTangent(e, t) {
        const n = 1e-4;
        let r = e - n,
            i = e + n;
        r < 0 && (r = 0), i > 1 && (i = 1);
        const s = this.getPoint(r),
              o = this.getPoint(i),
              a = t || (s.isVector2 ? new Pn() : new lr());
        return a.copy(o).sub(s).normalize(), a;
      }

      getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t);
      }

      computeFrenetFrames(e, t) {
        const n = new lr(),
              r = [],
              i = [],
              s = [],
              o = new lr(),
              a = new Br();

        for (let t = 0; t <= e; t++) {
          const n = t / e;
          r[t] = this.getTangentAt(n, new lr());
        }

        i[0] = new lr(), s[0] = new lr();
        let l = Number.MAX_VALUE;
        const c = Math.abs(r[0].x),
              u = Math.abs(r[0].y),
              p = Math.abs(r[0].z);
        c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), p <= l && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), s[0].crossVectors(r[0], i[0]);

        for (let t = 1; t <= e; t++) {
          if (i[t] = i[t - 1].clone(), s[t] = s[t - 1].clone(), o.crossVectors(r[t - 1], r[t]), o.length() > Number.EPSILON) {
            o.normalize();
            const e = Math.acos(Mn(r[t - 1].dot(r[t]), -1, 1));
            i[t].applyMatrix4(a.makeRotationAxis(o, e));
          }

          s[t].crossVectors(r[t], i[t]);
        }

        if (!0 === t) {
          let t = Math.acos(Mn(i[0].dot(i[e]), -1, 1));
          t /= e, r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (t = -t);

          for (let n = 1; n <= e; n++) i[n].applyMatrix4(a.makeRotationAxis(r[n], t * n)), s[n].crossVectors(r[n], i[n]);
        }

        return {
          tangents: r,
          normals: i,
          binormals: s
        };
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this;
      }

      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
      }

      fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this;
      }

    }

    class Sc extends wc {
      constructor(e = 0, t = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, o = !1, a = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a;
      }

      getPoint(e, t) {
        const n = t || new Pn(),
              r = 2 * Math.PI;
        let i = this.aEndAngle - this.aStartAngle;
        const s = Math.abs(i) < Number.EPSILON;

        for (; i < 0;) i += r;

        for (; i > r;) i -= r;

        i < Number.EPSILON && (i = s ? 0 : r), !0 !== this.aClockwise || s || (i === r ? i = -r : i -= r);
        const o = this.aStartAngle + e * i;
        let a = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o);

        if (0 !== this.aRotation) {
          const e = Math.cos(this.aRotation),
                t = Math.sin(this.aRotation),
                n = a - this.aX,
                r = l - this.aY;
          a = n * e - r * t + this.aX, l = n * t + r * e + this.aY;
        }

        return n.set(a, l);
      }

      copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
      }

    }

    class Mc extends Sc {
      constructor(e, t, n, r, i, s) {
        super(e, t, n, n, r, i, s), this.isArcCurve = !0, this.type = "ArcCurve";
      }

    }

    function Tc() {
      let e = 0,
          t = 0,
          n = 0,
          r = 0;

      function i(i, s, o, a) {
        e = i, t = o, n = -3 * i + 3 * s - 2 * o - a, r = 2 * i - 2 * s + o + a;
      }

      return {
        initCatmullRom: function (e, t, n, r, s) {
          i(t, n, s * (n - e), s * (r - t));
        },
        initNonuniformCatmullRom: function (e, t, n, r, s, o, a) {
          let l = (t - e) / s - (n - e) / (s + o) + (n - t) / o,
              c = (n - t) / o - (r - t) / (o + a) + (r - n) / a;
          l *= o, c *= o, i(t, n, l, c);
        },
        calc: function (i) {
          const s = i * i;
          return e + t * i + n * s + r * (s * i);
        }
      };
    }

    const Ec = new lr(),
          Ac = new Tc(),
          Cc = new Tc(),
          Rc = new Tc();

    class kc extends wc {
      constructor(e = [], t = !1, n = "centripetal", r = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r;
      }

      getPoint(e, t = new lr()) {
        const n = t,
              r = this.points,
              i = r.length,
              s = (i - (this.closed ? 0 : 1)) * e;
        let o,
            a,
            l = Math.floor(s),
            c = s - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? o = r[(l - 1) % i] : (Ec.subVectors(r[0], r[1]).add(r[0]), o = Ec);
        const u = r[l % i],
              p = r[(l + 1) % i];

        if (this.closed || l + 2 < i ? a = r[(l + 2) % i] : (Ec.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), a = Ec), "centripetal" === this.curveType || "chordal" === this.curveType) {
          const e = "chordal" === this.curveType ? .5 : .25;
          let t = Math.pow(o.distanceToSquared(u), e),
              n = Math.pow(u.distanceToSquared(p), e),
              r = Math.pow(p.distanceToSquared(a), e);
          n < 1e-4 && (n = 1), t < 1e-4 && (t = n), r < 1e-4 && (r = n), Ac.initNonuniformCatmullRom(o.x, u.x, p.x, a.x, t, n, r), Cc.initNonuniformCatmullRom(o.y, u.y, p.y, a.y, t, n, r), Rc.initNonuniformCatmullRom(o.z, u.z, p.z, a.z, t, n, r);
        } else "catmullrom" === this.curveType && (Ac.initCatmullRom(o.x, u.x, p.x, a.x, this.tension), Cc.initCatmullRom(o.y, u.y, p.y, a.y, this.tension), Rc.initCatmullRom(o.z, u.z, p.z, a.z, this.tension));

        return n.set(Ac.calc(c), Cc.calc(c), Rc.calc(c)), n;
      }

      copy(e) {
        super.copy(e), this.points = [];

        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }

        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
      }

      toJSON() {
        const e = super.toJSON();
        e.points = [];

        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }

        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
      }

      fromJSON(e) {
        super.fromJSON(e), this.points = [];

        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new lr().fromArray(n));
        }

        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
      }

    }

    function Pc(e, t, n, r, i) {
      const s = .5 * (r - t),
            o = .5 * (i - n),
            a = e * e;
      return (2 * n - 2 * r + s + o) * (e * a) + (-3 * n + 3 * r - 2 * s - o) * a + s * e + n;
    }

    function Dc(e, t, n, r) {
      return function (e, t) {
        const n = 1 - e;
        return n * n * t;
      }(e, t) + function (e, t) {
        return 2 * (1 - e) * e * t;
      }(e, n) + function (e, t) {
        return e * e * t;
      }(e, r);
    }

    function Oc(e, t, n, r, i) {
      return function (e, t) {
        const n = 1 - e;
        return n * n * n * t;
      }(e, t) + function (e, t) {
        const n = 1 - e;
        return 3 * n * n * e * t;
      }(e, n) + function (e, t) {
        return 3 * (1 - e) * e * e * t;
      }(e, r) + function (e, t) {
        return e * e * e * t;
      }(e, i);
    }

    class Lc extends wc {
      constructor(e = new Pn(), t = new Pn(), n = new Pn(), r = new Pn()) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
      }

      getPoint(e, t = new Pn()) {
        const n = t,
              r = this.v0,
              i = this.v1,
              s = this.v2,
              o = this.v3;
        return n.set(Oc(e, r.x, i.x, s.x, o.x), Oc(e, r.y, i.y, s.y, o.y)), n;
      }

      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
      }

    }

    class Ic extends wc {
      constructor(e = new lr(), t = new lr(), n = new lr(), r = new lr()) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
      }

      getPoint(e, t = new lr()) {
        const n = t,
              r = this.v0,
              i = this.v1,
              s = this.v2,
              o = this.v3;
        return n.set(Oc(e, r.x, i.x, s.x, o.x), Oc(e, r.y, i.y, s.y, o.y), Oc(e, r.z, i.z, s.z, o.z)), n;
      }

      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
      }

    }

    class Fc extends wc {
      constructor(e = new Pn(), t = new Pn()) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
      }

      getPoint(e, t = new Pn()) {
        const n = t;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
      }

      getPointAt(e, t) {
        return this.getPoint(e, t);
      }

      getTangent(e, t) {
        const n = t || new Pn();
        return n.copy(this.v2).sub(this.v1).normalize(), n;
      }

      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }

    }

    class Nc extends wc {
      constructor(e = new lr(), t = new lr()) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
      }

      getPoint(e, t = new lr()) {
        const n = t;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
      }

      getPointAt(e, t) {
        return this.getPoint(e, t);
      }

      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }

    }

    class Uc extends wc {
      constructor(e = new Pn(), t = new Pn(), n = new Pn()) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
      }

      getPoint(e, t = new Pn()) {
        const n = t,
              r = this.v0,
              i = this.v1,
              s = this.v2;
        return n.set(Dc(e, r.x, i.x, s.x), Dc(e, r.y, i.y, s.y)), n;
      }

      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }

    }

    class Bc extends wc {
      constructor(e = new lr(), t = new lr(), n = new lr()) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
      }

      getPoint(e, t = new lr()) {
        const n = t,
              r = this.v0,
              i = this.v1,
              s = this.v2;
        return n.set(Dc(e, r.x, i.x, s.x), Dc(e, r.y, i.y, s.y), Dc(e, r.z, i.z, s.z)), n;
      }

      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }

    }

    class jc extends wc {
      constructor(e = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
      }

      getPoint(e, t = new Pn()) {
        const n = t,
              r = this.points,
              i = (r.length - 1) * e,
              s = Math.floor(i),
              o = i - s,
              a = r[0 === s ? s : s - 1],
              l = r[s],
              c = r[s > r.length - 2 ? r.length - 1 : s + 1],
              u = r[s > r.length - 3 ? r.length - 1 : s + 2];
        return n.set(Pc(o, a.x, l.x, c.x, u.x), Pc(o, a.y, l.y, c.y, u.y)), n;
      }

      copy(e) {
        super.copy(e), this.points = [];

        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }

        return this;
      }

      toJSON() {
        const e = super.toJSON();
        e.points = [];

        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }

        return e;
      }

      fromJSON(e) {
        super.fromJSON(e), this.points = [];

        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new Pn().fromArray(n));
        }

        return this;
      }

    }

    var zc = Object.freeze({
      __proto__: null,
      ArcCurve: Mc,
      CatmullRomCurve3: kc,
      CubicBezierCurve: Lc,
      CubicBezierCurve3: Ic,
      EllipseCurve: Sc,
      LineCurve: Fc,
      LineCurve3: Nc,
      QuadraticBezierCurve: Uc,
      QuadraticBezierCurve3: Bc,
      SplineCurve: jc
    });

    class Vc extends wc {
      constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
      }

      add(e) {
        this.curves.push(e);
      }

      closePath() {
        const e = this.curves[0].getPoint(0),
              t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new Fc(t, e));
      }

      getPoint(e, t) {
        const n = e * this.getLength(),
              r = this.getCurveLengths();
        let i = 0;

        for (; i < r.length;) {
          if (r[i] >= n) {
            const e = r[i] - n,
                  s = this.curves[i],
                  o = s.getLength(),
                  a = 0 === o ? 0 : 1 - e / o;
            return s.getPointAt(a, t);
          }

          i++;
        }

        return null;
      }

      getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
      }

      updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
      }

      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let t = 0;

        for (let n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);

        return this.cacheLengths = e, e;
      }

      getSpacedPoints(e = 40) {
        const t = [];

        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));

        return this.autoClose && t.push(t[0]), t;
      }

      getPoints(e = 12) {
        const t = [];
        let n;

        for (let r = 0, i = this.curves; r < i.length; r++) {
          const s = i[r],
                o = s.isEllipseCurve ? 2 * e : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e,
                a = s.getPoints(o);

          for (let e = 0; e < a.length; e++) {
            const r = a[e];
            n && n.equals(r) || (t.push(r), n = r);
          }
        }

        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
      }

      copy(e) {
        super.copy(e), this.curves = [];

        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(n.clone());
        }

        return this.autoClose = e.autoClose, this;
      }

      toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];

        for (let t = 0, n = this.curves.length; t < n; t++) {
          const n = this.curves[t];
          e.curves.push(n.toJSON());
        }

        return e;
      }

      fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];

        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(new zc[n.type]().fromJSON(n));
        }

        return this;
      }

    }

    class Gc extends Vc {
      constructor(e) {
        super(), this.type = "Path", this.currentPoint = new Pn(), e && this.setFromPoints(e);
      }

      setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);

        for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);

        return this;
      }

      moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
      }

      lineTo(e, t) {
        const n = new Fc(this.currentPoint.clone(), new Pn(e, t));
        return this.curves.push(n), this.currentPoint.set(e, t), this;
      }

      quadraticCurveTo(e, t, n, r) {
        const i = new Uc(this.currentPoint.clone(), new Pn(e, t), new Pn(n, r));
        return this.curves.push(i), this.currentPoint.set(n, r), this;
      }

      bezierCurveTo(e, t, n, r, i, s) {
        const o = new Lc(this.currentPoint.clone(), new Pn(e, t), new Pn(n, r), new Pn(i, s));
        return this.curves.push(o), this.currentPoint.set(i, s), this;
      }

      splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
              n = new jc(t);
        return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
      }

      arc(e, t, n, r, i, s) {
        const o = this.currentPoint.x,
              a = this.currentPoint.y;
        return this.absarc(e + o, t + a, n, r, i, s), this;
      }

      absarc(e, t, n, r, i, s) {
        return this.absellipse(e, t, n, n, r, i, s), this;
      }

      ellipse(e, t, n, r, i, s, o, a) {
        const l = this.currentPoint.x,
              c = this.currentPoint.y;
        return this.absellipse(e + l, t + c, n, r, i, s, o, a), this;
      }

      absellipse(e, t, n, r, i, s, o, a) {
        const l = new Sc(e, t, n, r, i, s, o, a);

        if (this.curves.length > 0) {
          const e = l.getPoint(0);
          e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
        }

        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this;
      }

      copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
      }

      toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e;
      }

      fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
      }

    }

    class Hc extends Wi {
      constructor(e = [new Pn(0, -.5), new Pn(.5, 0), new Pn(0, .5)], t = 12, n = 0, r = 2 * Math.PI) {
        super(), this.type = "LatheGeometry", this.parameters = {
          points: e,
          segments: t,
          phiStart: n,
          phiLength: r
        }, t = Math.floor(t), r = Mn(r, 0, 2 * Math.PI);
        const i = [],
              s = [],
              o = [],
              a = [],
              l = [],
              c = 1 / t,
              u = new lr(),
              p = new Pn(),
              h = new lr(),
              d = new lr(),
              f = new lr();
        let _ = 0,
            m = 0;

        for (let t = 0; t <= e.length - 1; t++) switch (t) {
          case 0:
            _ = e[t + 1].x - e[t].x, m = e[t + 1].y - e[t].y, h.x = 1 * m, h.y = -_, h.z = 0 * m, f.copy(h), h.normalize(), a.push(h.x, h.y, h.z);
            break;

          case e.length - 1:
            a.push(f.x, f.y, f.z);
            break;

          default:
            _ = e[t + 1].x - e[t].x, m = e[t + 1].y - e[t].y, h.x = 1 * m, h.y = -_, h.z = 0 * m, d.copy(h), h.x += f.x, h.y += f.y, h.z += f.z, h.normalize(), a.push(h.x, h.y, h.z), f.copy(d);
        }

        for (let i = 0; i <= t; i++) {
          const h = n + i * c * r,
                d = Math.sin(h),
                f = Math.cos(h);

          for (let n = 0; n <= e.length - 1; n++) {
            u.x = e[n].x * d, u.y = e[n].y, u.z = e[n].x * f, s.push(u.x, u.y, u.z), p.x = i / t, p.y = n / (e.length - 1), o.push(p.x, p.y);
            const r = a[3 * n + 0] * d,
                  c = a[3 * n + 1],
                  h = a[3 * n + 0] * f;
            l.push(r, c, h);
          }
        }

        for (let n = 0; n < t; n++) for (let t = 0; t < e.length - 1; t++) {
          const r = t + n * e.length,
                s = r,
                o = r + e.length,
                a = r + e.length + 1,
                l = r + 1;
          i.push(s, o, l), i.push(a, l, o);
        }

        this.setIndex(i), this.setAttribute("position", new Fi(s, 3)), this.setAttribute("uv", new Fi(o, 2)), this.setAttribute("normal", new Fi(l, 3));
      }

      static fromJSON(e) {
        return new Hc(e.points, e.segments, e.phiStart, e.phiLength);
      }

    }

    class Wc extends Hc {
      constructor(e = 1, t = 1, n = 4, r = 8) {
        const i = new Gc();
        i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), i.absarc(0, t / 2, e, 0, .5 * Math.PI), super(i.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
          radius: e,
          height: t,
          capSegments: n,
          radialSegments: r
        };
      }

      static fromJSON(e) {
        return new Wc(e.radius, e.length, e.capSegments, e.radialSegments);
      }

    }

    class Kc extends Wi {
      constructor(e = 1, t = 8, n = 0, r = 2 * Math.PI) {
        super(), this.type = "CircleGeometry", this.parameters = {
          radius: e,
          segments: t,
          thetaStart: n,
          thetaLength: r
        }, t = Math.max(3, t);
        const i = [],
              s = [],
              o = [],
              a = [],
              l = new lr(),
              c = new Pn();
        s.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5);

        for (let i = 0, u = 3; i <= t; i++, u += 3) {
          const p = n + i / t * r;
          l.x = e * Math.cos(p), l.y = e * Math.sin(p), s.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (s[u] / e + 1) / 2, c.y = (s[u + 1] / e + 1) / 2, a.push(c.x, c.y);
        }

        for (let e = 1; e <= t; e++) i.push(e, e + 1, 0);

        this.setIndex(i), this.setAttribute("position", new Fi(s, 3)), this.setAttribute("normal", new Fi(o, 3)), this.setAttribute("uv", new Fi(a, 2));
      }

      static fromJSON(e) {
        return new Kc(e.radius, e.segments, e.thetaStart, e.thetaLength);
      }

    }

    class Xc extends Wi {
      constructor(e = 1, t = 1, n = 1, r = 8, i = 1, s = !1, o = 0, a = 2 * Math.PI) {
        super(), this.type = "CylinderGeometry", this.parameters = {
          radiusTop: e,
          radiusBottom: t,
          height: n,
          radialSegments: r,
          heightSegments: i,
          openEnded: s,
          thetaStart: o,
          thetaLength: a
        };
        const l = this;
        r = Math.floor(r), i = Math.floor(i);
        const c = [],
              u = [],
              p = [],
              h = [];
        let d = 0;

        const f = [],
              _ = n / 2;

        let m = 0;

        function g(n) {
          const i = d,
                s = new Pn(),
                f = new lr();
          let g = 0;
          const v = !0 === n ? e : t,
                b = !0 === n ? 1 : -1;

          for (let e = 1; e <= r; e++) u.push(0, _ * b, 0), p.push(0, b, 0), h.push(.5, .5), d++;

          const x = d;

          for (let e = 0; e <= r; e++) {
            const t = e / r * a + o,
                  n = Math.cos(t),
                  i = Math.sin(t);
            f.x = v * i, f.y = _ * b, f.z = v * n, u.push(f.x, f.y, f.z), p.push(0, b, 0), s.x = .5 * n + .5, s.y = .5 * i * b + .5, h.push(s.x, s.y), d++;
          }

          for (let e = 0; e < r; e++) {
            const t = i + e,
                  r = x + e;
            !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t), g += 3;
          }

          l.addGroup(m, g, !0 === n ? 1 : 2), m += g;
        }

        !function () {
          const s = new lr(),
                g = new lr();
          let v = 0;
          const b = (t - e) / n;

          for (let l = 0; l <= i; l++) {
            const c = [],
                  m = l / i,
                  v = m * (t - e) + e;

            for (let e = 0; e <= r; e++) {
              const t = e / r,
                    i = t * a + o,
                    l = Math.sin(i),
                    f = Math.cos(i);
              g.x = v * l, g.y = -m * n + _, g.z = v * f, u.push(g.x, g.y, g.z), s.set(l, b, f).normalize(), p.push(s.x, s.y, s.z), h.push(t, 1 - m), c.push(d++);
            }

            f.push(c);
          }

          for (let e = 0; e < r; e++) for (let t = 0; t < i; t++) {
            const n = f[t][e],
                  r = f[t + 1][e],
                  i = f[t + 1][e + 1],
                  s = f[t][e + 1];
            c.push(n, r, s), c.push(r, i, s), v += 6;
          }

          l.addGroup(m, v, 0), m += v;
        }(), !1 === s && (e > 0 && g(!0), t > 0 && g(!1)), this.setIndex(c), this.setAttribute("position", new Fi(u, 3)), this.setAttribute("normal", new Fi(p, 3)), this.setAttribute("uv", new Fi(h, 2));
      }

      static fromJSON(e) {
        return new Xc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
      }

    }

    class qc extends Xc {
      constructor(e = 1, t = 1, n = 8, r = 1, i = !1, s = 0, o = 2 * Math.PI) {
        super(0, e, t, n, r, i, s, o), this.type = "ConeGeometry", this.parameters = {
          radius: e,
          height: t,
          radialSegments: n,
          heightSegments: r,
          openEnded: i,
          thetaStart: s,
          thetaLength: o
        };
      }

      static fromJSON(e) {
        return new qc(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
      }

    }

    class Yc extends Wi {
      constructor(e = [], t = [], n = 1, r = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
          vertices: e,
          indices: t,
          radius: n,
          detail: r
        };
        const i = [],
              s = [];

        function o(e, t, n, r) {
          const i = r + 1,
                s = [];

          for (let r = 0; r <= i; r++) {
            s[r] = [];
            const o = e.clone().lerp(n, r / i),
                  a = t.clone().lerp(n, r / i),
                  l = i - r;

            for (let e = 0; e <= l; e++) s[r][e] = 0 === e && r === i ? o : o.clone().lerp(a, e / l);
          }

          for (let e = 0; e < i; e++) for (let t = 0; t < 2 * (i - e) - 1; t++) {
            const n = Math.floor(t / 2);
            t % 2 == 0 ? (a(s[e][n + 1]), a(s[e + 1][n]), a(s[e][n])) : (a(s[e][n + 1]), a(s[e + 1][n + 1]), a(s[e + 1][n]));
          }
        }

        function a(e) {
          i.push(e.x, e.y, e.z);
        }

        function l(t, n) {
          const r = 3 * t;
          n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2];
        }

        function c(e, t, n, r) {
          r < 0 && 1 === e.x && (s[t] = e.x - 1), 0 === n.x && 0 === n.z && (s[t] = r / 2 / Math.PI + .5);
        }

        function u(e) {
          return Math.atan2(e.z, -e.x);
        }

        !function (e) {
          const n = new lr(),
                r = new lr(),
                i = new lr();

          for (let s = 0; s < t.length; s += 3) l(t[s + 0], n), l(t[s + 1], r), l(t[s + 2], i), o(n, r, i, e);
        }(r), function (e) {
          const t = new lr();

          for (let n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z;
        }(n), function () {
          const e = new lr();

          for (let n = 0; n < i.length; n += 3) {
            e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2];
            const r = u(e) / 2 / Math.PI + .5,
                  o = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
            s.push(r, 1 - o);
          }

          var t;
          (function () {
            const e = new lr(),
                  t = new lr(),
                  n = new lr(),
                  r = new lr(),
                  o = new Pn(),
                  a = new Pn(),
                  l = new Pn();

            for (let p = 0, h = 0; p < i.length; p += 9, h += 6) {
              e.set(i[p + 0], i[p + 1], i[p + 2]), t.set(i[p + 3], i[p + 4], i[p + 5]), n.set(i[p + 6], i[p + 7], i[p + 8]), o.set(s[h + 0], s[h + 1]), a.set(s[h + 2], s[h + 3]), l.set(s[h + 4], s[h + 5]), r.copy(e).add(t).add(n).divideScalar(3);
              const d = u(r);
              c(o, h + 0, e, d), c(a, h + 2, t, d), c(l, h + 4, n, d);
            }
          })(), function () {
            for (let e = 0; e < s.length; e += 6) {
              const t = s[e + 0],
                    n = s[e + 2],
                    r = s[e + 4],
                    i = Math.max(t, n, r),
                    o = Math.min(t, n, r);
              i > .9 && o < .1 && (t < .2 && (s[e + 0] += 1), n < .2 && (s[e + 2] += 1), r < .2 && (s[e + 4] += 1));
            }
          }();
        }(), this.setAttribute("position", new Fi(i, 3)), this.setAttribute("normal", new Fi(i.slice(), 3)), this.setAttribute("uv", new Fi(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals();
      }

      static fromJSON(e) {
        return new Yc(e.vertices, e.indices, e.radius, e.details);
      }

    }

    class Zc extends Yc {
      constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
              r = 1 / n;
        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
          radius: e,
          detail: t
        };
      }

      static fromJSON(e) {
        return new Zc(e.radius, e.detail);
      }

    }

    const Jc = new lr(),
          $c = new lr(),
          Qc = new lr(),
          eu = new yi();

    class tu extends Wi {
      constructor(e = null, t = 1) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {
          geometry: e,
          thresholdAngle: t
        }, null !== e) {
          const n = 4,
                r = Math.pow(10, n),
                i = Math.cos(yn * t),
                s = e.getIndex(),
                o = e.getAttribute("position"),
                a = s ? s.count : o.count,
                l = [0, 0, 0],
                c = ["a", "b", "c"],
                u = new Array(3),
                p = {},
                h = [];

          for (let e = 0; e < a; e += 3) {
            s ? (l[0] = s.getX(e), l[1] = s.getX(e + 1), l[2] = s.getX(e + 2)) : (l[0] = e, l[1] = e + 1, l[2] = e + 2);
            const {
              a: t,
              b: n,
              c: a
            } = eu;
            if (t.fromBufferAttribute(o, l[0]), n.fromBufferAttribute(o, l[1]), a.fromBufferAttribute(o, l[2]), eu.getNormal(Qc), u[0] = `${Math.round(t.x * r)},${Math.round(t.y * r)},${Math.round(t.z * r)}`, u[1] = `${Math.round(n.x * r)},${Math.round(n.y * r)},${Math.round(n.z * r)}`, u[2] = `${Math.round(a.x * r)},${Math.round(a.y * r)},${Math.round(a.z * r)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0]) for (let e = 0; e < 3; e++) {
              const t = (e + 1) % 3,
                    n = u[e],
                    r = u[t],
                    s = eu[c[e]],
                    o = eu[c[t]],
                    a = `${n}_${r}`,
                    d = `${r}_${n}`;
              d in p && p[d] ? (Qc.dot(p[d].normal) <= i && (h.push(s.x, s.y, s.z), h.push(o.x, o.y, o.z)), p[d] = null) : a in p || (p[a] = {
                index0: l[e],
                index1: l[t],
                normal: Qc.clone()
              });
            }
          }

          for (const e in p) if (p[e]) {
            const {
              index0: t,
              index1: n
            } = p[e];
            Jc.fromBufferAttribute(o, t), $c.fromBufferAttribute(o, n), h.push(Jc.x, Jc.y, Jc.z), h.push($c.x, $c.y, $c.z);
          }

          this.setAttribute("position", new Fi(h, 3));
        }
      }

    }

    class nu extends Gc {
      constructor(e) {
        super(e), this.uuid = Sn(), this.type = "Shape", this.holes = [];
      }

      getPointsHoles(e) {
        const t = [];

        for (let n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);

        return t;
      }

      extractPoints(e) {
        return {
          shape: this.getPoints(e),
          holes: this.getPointsHoles(e)
        };
      }

      copy(e) {
        super.copy(e), this.holes = [];

        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(n.clone());
        }

        return this;
      }

      toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];

        for (let t = 0, n = this.holes.length; t < n; t++) {
          const n = this.holes[t];
          e.holes.push(n.toJSON());
        }

        return e;
      }

      fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];

        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(new Gc().fromJSON(n));
        }

        return this;
      }

    }

    function ru(e, t, n, r, i) {
      let s, o;
      if (i === function (e, t, n, r) {
        let i = 0;

        for (let s = t, o = n - r; s < n; s += r) i += (e[o] - e[s]) * (e[s + 1] + e[o + 1]), o = s;

        return i;
      }(e, t, n, r) > 0) for (s = t; s < n; s += r) o = Mu(s, e[s], e[s + 1], o);else for (s = n - r; s >= t; s -= r) o = Mu(s, e[s], e[s + 1], o);
      return o && vu(o, o.next) && (Tu(o), o = o.next), o;
    }

    function iu(e, t) {
      if (!e) return e;
      t || (t = e);
      let n,
          r = e;

      do {
        if (n = !1, r.steiner || !vu(r, r.next) && 0 !== gu(r.prev, r, r.next)) r = r.next;else {
          if (Tu(r), r = t = r.prev, r === r.next) break;
          n = !0;
        }
      } while (n || r !== t);

      return t;
    }

    function su(e, t, n, r, i, s, o) {
      if (!e) return;
      !o && s && function (e, t, n, r) {
        let i = e;

        do {
          null === i.z && (i.z = du(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
        } while (i !== e);

        i.prevZ.nextZ = null, i.prevZ = null, function (e) {
          let t,
              n,
              r,
              i,
              s,
              o,
              a,
              l,
              c = 1;

          do {
            for (n = e, e = null, s = null, o = 0; n;) {
              for (o++, r = n, a = 0, t = 0; t < c && (a++, r = r.nextZ, r); t++);

              for (l = c; a > 0 || l > 0 && r;) 0 !== a && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : e = i, i.prevZ = s, s = i;

              n = r;
            }

            s.nextZ = null, c *= 2;
          } while (o > 1);
        }(i);
      }(e, r, i, s);
      let a,
          l,
          c = e;

      for (; e.prev !== e.next;) if (a = e.prev, l = e.next, s ? au(e, r, i, s) : ou(e)) t.push(a.i / n), t.push(e.i / n), t.push(l.i / n), Tu(e), e = l.next, c = l.next;else if ((e = l) === c) {
        o ? 1 === o ? su(e = lu(iu(e), t, n), t, n, r, i, s, 2) : 2 === o && cu(e, t, n, r, i, s) : su(iu(e), t, n, r, i, s, 1);
        break;
      }
    }

    function ou(e) {
      const t = e.prev,
            n = e,
            r = e.next;
      if (gu(t, n, r) >= 0) return !1;
      let i = e.next.next;

      for (; i !== e.prev;) {
        if (_u(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && gu(i.prev, i, i.next) >= 0) return !1;
        i = i.next;
      }

      return !0;
    }

    function au(e, t, n, r) {
      const i = e.prev,
            s = e,
            o = e.next;
      if (gu(i, s, o) >= 0) return !1;
      const a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x,
            l = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y,
            c = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x,
            u = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y,
            p = du(a, l, t, n, r),
            h = du(c, u, t, n, r);
      let d = e.prevZ,
          f = e.nextZ;

      for (; d && d.z >= p && f && f.z <= h;) {
        if (d !== e.prev && d !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && gu(d.prev, d, d.next) >= 0) return !1;
        if (d = d.prevZ, f !== e.prev && f !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && gu(f.prev, f, f.next) >= 0) return !1;
        f = f.nextZ;
      }

      for (; d && d.z >= p;) {
        if (d !== e.prev && d !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && gu(d.prev, d, d.next) >= 0) return !1;
        d = d.prevZ;
      }

      for (; f && f.z <= h;) {
        if (f !== e.prev && f !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && gu(f.prev, f, f.next) >= 0) return !1;
        f = f.nextZ;
      }

      return !0;
    }

    function lu(e, t, n) {
      let r = e;

      do {
        const i = r.prev,
              s = r.next.next;
        !vu(i, s) && bu(i, r, r.next, s) && wu(i, s) && wu(s, i) && (t.push(i.i / n), t.push(r.i / n), t.push(s.i / n), Tu(r), Tu(r.next), r = e = s), r = r.next;
      } while (r !== e);

      return iu(r);
    }

    function cu(e, t, n, r, i, s) {
      let o = e;

      do {
        let e = o.next.next;

        for (; e !== o.prev;) {
          if (o.i !== e.i && mu(o, e)) {
            let a = Su(o, e);
            return o = iu(o, o.next), a = iu(a, a.next), su(o, t, n, r, i, s), void su(a, t, n, r, i, s);
          }

          e = e.next;
        }

        o = o.next;
      } while (o !== e);
    }

    function uu(e, t) {
      return e.x - t.x;
    }

    function pu(e, t) {
      if (t = function (e, t) {
        let n = t;
        const r = e.x,
              i = e.y;
        let s,
            o = -1 / 0;

        do {
          if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
            const e = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);

            if (e <= r && e > o) {
              if (o = e, e === r) {
                if (i === n.y) return n;
                if (i === n.next.y) return n.next;
              }

              s = n.x < n.next.x ? n : n.next;
            }
          }

          n = n.next;
        } while (n !== t);

        if (!s) return null;
        if (r === o) return s;
        const a = s,
              l = s.x,
              c = s.y;
        let u,
            p = 1 / 0;
        n = s;

        do {
          r >= n.x && n.x >= l && r !== n.x && _u(i < c ? r : o, i, l, c, i < c ? o : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x), wu(n, e) && (u < p || u === p && (n.x > s.x || n.x === s.x && hu(s, n))) && (s = n, p = u)), n = n.next;
        } while (n !== a);

        return s;
      }(e, t), t) {
        const n = Su(t, e);
        iu(t, t.next), iu(n, n.next);
      }
    }

    function hu(e, t) {
      return gu(e.prev, e, t.prev) < 0 && gu(t.next, e, e.next) < 0;
    }

    function du(e, t, n, r, i) {
      return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
    }

    function fu(e) {
      let t = e,
          n = e;

      do {
        (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
      } while (t !== e);

      return n;
    }

    function _u(e, t, n, r, i, s, o, a) {
      return (i - o) * (t - a) - (e - o) * (s - a) >= 0 && (e - o) * (r - a) - (n - o) * (t - a) >= 0 && (n - o) * (s - a) - (i - o) * (r - a) >= 0;
    }

    function mu(e, t) {
      return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) {
        let n = e;

        do {
          if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && bu(n, n.next, e, t)) return !0;
          n = n.next;
        } while (n !== e);

        return !1;
      }(e, t) && (wu(e, t) && wu(t, e) && function (e, t) {
        let n = e,
            r = !1;
        const i = (e.x + t.x) / 2,
              s = (e.y + t.y) / 2;

        do {
          n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next;
        } while (n !== e);

        return r;
      }(e, t) && (gu(e.prev, e, t.prev) || gu(e, t.prev, t)) || vu(e, t) && gu(e.prev, e, e.next) > 0 && gu(t.prev, t, t.next) > 0);
    }

    function gu(e, t, n) {
      return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
    }

    function vu(e, t) {
      return e.x === t.x && e.y === t.y;
    }

    function bu(e, t, n, r) {
      const i = yu(gu(e, t, n)),
            s = yu(gu(e, t, r)),
            o = yu(gu(n, r, e)),
            a = yu(gu(n, r, t));
      return i !== s && o !== a || !(0 !== i || !xu(e, n, t)) || !(0 !== s || !xu(e, r, t)) || !(0 !== o || !xu(n, e, r)) || !(0 !== a || !xu(n, t, r));
    }

    function xu(e, t, n) {
      return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);
    }

    function yu(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }

    function wu(e, t) {
      return gu(e.prev, e, e.next) < 0 ? gu(e, t, e.next) >= 0 && gu(e, e.prev, t) >= 0 : gu(e, t, e.prev) < 0 || gu(e, e.next, t) < 0;
    }

    function Su(e, t) {
      const n = new Eu(e.i, e.x, e.y),
            r = new Eu(t.i, t.x, t.y),
            i = e.next,
            s = t.prev;
      return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r;
    }

    function Mu(e, t, n, r) {
      const i = new Eu(e, t, n);
      return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i;
    }

    function Tu(e) {
      e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
    }

    function Eu(e, t, n) {
      this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
    }

    class Au {
      static area(e) {
        const t = e.length;
        let n = 0;

        for (let r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;

        return .5 * n;
      }

      static isClockWise(e) {
        return Au.area(e) < 0;
      }

      static triangulateShape(e, t) {
        const n = [],
              r = [],
              i = [];
        Cu(e), Ru(n, e);
        let s = e.length;
        t.forEach(Cu);

        for (let e = 0; e < t.length; e++) r.push(s), s += t[e].length, Ru(n, t[e]);

        const o = function (e, t, n = 2) {
          const r = t && t.length,
                i = r ? t[0] * n : e.length;
          let s = ru(e, 0, i, n, !0);
          const o = [];
          if (!s || s.next === s.prev) return o;
          let a, l, c, u, p, h, d;

          if (r && (s = function (e, t, n, r) {
            const i = [];
            let s, o, a, l, c;

            for (s = 0, o = t.length; s < o; s++) a = t[s] * r, l = s < o - 1 ? t[s + 1] * r : e.length, c = ru(e, a, l, r, !1), c === c.next && (c.steiner = !0), i.push(fu(c));

            for (i.sort(uu), s = 0; s < i.length; s++) pu(i[s], n), n = iu(n, n.next);

            return n;
          }(e, t, s, n)), e.length > 80 * n) {
            a = c = e[0], l = u = e[1];

            for (let t = n; t < i; t += n) p = e[t], h = e[t + 1], p < a && (a = p), h < l && (l = h), p > c && (c = p), h > u && (u = h);

            d = Math.max(c - a, u - l), d = 0 !== d ? 1 / d : 0;
          }

          return su(s, o, n, a, l, d), o;
        }(n, r);

        for (let e = 0; e < o.length; e += 3) i.push(o.slice(e, e + 3));

        return i;
      }

    }

    function Cu(e) {
      const t = e.length;
      t > 2 && e[t - 1].equals(e[0]) && e.pop();
    }

    function Ru(e, t) {
      for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
    }

    class ku extends Wi {
      constructor(e = new nu([new Pn(.5, .5), new Pn(-.5, .5), new Pn(-.5, -.5), new Pn(.5, -.5)]), t = {}) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
          shapes: e,
          options: t
        }, e = Array.isArray(e) ? e : [e];
        const n = this,
              r = [],
              i = [];

        for (let t = 0, n = e.length; t < n; t++) s(e[t]);

        function s(e) {
          const s = [],
                o = void 0 !== t.curveSegments ? t.curveSegments : 12,
                a = void 0 !== t.steps ? t.steps : 1,
                l = void 0 !== t.depth ? t.depth : 1;
          let c = void 0 === t.bevelEnabled || t.bevelEnabled,
              u = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
              p = void 0 !== t.bevelSize ? t.bevelSize : u - .1,
              h = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
              d = void 0 !== t.bevelSegments ? t.bevelSegments : 3;

          const f = t.extrudePath,
                _ = void 0 !== t.UVGenerator ? t.UVGenerator : Pu;

          let m,
              g,
              v,
              b,
              x,
              y = !1;
          f && (m = f.getSpacedPoints(a), y = !0, c = !1, g = f.computeFrenetFrames(a, !1), v = new lr(), b = new lr(), x = new lr()), c || (d = 0, u = 0, p = 0, h = 0);
          const w = e.extractPoints(o);
          let S = w.shape;
          const M = w.holes;

          if (!Au.isClockWise(S)) {
            S = S.reverse();

            for (let e = 0, t = M.length; e < t; e++) {
              const t = M[e];
              Au.isClockWise(t) && (M[e] = t.reverse());
            }
          }

          const T = Au.triangulateShape(S, M),
                E = S;

          for (let e = 0, t = M.length; e < t; e++) {
            const t = M[e];
            S = S.concat(t);
          }

          function A(e, t, n) {
            return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e);
          }

          const C = S.length,
                R = T.length;

          function k(e, t, n) {
            let r, i, s;
            const o = e.x - t.x,
                  a = e.y - t.y,
                  l = n.x - e.x,
                  c = n.y - e.y,
                  u = o * o + a * a,
                  p = o * c - a * l;

            if (Math.abs(p) > Number.EPSILON) {
              const p = Math.sqrt(u),
                    h = Math.sqrt(l * l + c * c),
                    d = t.x - a / p,
                    f = t.y + o / p,
                    _ = ((n.x - c / h - d) * c - (n.y + l / h - f) * l) / (o * c - a * l);

              r = d + o * _ - e.x, i = f + a * _ - e.y;
              const m = r * r + i * i;
              if (m <= 2) return new Pn(r, i);
              s = Math.sqrt(m / 2);
            } else {
              let e = !1;
              o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(a) === Math.sign(c) && (e = !0), e ? (r = -a, i = o, s = Math.sqrt(u)) : (r = o, i = a, s = Math.sqrt(u / 2));
            }

            return new Pn(r / s, i / s);
          }

          const P = [];

          for (let e = 0, t = E.length, n = t - 1, r = e + 1; e < t; e++, n++, r++) n === t && (n = 0), r === t && (r = 0), P[e] = k(E[e], E[n], E[r]);

          const D = [];
          let O,
              L = P.concat();

          for (let e = 0, t = M.length; e < t; e++) {
            const t = M[e];
            O = [];

            for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), O[e] = k(t[e], t[r], t[i]);

            D.push(O), L = L.concat(O);
          }

          for (let e = 0; e < d; e++) {
            const t = e / d,
                  n = u * Math.cos(t * Math.PI / 2),
                  r = p * Math.sin(t * Math.PI / 2) + h;

            for (let e = 0, t = E.length; e < t; e++) {
              const t = A(E[e], P[e], r);
              N(t.x, t.y, -n);
            }

            for (let e = 0, t = M.length; e < t; e++) {
              const t = M[e];
              O = D[e];

              for (let e = 0, i = t.length; e < i; e++) {
                const i = A(t[e], O[e], r);
                N(i.x, i.y, -n);
              }
            }
          }

          const I = p + h;

          for (let e = 0; e < C; e++) {
            const t = c ? A(S[e], L[e], I) : S[e];
            y ? (b.copy(g.normals[0]).multiplyScalar(t.x), v.copy(g.binormals[0]).multiplyScalar(t.y), x.copy(m[0]).add(b).add(v), N(x.x, x.y, x.z)) : N(t.x, t.y, 0);
          }

          for (let e = 1; e <= a; e++) for (let t = 0; t < C; t++) {
            const n = c ? A(S[t], L[t], I) : S[t];
            y ? (b.copy(g.normals[e]).multiplyScalar(n.x), v.copy(g.binormals[e]).multiplyScalar(n.y), x.copy(m[e]).add(b).add(v), N(x.x, x.y, x.z)) : N(n.x, n.y, l / a * e);
          }

          for (let e = d - 1; e >= 0; e--) {
            const t = e / d,
                  n = u * Math.cos(t * Math.PI / 2),
                  r = p * Math.sin(t * Math.PI / 2) + h;

            for (let e = 0, t = E.length; e < t; e++) {
              const t = A(E[e], P[e], r);
              N(t.x, t.y, l + n);
            }

            for (let e = 0, t = M.length; e < t; e++) {
              const t = M[e];
              O = D[e];

              for (let e = 0, i = t.length; e < i; e++) {
                const i = A(t[e], O[e], r);
                y ? N(i.x, i.y + m[a - 1].y, m[a - 1].x + n) : N(i.x, i.y, l + n);
              }
            }
          }

          function F(e, t) {
            let n = e.length;

            for (; --n >= 0;) {
              const r = n;
              let i = n - 1;
              i < 0 && (i = e.length - 1);

              for (let e = 0, n = a + 2 * d; e < n; e++) {
                const n = C * e,
                      s = C * (e + 1);
                B(t + r + n, t + i + n, t + i + s, t + r + s);
              }
            }
          }

          function N(e, t, n) {
            s.push(e), s.push(t), s.push(n);
          }

          function U(e, t, i) {
            j(e), j(t), j(i);

            const s = r.length / 3,
                  o = _.generateTopUV(n, r, s - 3, s - 2, s - 1);

            z(o[0]), z(o[1]), z(o[2]);
          }

          function B(e, t, i, s) {
            j(e), j(t), j(s), j(t), j(i), j(s);

            const o = r.length / 3,
                  a = _.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);

            z(a[0]), z(a[1]), z(a[3]), z(a[1]), z(a[2]), z(a[3]);
          }

          function j(e) {
            r.push(s[3 * e + 0]), r.push(s[3 * e + 1]), r.push(s[3 * e + 2]);
          }

          function z(e) {
            i.push(e.x), i.push(e.y);
          }

          !function () {
            const e = r.length / 3;

            if (c) {
              let e = 0,
                  t = C * e;

              for (let e = 0; e < R; e++) {
                const n = T[e];
                U(n[2] + t, n[1] + t, n[0] + t);
              }

              e = a + 2 * d, t = C * e;

              for (let e = 0; e < R; e++) {
                const n = T[e];
                U(n[0] + t, n[1] + t, n[2] + t);
              }
            } else {
              for (let e = 0; e < R; e++) {
                const t = T[e];
                U(t[2], t[1], t[0]);
              }

              for (let e = 0; e < R; e++) {
                const t = T[e];
                U(t[0] + C * a, t[1] + C * a, t[2] + C * a);
              }
            }

            n.addGroup(e, r.length / 3 - e, 0);
          }(), function () {
            const e = r.length / 3;
            let t = 0;
            F(E, t), t += E.length;

            for (let e = 0, n = M.length; e < n; e++) {
              const n = M[e];
              F(n, t), t += n.length;
            }

            n.addGroup(e, r.length / 3 - e, 1);
          }();
        }

        this.setAttribute("position", new Fi(r, 3)), this.setAttribute("uv", new Fi(i, 2)), this.computeVertexNormals();
      }

      toJSON() {
        const e = super.toJSON();
        return function (e, t, n) {
          if (n.shapes = [], Array.isArray(e)) for (let t = 0, r = e.length; t < r; t++) {
            const r = e[t];
            n.shapes.push(r.uuid);
          } else n.shapes.push(e.uuid);
          return n.options = Object.assign({}, t), void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n;
        }(this.parameters.shapes, this.parameters.options, e);
      }

      static fromJSON(e, t) {
        const n = [];

        for (let r = 0, i = e.shapes.length; r < i; r++) {
          const i = t[e.shapes[r]];
          n.push(i);
        }

        const r = e.options.extrudePath;
        return void 0 !== r && (e.options.extrudePath = new zc[r.type]().fromJSON(r)), new ku(n, e.options);
      }

    }

    const Pu = {
      generateTopUV: function (e, t, n, r, i) {
        const s = t[3 * n],
              o = t[3 * n + 1],
              a = t[3 * r],
              l = t[3 * r + 1],
              c = t[3 * i],
              u = t[3 * i + 1];
        return [new Pn(s, o), new Pn(a, l), new Pn(c, u)];
      },
      generateSideWallUV: function (e, t, n, r, i, s) {
        const o = t[3 * n],
              a = t[3 * n + 1],
              l = t[3 * n + 2],
              c = t[3 * r],
              u = t[3 * r + 1],
              p = t[3 * r + 2],
              h = t[3 * i],
              d = t[3 * i + 1],
              f = t[3 * i + 2],
              _ = t[3 * s],
              m = t[3 * s + 1],
              g = t[3 * s + 2];
        return Math.abs(a - u) < Math.abs(o - c) ? [new Pn(o, 1 - l), new Pn(c, 1 - p), new Pn(h, 1 - f), new Pn(_, 1 - g)] : [new Pn(a, 1 - l), new Pn(u, 1 - p), new Pn(d, 1 - f), new Pn(m, 1 - g)];
      }
    };

    class Du extends Yc {
      constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2;
        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
          radius: e,
          detail: t
        };
      }

      static fromJSON(e) {
        return new Du(e.radius, e.detail);
      }

    }

    class Ou extends Yc {
      constructor(e = 1, t = 0) {
        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
          radius: e,
          detail: t
        };
      }

      static fromJSON(e) {
        return new Ou(e.radius, e.detail);
      }

    }

    class Lu extends Wi {
      constructor(e = .5, t = 1, n = 8, r = 1, i = 0, s = 2 * Math.PI) {
        super(), this.type = "RingGeometry", this.parameters = {
          innerRadius: e,
          outerRadius: t,
          thetaSegments: n,
          phiSegments: r,
          thetaStart: i,
          thetaLength: s
        }, n = Math.max(3, n);
        const o = [],
              a = [],
              l = [],
              c = [];
        let u = e;
        const p = (t - e) / (r = Math.max(1, r)),
              h = new lr(),
              d = new Pn();

        for (let e = 0; e <= r; e++) {
          for (let e = 0; e <= n; e++) {
            const r = i + e / n * s;
            h.x = u * Math.cos(r), h.y = u * Math.sin(r), a.push(h.x, h.y, h.z), l.push(0, 0, 1), d.x = (h.x / t + 1) / 2, d.y = (h.y / t + 1) / 2, c.push(d.x, d.y);
          }

          u += p;
        }

        for (let e = 0; e < r; e++) {
          const t = e * (n + 1);

          for (let e = 0; e < n; e++) {
            const r = e + t,
                  i = r,
                  s = r + n + 1,
                  a = r + n + 2,
                  l = r + 1;
            o.push(i, s, l), o.push(s, a, l);
          }
        }

        this.setIndex(o), this.setAttribute("position", new Fi(a, 3)), this.setAttribute("normal", new Fi(l, 3)), this.setAttribute("uv", new Fi(c, 2));
      }

      static fromJSON(e) {
        return new Lu(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
      }

    }

    class Iu extends Wi {
      constructor(e = new nu([new Pn(0, .5), new Pn(-.5, -.5), new Pn(.5, -.5)]), t = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
          shapes: e,
          curveSegments: t
        };
        const n = [],
              r = [],
              i = [],
              s = [];
        let o = 0,
            a = 0;
        if (!1 === Array.isArray(e)) l(e);else for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(o, a, t), o += a, a = 0;

        function l(e) {
          const o = r.length / 3,
                l = e.extractPoints(t);
          let c = l.shape;
          const u = l.holes;
          !1 === Au.isClockWise(c) && (c = c.reverse());

          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e];
            !0 === Au.isClockWise(t) && (u[e] = t.reverse());
          }

          const p = Au.triangulateShape(c, u);

          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e];
            c = c.concat(t);
          }

          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            r.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y);
          }

          for (let e = 0, t = p.length; e < t; e++) {
            const t = p[e],
                  r = t[0] + o,
                  i = t[1] + o,
                  s = t[2] + o;
            n.push(r, i, s), a += 3;
          }
        }

        this.setIndex(n), this.setAttribute("position", new Fi(r, 3)), this.setAttribute("normal", new Fi(i, 3)), this.setAttribute("uv", new Fi(s, 2));
      }

      toJSON() {
        const e = super.toJSON();
        return function (e, t) {
          if (t.shapes = [], Array.isArray(e)) for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            t.shapes.push(r.uuid);
          } else t.shapes.push(e.uuid);
          return t;
        }(this.parameters.shapes, e);
      }

      static fromJSON(e, t) {
        const n = [];

        for (let r = 0, i = e.shapes.length; r < i; r++) {
          const i = t[e.shapes[r]];
          n.push(i);
        }

        return new Iu(n, e.curveSegments);
      }

    }

    class Fu extends Wi {
      constructor(e = 1, t = 32, n = 16, r = 0, i = 2 * Math.PI, s = 0, o = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
          radius: e,
          widthSegments: t,
          heightSegments: n,
          phiStart: r,
          phiLength: i,
          thetaStart: s,
          thetaLength: o
        }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
        const a = Math.min(s + o, Math.PI);
        let l = 0;
        const c = [],
              u = new lr(),
              p = new lr(),
              h = [],
              d = [],
              f = [],
              _ = [];

        for (let h = 0; h <= n; h++) {
          const m = [],
                g = h / n;
          let v = 0;
          0 == h && 0 == s ? v = .5 / t : h == n && a == Math.PI && (v = -.5 / t);

          for (let n = 0; n <= t; n++) {
            const a = n / t;
            u.x = -e * Math.cos(r + a * i) * Math.sin(s + g * o), u.y = e * Math.cos(s + g * o), u.z = e * Math.sin(r + a * i) * Math.sin(s + g * o), d.push(u.x, u.y, u.z), p.copy(u).normalize(), f.push(p.x, p.y, p.z), _.push(a + v, 1 - g), m.push(l++);
          }

          c.push(m);
        }

        for (let e = 0; e < n; e++) for (let r = 0; r < t; r++) {
          const t = c[e][r + 1],
                i = c[e][r],
                o = c[e + 1][r],
                l = c[e + 1][r + 1];
          (0 !== e || s > 0) && h.push(t, i, l), (e !== n - 1 || a < Math.PI) && h.push(i, o, l);
        }

        this.setIndex(h), this.setAttribute("position", new Fi(d, 3)), this.setAttribute("normal", new Fi(f, 3)), this.setAttribute("uv", new Fi(_, 2));
      }

      static fromJSON(e) {
        return new Fu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
      }

    }

    class Nu extends Yc {
      constructor(e = 1, t = 0) {
        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
          radius: e,
          detail: t
        };
      }

      static fromJSON(e) {
        return new Nu(e.radius, e.detail);
      }

    }

    class Uu extends Wi {
      constructor(e = 1, t = .4, n = 8, r = 6, i = 2 * Math.PI) {
        super(), this.type = "TorusGeometry", this.parameters = {
          radius: e,
          tube: t,
          radialSegments: n,
          tubularSegments: r,
          arc: i
        }, n = Math.floor(n), r = Math.floor(r);
        const s = [],
              o = [],
              a = [],
              l = [],
              c = new lr(),
              u = new lr(),
              p = new lr();

        for (let s = 0; s <= n; s++) for (let h = 0; h <= r; h++) {
          const d = h / r * i,
                f = s / n * Math.PI * 2;
          u.x = (e + t * Math.cos(f)) * Math.cos(d), u.y = (e + t * Math.cos(f)) * Math.sin(d), u.z = t * Math.sin(f), o.push(u.x, u.y, u.z), c.x = e * Math.cos(d), c.y = e * Math.sin(d), p.subVectors(u, c).normalize(), a.push(p.x, p.y, p.z), l.push(h / r), l.push(s / n);
        }

        for (let e = 1; e <= n; e++) for (let t = 1; t <= r; t++) {
          const n = (r + 1) * e + t - 1,
                i = (r + 1) * (e - 1) + t - 1,
                o = (r + 1) * (e - 1) + t,
                a = (r + 1) * e + t;
          s.push(n, i, a), s.push(i, o, a);
        }

        this.setIndex(s), this.setAttribute("position", new Fi(o, 3)), this.setAttribute("normal", new Fi(a, 3)), this.setAttribute("uv", new Fi(l, 2));
      }

      static fromJSON(e) {
        return new Uu(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
      }

    }

    class Bu extends Wi {
      constructor(e = 1, t = .4, n = 64, r = 8, i = 2, s = 3) {
        super(), this.type = "TorusKnotGeometry", this.parameters = {
          radius: e,
          tube: t,
          tubularSegments: n,
          radialSegments: r,
          p: i,
          q: s
        }, n = Math.floor(n), r = Math.floor(r);

        const o = [],
              a = [],
              l = [],
              c = [],
              u = new lr(),
              p = new lr(),
              h = new lr(),
              d = new lr(),
              f = new lr(),
              _ = new lr(),
              m = new lr();

        for (let o = 0; o <= n; ++o) {
          const v = o / n * i * Math.PI * 2;
          g(v, i, s, e, h), g(v + .01, i, s, e, d), _.subVectors(d, h), m.addVectors(d, h), f.crossVectors(_, m), m.crossVectors(f, _), f.normalize(), m.normalize();

          for (let e = 0; e <= r; ++e) {
            const i = e / r * Math.PI * 2,
                  s = -t * Math.cos(i),
                  d = t * Math.sin(i);
            u.x = h.x + (s * m.x + d * f.x), u.y = h.y + (s * m.y + d * f.y), u.z = h.z + (s * m.z + d * f.z), a.push(u.x, u.y, u.z), p.subVectors(u, h).normalize(), l.push(p.x, p.y, p.z), c.push(o / n), c.push(e / r);
          }
        }

        for (let e = 1; e <= n; e++) for (let t = 1; t <= r; t++) {
          const n = (r + 1) * (e - 1) + (t - 1),
                i = (r + 1) * e + (t - 1),
                s = (r + 1) * e + t,
                a = (r + 1) * (e - 1) + t;
          o.push(n, i, a), o.push(i, s, a);
        }

        function g(e, t, n, r, i) {
          const s = Math.cos(e),
                o = Math.sin(e),
                a = n / t * e,
                l = Math.cos(a);
          i.x = r * (2 + l) * .5 * s, i.y = r * (2 + l) * o * .5, i.z = r * Math.sin(a) * .5;
        }

        this.setIndex(o), this.setAttribute("position", new Fi(a, 3)), this.setAttribute("normal", new Fi(l, 3)), this.setAttribute("uv", new Fi(c, 2));
      }

      static fromJSON(e) {
        return new Bu(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
      }

    }

    class ju extends Wi {
      constructor(e = new Bc(new lr(-1, -1, 0), new lr(-1, 1, 0), new lr(1, 1, 0)), t = 64, n = 1, r = 8, i = !1) {
        super(), this.type = "TubeGeometry", this.parameters = {
          path: e,
          tubularSegments: t,
          radius: n,
          radialSegments: r,
          closed: i
        };
        const s = e.computeFrenetFrames(t, i);
        this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
        const o = new lr(),
              a = new lr(),
              l = new Pn();
        let c = new lr();
        const u = [],
              p = [],
              h = [],
              d = [];

        function f(i) {
          c = e.getPointAt(i / t, c);
          const l = s.normals[i],
                h = s.binormals[i];

          for (let e = 0; e <= r; e++) {
            const t = e / r * Math.PI * 2,
                  i = Math.sin(t),
                  s = -Math.cos(t);
            a.x = s * l.x + i * h.x, a.y = s * l.y + i * h.y, a.z = s * l.z + i * h.z, a.normalize(), p.push(a.x, a.y, a.z), o.x = c.x + n * a.x, o.y = c.y + n * a.y, o.z = c.z + n * a.z, u.push(o.x, o.y, o.z);
          }
        }

        !function () {
          for (let e = 0; e < t; e++) f(e);

          f(!1 === i ? t : 0), function () {
            for (let e = 0; e <= t; e++) for (let n = 0; n <= r; n++) l.x = e / t, l.y = n / r, h.push(l.x, l.y);
          }(), function () {
            for (let e = 1; e <= t; e++) for (let t = 1; t <= r; t++) {
              const n = (r + 1) * (e - 1) + (t - 1),
                    i = (r + 1) * e + (t - 1),
                    s = (r + 1) * e + t,
                    o = (r + 1) * (e - 1) + t;
              d.push(n, i, o), d.push(i, s, o);
            }
          }();
        }(), this.setIndex(d), this.setAttribute("position", new Fi(u, 3)), this.setAttribute("normal", new Fi(p, 3)), this.setAttribute("uv", new Fi(h, 2));
      }

      toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(), e;
      }

      static fromJSON(e) {
        return new ju(new zc[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
      }

    }

    class zu extends Wi {
      constructor(e = null) {
        if (super(), this.type = "WireframeGeometry", this.parameters = {
          geometry: e
        }, null !== e) {
          const t = [],
                n = new Set(),
                r = new lr(),
                i = new lr();

          if (null !== e.index) {
            const s = e.attributes.position,
                  o = e.index;
            let a = e.groups;
            0 === a.length && (a = [{
              start: 0,
              count: o.count,
              materialIndex: 0
            }]);

            for (let e = 0, l = a.length; e < l; ++e) {
              const l = a[e],
                    c = l.start;

              for (let e = c, a = c + l.count; e < a; e += 3) for (let a = 0; a < 3; a++) {
                const l = o.getX(e + a),
                      c = o.getX(e + (a + 1) % 3);
                r.fromBufferAttribute(s, l), i.fromBufferAttribute(s, c), !0 === Vu(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z));
              }
            }
          } else {
            const s = e.attributes.position;

            for (let e = 0, o = s.count / 3; e < o; e++) for (let o = 0; o < 3; o++) {
              const a = 3 * e + o,
                    l = 3 * e + (o + 1) % 3;
              r.fromBufferAttribute(s, a), i.fromBufferAttribute(s, l), !0 === Vu(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z));
            }
          }

          this.setAttribute("position", new Fi(t, 3));
        }
      }

    }

    function Vu(e, t, n) {
      const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
            i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
      return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0);
    }

    var Gu = Object.freeze({
      __proto__: null,
      BoxGeometry: ps,
      BoxBufferGeometry: ps,
      CapsuleGeometry: Wc,
      CapsuleBufferGeometry: Wc,
      CircleGeometry: Kc,
      CircleBufferGeometry: Kc,
      ConeGeometry: qc,
      ConeBufferGeometry: qc,
      CylinderGeometry: Xc,
      CylinderBufferGeometry: Xc,
      DodecahedronGeometry: Zc,
      DodecahedronBufferGeometry: Zc,
      EdgesGeometry: tu,
      ExtrudeGeometry: ku,
      ExtrudeBufferGeometry: ku,
      IcosahedronGeometry: Du,
      IcosahedronBufferGeometry: Du,
      LatheGeometry: Hc,
      LatheBufferGeometry: Hc,
      OctahedronGeometry: Ou,
      OctahedronBufferGeometry: Ou,
      PlaneGeometry: Ps,
      PlaneBufferGeometry: Ps,
      PolyhedronGeometry: Yc,
      PolyhedronBufferGeometry: Yc,
      RingGeometry: Lu,
      RingBufferGeometry: Lu,
      ShapeGeometry: Iu,
      ShapeBufferGeometry: Iu,
      SphereGeometry: Fu,
      SphereBufferGeometry: Fu,
      TetrahedronGeometry: Nu,
      TetrahedronBufferGeometry: Nu,
      TorusGeometry: Uu,
      TorusBufferGeometry: Uu,
      TorusKnotGeometry: Bu,
      TorusKnotBufferGeometry: Bu,
      TubeGeometry: ju,
      TubeBufferGeometry: ju,
      WireframeGeometry: zu
    });

    class Hu extends Si {
      constructor(e) {
        super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Xn(0), this.transparent = !0, this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
      }

    }

    class Wu extends _s {
      constructor(e) {
        super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
      }

    }

    class Ku extends Si {
      constructor(e) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {
          STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Xn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.defines = {
          STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
      }

    }

    class Xu extends Ku {
      constructor(e) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Pn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
          get: function () {
            return Mn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          },
          set: function (e) {
            this.ior = (1 + .4 * e) / (1 - .4 * e);
          }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Xn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Xn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Xn(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
      }

      get sheen() {
        return this._sheen;
      }

      set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
      }

      get clearcoat() {
        return this._clearcoat;
      }

      set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
      }

      get iridescence() {
        return this._iridescence;
      }

      set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
      }

      get transmission() {
        return this._transmission;
      }

      set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
      }

      copy(e) {
        return super.copy(e), this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
      }

    }

    class qu extends Si {
      constructor(e) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Xn(16777215), this.specular = new Xn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Y, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
      }

    }

    class Yu extends Si {
      constructor(e) {
        super(), this.isMeshToonMaterial = !0, this.defines = {
          TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new Xn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
      }

    }

    class Zu extends Si {
      constructor(e) {
        super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
      }

    }

    class Ju extends Si {
      constructor(e) {
        super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Xn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Y, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
      }

    }

    class $u extends Si {
      constructor(e) {
        super(), this.isMeshMatcapMaterial = !0, this.defines = {
          MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Xn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.defines = {
          MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
      }

    }

    class Qu extends ec {
      constructor(e) {
        super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
      }

      copy(e) {
        return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
      }

    }

    function ep(e, t, n) {
      return np(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n);
    }

    function tp(e, t, n) {
      return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e);
    }

    function np(e) {
      return ArrayBuffer.isView(e) && !(e instanceof DataView);
    }

    function rp(e) {
      const t = e.length,
            n = new Array(t);

      for (let e = 0; e !== t; ++e) n[e] = e;

      return n.sort(function (t, n) {
        return e[t] - e[n];
      }), n;
    }

    function ip(e, t, n) {
      const r = e.length,
            i = new e.constructor(r);

      for (let s = 0, o = 0; o !== r; ++s) {
        const r = n[s] * t;

        for (let n = 0; n !== t; ++n) i[o++] = e[r + n];
      }

      return i;
    }

    function sp(e, t, n, r) {
      let i = 1,
          s = e[0];

      for (; void 0 !== s && void 0 === s[r];) s = e[i++];

      if (void 0 === s) return;
      let o = s[r];
      if (void 0 !== o) if (Array.isArray(o)) do {
        o = s[r], void 0 !== o && (t.push(s.time), n.push.apply(n, o)), s = e[i++];
      } while (void 0 !== s);else if (void 0 !== o.toArray) do {
        o = s[r], void 0 !== o && (t.push(s.time), o.toArray(n, n.length)), s = e[i++];
      } while (void 0 !== s);else do {
        o = s[r], void 0 !== o && (t.push(s.time), n.push(o)), s = e[i++];
      } while (void 0 !== s);
    }

    var op = Object.freeze({
      __proto__: null,
      arraySlice: ep,
      convertArray: tp,
      isTypedArray: np,
      getKeyframeOrder: rp,
      sortedArray: ip,
      flattenJSON: sp,
      subclip: function (e, t, n, r, i = 30) {
        const s = e.clone();
        s.name = t;
        const o = [];

        for (let e = 0; e < s.tracks.length; ++e) {
          const t = s.tracks[e],
                a = t.getValueSize(),
                l = [],
                c = [];

          for (let e = 0; e < t.times.length; ++e) {
            const s = t.times[e] * i;

            if (!(s < n || s >= r)) {
              l.push(t.times[e]);

              for (let n = 0; n < a; ++n) c.push(t.values[e * a + n]);
            }
          }

          0 !== l.length && (t.times = tp(l, t.times.constructor), t.values = tp(c, t.values.constructor), o.push(t));
        }

        s.tracks = o;
        let a = 1 / 0;

        for (let e = 0; e < s.tracks.length; ++e) a > s.tracks[e].times[0] && (a = s.tracks[e].times[0]);

        for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * a);

        return s.resetDuration(), s;
      },
      makeClipAdditive: function (e, t = 0, n = e, r = 30) {
        r <= 0 && (r = 30);
        const i = n.tracks.length,
              s = t / r;

        for (let t = 0; t < i; ++t) {
          const r = n.tracks[t],
                i = r.ValueTypeName;
          if ("bool" === i || "string" === i) continue;
          const o = e.tracks.find(function (e) {
            return e.name === r.name && e.ValueTypeName === i;
          });
          if (void 0 === o) continue;
          let a = 0;
          const l = r.getValueSize();
          r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
          let c = 0;
          const u = o.getValueSize();
          o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
          const p = r.times.length - 1;
          let h;

          if (s <= r.times[0]) {
            const e = a,
                  t = l - a;
            h = ep(r.values, e, t);
          } else if (s >= r.times[p]) {
            const e = p * l + a,
                  t = e + l - a;
            h = ep(r.values, e, t);
          } else {
            const e = r.createInterpolant(),
                  t = a,
                  n = l - a;
            e.evaluate(s), h = ep(e.resultBuffer, t, n);
          }

          "quaternion" === i && new ar().fromArray(h).normalize().conjugate().toArray(h);
          const d = o.times.length;

          for (let e = 0; e < d; ++e) {
            const t = e * u + c;
            if ("quaternion" === i) ar.multiplyQuaternionsFlat(o.values, t, h, 0, o.values, t);else {
              const e = u - 2 * c;

              for (let n = 0; n < e; ++n) o.values[t + n] -= h[n];
            }
          }
        }

        return e.blendMode = Ct, e;
      }
    });

    class ap {
      constructor(e, t, n, r) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
      }

      evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex,
            r = t[n],
            i = t[n - 1];

        e: {
          t: {
            let s;

            n: {
              r: if (!(e < r)) {
                for (let s = n + 2;;) {
                  if (void 0 === r) {
                    if (e < i) break r;
                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                  }

                  if (n === s) break;
                  if (i = r, r = t[++n], e < r) break t;
                }

                s = t.length;
                break n;
              }

              if (e >= i) break e;
              {
                const o = t[1];
                e < o && (n = 2, i = o);

                for (let s = n - 2;;) {
                  if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                  if (n === s) break;
                  if (r = i, i = t[--n - 1], e >= i) break t;
                }

                s = n, n = 0;
              }
            }

            for (; n < s;) {
              const r = n + s >>> 1;
              e < t[r] ? s = r : n = r + 1;
            }

            if (r = t[n], i = t[n - 1], void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
            if (void 0 === r) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
          }

          this._cachedIndex = n, this.intervalChanged_(n, i, r);
        }

        return this.interpolate_(n, i, e, r);
      }

      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }

      copySampleValue_(e) {
        const t = this.resultBuffer,
              n = this.sampleValues,
              r = this.valueSize,
              i = e * r;

        for (let e = 0; e !== r; ++e) t[e] = n[i + e];

        return t;
      }

      interpolate_() {
        throw new Error("call to abstract method");
      }

      intervalChanged_() {}

    }

    class lp extends ap {
      constructor(e, t, n, r) {
        super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
          endingStart: Mt,
          endingEnd: Mt
        };
      }

      intervalChanged_(e, t, n) {
        const r = this.parameterPositions;
        let i = e - 2,
            s = e + 1,
            o = r[i],
            a = r[s];
        if (void 0 === o) switch (this.getSettings_().endingStart) {
          case Tt:
            i = e, o = 2 * t - n;
            break;

          case Et:
            i = r.length - 2, o = t + r[i] - r[i + 1];
            break;

          default:
            i = e, o = n;
        }
        if (void 0 === a) switch (this.getSettings_().endingEnd) {
          case Tt:
            s = e, a = 2 * n - t;
            break;

          case Et:
            s = 1, a = n + r[1] - r[0];
            break;

          default:
            s = e - 1, a = t;
        }
        const l = .5 * (n - t),
              c = this.valueSize;
        this._weightPrev = l / (t - o), this._weightNext = l / (a - n), this._offsetPrev = i * c, this._offsetNext = s * c;
      }

      interpolate_(e, t, n, r) {
        const i = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = e * o,
              l = a - o,
              c = this._offsetPrev,
              u = this._offsetNext,
              p = this._weightPrev,
              h = this._weightNext,
              d = (n - t) / (r - t),
              f = d * d,
              _ = f * d,
              m = -p * _ + 2 * p * f - p * d,
              g = (1 + p) * _ + (-1.5 - 2 * p) * f + (-.5 + p) * d + 1,
              v = (-1 - h) * _ + (1.5 + h) * f + .5 * d,
              b = h * _ - h * f;

        for (let e = 0; e !== o; ++e) i[e] = m * s[c + e] + g * s[l + e] + v * s[a + e] + b * s[u + e];

        return i;
      }

    }

    class cp extends ap {
      constructor(e, t, n, r) {
        super(e, t, n, r);
      }

      interpolate_(e, t, n, r) {
        const i = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = e * o,
              l = a - o,
              c = (n - t) / (r - t),
              u = 1 - c;

        for (let e = 0; e !== o; ++e) i[e] = s[l + e] * u + s[a + e] * c;

        return i;
      }

    }

    class up extends ap {
      constructor(e, t, n, r) {
        super(e, t, n, r);
      }

      interpolate_(e) {
        return this.copySampleValue_(e - 1);
      }

    }

    class pp {
      constructor(e, t, n, r) {
        if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = tp(t, this.TimeBufferType), this.values = tp(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
      }

      static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON) n = t.toJSON(e);else {
          n = {
            name: e.name,
            times: tp(e.times, Array),
            values: tp(e.values, Array)
          };
          const t = e.getInterpolation();
          t !== e.DefaultInterpolation && (n.interpolation = t);
        }
        return n.type = e.ValueTypeName, n;
      }

      InterpolantFactoryMethodDiscrete(e) {
        return new up(this.times, this.values, this.getValueSize(), e);
      }

      InterpolantFactoryMethodLinear(e) {
        return new cp(this.times, this.values, this.getValueSize(), e);
      }

      InterpolantFactoryMethodSmooth(e) {
        return new lp(this.times, this.values, this.getValueSize(), e);
      }

      setInterpolation(e) {
        let t;

        switch (e) {
          case yt:
            t = this.InterpolantFactoryMethodDiscrete;
            break;

          case wt:
            t = this.InterpolantFactoryMethodLinear;
            break;

          case St:
            t = this.InterpolantFactoryMethodSmooth;
        }

        if (void 0 === t) {
          const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

          if (void 0 === this.createInterpolant) {
            if (e === this.DefaultInterpolation) throw new Error(t);
            this.setInterpolation(this.DefaultInterpolation);
          }

          return console.warn("THREE.KeyframeTrack:", t), this;
        }

        return this.createInterpolant = t, this;
      }

      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return yt;

          case this.InterpolantFactoryMethodLinear:
            return wt;

          case this.InterpolantFactoryMethodSmooth:
            return St;
        }
      }

      getValueSize() {
        return this.values.length / this.times.length;
      }

      shift(e) {
        if (0 !== e) {
          const t = this.times;

          for (let n = 0, r = t.length; n !== r; ++n) t[n] += e;
        }

        return this;
      }

      scale(e) {
        if (1 !== e) {
          const t = this.times;

          for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e;
        }

        return this;
      }

      trim(e, t) {
        const n = this.times,
              r = n.length;
        let i = 0,
            s = r - 1;

        for (; i !== r && n[i] < e;) ++i;

        for (; -1 !== s && n[s] > t;) --s;

        if (++s, 0 !== i || s !== r) {
          i >= s && (s = Math.max(s, 1), i = s - 1);
          const e = this.getValueSize();
          this.times = ep(n, i, s), this.values = ep(this.values, i * e, s * e);
        }

        return this;
      }

      validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
        const n = this.times,
              r = this.values,
              i = n.length;
        0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
        let s = null;

        for (let t = 0; t !== i; t++) {
          const r = n[t];

          if ("number" == typeof r && isNaN(r)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r), e = !1;
            break;
          }

          if (null !== s && s > r) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, s), e = !1;
            break;
          }

          s = r;
        }

        if (void 0 !== r && np(r)) for (let t = 0, n = r.length; t !== n; ++t) {
          const n = r[t];

          if (isNaN(n)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1;
            break;
          }
        }
        return e;
      }

      optimize() {
        const e = ep(this.times),
              t = ep(this.values),
              n = this.getValueSize(),
              r = this.getInterpolation() === St,
              i = e.length - 1;
        let s = 1;

        for (let o = 1; o < i; ++o) {
          let i = !1;
          const a = e[o];
          if (a !== e[o + 1] && (1 !== o || a !== e[0])) if (r) i = !0;else {
            const e = o * n,
                  r = e - n,
                  s = e + n;

            for (let o = 0; o !== n; ++o) {
              const n = t[e + o];

              if (n !== t[r + o] || n !== t[s + o]) {
                i = !0;
                break;
              }
            }
          }

          if (i) {
            if (o !== s) {
              e[s] = e[o];
              const r = o * n,
                    i = s * n;

              for (let e = 0; e !== n; ++e) t[i + e] = t[r + e];
            }

            ++s;
          }
        }

        if (i > 0) {
          e[s] = e[i];

          for (let e = i * n, r = s * n, o = 0; o !== n; ++o) t[r + o] = t[e + o];

          ++s;
        }

        return s !== e.length ? (this.times = ep(e, 0, s), this.values = ep(t, 0, s * n)) : (this.times = e, this.values = t), this;
      }

      clone() {
        const e = ep(this.times, 0),
              t = ep(this.values, 0),
              n = new (0, this.constructor)(this.name, e, t);
        return n.createInterpolant = this.createInterpolant, n;
      }

    }

    pp.prototype.TimeBufferType = Float32Array, pp.prototype.ValueBufferType = Float32Array, pp.prototype.DefaultInterpolation = wt;

    class hp extends pp {}

    hp.prototype.ValueTypeName = "bool", hp.prototype.ValueBufferType = Array, hp.prototype.DefaultInterpolation = yt, hp.prototype.InterpolantFactoryMethodLinear = void 0, hp.prototype.InterpolantFactoryMethodSmooth = void 0;

    class dp extends pp {}

    dp.prototype.ValueTypeName = "color";

    class fp extends pp {}

    fp.prototype.ValueTypeName = "number";

    class _p extends ap {
      constructor(e, t, n, r) {
        super(e, t, n, r);
      }

      interpolate_(e, t, n, r) {
        const i = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = (n - t) / (r - t);
        let l = e * o;

        for (let e = l + o; l !== e; l += 4) ar.slerpFlat(i, 0, s, l - o, s, l, a);

        return i;
      }

    }

    class mp extends pp {
      InterpolantFactoryMethodLinear(e) {
        return new _p(this.times, this.values, this.getValueSize(), e);
      }

    }

    mp.prototype.ValueTypeName = "quaternion", mp.prototype.DefaultInterpolation = wt, mp.prototype.InterpolantFactoryMethodSmooth = void 0;

    class gp extends pp {}

    gp.prototype.ValueTypeName = "string", gp.prototype.ValueBufferType = Array, gp.prototype.DefaultInterpolation = yt, gp.prototype.InterpolantFactoryMethodLinear = void 0, gp.prototype.InterpolantFactoryMethodSmooth = void 0;

    class vp extends pp {}

    vp.prototype.ValueTypeName = "vector";

    class bp {
      constructor(e, t = -1, n, r = At) {
        this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = Sn(), this.duration < 0 && this.resetDuration();
      }

      static parse(e) {
        const t = [],
              n = e.tracks,
              r = 1 / (e.fps || 1);

        for (let e = 0, i = n.length; e !== i; ++e) t.push(xp(n[e]).scale(r));

        const i = new this(e.name, e.duration, t, e.blendMode);
        return i.uuid = e.uuid, i;
      }

      static toJSON(e) {
        const t = [],
              n = e.tracks,
              r = {
          name: e.name,
          duration: e.duration,
          tracks: t,
          uuid: e.uuid,
          blendMode: e.blendMode
        };

        for (let e = 0, r = n.length; e !== r; ++e) t.push(pp.toJSON(n[e]));

        return r;
      }

      static CreateFromMorphTargetSequence(e, t, n, r) {
        const i = t.length,
              s = [];

        for (let e = 0; e < i; e++) {
          let o = [],
              a = [];
          o.push((e + i - 1) % i, e, (e + 1) % i), a.push(0, 1, 0);
          const l = rp(o);
          o = ip(o, 1, l), a = ip(a, 1, l), r || 0 !== o[0] || (o.push(i), a.push(a[0])), s.push(new fp(".morphTargetInfluences[" + t[e].name + "]", o, a).scale(1 / n));
        }

        return new this(e, -1, s);
      }

      static findByName(e, t) {
        let n = e;

        if (!Array.isArray(e)) {
          const t = e;
          n = t.geometry && t.geometry.animations || t.animations;
        }

        for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];

        return null;
      }

      static CreateClipsFromMorphTargetSequences(e, t, n) {
        const r = {},
              i = /^([\w-]*?)([\d]+)$/;

        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t],
                s = n.name.match(i);

          if (s && s.length > 1) {
            const e = s[1];
            let t = r[e];
            t || (r[e] = t = []), t.push(n);
          }
        }

        const s = [];

        for (const e in r) s.push(this.CreateFromMorphTargetSequence(e, r[e], t, n));

        return s;
      }

      static parseAnimation(e, t) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;

        const n = function (e, t, n, r, i) {
          if (0 !== n.length) {
            const s = [],
                  o = [];
            sp(n, s, o, r), 0 !== s.length && i.push(new e(t, s, o));
          }
        },
              r = [],
              i = e.name || "default",
              s = e.fps || 30,
              o = e.blendMode;

        let a = e.length || -1;
        const l = e.hierarchy || [];

        for (let e = 0; e < l.length; e++) {
          const i = l[e].keys;
          if (i && 0 !== i.length) if (i[0].morphTargets) {
            const e = {};
            let t;

            for (t = 0; t < i.length; t++) if (i[t].morphTargets) for (let n = 0; n < i[t].morphTargets.length; n++) e[i[t].morphTargets[n]] = -1;

            for (const n in e) {
              const e = [],
                    s = [];

              for (let r = 0; r !== i[t].morphTargets.length; ++r) {
                const r = i[t];
                e.push(r.time), s.push(r.morphTarget === n ? 1 : 0);
              }

              r.push(new fp(".morphTargetInfluence[" + n + "]", e, s));
            }

            a = e.length * s;
          } else {
            const s = ".bones[" + t[e].name + "]";
            n(vp, s + ".position", i, "pos", r), n(mp, s + ".quaternion", i, "rot", r), n(vp, s + ".scale", i, "scl", r);
          }
        }

        return 0 === r.length ? null : new this(i, a, r, o);
      }

      resetDuration() {
        let e = 0;

        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
          const n = this.tracks[t];
          e = Math.max(e, n.times[n.times.length - 1]);
        }

        return this.duration = e, this;
      }

      trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);

        return this;
      }

      validate() {
        let e = !0;

        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();

        return e;
      }

      optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();

        return this;
      }

      clone() {
        const e = [];

        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());

        return new this.constructor(this.name, this.duration, e, this.blendMode);
      }

      toJSON() {
        return this.constructor.toJSON(this);
      }

    }

    function xp(e) {
      if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");

      const t = function (e) {
        switch (e.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return fp;

          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return vp;

          case "color":
            return dp;

          case "quaternion":
            return mp;

          case "bool":
          case "boolean":
            return hp;

          case "string":
            return gp;
        }

        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
      }(e.type);

      if (void 0 === e.times) {
        const t = [],
              n = [];
        sp(e.keys, t, n, "value"), e.times = t, e.values = n;
      }

      return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
    }

    const yp = {
      enabled: !1,
      files: {},
      add: function (e, t) {
        !1 !== this.enabled && (this.files[e] = t);
      },
      get: function (e, t) {
        return !1 === this.enabled ? t ? Promise.resolve() : void 0 : t ? Promise.resolve(this.files[e]) : this.files[e];
      },
      remove: function (e) {
        delete this.files[e];
      },
      clear: function () {
        this.files = {};
      }
    };

    class wp {
      constructor(e, t, n) {
        const r = this;
        let i,
            s = !1,
            o = 0,
            a = 0;
        const l = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
          a++, !1 === s && void 0 !== r.onStart && r.onStart(e, o, a), s = !0;
        }, this.itemEnd = function (e) {
          o++, void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (s = !1, void 0 !== r.onLoad && r.onLoad());
        }, this.itemError = function (e) {
          void 0 !== r.onError && r.onError(e);
        }, this.resolveURL = function (e) {
          return i ? i(e) : e;
        }, this.setURLModifier = function (e) {
          return i = e, this;
        }, this.addHandler = function (e, t) {
          return l.push(e, t), this;
        }, this.removeHandler = function (e) {
          const t = l.indexOf(e);
          return -1 !== t && l.splice(t, 2), this;
        }, this.getHandler = function (e) {
          for (let t = 0, n = l.length; t < n; t += 2) {
            const n = l[t],
                  r = l[t + 1];
            if (n.global && (n.lastIndex = 0), n.test(e)) return r;
          }

          return null;
        };
      }

    }

    const Sp = new wp();

    class Mp {
      constructor(e) {
        this.manager = void 0 !== e ? e : Sp, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
      }

      load() {}

      loadAsync(e, t) {
        const n = this;
        return new Promise(function (r, i) {
          n.load(e, r, t, i);
        });
      }

      parse() {}

      setCrossOrigin(e) {
        return this.crossOrigin = e, this;
      }

      setWithCredentials(e) {
        return this.withCredentials = e, this;
      }

      setPath(e) {
        return this.path = e, this;
      }

      setResourcePath(e) {
        return this.resourcePath = e, this;
      }

      setRequestHeader(e) {
        return this.requestHeader = e, this;
      }

    }

    const Tp = {};

    class Ep extends Mp {
      constructor(e) {
        super(e), this.responseType = "text";
      }

      load(e, t, n, r) {
        void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e), yp.get(e, this.responseType, this.mimeType).then(i => {
          if (void 0 !== i) return this.manager.itemStart(e), setTimeout(() => {
            t && t(i), this.manager.itemEnd(e);
          }, 0), i;
          if (void 0 !== Tp[e]) return void Tp[e].push({
            onLoad: t,
            onProgress: n,
            onError: r
          });
          Tp[e] = [], Tp[e].push({
            onLoad: t,
            onProgress: n,
            onError: r
          });
          const s = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          }),
                o = this.mimeType,
                a = this.responseType;
          fetch(s).then(t => {
            if (200 === t.status || 0 === t.status) {
              if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
              const n = Tp[e],
                    r = t.body.getReader(),
                    i = t.headers.get("Content-Length"),
                    s = i ? parseInt(i) : 0,
                    o = 0 !== s;
              let a = 0;
              const l = new ReadableStream({
                start(e) {
                  !function t() {
                    r.read().then(({
                      done: r,
                      value: i
                    }) => {
                      if (r) e.close();else {
                        a += i.byteLength;
                        const r = new ProgressEvent("progress", {
                          lengthComputable: o,
                          loaded: a,
                          total: s
                        });

                        for (let e = 0, t = n.length; e < t; e++) {
                          const t = n[e];
                          t.onProgress && t.onProgress(r);
                        }

                        e.enqueue(i), t();
                      }
                    });
                  }();
                }

              });
              return new Response(l);
            }

            throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`);
          }).then(e => {
            switch (a) {
              case "arraybuffer":
                return e.arrayBuffer();

              case "blob":
                return e.blob();

              case "document":
                return e.text().then(e => new DOMParser().parseFromString(e, o));

              case "json":
                return e.json();

              default:
                if (void 0 === o) return e.text();
                {
                  const t = /charset="?([^;"\s]*)"?/i.exec(o),
                        n = t && t[1] ? t[1].toLowerCase() : void 0,
                        r = new TextDecoder(n);
                  return e.arrayBuffer().then(e => r.decode(e));
                }
            }
          }).then(t => {
            yp.add(e, t, this.responseType);
            const n = Tp[e];
            delete Tp[e];

            for (let e = 0, r = n.length; e < r; e++) {
              const r = n[e];
              r.onLoad && r.onLoad(t);
            }
          }).catch(t => {
            const n = Tp[e];
            if (void 0 === n) throw this.manager.itemError(e), t;
            delete Tp[e];

            for (let e = 0, r = n.length; e < r; e++) {
              const r = n[e];
              r.onError && r.onError(t);
            }

            this.manager.itemError(e);
          }).finally(() => {
            this.manager.itemEnd(e);
          }), this.manager.itemStart(e);
        });
      }

      setResponseType(e) {
        return this.responseType = e, this;
      }

      setMimeType(e) {
        return this.mimeType = e, this;
      }

    }

    class Ap extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = this,
              s = new Ep(this.manager);
        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (n) {
          try {
            t(i.parse(JSON.parse(n)));
          } catch (t) {
            r ? r(t) : console.error(t), i.manager.itemError(e);
          }
        }, n, r);
      }

      parse(e) {
        const t = [];

        for (let n = 0; n < e.length; n++) {
          const r = bp.parse(e[n]);
          t.push(r);
        }

        return t;
      }

    }

    class Cp extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = this,
              s = [],
              o = new xc(),
              a = new Ep(this.manager);
        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials);
        let l = 0;

        function c(c) {
          a.load(e[c], function (e) {
            const n = i.parse(e, !0);
            s[c] = {
              width: n.width,
              height: n.height,
              format: n.format,
              mipmaps: n.mipmaps
            }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = ve), o.image = s, o.format = n.format, o.needsUpdate = !0, t && t(o));
          }, n, r);
        }

        if (Array.isArray(e)) for (let t = 0, n = e.length; t < n; ++t) c(t);else a.load(e, function (e) {
          const n = i.parse(e, !0);

          if (n.isCubemap) {
            const e = n.mipmaps.length / n.mipmapCount;

            for (let t = 0; t < e; t++) {
              s[t] = {
                mipmaps: []
              };

              for (let e = 0; e < n.mipmapCount; e++) s[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), s[t].format = n.format, s[t].width = n.width, s[t].height = n.height;
            }

            o.image = s;
          } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;

          1 === n.mipmapCount && (o.minFilter = ve), o.format = n.format, o.needsUpdate = !0, t && t(o);
        }, n, r);
        return o;
      }

    }

    class Rp extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
        const i = this,
              s = yp.get(e);
        if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function () {
          t && t(s), i.manager.itemEnd(e);
        }, 0), s;
        const o = Fn("img");

        function a() {
          c(), yp.add(e, this), t && t(this), i.manager.itemEnd(e);
        }

        function l(t) {
          c(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
        }

        function c() {
          o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1);
        }

        return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(e), o.src = e, o;
      }

    }

    class kp extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = new xs(),
              s = new Rp(this.manager);
        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
        let o = 0;

        function a(n) {
          s.load(e[n], function (e) {
            i.images[n] = e, o++, 6 === o && (i.needsUpdate = !0, t && t(i));
          }, void 0, r);
        }

        for (let t = 0; t < e.length; ++t) a(t);

        return i;
      }

    }

    class Pp extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = this,
              s = new Hl(),
              o = new Ep(this.manager);
        return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(e, function (e) {
          const n = i.parse(e);
          n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data, s.image.complete = !0), s.wrapS = void 0 !== n.wrapS ? n.wrapS : pe, s.wrapT = void 0 !== n.wrapT ? n.wrapT : pe, s.magFilter = void 0 !== n.magFilter ? n.magFilter : ve, s.minFilter = void 0 !== n.minFilter ? n.minFilter : ve, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = ye), 1 === n.mipmapCount && (s.minFilter = ve), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, t && t(s, n));
        }, n, r), s;
      }

    }

    class Dp extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = new Qn(),
              s = new Rp(this.manager);
        return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function (e) {
          i.image = e, i.needsUpdate = !0, void 0 !== t && t(i);
        }, n, r), i;
      }

    }

    class Op extends ui {
      constructor(e, t = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new Xn(e), this.intensity = t;
      }

      dispose() {}

      copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
      }

      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t;
      }

    }

    class Lp extends Op {
      constructor(e, t, n) {
        super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.groundColor = new Xn(t);
      }

      copy(e, t) {
        return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
      }

    }

    const Ip = new Br(),
          Fp = new lr(),
          Np = new lr();

    class Up {
      constructor(e) {
        this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Pn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Br(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Cs(), this._frameExtents = new Pn(1, 1), this._viewportCount = 1, this._viewports = [new er(0, 0, 1, 1)];
      }

      getViewportCount() {
        return this._viewportCount;
      }

      getFrustum() {
        return this._frustum;
      }

      updateMatrices(e) {
        const t = this.camera,
              n = this.matrix;
        Fp.setFromMatrixPosition(e.matrixWorld), t.position.copy(Fp), Np.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Np), t.updateMatrixWorld(), Ip.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ip), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse);
      }

      getViewport(e) {
        return this._viewports[e];
      }

      getFrameExtents() {
        return this._frameExtents;
      }

      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }

      copy(e) {
        return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
      }

      clone() {
        return new this.constructor().copy(this);
      }

      toJSON() {
        const e = {};
        return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
      }

    }

    class Bp extends Up {
      constructor() {
        super(new gs(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
      }

      updateMatrices(e) {
        const t = this.camera,
              n = 2 * wn * e.angle * this.focus,
              r = this.mapSize.width / this.mapSize.height,
              i = e.distance || t.far;
        n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e);
      }

      copy(e) {
        return super.copy(e), this.focus = e.focus, this;
      }

    }

    class jp extends Op {
      constructor(e, t, n = 0, r = Math.PI / 3, i = 0, s = 1) {
        super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui(), this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.shadow = new Bp();
      }

      get power() {
        return this.intensity * Math.PI;
      }

      set power(e) {
        this.intensity = e / Math.PI;
      }

      dispose() {
        this.shadow.dispose();
      }

      copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
      }

    }

    const zp = new Br(),
          Vp = new lr(),
          Gp = new lr();

    class Hp extends Up {
      constructor() {
        super(new gs(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Pn(4, 2), this._viewportCount = 6, this._viewports = [new er(2, 1, 1, 1), new er(0, 1, 1, 1), new er(3, 1, 1, 1), new er(1, 1, 1, 1), new er(3, 0, 1, 1), new er(1, 0, 1, 1)], this._cubeDirections = [new lr(1, 0, 0), new lr(-1, 0, 0), new lr(0, 0, 1), new lr(0, 0, -1), new lr(0, 1, 0), new lr(0, -1, 0)], this._cubeUps = [new lr(0, 1, 0), new lr(0, 1, 0), new lr(0, 1, 0), new lr(0, 1, 0), new lr(0, 0, 1), new lr(0, 0, -1)];
      }

      updateMatrices(e, t = 0) {
        const n = this.camera,
              r = this.matrix,
              i = e.distance || n.far;
        i !== n.far && (n.far = i, n.updateProjectionMatrix()), Vp.setFromMatrixPosition(e.matrixWorld), n.position.copy(Vp), Gp.copy(n.position), Gp.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Gp), n.updateMatrixWorld(), r.makeTranslation(-Vp.x, -Vp.y, -Vp.z), zp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(zp);
      }

    }

    class Wp extends Op {
      constructor(e, t, n = 0, r = 1) {
        super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Hp();
      }

      get power() {
        return 4 * this.intensity * Math.PI;
      }

      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }

      dispose() {
        this.shadow.dispose();
      }

      copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
      }

    }

    class Kp extends Up {
      constructor() {
        super(new zs(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0;
      }

    }

    class Xp extends Op {
      constructor(e, t) {
        super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui(), this.shadow = new Kp();
      }

      dispose() {
        this.shadow.dispose();
      }

      copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
      }

    }

    class qp extends Op {
      constructor(e, t) {
        super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
      }

    }

    class Yp extends Op {
      constructor(e, t, n = 10, r = 10) {
        super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r;
      }

      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }

      set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI);
      }

      copy(e) {
        return super.copy(e), this.width = e.width, this.height = e.height, this;
      }

      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width, t.object.height = this.height, t;
      }

    }

    class Zp {
      constructor() {
        this.isSphericalHarmonics3 = !0, this.coefficients = [];

        for (let e = 0; e < 9; e++) this.coefficients.push(new lr());
      }

      set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);

        return this;
      }

      zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);

        return this;
      }

      getAt(e, t) {
        const n = e.x,
              r = e.y,
              i = e.z,
              s = this.coefficients;
        return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * r), t.addScaledVector(s[2], .488603 * i), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * r * 1.092548), t.addScaledVector(s[5], r * i * 1.092548), t.addScaledVector(s[6], .315392 * (3 * i * i - 1)), t.addScaledVector(s[7], n * i * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - r * r)), t;
      }

      getIrradianceAt(e, t) {
        const n = e.x,
              r = e.y,
              i = e.z,
              s = this.coefficients;
        return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * r), t.addScaledVector(s[2], 1.023328 * i), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * r), t.addScaledVector(s[5], .858086 * r * i), t.addScaledVector(s[6], .743125 * i * i - .247708), t.addScaledVector(s[7], .858086 * n * i), t.addScaledVector(s[8], .429043 * (n * n - r * r)), t;
      }

      add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);

        return this;
      }

      addScaledSH(e, t) {
        for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);

        return this;
      }

      scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);

        return this;
      }

      lerp(e, t) {
        for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);

        return this;
      }

      equals(e) {
        for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;

        return !0;
      }

      copy(e) {
        return this.set(e.coefficients);
      }

      clone() {
        return new this.constructor().copy(this);
      }

      fromArray(e, t = 0) {
        const n = this.coefficients;

        for (let r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);

        return this;
      }

      toArray(e = [], t = 0) {
        const n = this.coefficients;

        for (let r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);

        return e;
      }

      static getBasisAt(e, t) {
        const n = e.x,
              r = e.y,
              i = e.z;
        t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r);
      }

    }

    class Jp extends Op {
      constructor(e = new Zp(), t = 1) {
        super(void 0, t), this.isLightProbe = !0, this.sh = e;
      }

      copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
      }

      fromJSON(e) {
        return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
      }

      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(), t;
      }

    }

    class $p extends Mp {
      constructor(e) {
        super(e), this.textures = {};
      }

      load(e, t, n, r) {
        const i = this,
              s = new Ep(i.manager);
        s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (n) {
          try {
            t(i.parse(JSON.parse(n)));
          } catch (t) {
            r ? r(t) : console.error(t), i.manager.itemError(e);
          }
        }, n, r);
      }

      parse(e) {
        const t = this.textures;

        function n(e) {
          return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e];
        }

        const r = $p.createMaterialFromType(e.type);
        if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = new Xn().setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.iridescence && (r.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms) for (const t in e.uniforms) {
          const i = e.uniforms[t];

          switch (r.uniforms[t] = {}, i.type) {
            case "t":
              r.uniforms[t].value = n(i.value);
              break;

            case "c":
              r.uniforms[t].value = new Xn().setHex(i.value);
              break;

            case "v2":
              r.uniforms[t].value = new Pn().fromArray(i.value);
              break;

            case "v3":
              r.uniforms[t].value = new lr().fromArray(i.value);
              break;

            case "v4":
              r.uniforms[t].value = new er().fromArray(i.value);
              break;

            case "m3":
              r.uniforms[t].value = new Dn().fromArray(i.value);
              break;

            case "m4":
              r.uniforms[t].value = new Br().fromArray(i.value);
              break;

            default:
              r.uniforms[t].value = i.value;
          }
        }
        if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions) for (const t in e.extensions) r.extensions[t] = e.extensions[t];

        if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
          let t = e.normalScale;
          !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = new Pn().fromArray(t);
        }

        return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = new Pn().fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (r.iridescenceMap = n(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r;
      }

      setTextures(e) {
        return this.textures = e, this;
      }

      static createMaterialFromType(e) {
        return new {
          ShadowMaterial: Hu,
          SpriteMaterial: vl,
          RawShaderMaterial: Wu,
          ShaderMaterial: _s,
          PointsMaterial: pc,
          MeshPhysicalMaterial: Xu,
          MeshStandardMaterial: Ku,
          MeshPhongMaterial: qu,
          MeshToonMaterial: Yu,
          MeshNormalMaterial: Zu,
          MeshLambertMaterial: Ju,
          MeshDepthMaterial: Za,
          MeshDistanceMaterial: Ja,
          MeshBasicMaterial: Mi,
          MeshMatcapMaterial: $u,
          LineDashedMaterial: Qu,
          LineBasicMaterial: ec,
          Material: Si
        }[e]();
      }

    }

    class Qp {
      static decodeText(e) {
        if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
        let t = "";

        for (let n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);

        try {
          return decodeURIComponent(escape(t));
        } catch (e) {
          return t;
        }
      }

      static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.slice(0, t + 1);
      }

      static resolveURL(e, t) {
        return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
      }

    }

    class eh extends Wi {
      constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
      }

      copy(e) {
        return super.copy(e), this.instanceCount = e.instanceCount, this;
      }

      clone() {
        return new this.constructor().copy(this);
      }

      toJSON() {
        const e = super.toJSON(this);
        return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
      }

    }

    class th extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = this,
              s = new Ep(i.manager);
        s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (n) {
          try {
            t(i.parse(JSON.parse(n)));
          } catch (t) {
            r ? r(t) : console.error(t), i.manager.itemError(e);
          }
        }, n, r);
      }

      parse(e) {
        const t = {},
              n = {};

        function r(e, r) {
          if (void 0 !== t[r]) return t[r];

          const i = e.interleavedBuffers[r],
                s = function (e, t) {
            if (void 0 !== n[t]) return n[t];
            const r = e.arrayBuffers[t],
                  i = new Uint32Array(r).buffer;
            return n[t] = i, i;
          }(e, i.buffer),
                o = In(i.type, s),
                a = new _l(o, i.stride);

          return a.uuid = i.uuid, t[r] = a, a;
        }

        const i = e.isInstancedBufferGeometry ? new eh() : new Wi(),
              s = e.data.index;

        if (void 0 !== s) {
          const e = In(s.type, s.array);
          i.setIndex(new Ai(e, 1));
        }

        const o = e.data.attributes;

        for (const t in o) {
          const n = o[t];
          let s;

          if (n.isInterleavedBufferAttribute) {
            const t = r(e.data, n.data);
            s = new gl(t, n.itemSize, n.offset, n.normalized);
          } else {
            const e = In(n.type, n.array);
            s = new (n.isInstancedBufferAttribute ? ql : Ai)(e, n.itemSize, n.normalized);
          }

          void 0 !== n.name && (s.name = n.name), void 0 !== n.usage && s.setUsage(n.usage), void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset, s.updateRange.count = n.updateRange.count), i.setAttribute(t, s);
        }

        const a = e.data.morphAttributes;
        if (a) for (const t in a) {
          const n = a[t],
                s = [];

          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            let o;

            if (i.isInterleavedBufferAttribute) {
              const t = r(e.data, i.data);
              o = new gl(t, i.itemSize, i.offset, i.normalized);
            } else {
              const e = In(i.type, i.array);
              o = new Ai(e, i.itemSize, i.normalized);
            }

            void 0 !== i.name && (o.name = i.name), s.push(o);
          }

          i.morphAttributes[t] = s;
        }
        e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
        const l = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (void 0 !== l) for (let e = 0, t = l.length; e !== t; ++e) {
          const t = l[e];
          i.addGroup(t.start, t.count, t.materialIndex);
        }
        const c = e.data.boundingSphere;

        if (void 0 !== c) {
          const e = new lr();
          void 0 !== c.center && e.fromArray(c.center), i.boundingSphere = new kr(e, c.radius);
        }

        return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i;
      }

    }

    class nh extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = this,
              s = "" === this.path ? Qp.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || s;
        const o = new Ep(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (n) {
          let s = null;

          try {
            s = JSON.parse(n);
          } catch (t) {
            return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message);
          }

          const o = s.metadata;
          void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? i.parse(s, t) : console.error("THREE.ObjectLoader: Can't load " + e);
        }, n, r);
      }

      async loadAsync(e, t) {
        const n = "" === this.path ? Qp.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || n;
        const r = new Ep(this.manager);
        r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
        const i = await r.loadAsync(e, t),
              s = JSON.parse(i),
              o = s.metadata;
        if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await this.parseAsync(s);
      }

      parse(e, t) {
        const n = this.parseAnimations(e.animations),
              r = this.parseShapes(e.shapes),
              i = this.parseGeometries(e.geometries, r),
              s = this.parseImages(e.images, function () {
          void 0 !== t && t(l);
        }),
              o = this.parseTextures(e.textures, s),
              a = this.parseMaterials(e.materials, o),
              l = this.parseObject(e.object, i, a, o, n),
              c = this.parseSkeletons(e.skeletons, l);

        if (this.bindSkeletons(l, c), void 0 !== t) {
          let e = !1;

          for (const t in s) if (s[t].data instanceof HTMLImageElement) {
            e = !0;
            break;
          }

          !1 === e && t(l);
        }

        return l;
      }

      async parseAsync(e) {
        const t = this.parseAnimations(e.animations),
              n = this.parseShapes(e.shapes),
              r = this.parseGeometries(e.geometries, n),
              i = await this.parseImagesAsync(e.images),
              s = this.parseTextures(e.textures, i),
              o = this.parseMaterials(e.materials, s),
              a = this.parseObject(e.object, r, o, s, t),
              l = this.parseSkeletons(e.skeletons, a);
        return this.bindSkeletons(a, l), a;
      }

      parseShapes(e) {
        const t = {};
        if (void 0 !== e) for (let n = 0, r = e.length; n < r; n++) {
          const r = new nu().fromJSON(e[n]);
          t[r.uuid] = r;
        }
        return t;
      }

      parseSkeletons(e, t) {
        const n = {},
              r = {};
        if (t.traverse(function (e) {
          e.isBone && (r[e.uuid] = e);
        }), void 0 !== e) for (let t = 0, i = e.length; t < i; t++) {
          const i = new Xl().fromJSON(e[t], r);
          n[i.uuid] = i;
        }
        return n;
      }

      parseGeometries(e, t) {
        const n = {};

        if (void 0 !== e) {
          const r = new th();

          for (let i = 0, s = e.length; i < s; i++) {
            let s;
            const o = e[i];

            switch (o.type) {
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                s = r.parse(o);
                break;

              case "Geometry":
                console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                break;

              default:
                o.type in Gu ? s = Gu[o.type].fromJSON(o, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`);
            }

            s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), n[o.uuid] = s;
          }
        }

        return n;
      }

      parseMaterials(e, t) {
        const n = {},
              r = {};

        if (void 0 !== e) {
          const i = new $p();
          i.setTextures(t);

          for (let t = 0, s = e.length; t < s; t++) {
            const s = e[t];

            if ("MultiMaterial" === s.type) {
              const e = [];

              for (let t = 0; t < s.materials.length; t++) {
                const r = s.materials[t];
                void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)), e.push(n[r.uuid]);
              }

              r[s.uuid] = e;
            } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid];
          }
        }

        return r;
      }

      parseAnimations(e) {
        const t = {};
        if (void 0 !== e) for (let n = 0; n < e.length; n++) {
          const r = e[n],
                i = bp.parse(r);
          t[i.uuid] = i;
        }
        return t;
      }

      parseImages(e, t) {
        const n = this,
              r = {};
        let i;

        function s(e) {
          if ("string" == typeof e) {
            const t = e;
            return function (e) {
              return n.manager.itemStart(e), i.load(e, function () {
                n.manager.itemEnd(e);
              }, void 0, function () {
                n.manager.itemError(e), n.manager.itemEnd(e);
              });
            }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t);
          }

          return e.data ? {
            data: In(e.type, e.data),
            width: e.width,
            height: e.height,
            complete: !0
          } : null;
        }

        if (void 0 !== e && e.length > 0) {
          const n = new wp(t);
          i = new Rp(n), i.setCrossOrigin(this.crossOrigin);

          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t],
                  i = n.url;

            if (Array.isArray(i)) {
              const e = [];

              for (let t = 0, n = i.length; t < n; t++) {
                const n = s(i[t]);
                null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new Hl(n.data, n.width, n.height)));
              }

              r[n.uuid] = new Zn(e);
            } else {
              const e = s(n.url);
              r[n.uuid] = new Zn(e);
            }
          }
        }

        return r;
      }

      async parseImagesAsync(e) {
        const t = this,
              n = {};
        let r;

        async function i(e) {
          if ("string" == typeof e) {
            const n = e,
                  i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
            return await r.loadAsync(i);
          }

          return e.data ? {
            data: In(e.type, e.data),
            width: e.width,
            height: e.height,
            complete: !0
          } : null;
        }

        if (void 0 !== e && e.length > 0) {
          r = new Rp(this.manager), r.setCrossOrigin(this.crossOrigin);

          for (let t = 0, r = e.length; t < r; t++) {
            const r = e[t],
                  s = r.url;

            if (Array.isArray(s)) {
              const e = [];

              for (let t = 0, n = s.length; t < n; t++) {
                const n = s[t],
                      r = await i(n);
                null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new Hl(r.data, r.width, r.height)));
              }

              n[r.uuid] = new Zn(e);
            } else {
              const e = await i(r.url);
              n[r.uuid] = new Zn(e);
            }
          }
        }

        return n;
      }

      parseTextures(e, t) {
        function n(e, t) {
          return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]);
        }

        const r = {};
        if (void 0 !== e) for (let i = 0, s = e.length; i < s; i++) {
          const s = e[i];
          void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
          const o = t[s.image],
                a = o ? o.data : void 0;
          let l;
          Array.isArray(a) ? (l = new xs(), 6 === a.length && (l.needsUpdate = !0)) : (l = a && a.data ? new Hl() : new Qn(), a && a.complete && (l.needsUpdate = !0)), l.source = o, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = n(s.mapping, rh)), void 0 !== s.offset && l.offset.fromArray(s.offset), void 0 !== s.repeat && l.repeat.fromArray(s.repeat), void 0 !== s.center && l.center.fromArray(s.center), void 0 !== s.rotation && (l.rotation = s.rotation), void 0 !== s.wrap && (l.wrapS = n(s.wrap[0], ih), l.wrapT = n(s.wrap[1], ih)), void 0 !== s.format && (l.format = s.format), void 0 !== s.type && (l.type = s.type), void 0 !== s.encoding && (l.encoding = s.encoding), void 0 !== s.minFilter && (l.minFilter = n(s.minFilter, sh)), void 0 !== s.magFilter && (l.magFilter = n(s.magFilter, sh)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), void 0 !== s.flipY && (l.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (l.userData = s.userData), r[s.uuid] = l;
        }
        return r;
      }

      parseObject(e, t, n, r, i) {
        let s, o, a;

        function l(e) {
          return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e];
        }

        function c(e) {
          if (void 0 !== e) {
            if (Array.isArray(e)) {
              const t = [];

              for (let r = 0, i = e.length; r < i; r++) {
                const i = e[r];
                void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(n[i]);
              }

              return t;
            }

            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e];
          }
        }

        function u(e) {
          return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e];
        }

        switch (e.type) {
          case "Scene":
            s = new fl(), void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new Xn(e.background) : s.background = u(e.background)), void 0 !== e.environment && (s.environment = u(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new dl(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new hl(e.fog.color, e.fog.density)));
            break;

          case "PerspectiveCamera":
            s = new gs(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (s.focus = e.focus), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset), void 0 !== e.view && (s.view = Object.assign({}, e.view));
            break;

          case "OrthographicCamera":
            s = new zs(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.view && (s.view = Object.assign({}, e.view));
            break;

          case "AmbientLight":
            s = new qp(e.color, e.intensity);
            break;

          case "DirectionalLight":
            s = new Xp(e.color, e.intensity);
            break;

          case "PointLight":
            s = new Wp(e.color, e.intensity, e.distance, e.decay);
            break;

          case "RectAreaLight":
            s = new Yp(e.color, e.intensity, e.width, e.height);
            break;

          case "SpotLight":
            s = new jp(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
            break;

          case "HemisphereLight":
            s = new Lp(e.color, e.groundColor, e.intensity);
            break;

          case "LightProbe":
            s = new Jp().fromJSON(e);
            break;

          case "SkinnedMesh":
            o = l(e.geometry), a = c(e.material), s = new Vl(o, a), void 0 !== e.bindMode && (s.bindMode = e.bindMode), void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (s.skeleton = e.skeleton);
            break;

          case "Mesh":
            o = l(e.geometry), a = c(e.material), s = new cs(o, a);
            break;

          case "InstancedMesh":
            o = l(e.geometry), a = c(e.material);
            const t = e.count,
                  n = e.instanceMatrix,
                  r = e.instanceColor;
            s = new Ql(o, a, t), s.instanceMatrix = new ql(new Float32Array(n.array), 16), void 0 !== r && (s.instanceColor = new ql(new Float32Array(r.array), r.itemSize));
            break;

          case "LOD":
            s = new Fl();
            break;

          case "Line":
            s = new oc(l(e.geometry), c(e.material));
            break;

          case "LineLoop":
            s = new uc(l(e.geometry), c(e.material));
            break;

          case "LineSegments":
            s = new cc(l(e.geometry), c(e.material));
            break;

          case "PointCloud":
          case "Points":
            s = new mc(l(e.geometry), c(e.material));
            break;

          case "Sprite":
            s = new Dl(c(e.material));
            break;

          case "Group":
            s = new rl();
            break;

          case "Bone":
            s = new Gl();
            break;

          default:
            s = new ui();
        }

        if (s.uuid = e.uuid, void 0 !== e.name && (s.name = e.name), void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position), void 0 !== e.rotation && s.rotation.fromArray(e.rotation), void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion), void 0 !== e.scale && s.scale.fromArray(e.scale)), void 0 !== e.castShadow && (s.castShadow = e.castShadow), void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.layers && (s.layers.mask = e.layers), void 0 !== e.children) {
          const o = e.children;

          for (let e = 0; e < o.length; e++) s.add(this.parseObject(o[e], t, n, r, i));
        }

        if (void 0 !== e.animations) {
          const t = e.animations;

          for (let e = 0; e < t.length; e++) {
            const n = t[e];
            s.animations.push(i[n]);
          }
        }

        if ("LOD" === e.type) {
          void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate);
          const t = e.levels;

          for (let e = 0; e < t.length; e++) {
            const n = t[e],
                  r = s.getObjectByProperty("uuid", n.object);
            void 0 !== r && s.addLevel(r, n.distance);
          }
        }

        return s;
      }

      bindSkeletons(e, t) {
        0 !== Object.keys(t).length && e.traverse(function (e) {
          if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
            const n = t[e.skeleton];
            void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix);
          }
        });
      }

    }

    const rh = {
      UVMapping: ie,
      CubeReflectionMapping: se,
      CubeRefractionMapping: oe,
      EquirectangularReflectionMapping: ae,
      EquirectangularRefractionMapping: le,
      CubeUVReflectionMapping: ce
    },
          ih = {
      RepeatWrapping: ue,
      ClampToEdgeWrapping: pe,
      MirroredRepeatWrapping: he
    },
          sh = {
      NearestFilter: de,
      NearestMipmapNearestFilter: fe,
      NearestMipmapLinearFilter: me,
      LinearFilter: ve,
      LinearMipmapNearestFilter: be,
      LinearMipmapLinearFilter: ye
    };

    class oh extends Mp {
      constructor(e) {
        super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
          premultiplyAlpha: "none"
        };
      }

      setOptions(e) {
        return this.options = e, this;
      }

      load(e, t, n, r) {
        void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
        const i = this,
              s = yp.get(e);
        if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function () {
          t && t(s), i.manager.itemEnd(e);
        }, 0), s;
        const o = {};
        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function (e) {
          return e.blob();
        }).then(function (e) {
          return createImageBitmap(e, Object.assign(i.options, {
            colorSpaceConversion: "none"
          }));
        }).then(function (n) {
          yp.add(e, n), t && t(n), i.manager.itemEnd(e);
        }).catch(function (t) {
          r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
        }), i.manager.itemStart(e);
      }

    }

    let ah;
    const lh = {
      getContext: function () {
        return void 0 === ah && (ah = new (window.AudioContext || window.webkitAudioContext)()), ah;
      },
      setContext: function (e) {
        ah = e;
      }
    };

    class ch extends Mp {
      constructor(e) {
        super(e);
      }

      load(e, t, n, r) {
        const i = this,
              s = new Ep(this.manager);
        s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (n) {
          try {
            const e = n.slice(0);
            lh.getContext().decodeAudioData(e, function (e) {
              t(e);
            });
          } catch (t) {
            r ? r(t) : console.error(t), i.manager.itemError(e);
          }
        }, n, r);
      }

    }

    class uh extends Jp {
      constructor(e, t, n = 1) {
        super(void 0, n), this.isHemisphereLightProbe = !0;
        const r = new Xn().set(e),
              i = new Xn().set(t),
              s = new lr(r.r, r.g, r.b),
              o = new lr(i.r, i.g, i.b),
              a = Math.sqrt(Math.PI),
              l = a * Math.sqrt(.75);
        this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l);
      }

    }

    class ph extends Jp {
      constructor(e, t = 1) {
        super(void 0, t), this.isAmbientLightProbe = !0;
        const n = new Xn().set(e);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
      }

    }

    const hh = new Br(),
          dh = new Br(),
          fh = new Br();

    class _h {
      constructor() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new gs(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new gs(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null
        };
      }

      update(e) {
        const t = this._cache;

        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
          t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, fh.copy(e.projectionMatrix);
          const n = t.eyeSep / 2,
                r = n * t.near / t.focus,
                i = t.near * Math.tan(yn * t.fov * .5) / t.zoom;
          let s, o;
          dh.elements[12] = -n, hh.elements[12] = n, s = -i * t.aspect + r, o = i * t.aspect + r, fh.elements[0] = 2 * t.near / (o - s), fh.elements[8] = (o + s) / (o - s), this.cameraL.projectionMatrix.copy(fh), s = -i * t.aspect - r, o = i * t.aspect - r, fh.elements[0] = 2 * t.near / (o - s), fh.elements[8] = (o + s) / (o - s), this.cameraR.projectionMatrix.copy(fh);
        }

        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(dh), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(hh);
      }

    }

    class mh {
      constructor(e = !0) {
        this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
      }

      start() {
        this.startTime = gh(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
      }

      stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1;
      }

      getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
      }

      getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;

        if (this.running) {
          const t = gh();
          e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
        }

        return e;
      }

    }

    function gh() {
      return ("undefined" == typeof performance ? Date : performance).now();
    }

    const vh = new lr(),
          bh = new ar(),
          xh = new lr(),
          yh = new lr();

    class wh extends ui {
      constructor() {
        super(), this.type = "AudioListener", this.context = lh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new mh();
      }

      getInput() {
        return this.gain;
      }

      removeFilter() {
        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
      }

      getFilter() {
        return this.filter;
      }

      setFilter(e) {
        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
      }

      getMasterVolume() {
        return this.gain.gain.value;
      }

      setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
      }

      updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener,
              n = this.up;

        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(vh, bh, xh), yh.set(0, 0, -1).applyQuaternion(bh), t.positionX) {
          const e = this.context.currentTime + this.timeDelta;
          t.positionX.linearRampToValueAtTime(vh.x, e), t.positionY.linearRampToValueAtTime(vh.y, e), t.positionZ.linearRampToValueAtTime(vh.z, e), t.forwardX.linearRampToValueAtTime(yh.x, e), t.forwardY.linearRampToValueAtTime(yh.y, e), t.forwardZ.linearRampToValueAtTime(yh.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e);
        } else t.setPosition(vh.x, vh.y, vh.z), t.setOrientation(yh.x, yh.y, yh.z, n.x, n.y, n.z);
      }

    }

    class Sh extends ui {
      constructor(e) {
        super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
      }

      getOutput() {
        return this.gain;
      }

      setNodeSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
      }

      setMediaElementSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
      }

      setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
      }

      setBuffer(e) {
        return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
      }

      play(e = 0) {
        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
      }

      pause() {
        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }

      stop() {
        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }

      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);

          for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);

          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());

        return this._connected = !0, this;
      }

      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);

          for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);

          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());

        return this._connected = !1, this;
      }

      getFilters() {
        return this.filters;
      }

      setFilters(e) {
        return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
      }

      setDetune(e) {
        if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
      }

      getDetune() {
        return this.detune;
      }

      getFilter() {
        return this.getFilters()[0];
      }

      setFilter(e) {
        return this.setFilters(e ? [e] : []);
      }

      setPlaybackRate(e) {
        if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }

      getPlaybackRate() {
        return this.playbackRate;
      }

      onEnded() {
        this.isPlaying = !1;
      }

      getLoop() {
        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
      }

      setLoop(e) {
        if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }

      setLoopStart(e) {
        return this.loopStart = e, this;
      }

      setLoopEnd(e) {
        return this.loopEnd = e, this;
      }

      getVolume() {
        return this.gain.gain.value;
      }

      setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
      }

    }

    const Mh = new lr(),
          Th = new ar(),
          Eh = new lr(),
          Ah = new lr();

    class Ch extends Sh {
      constructor(e) {
        super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
      }

      disconnect() {
        super.disconnect(), this.panner.disconnect(this.gain);
      }

      getOutput() {
        return this.panner;
      }

      getRefDistance() {
        return this.panner.refDistance;
      }

      setRefDistance(e) {
        return this.panner.refDistance = e, this;
      }

      getRolloffFactor() {
        return this.panner.rolloffFactor;
      }

      setRolloffFactor(e) {
        return this.panner.rolloffFactor = e, this;
      }

      getDistanceModel() {
        return this.panner.distanceModel;
      }

      setDistanceModel(e) {
        return this.panner.distanceModel = e, this;
      }

      getMaxDistance() {
        return this.panner.maxDistance;
      }

      setMaxDistance(e) {
        return this.panner.maxDistance = e, this;
      }

      setDirectionalCone(e, t, n) {
        return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
      }

      updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
        this.matrixWorld.decompose(Mh, Th, Eh), Ah.set(0, 0, 1).applyQuaternion(Th);
        const t = this.panner;

        if (t.positionX) {
          const e = this.context.currentTime + this.listener.timeDelta;
          t.positionX.linearRampToValueAtTime(Mh.x, e), t.positionY.linearRampToValueAtTime(Mh.y, e), t.positionZ.linearRampToValueAtTime(Mh.z, e), t.orientationX.linearRampToValueAtTime(Ah.x, e), t.orientationY.linearRampToValueAtTime(Ah.y, e), t.orientationZ.linearRampToValueAtTime(Ah.z, e);
        } else t.setPosition(Mh.x, Mh.y, Mh.z), t.setOrientation(Ah.x, Ah.y, Ah.z);
      }

    }

    class Rh {
      constructor(e, t = 2048) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
      }

      getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data;
      }

      getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();

        for (let n = 0; n < t.length; n++) e += t[n];

        return e / t.length;
      }

    }

    class kh {
      constructor(e, t, n) {
        let r, i, s;

        switch (this.binding = e, this.valueSize = n, t) {
          case "quaternion":
            r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
            break;

          case "string":
          case "bool":
            r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
            break;

          default:
            r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
        }

        this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
      }

      accumulate(e, t) {
        const n = this.buffer,
              r = this.valueSize,
              i = e * r + r;
        let s = this.cumulativeWeight;

        if (0 === s) {
          for (let e = 0; e !== r; ++e) n[i + e] = n[e];

          s = t;
        } else {
          s += t;
          const e = t / s;

          this._mixBufferRegion(n, i, 0, e, r);
        }

        this.cumulativeWeight = s;
      }

      accumulateAdditive(e) {
        const t = this.buffer,
              n = this.valueSize,
              r = n * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e;
      }

      apply(e) {
        const t = this.valueSize,
              n = this.buffer,
              r = e * t + t,
              i = this.cumulativeWeight,
              s = this.cumulativeWeightAdditive,
              o = this.binding;

        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
          const e = t * this._origIndex;

          this._mixBufferRegion(n, r, e, 1 - i, t);
        }

        s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);

        for (let e = t, i = t + t; e !== i; ++e) if (n[e] !== n[e + t]) {
          o.setValue(n, r);
          break;
        }
      }

      saveOriginalState() {
        const e = this.binding,
              t = this.buffer,
              n = this.valueSize,
              r = n * this._origIndex;
        e.getValue(t, r);

        for (let e = n, i = r; e !== i; ++e) t[e] = t[r + e % n];

        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
      }

      restoreOriginalState() {
        const e = 3 * this.valueSize;
        this.binding.setValue(this.buffer, e);
      }

      _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
              t = e + this.valueSize;

        for (let n = e; n < t; n++) this.buffer[n] = 0;
      }

      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }

      _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
              t = this._addIndex * this.valueSize;

        for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n];
      }

      _select(e, t, n, r, i) {
        if (r >= .5) for (let r = 0; r !== i; ++r) e[t + r] = e[n + r];
      }

      _slerp(e, t, n, r) {
        ar.slerpFlat(e, t, e, t, e, n, r);
      }

      _slerpAdditive(e, t, n, r, i) {
        const s = this._workIndex * i;
        ar.multiplyQuaternionsFlat(e, s, e, t, e, n), ar.slerpFlat(e, t, e, t, e, s, r);
      }

      _lerp(e, t, n, r, i) {
        const s = 1 - r;

        for (let o = 0; o !== i; ++o) {
          const i = t + o;
          e[i] = e[i] * s + e[n + o] * r;
        }
      }

      _lerpAdditive(e, t, n, r, i) {
        for (let s = 0; s !== i; ++s) {
          const i = t + s;
          e[i] = e[i] + e[n + s] * r;
        }
      }

    }

    const Ph = new RegExp("[\\[\\]\\.:\\/]", "g"),
          Dh = "[^\\[\\]\\.:\\/]",
          Oh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
          Lh = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Dh) + /(WCOD+)?/.source.replace("WCOD", Oh) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dh) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dh) + "$"),
          Ih = ["material", "materials", "bones"];

    class Fh {
      constructor(e, t, n) {
        this.path = t, this.parsedPath = n || Fh.parseTrackName(t), this.node = Fh.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }

      static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new Fh.Composite(e, t, n) : new Fh(e, t, n);
      }

      static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(Ph, "");
      }

      static parseTrackName(e) {
        const t = Lh.exec(e);
        if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
          nodeName: t[2],
          objectName: t[3],
          objectIndex: t[4],
          propertyName: t[5],
          propertyIndex: t[6]
        },
              r = n.nodeName && n.nodeName.lastIndexOf(".");

        if (void 0 !== r && -1 !== r) {
          const e = n.nodeName.substring(r + 1);
          -1 !== Ih.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e);
        }

        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n;
      }

      static findNode(e, t) {
        if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;

        if (e.skeleton) {
          const n = e.skeleton.getBoneByName(t);
          if (void 0 !== n) return n;
        }

        if (e.children) {
          const n = function (e) {
            for (let r = 0; r < e.length; r++) {
              const i = e[r];
              if (i.name === t || i.uuid === t) return i;
              const s = n(i.children);
              if (s) return s;
            }

            return null;
          },
                r = n(e.children);

          if (r) return r;
        }

        return null;
      }

      _getValue_unavailable() {}

      _setValue_unavailable() {}

      _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
      }

      _getValue_array(e, t) {
        const n = this.resolvedProperty;

        for (let r = 0, i = n.length; r !== i; ++r) e[t++] = n[r];
      }

      _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
      }

      _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
      }

      _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
      }

      _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
      }

      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
      }

      _setValue_array(e, t) {
        const n = this.resolvedProperty;

        for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
      }

      _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;

        for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];

        this.targetObject.needsUpdate = !0;
      }

      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;

        for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];

        this.targetObject.matrixWorldNeedsUpdate = !0;
      }

      _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
      }

      _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
      }

      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
      }

      _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
      }

      _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
      }

      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
      }

      _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
      }

      _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
      }

      bind() {
        let e = this.node;
        const t = this.parsedPath,
              n = t.objectName,
              r = t.propertyName;
        let i = t.propertyIndex;
        if (e || (e = Fh.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");

        if (n) {
          let r = t.objectIndex;

          switch (n) {
            case "materials":
              if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              e = e.material.materials;
              break;

            case "bones":
              if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              e = e.skeleton.bones;

              for (let t = 0; t < e.length; t++) if (e[t].name === r) {
                r = t;
                break;
              }

              break;

            default:
              if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              e = e[n];
          }

          if (void 0 !== r) {
            if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
            e = e[r];
          }
        }

        const s = e[r];

        if (void 0 === s) {
          const n = t.nodeName;
          return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e);
        }

        let o = this.Versioning.None;
        this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;

        if (void 0 !== i) {
          if ("morphTargetInfluences" === r) {
            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i]);
          }

          a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i;
        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;

        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o];
      }

      unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }

    }

    Fh.Composite = class {
      constructor(e, t, n) {
        const r = n || Fh.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, r);
      }

      getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
              r = this._bindings[n];
        void 0 !== r && r.getValue(e, t);
      }

      setValue(e, t) {
        const n = this._bindings;

        for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t);
      }

      bind() {
        const e = this._bindings;

        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
      }

      unbind() {
        const e = this._bindings;

        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
      }

    }, Fh.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    }, Fh.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    }, Fh.prototype.GetterByBindingType = [Fh.prototype._getValue_direct, Fh.prototype._getValue_array, Fh.prototype._getValue_arrayElement, Fh.prototype._getValue_toArray], Fh.prototype.SetterByBindingTypeAndVersioning = [[Fh.prototype._setValue_direct, Fh.prototype._setValue_direct_setNeedsUpdate, Fh.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Fh.prototype._setValue_array, Fh.prototype._setValue_array_setNeedsUpdate, Fh.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Fh.prototype._setValue_arrayElement, Fh.prototype._setValue_arrayElement_setNeedsUpdate, Fh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Fh.prototype._setValue_fromArray, Fh.prototype._setValue_fromArray_setNeedsUpdate, Fh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

    class Nh {
      constructor() {
        this.isAnimationObjectGroup = !0, this.uuid = Sn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;

        for (let t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;

        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
          objects: {
            get total() {
              return t._objects.length;
            },

            get inUse() {
              return this.total - t.nCachedObjects_;
            }

          },

          get bindingsPerObject() {
            return t._bindings.length;
          }

        };
      }

      add() {
        const e = this._objects,
              t = this._indicesByUUID,
              n = this._paths,
              r = this._parsedPaths,
              i = this._bindings,
              s = i.length;
        let o,
            a = e.length,
            l = this.nCachedObjects_;

        for (let c = 0, u = arguments.length; c !== u; ++c) {
          const u = arguments[c],
                p = u.uuid;
          let h = t[p];

          if (void 0 === h) {
            h = a++, t[p] = h, e.push(u);

            for (let e = 0, t = s; e !== t; ++e) i[e].push(new Fh(u, n[e], r[e]));
          } else if (h < l) {
            o = e[h];
            const a = --l,
                  c = e[a];
            t[c.uuid] = h, e[h] = c, t[p] = a, e[a] = u;

            for (let e = 0, t = s; e !== t; ++e) {
              const t = i[e],
                    s = t[a];
              let o = t[h];
              t[h] = s, void 0 === o && (o = new Fh(u, n[e], r[e])), t[a] = o;
            }
          } else e[h] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }

        this.nCachedObjects_ = l;
      }

      remove() {
        const e = this._objects,
              t = this._indicesByUUID,
              n = this._bindings,
              r = n.length;
        let i = this.nCachedObjects_;

        for (let s = 0, o = arguments.length; s !== o; ++s) {
          const o = arguments[s],
                a = o.uuid,
                l = t[a];

          if (void 0 !== l && l >= i) {
            const s = i++,
                  c = e[s];
            t[c.uuid] = l, e[l] = c, t[a] = s, e[s] = o;

            for (let e = 0, t = r; e !== t; ++e) {
              const t = n[e],
                    r = t[s],
                    i = t[l];
              t[l] = r, t[s] = i;
            }
          }
        }

        this.nCachedObjects_ = i;
      }

      uncache() {
        const e = this._objects,
              t = this._indicesByUUID,
              n = this._bindings,
              r = n.length;
        let i = this.nCachedObjects_,
            s = e.length;

        for (let o = 0, a = arguments.length; o !== a; ++o) {
          const a = arguments[o].uuid,
                l = t[a];
          if (void 0 !== l) if (delete t[a], l < i) {
            const o = --i,
                  a = e[o],
                  c = --s,
                  u = e[c];
            t[a.uuid] = l, e[l] = a, t[u.uuid] = o, e[o] = u, e.pop();

            for (let e = 0, t = r; e !== t; ++e) {
              const t = n[e],
                    r = t[o],
                    i = t[c];
              t[l] = r, t[o] = i, t.pop();
            }
          } else {
            const i = --s,
                  o = e[i];
            i > 0 && (t[o.uuid] = l), e[l] = o, e.pop();

            for (let e = 0, t = r; e !== t; ++e) {
              const t = n[e];
              t[l] = t[i], t.pop();
            }
          }
        }

        this.nCachedObjects_ = i;
      }

      subscribe_(e, t) {
        const n = this._bindingsIndicesByPath;
        let r = n[e];
        const i = this._bindings;
        if (void 0 !== r) return i[r];
        const s = this._paths,
              o = this._parsedPaths,
              a = this._objects,
              l = a.length,
              c = this.nCachedObjects_,
              u = new Array(l);
        r = i.length, n[e] = r, s.push(e), o.push(t), i.push(u);

        for (let n = c, r = a.length; n !== r; ++n) {
          const r = a[n];
          u[n] = new Fh(r, e, t);
        }

        return u;
      }

      unsubscribe_(e) {
        const t = this._bindingsIndicesByPath,
              n = t[e];

        if (void 0 !== n) {
          const r = this._paths,
                i = this._parsedPaths,
                s = this._bindings,
                o = s.length - 1,
                a = s[o];
          t[e[o]] = n, s[n] = a, s.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop();
        }
      }

    }

    class Uh {
      constructor(e, t, n = null, r = t.blendMode) {
        this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
        const i = t.tracks,
              s = i.length,
              o = new Array(s),
              a = {
          endingStart: Mt,
          endingEnd: Mt
        };

        for (let e = 0; e !== s; ++e) {
          const t = i[e].createInterpolant(null);
          o[e] = t, t.settings = a;
        }

        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = bt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
      }

      play() {
        return this._mixer._activateAction(this), this;
      }

      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }

      reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
      }

      isRunning() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
      }

      isScheduled() {
        return this._mixer._isActiveAction(this);
      }

      startAt(e) {
        return this._startTime = e, this;
      }

      setLoop(e, t) {
        return this.loop = e, this.repetitions = t, this;
      }

      setEffectiveWeight(e) {
        return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
      }

      getEffectiveWeight() {
        return this._effectiveWeight;
      }

      fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
      }

      fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
      }

      crossFadeFrom(e, t, n) {
        if (e.fadeOut(t), this.fadeIn(t), n) {
          const n = this._clip.duration,
                r = e._clip.duration,
                i = r / n,
                s = n / r;
          e.warp(1, i, t), this.warp(s, 1, t);
        }

        return this;
      }

      crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n);
      }

      stopFading() {
        const e = this._weightInterpolant;
        return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
      }

      setEffectiveTimeScale(e) {
        return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
      }

      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }

      setDuration(e) {
        return this.timeScale = this._clip.duration / e, this.stopWarping();
      }

      syncWith(e) {
        return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
      }

      halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
      }

      warp(e, t, n) {
        const r = this._mixer,
              i = r.time,
              s = this.timeScale;
        let o = this._timeScaleInterpolant;
        null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
        const a = o.parameterPositions,
              l = o.sampleValues;
        return a[0] = i, a[1] = i + n, l[0] = e / s, l[1] = t / s, this;
      }

      stopWarping() {
        const e = this._timeScaleInterpolant;
        return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
      }

      getMixer() {
        return this._mixer;
      }

      getClip() {
        return this._clip;
      }

      getRoot() {
        return this._localRoot || this._mixer._root;
      }

      _update(e, t, n, r) {
        if (!this.enabled) return void this._updateWeight(e);
        const i = this._startTime;

        if (null !== i) {
          const r = (e - i) * n;
          if (r < 0 || 0 === n) return;
          this._startTime = null, t = n * r;
        }

        t *= this._updateTimeScale(e);

        const s = this._updateTime(t),
              o = this._updateWeight(e);

        if (o > 0) {
          const e = this._interpolants,
                t = this._propertyBindings;
          if (this.blendMode === Ct) for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(s), t[n].accumulateAdditive(o);else for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(s), t[n].accumulate(r, o);
        }
      }

      _updateWeight(e) {
        let t = 0;

        if (this.enabled) {
          t = this.weight;
          const n = this._weightInterpolant;

          if (null !== n) {
            const r = n.evaluate(e)[0];
            t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1));
          }
        }

        return this._effectiveWeight = t, t;
      }

      _updateTimeScale(e) {
        let t = 0;

        if (!this.paused) {
          t = this.timeScale;
          const n = this._timeScaleInterpolant;
          null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t));
        }

        return this._effectiveTimeScale = t, t;
      }

      _updateTime(e) {
        const t = this._clip.duration,
              n = this.loop;
        let r = this.time + e,
            i = this._loopCount;
        const s = n === xt;
        if (0 === e) return -1 === i ? r : s && 1 == (1 & i) ? t - r : r;

        if (n === vt) {
          -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));

          e: {
            if (r >= t) r = t;else {
              if (!(r < 0)) {
                this.time = r;
                break e;
              }

              r = 0;
            }
            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e < 0 ? -1 : 1
            });
          }
        } else {
          if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= t || r < 0) {
            const n = Math.floor(r / t);
            r -= t * n, i += Math.abs(n);
            const o = this.repetitions - i;
            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1
            });else {
              if (1 === o) {
                const t = e < 0;

                this._setEndings(t, !t, s);
              } else this._setEndings(!1, !1, s);

              this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: n
              });
            }
          } else this.time = r;

          if (s && 1 == (1 & i)) return t - r;
        }

        return r;
      }

      _setEndings(e, t, n) {
        const r = this._interpolantSettings;
        n ? (r.endingStart = Tt, r.endingEnd = Tt) : (r.endingStart = e ? this.zeroSlopeAtStart ? Tt : Mt : Et, r.endingEnd = t ? this.zeroSlopeAtEnd ? Tt : Mt : Et);
      }

      _scheduleFading(e, t, n) {
        const r = this._mixer,
              i = r.time;
        let s = this._weightInterpolant;
        null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s);
        const o = s.parameterPositions,
              a = s.sampleValues;
        return o[0] = i, a[0] = t, o[1] = i + e, a[1] = n, this;
      }

    }

    const Bh = new Float32Array(1);

    class jh extends vn {
      constructor(e) {
        super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
      }

      _bindAction(e, t) {
        const n = e._localRoot || this._root,
              r = e._clip.tracks,
              i = r.length,
              s = e._propertyBindings,
              o = e._interpolants,
              a = n.uuid,
              l = this._bindingsByRootAndName;
        let c = l[a];
        void 0 === c && (c = {}, l[a] = c);

        for (let e = 0; e !== i; ++e) {
          const i = r[e],
                l = i.name;
          let u = c[l];
          if (void 0 !== u) ++u.referenceCount, s[e] = u;else {
            if (u = s[e], void 0 !== u) {
              null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, l));
              continue;
            }

            const r = t && t._propertyBindings[e].binding.parsedPath;
            u = new kh(Fh.create(n, l, r), i.ValueTypeName, i.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, l), s[e] = u;
          }
          o[e].resultBuffer = u.buffer;
        }
      }

      _activateAction(e) {
        if (!this._isActiveAction(e)) {
          if (null === e._cacheIndex) {
            const t = (e._localRoot || this._root).uuid,
                  n = e._clip.uuid,
                  r = this._actionsByClip[n];
            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t);
          }

          const t = e._propertyBindings;

          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
          }

          this._lendAction(e);
        }
      }

      _deactivateAction(e) {
        if (this._isActiveAction(e)) {
          const t = e._propertyBindings;

          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n));
          }

          this._takeBackAction(e);
        }
      }

      _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
          actions: {
            get total() {
              return e._actions.length;
            },

            get inUse() {
              return e._nActiveActions;
            }

          },
          bindings: {
            get total() {
              return e._bindings.length;
            },

            get inUse() {
              return e._nActiveBindings;
            }

          },
          controlInterpolants: {
            get total() {
              return e._controlInterpolants.length;
            },

            get inUse() {
              return e._nActiveControlInterpolants;
            }

          }
        };
      }

      _isActiveAction(e) {
        const t = e._cacheIndex;
        return null !== t && t < this._nActiveActions;
      }

      _addInactiveAction(e, t, n) {
        const r = this._actions,
              i = this._actionsByClip;
        let s = i[t];
        if (void 0 === s) s = {
          knownActions: [e],
          actionByRoot: {}
        }, e._byClipCacheIndex = 0, i[t] = s;else {
          const t = s.knownActions;
          e._byClipCacheIndex = t.length, t.push(e);
        }
        e._cacheIndex = r.length, r.push(e), s.actionByRoot[n] = e;
      }

      _removeInactiveAction(e) {
        const t = this._actions,
              n = t[t.length - 1],
              r = e._cacheIndex;
        n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
        const i = e._clip.uuid,
              s = this._actionsByClip,
              o = s[i],
              a = o.knownActions,
              l = a[a.length - 1],
              c = e._byClipCacheIndex;
        l._byClipCacheIndex = c, a[c] = l, a.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === a.length && delete s[i], this._removeInactiveBindingsForAction(e);
      }

      _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;

        for (let e = 0, n = t.length; e !== n; ++e) {
          const n = t[e];
          0 == --n.referenceCount && this._removeInactiveBinding(n);
        }
      }

      _lendAction(e) {
        const t = this._actions,
              n = e._cacheIndex,
              r = this._nActiveActions++,
              i = t[r];
        e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
      }

      _takeBackAction(e) {
        const t = this._actions,
              n = e._cacheIndex,
              r = --this._nActiveActions,
              i = t[r];
        e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
      }

      _addInactiveBinding(e, t, n) {
        const r = this._bindingsByRootAndName,
              i = this._bindings;
        let s = r[t];
        void 0 === s && (s = {}, r[t] = s), s[n] = e, e._cacheIndex = i.length, i.push(e);
      }

      _removeInactiveBinding(e) {
        const t = this._bindings,
              n = e.binding,
              r = n.rootNode.uuid,
              i = n.path,
              s = this._bindingsByRootAndName,
              o = s[r],
              a = t[t.length - 1],
              l = e._cacheIndex;
        a._cacheIndex = l, t[l] = a, t.pop(), delete o[i], 0 === Object.keys(o).length && delete s[r];
      }

      _lendBinding(e) {
        const t = this._bindings,
              n = e._cacheIndex,
              r = this._nActiveBindings++,
              i = t[r];
        e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
      }

      _takeBackBinding(e) {
        const t = this._bindings,
              n = e._cacheIndex,
              r = --this._nActiveBindings,
              i = t[r];
        e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i;
      }

      _lendControlInterpolant() {
        const e = this._controlInterpolants,
              t = this._nActiveControlInterpolants++;
        let n = e[t];
        return void 0 === n && (n = new cp(new Float32Array(2), new Float32Array(2), 1, Bh), n.__cacheIndex = t, e[t] = n), n;
      }

      _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
              n = e.__cacheIndex,
              r = --this._nActiveControlInterpolants,
              i = t[r];
        e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i;
      }

      clipAction(e, t, n) {
        const r = t || this._root,
              i = r.uuid;
        let s = "string" == typeof e ? bp.findByName(r, e) : e;
        const o = null !== s ? s.uuid : e,
              a = this._actionsByClip[o];
        let l = null;

        if (void 0 === n && (n = null !== s ? s.blendMode : At), void 0 !== a) {
          const e = a.actionByRoot[i];
          if (void 0 !== e && e.blendMode === n) return e;
          l = a.knownActions[0], null === s && (s = l._clip);
        }

        if (null === s) return null;
        const c = new Uh(this, s, t, n);
        return this._bindAction(c, l), this._addInactiveAction(c, o, i), c;
      }

      existingAction(e, t) {
        const n = t || this._root,
              r = n.uuid,
              i = "string" == typeof e ? bp.findByName(n, e) : e,
              s = i ? i.uuid : e,
              o = this._actionsByClip[s];
        return void 0 !== o && o.actionByRoot[r] || null;
      }

      stopAllAction() {
        const e = this._actions;

        for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();

        return this;
      }

      update(e) {
        e *= this.timeScale;
        const t = this._actions,
              n = this._nActiveActions,
              r = this.time += e,
              i = Math.sign(e),
              s = this._accuIndex ^= 1;

        for (let o = 0; o !== n; ++o) t[o]._update(r, e, i, s);

        const o = this._bindings,
              a = this._nActiveBindings;

        for (let e = 0; e !== a; ++e) o[e].apply(s);

        return this;
      }

      setTime(e) {
        this.time = 0;

        for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;

        return this.update(e);
      }

      getRoot() {
        return this._root;
      }

      uncacheClip(e) {
        const t = this._actions,
              n = e.uuid,
              r = this._actionsByClip,
              i = r[n];

        if (void 0 !== i) {
          const e = i.knownActions;

          for (let n = 0, r = e.length; n !== r; ++n) {
            const r = e[n];

            this._deactivateAction(r);

            const i = r._cacheIndex,
                  s = t[t.length - 1];
            r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, t[i] = s, t.pop(), this._removeInactiveBindingsForAction(r);
          }

          delete r[n];
        }
      }

      uncacheRoot(e) {
        const t = e.uuid,
              n = this._actionsByClip;

        for (const e in n) {
          const r = n[e].actionByRoot[t];
          void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r));
        }

        const r = this._bindingsByRootAndName[t];
        if (void 0 !== r) for (const e in r) {
          const t = r[e];
          t.restoreOriginalState(), this._removeInactiveBinding(t);
        }
      }

      uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
      }

    }

    class zh {
      constructor(e) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
      }

      clone() {
        return new zh(void 0 === this.value.clone ? this.value : this.value.clone());
      }

    }

    let Vh = 0;

    class Gh extends vn {
      constructor() {
        super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
          value: Vh++
        }), this.name = "", this.usage = on, this.uniforms = [];
      }

      add(e) {
        return this.uniforms.push(e), this;
      }

      remove(e) {
        const t = this.uniforms.indexOf(e);
        return -1 !== t && this.uniforms.splice(t, 1), this;
      }

      setName(e) {
        return this.name = e, this;
      }

      setUsage(e) {
        return this.usage = e, this;
      }

      dispose() {
        return this.dispatchEvent({
          type: "dispose"
        }), this;
      }

      copy(e) {
        this.name = e.name, this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;

        for (let e = 0, n = t.length; e < n; e++) this.uniforms.push(t[e].clone());

        return this;
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    class Hh extends _l {
      constructor(e, t, n = 1) {
        super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
      }

      copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
      }

      clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute, t;
      }

      toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
      }

    }

    class Wh {
      constructor(e, t, n, r, i) {
        this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0;
      }

      set needsUpdate(e) {
        !0 === e && this.version++;
      }

      setBuffer(e) {
        return this.buffer = e, this;
      }

      setType(e, t) {
        return this.type = e, this.elementSize = t, this;
      }

      setItemSize(e) {
        return this.itemSize = e, this;
      }

      setCount(e) {
        return this.count = e, this;
      }

    }

    class Kh {
      constructor(e, t, n = 0, r = 1 / 0) {
        this.ray = new Ur(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new Zr(), this.params = {
          Mesh: {},
          Line: {
            threshold: 1
          },
          LOD: {},
          Points: {
            threshold: 1
          },
          Sprite: {}
        };
      }

      set(e, t) {
        this.ray.set(e, t);
      }

      setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
      }

      intersectObject(e, t = !0, n = []) {
        return qh(e, this, n, t), n.sort(Xh), n;
      }

      intersectObjects(e, t = !0, n = []) {
        for (let r = 0, i = e.length; r < i; r++) qh(e[r], this, n, t);

        return n.sort(Xh), n;
      }

    }

    function Xh(e, t) {
      return e.distance - t.distance;
    }

    function qh(e, t, n, r) {
      if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) {
        const r = e.children;

        for (let e = 0, i = r.length; e < i; e++) qh(r[e], t, n, !0);
      }
    }

    class Yh {
      constructor(e = 1, t = 0, n = 0) {
        return this.radius = e, this.phi = t, this.theta = n, this;
      }

      set(e, t, n) {
        return this.radius = e, this.phi = t, this.theta = n, this;
      }

      copy(e) {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
      }

      makeSafe() {
        const e = 1e-6;
        return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this;
      }

      setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
      }

      setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Mn(t / this.radius, -1, 1))), this;
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    class Zh {
      constructor(e = 1, t = 0, n = 0) {
        return this.radius = e, this.theta = t, this.y = n, this;
      }

      set(e, t, n) {
        return this.radius = e, this.theta = t, this.y = n, this;
      }

      copy(e) {
        return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
      }

      setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
      }

      setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    const Jh = new Pn();

    class $h {
      constructor(e = new Pn(1 / 0, 1 / 0), t = new Pn(-1 / 0, -1 / 0)) {
        this.isBox2 = !0, this.min = e, this.max = t;
      }

      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }

      setFromPoints(e) {
        this.makeEmpty();

        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);

        return this;
      }

      setFromCenterAndSize(e, t) {
        const n = Jh.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }

      clone() {
        return new this.constructor().copy(this);
      }

      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }

      makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
      }

      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }

      getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
      }

      getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
      }

      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }

      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }

      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }

      containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
      }

      containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
      }

      getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
      }

      intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
      }

      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }

      distanceToPoint(e) {
        return Jh.copy(e).clamp(this.min, this.max).sub(e).length();
      }

      intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this;
      }

      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }

      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }

      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }

    }

    const Qh = new lr(),
          ed = new lr();

    class td {
      constructor(e = new lr(), t = new lr()) {
        this.start = e, this.end = t;
      }

      set(e, t) {
        return this.start.copy(e), this.end.copy(t), this;
      }

      copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this;
      }

      getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5);
      }

      delta(e) {
        return e.subVectors(this.end, this.start);
      }

      distanceSq() {
        return this.start.distanceToSquared(this.end);
      }

      distance() {
        return this.start.distanceTo(this.end);
      }

      at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start);
      }

      closestPointToPointParameter(e, t) {
        Qh.subVectors(e, this.start), ed.subVectors(this.end, this.start);
        const n = ed.dot(ed);
        let r = ed.dot(Qh) / n;
        return t && (r = Mn(r, 0, 1)), r;
      }

      closestPointToPoint(e, t, n) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(n).multiplyScalar(r).add(this.start);
      }

      applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
      }

      equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end);
      }

      clone() {
        return new this.constructor().copy(this);
      }

    }

    const nd = new lr();

    class rd extends ui {
      constructor(e, t) {
        super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
        const n = new Wi(),
              r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

        for (let e = 0, t = 1, n = 32; e < n; e++, t++) {
          const i = e / n * Math.PI * 2,
                s = t / n * Math.PI * 2;
          r.push(Math.cos(i), Math.sin(i), 1, Math.cos(s), Math.sin(s), 1);
        }

        n.setAttribute("position", new Fi(r, 3));
        const i = new ec({
          fog: !1,
          toneMapped: !1
        });
        this.cone = new cc(n, i), this.add(this.cone), this.update();
      }

      dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }

      update() {
        this.light.updateMatrixWorld();
        const e = this.light.distance ? this.light.distance : 1e3,
              t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e), nd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(nd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
      }

    }

    const id = new lr(),
          sd = new Br(),
          od = new Br();

    class ad extends cc {
      constructor(e) {
        const t = ld(e),
              n = new Wi(),
              r = [],
              i = [],
              s = new Xn(0, 0, 1),
              o = new Xn(0, 1, 0);

        for (let e = 0; e < t.length; e++) {
          const n = t[e];
          n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(o.r, o.g, o.b));
        }

        n.setAttribute("position", new Fi(r, 3)), n.setAttribute("color", new Fi(i, 3)), super(n, new ec({
          vertexColors: !0,
          depthTest: !1,
          depthWrite: !1,
          toneMapped: !1,
          transparent: !0
        })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
      }

      updateMatrixWorld(e) {
        const t = this.bones,
              n = this.geometry,
              r = n.getAttribute("position");
        od.copy(this.root.matrixWorld).invert();

        for (let e = 0, n = 0; e < t.length; e++) {
          const i = t[e];
          i.parent && i.parent.isBone && (sd.multiplyMatrices(od, i.matrixWorld), id.setFromMatrixPosition(sd), r.setXYZ(n, id.x, id.y, id.z), sd.multiplyMatrices(od, i.parent.matrixWorld), id.setFromMatrixPosition(sd), r.setXYZ(n + 1, id.x, id.y, id.z), n += 2);
        }

        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
      }

    }

    function ld(e) {
      const t = [];
      !0 === e.isBone && t.push(e);

      for (let n = 0; n < e.children.length; n++) t.push.apply(t, ld(e.children[n]));

      return t;
    }

    class cd extends cs {
      constructor(e, t, n) {
        super(new Fu(t, 4, 2), new Mi({
          wireframe: !0,
          fog: !1,
          toneMapped: !1
        })), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
      }

      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }

      update() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
      }

    }

    const ud = new lr(),
          pd = new Xn(),
          hd = new Xn();

    class dd extends ui {
      constructor(e, t, n) {
        super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
        const r = new Ou(t);
        r.rotateY(.5 * Math.PI), this.material = new Mi({
          wireframe: !0,
          fog: !1,
          toneMapped: !1
        }), void 0 === this.color && (this.material.vertexColors = !0);
        const i = r.getAttribute("position"),
              s = new Float32Array(3 * i.count);
        r.setAttribute("color", new Ai(s, 3)), this.add(new cs(r, this.material)), this.update();
      }

      dispose() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
      }

      update() {
        const e = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);else {
          const t = e.geometry.getAttribute("color");
          pd.copy(this.light.color), hd.copy(this.light.groundColor);

          for (let e = 0, n = t.count; e < n; e++) {
            const r = e < n / 2 ? pd : hd;
            t.setXYZ(e, r.r, r.g, r.b);
          }

          t.needsUpdate = !0;
        }
        e.lookAt(ud.setFromMatrixPosition(this.light.matrixWorld).negate());
      }

    }

    class fd extends cc {
      constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
        n = new Xn(n), r = new Xn(r);
        const i = t / 2,
              s = e / t,
              o = e / 2,
              a = [],
              l = [];

        for (let e = 0, c = 0, u = -o; e <= t; e++, u += s) {
          a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o);
          const t = e === i ? n : r;
          t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3;
        }

        const c = new Wi();
        c.setAttribute("position", new Fi(a, 3)), c.setAttribute("color", new Fi(l, 3)), super(c, new ec({
          vertexColors: !0,
          toneMapped: !1
        })), this.type = "GridHelper";
      }

    }

    class _d extends cc {
      constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, s = 8947848) {
        i = new Xn(i), s = new Xn(s);
        const o = [],
              a = [];

        for (let n = 0; n <= t; n++) {
          const r = n / t * (2 * Math.PI),
                l = Math.sin(r) * e,
                c = Math.cos(r) * e;
          o.push(0, 0, 0), o.push(l, 0, c);
          const u = 1 & n ? i : s;
          a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b);
        }

        for (let t = 0; t <= n; t++) {
          const l = 1 & t ? i : s,
                c = e - e / n * t;

          for (let e = 0; e < r; e++) {
            let t = e / r * (2 * Math.PI),
                n = Math.sin(t) * c,
                i = Math.cos(t) * c;
            o.push(n, 0, i), a.push(l.r, l.g, l.b), t = (e + 1) / r * (2 * Math.PI), n = Math.sin(t) * c, i = Math.cos(t) * c, o.push(n, 0, i), a.push(l.r, l.g, l.b);
          }
        }

        const l = new Wi();
        l.setAttribute("position", new Fi(o, 3)), l.setAttribute("color", new Fi(a, 3)), super(l, new ec({
          vertexColors: !0,
          toneMapped: !1
        })), this.type = "PolarGridHelper";
      }

    }

    const md = new lr(),
          gd = new lr(),
          vd = new lr();

    class bd extends ui {
      constructor(e, t, n) {
        super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
        let r = new Wi();
        r.setAttribute("position", new Fi([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        const i = new ec({
          fog: !1,
          toneMapped: !1
        });
        this.lightPlane = new oc(r, i), this.add(this.lightPlane), r = new Wi(), r.setAttribute("position", new Fi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new oc(r, i), this.add(this.targetLine), this.update();
      }

      dispose() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
      }

      update() {
        md.setFromMatrixPosition(this.light.matrixWorld), gd.setFromMatrixPosition(this.light.target.matrixWorld), vd.subVectors(gd, md), this.lightPlane.lookAt(gd), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(gd), this.targetLine.scale.z = vd.length();
      }

    }

    const xd = new lr(),
          yd = new ms();

    class wd extends cc {
      constructor(e) {
        const t = new Wi(),
              n = new ec({
          color: 16777215,
          vertexColors: !0,
          toneMapped: !1
        }),
              r = [],
              i = [],
              s = {};

        function o(e, t) {
          a(e), a(t);
        }

        function a(e) {
          r.push(0, 0, 0), i.push(0, 0, 0), void 0 === s[e] && (s[e] = []), s[e].push(r.length / 3 - 1);
        }

        o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"), t.setAttribute("position", new Fi(r, 3)), t.setAttribute("color", new Fi(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
        const l = new Xn(16755200),
              c = new Xn(16711680),
              u = new Xn(43775),
              p = new Xn(16777215),
              h = new Xn(3355443);
        this.setColors(l, c, u, p, h);
      }

      setColors(e, t, n, r, i) {
        const s = this.geometry.getAttribute("color");
        s.setXYZ(0, e.r, e.g, e.b), s.setXYZ(1, e.r, e.g, e.b), s.setXYZ(2, e.r, e.g, e.b), s.setXYZ(3, e.r, e.g, e.b), s.setXYZ(4, e.r, e.g, e.b), s.setXYZ(5, e.r, e.g, e.b), s.setXYZ(6, e.r, e.g, e.b), s.setXYZ(7, e.r, e.g, e.b), s.setXYZ(8, e.r, e.g, e.b), s.setXYZ(9, e.r, e.g, e.b), s.setXYZ(10, e.r, e.g, e.b), s.setXYZ(11, e.r, e.g, e.b), s.setXYZ(12, e.r, e.g, e.b), s.setXYZ(13, e.r, e.g, e.b), s.setXYZ(14, e.r, e.g, e.b), s.setXYZ(15, e.r, e.g, e.b), s.setXYZ(16, e.r, e.g, e.b), s.setXYZ(17, e.r, e.g, e.b), s.setXYZ(18, e.r, e.g, e.b), s.setXYZ(19, e.r, e.g, e.b), s.setXYZ(20, e.r, e.g, e.b), s.setXYZ(21, e.r, e.g, e.b), s.setXYZ(22, e.r, e.g, e.b), s.setXYZ(23, e.r, e.g, e.b), s.setXYZ(24, t.r, t.g, t.b), s.setXYZ(25, t.r, t.g, t.b), s.setXYZ(26, t.r, t.g, t.b), s.setXYZ(27, t.r, t.g, t.b), s.setXYZ(28, t.r, t.g, t.b), s.setXYZ(29, t.r, t.g, t.b), s.setXYZ(30, t.r, t.g, t.b), s.setXYZ(31, t.r, t.g, t.b), s.setXYZ(32, n.r, n.g, n.b), s.setXYZ(33, n.r, n.g, n.b), s.setXYZ(34, n.r, n.g, n.b), s.setXYZ(35, n.r, n.g, n.b), s.setXYZ(36, n.r, n.g, n.b), s.setXYZ(37, n.r, n.g, n.b), s.setXYZ(38, r.r, r.g, r.b), s.setXYZ(39, r.r, r.g, r.b), s.setXYZ(40, i.r, i.g, i.b), s.setXYZ(41, i.r, i.g, i.b), s.setXYZ(42, i.r, i.g, i.b), s.setXYZ(43, i.r, i.g, i.b), s.setXYZ(44, i.r, i.g, i.b), s.setXYZ(45, i.r, i.g, i.b), s.setXYZ(46, i.r, i.g, i.b), s.setXYZ(47, i.r, i.g, i.b), s.setXYZ(48, i.r, i.g, i.b), s.setXYZ(49, i.r, i.g, i.b), s.needsUpdate = !0;
      }

      update() {
        const e = this.geometry,
              t = this.pointMap;
        yd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Sd("c", t, e, yd, 0, 0, -1), Sd("t", t, e, yd, 0, 0, 1), Sd("n1", t, e, yd, -1, -1, -1), Sd("n2", t, e, yd, 1, -1, -1), Sd("n3", t, e, yd, -1, 1, -1), Sd("n4", t, e, yd, 1, 1, -1), Sd("f1", t, e, yd, -1, -1, 1), Sd("f2", t, e, yd, 1, -1, 1), Sd("f3", t, e, yd, -1, 1, 1), Sd("f4", t, e, yd, 1, 1, 1), Sd("u1", t, e, yd, .7, 1.1, -1), Sd("u2", t, e, yd, -.7, 1.1, -1), Sd("u3", t, e, yd, 0, 2, -1), Sd("cf1", t, e, yd, -1, 0, 1), Sd("cf2", t, e, yd, 1, 0, 1), Sd("cf3", t, e, yd, 0, -1, 1), Sd("cf4", t, e, yd, 0, 1, 1), Sd("cn1", t, e, yd, -1, 0, -1), Sd("cn2", t, e, yd, 1, 0, -1), Sd("cn3", t, e, yd, 0, -1, -1), Sd("cn4", t, e, yd, 0, 1, -1), e.getAttribute("position").needsUpdate = !0;
      }

      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }

    }

    function Sd(e, t, n, r, i, s, o) {
      xd.set(i, s, o).unproject(r);
      const a = t[e];

      if (void 0 !== a) {
        const e = n.getAttribute("position");

        for (let t = 0, n = a.length; t < n; t++) e.setXYZ(a[t], xd.x, xd.y, xd.z);
      }
    }

    const Md = new pr();

    class Td extends cc {
      constructor(e, t = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
              r = new Float32Array(24),
              i = new Wi();
        i.setIndex(new Ai(n, 1)), i.setAttribute("position", new Ai(r, 3)), super(i, new ec({
          color: t,
          toneMapped: !1
        })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
      }

      update(e) {
        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Md.setFromObject(this.object), Md.isEmpty()) return;
        const t = Md.min,
              n = Md.max,
              r = this.geometry.attributes.position,
              i = r.array;
        i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere();
      }

      setFromObject(e) {
        return this.object = e, this.update(), this;
      }

      copy(e, t) {
        return super.copy(e, t), this.object = e.object, this;
      }

    }

    class Ed extends cc {
      constructor(e, t = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
              r = new Wi();
        r.setIndex(new Ai(n, 1)), r.setAttribute("position", new Fi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new ec({
          color: t,
          toneMapped: !1
        })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
      }

      updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e));
      }

    }

    class Ad extends oc {
      constructor(e, t = 1, n = 16776960) {
        const r = n,
              i = new Wi();
        i.setAttribute("position", new Fi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), super(i, new ec({
          color: r,
          toneMapped: !1
        })), this.type = "PlaneHelper", this.plane = e, this.size = t;
        const s = new Wi();
        s.setAttribute("position", new Fi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new cs(s, new Mi({
          color: r,
          opacity: .2,
          transparent: !0,
          depthWrite: !1,
          toneMapped: !1
        })));
      }

      updateMatrixWorld(e) {
        let t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? _ : f, this.lookAt(this.plane.normal), super.updateMatrixWorld(e);
      }

    }

    const Cd = new lr();
    let Rd, kd;

    class Pd extends ui {
      constructor(e = new lr(0, 0, 1), t = new lr(0, 0, 0), n = 1, r = 16776960, i = .2 * n, s = .2 * i) {
        super(), this.type = "ArrowHelper", void 0 === Rd && (Rd = new Wi(), Rd.setAttribute("position", new Fi([0, 0, 0, 0, 1, 0], 3)), kd = new Xc(0, .5, 1, 5, 1), kd.translate(0, -.5, 0)), this.position.copy(t), this.line = new oc(Rd, new ec({
          color: r,
          toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new cs(kd, new Mi({
          color: r,
          toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, s);
      }

      setDirection(e) {
        if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);else {
          Cd.set(e.z, 0, -e.x).normalize();
          const t = Math.acos(e.y);
          this.quaternion.setFromAxisAngle(Cd, t);
        }
      }

      setLength(e, t = .2 * e, n = .2 * t) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
      }

      setColor(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e);
      }

      copy(e) {
        return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
      }

    }

    class Dd extends cc {
      constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
              n = new Wi();
        n.setAttribute("position", new Fi(t, 3)), n.setAttribute("color", new Fi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new ec({
          vertexColors: !0,
          toneMapped: !1
        })), this.type = "AxesHelper";
      }

      setColors(e, t, n) {
        const r = new Xn(),
              i = this.geometry.attributes.color.array;
        return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this;
      }

      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }

    }

    class Od {
      constructor() {
        this.type = "ShapePath", this.color = new Xn(), this.subPaths = [], this.currentPath = null;
      }

      moveTo(e, t) {
        return this.currentPath = new Gc(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
      }

      lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this;
      }

      quadraticCurveTo(e, t, n, r) {
        return this.currentPath.quadraticCurveTo(e, t, n, r), this;
      }

      bezierCurveTo(e, t, n, r, i, s) {
        return this.currentPath.bezierCurveTo(e, t, n, r, i, s), this;
      }

      splineThru(e) {
        return this.currentPath.splineThru(e), this;
      }

      toShapes(e, t) {
        function n(e) {
          const t = [];

          for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n],
                  i = new nu();
            i.curves = r.curves, t.push(i);
          }

          return t;
        }

        function r(e, t) {
          const n = t.length;
          let r = !1;

          for (let i = n - 1, s = 0; s < n; i = s++) {
            let n = t[i],
                o = t[s],
                a = o.x - n.x,
                l = o.y - n.y;

            if (Math.abs(l) > Number.EPSILON) {
              if (l < 0 && (n = t[s], a = -a, o = t[i], l = -l), e.y < n.y || e.y > o.y) continue;

              if (e.y === n.y) {
                if (e.x === n.x) return !0;
              } else {
                const t = l * (e.x - n.x) - a * (e.y - n.y);
                if (0 === t) return !0;
                if (t < 0) continue;
                r = !r;
              }
            } else {
              if (e.y !== n.y) continue;
              if (o.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= o.x) return !0;
            }
          }

          return r;
        }

        const i = Au.isClockWise,
              s = this.subPaths;
        if (0 === s.length) return [];
        if (!0 === t) return n(s);
        let o, a, l;
        const c = [];
        if (1 === s.length) return a = s[0], l = new nu(), l.curves = a.curves, c.push(l), c;
        let u = !i(s[0].getPoints());
        u = e ? !u : u;
        const p = [],
              h = [];
        let d,
            f,
            _ = [],
            m = 0;
        h[m] = void 0, _[m] = [];

        for (let t = 0, n = s.length; t < n; t++) a = s[t], d = a.getPoints(), o = i(d), o = e ? !o : o, o ? (!u && h[m] && m++, h[m] = {
          s: new nu(),
          p: d
        }, h[m].s.curves = a.curves, u && m++, _[m] = []) : _[m].push({
          h: a,
          p: d[0]
        });

        if (!h[0]) return n(s);

        if (h.length > 1) {
          let e = !1,
              t = 0;

          for (let e = 0, t = h.length; e < t; e++) p[e] = [];

          for (let n = 0, i = h.length; n < i; n++) {
            const i = _[n];

            for (let s = 0; s < i.length; s++) {
              const o = i[s];
              let a = !0;

              for (let i = 0; i < h.length; i++) r(o.p, h[i].p) && (n !== i && t++, a ? (a = !1, p[i].push(o)) : e = !0);

              a && p[n].push(o);
            }
          }

          t > 0 && !1 === e && (_ = p);
        }

        for (let e = 0, t = h.length; e < t; e++) {
          l = h[e].s, c.push(l), f = _[e];

          for (let e = 0, t = f.length; e < t; e++) l.holes.push(f[e].h);
        }

        return c;
      }

    }

    const {
      floatView: Ld,
      uint32View: Id,
      baseTable: Fd,
      shiftTable: Nd,
      mantissaTable: Ud,
      exponentTable: Bd,
      offsetTable: jd
    } = zd();

    function zd() {
      const e = new ArrayBuffer(4),
            t = new Float32Array(e),
            n = new Uint32Array(e),
            r = new Uint32Array(512),
            i = new Uint32Array(512);

      for (let e = 0; e < 256; ++e) {
        const t = e - 127;
        t < -27 ? (r[e] = 0, r[256 | e] = 32768, i[e] = 24, i[256 | e] = 24) : t < -14 ? (r[e] = 1024 >> -t - 14, r[256 | e] = 1024 >> -t - 14 | 32768, i[e] = -t - 1, i[256 | e] = -t - 1) : t <= 15 ? (r[e] = t + 15 << 10, r[256 | e] = t + 15 << 10 | 32768, i[e] = 13, i[256 | e] = 13) : t < 128 ? (r[e] = 31744, r[256 | e] = 64512, i[e] = 24, i[256 | e] = 24) : (r[e] = 31744, r[256 | e] = 64512, i[e] = 13, i[256 | e] = 13);
      }

      const s = new Uint32Array(2048),
            o = new Uint32Array(64),
            a = new Uint32Array(64);

      for (let e = 1; e < 1024; ++e) {
        let t = e << 13,
            n = 0;

        for (; 0 == (8388608 & t);) t <<= 1, n -= 8388608;

        t &= -8388609, n += 947912704, s[e] = t | n;
      }

      for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + (e - 1024 << 13);

      for (let e = 1; e < 31; ++e) o[e] = e << 23;

      o[31] = 1199570944, o[32] = 2147483648;

      for (let e = 33; e < 63; ++e) o[e] = 2147483648 + (e - 32 << 23);

      o[63] = 3347054592;

      for (let e = 1; e < 64; ++e) 32 !== e && (a[e] = 1024);

      return {
        floatView: t,
        uint32View: n,
        baseTable: r,
        shiftTable: i,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
      };
    }

    var Vd = Object.freeze({
      __proto__: null,
      toHalfFloat: function (e) {
        Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = Mn(e, -65504, 65504), Ld[0] = e;
        const t = Id[0],
              n = t >> 23 & 511;
        return Fd[n] + ((8388607 & t) >> Nd[n]);
      },
      fromHalfFloat: function (e) {
        const t = e >> 10;
        return Id[0] = Ud[jd[t] + (1023 & e)] + Bd[t], Ld[0];
      }
    });

    class Gd extends Wi {
      constructor() {
        console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), super();
      }

    }

    class Hd extends Wi {
      constructor() {
        console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), super();
      }

    }

    function Wd() {
      console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
    }

    function Kd() {
      console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
    }

    function Xd() {
      console.error("THREE.ImmediateRenderObject has been removed.");
    }

    class qd extends tr {
      constructor(e, t, n) {
        console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, n), this.samples = 4;
      }

    }

    class Yd extends nr {
      constructor(e, t, n, r) {
        console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, n, r);
      }

    }

    class Zd extends ir {
      constructor(e, t, n, r) {
        console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, n, r);
      }

    }

    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
      detail: {
        revision: r
      }
    })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r);
  },
  365: function (e, t, n) {
    n.d(t, {
      _: function () {
        return s;
      }
    });
    var r = n(927);
    const i = new WeakMap();

    class s extends r.aNw {
      constructor(e) {
        super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
          position: "POSITION",
          normal: "NORMAL",
          color: "COLOR",
          uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
          position: "Float32Array",
          normal: "Float32Array",
          color: "Float32Array",
          uv: "Float32Array"
        };
      }

      setDecoderPath(e) {
        return this.decoderPath = e, this;
      }

      setDecoderConfig(e) {
        return this.decoderConfig = e, this;
      }

      setWorkerLimit(e) {
        return this.workerLimit = e, this;
      }

      load(e, t, n, i) {
        const s = new r.hH6(this.manager);
        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, e => {
          const n = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1
          };
          this.decodeGeometry(e, n).then(t).catch(i);
        }, n, i);
      }

      decodeDracoFile(e, t, n, r) {
        const i = {
          attributeIDs: n || this.defaultAttributeIDs,
          attributeTypes: r || this.defaultAttributeTypes,
          useUniqueIDs: !!n
        };
        this.decodeGeometry(e, i).then(t);
      }

      decodeGeometry(e, t) {
        for (const e in t.attributeTypes) {
          const n = t.attributeTypes[e];
          void 0 !== n.BYTES_PER_ELEMENT && (t.attributeTypes[e] = n.name);
        }

        const n = JSON.stringify(t);

        if (i.has(e)) {
          const t = i.get(e);
          if (t.key === n) return t.promise;
          if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
        }

        let r;

        const s = this.workerNextTaskID++,
              o = e.byteLength,
              a = this._getWorker(s, o).then(n => (r = n, new Promise((n, i) => {
          r._callbacks[s] = {
            resolve: n,
            reject: i
          }, r.postMessage({
            type: "decode",
            id: s,
            taskConfig: t,
            buffer: e
          }, [e]);
        }))).then(e => this._createGeometry(e.geometry));

        return a.catch(() => !0).then(() => {
          r && s && this._releaseTask(r, s);
        }), i.set(e, {
          key: n,
          promise: a
        }), a;
      }

      _createGeometry(e) {
        const t = new r.u9r();
        e.index && t.setIndex(new r.TlE(e.index.array, 1));

        for (let n = 0; n < e.attributes.length; n++) {
          const i = e.attributes[n],
                s = i.name,
                o = i.array,
                a = i.itemSize;
          t.setAttribute(s, new r.TlE(o, a));
        }

        return t;
      }

      _loadLibrary(e, t) {
        const n = new r.hH6(this.manager);
        return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((t, r) => {
          n.load(e, t, void 0, r);
        });
      }

      preload() {
        return this._initDecoder(), this;
      }

      _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
              t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(t => {
          const n = t[0];
          e || (this.decoderConfig.wasmBinary = t[1]);
          const r = o.toString(),
                i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([i]));
        }), this.decoderPending;
      }

      _getWorker(e, t) {
        return this._initDecoder().then(() => {
          if (this.workerPool.length < this.workerLimit) {
            const e = new Worker(this.workerSourceURL);
            e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
              type: "init",
              decoderConfig: this.decoderConfig
            }), e.onmessage = function (t) {
              const n = t.data;

              switch (n.type) {
                case "decode":
                  e._callbacks[n.id].resolve(n);

                  break;

                case "error":
                  e._callbacks[n.id].reject(n);

                  break;

                default:
                  console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"');
              }
            }, this.workerPool.push(e);
          } else this.workerPool.sort(function (e, t) {
            return e._taskLoad > t._taskLoad ? -1 : 1;
          });

          const n = this.workerPool[this.workerPool.length - 1];
          return n._taskCosts[e] = t, n._taskLoad += t, n;
        });
      }

      _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
      }

      debug() {
        console.log("Task load: ", this.workerPool.map(e => e._taskLoad));
      }

      dispose() {
        for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();

        return this.workerPool.length = 0, this;
      }

    }

    function o() {
      let e, t;

      function n(e, t, n, r, i, s) {
        const o = s.num_components(),
              a = n.num_points() * o,
              l = a * i.BYTES_PER_ELEMENT,
              c = function (e, t) {
          switch (t) {
            case Float32Array:
              return e.DT_FLOAT32;

            case Int8Array:
              return e.DT_INT8;

            case Int16Array:
              return e.DT_INT16;

            case Int32Array:
              return e.DT_INT32;

            case Uint8Array:
              return e.DT_UINT8;

            case Uint16Array:
              return e.DT_UINT16;

            case Uint32Array:
              return e.DT_UINT32;
          }
        }(e, i),
              u = e._malloc(l);

        t.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
        const p = new i(e.HEAPF32.buffer, u, a).slice();
        return e._free(u), {
          name: r,
          array: p,
          itemSize: o
        };
      }

      onmessage = function (r) {
        const i = r.data;

        switch (i.type) {
          case "init":
            e = i.decoderConfig, t = new Promise(function (t) {
              e.onModuleLoaded = function (e) {
                t({
                  draco: e
                });
              }, DracoDecoderModule(e);
            });
            break;

          case "decode":
            const r = i.buffer,
                  s = i.taskConfig;
            t.then(e => {
              const t = e.draco,
                    o = new t.Decoder(),
                    a = new t.DecoderBuffer();
              a.Init(new Int8Array(r), r.byteLength);

              try {
                const e = function (e, t, r, i) {
                  const s = i.attributeIDs,
                        o = i.attributeTypes;
                  let a, l;
                  const c = t.GetEncodedGeometryType(r);
                  if (c === e.TRIANGULAR_MESH) a = new e.Mesh(), l = t.DecodeBufferToMesh(r, a);else {
                    if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                    a = new e.PointCloud(), l = t.DecodeBufferToPointCloud(r, a);
                  }
                  if (!l.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                  const u = {
                    index: null,
                    attributes: []
                  };

                  for (const r in s) {
                    const l = self[o[r]];
                    let c, p;
                    if (i.useUniqueIDs) p = s[r], c = t.GetAttributeByUniqueId(a, p);else {
                      if (p = t.GetAttributeId(a, e[s[r]]), -1 === p) continue;
                      c = t.GetAttribute(a, p);
                    }
                    u.attributes.push(n(e, t, a, r, l, c));
                  }

                  return c === e.TRIANGULAR_MESH && (u.index = function (e, t, n) {
                    const r = 3 * n.num_faces(),
                          i = 4 * r,
                          s = e._malloc(i);

                    t.GetTrianglesUInt32Array(n, i, s);
                    const o = new Uint32Array(e.HEAPF32.buffer, s, r).slice();
                    return e._free(s), {
                      array: o,
                      itemSize: 1
                    };
                  }(e, t, a)), e.destroy(a), u;
                }(t, o, a, s),
                      r = e.attributes.map(e => e.array.buffer);

                e.index && r.push(e.index.array.buffer), self.postMessage({
                  type: "decode",
                  id: i.id,
                  geometry: e
                }, r);
              } catch (e) {
                console.error(e), self.postMessage({
                  type: "error",
                  id: i.id,
                  error: e.message
                });
              } finally {
                t.destroy(a), t.destroy(o);
              }
            });
        }
      };
    }
  },
  352: function (e) {
    e.exports = function (e) {
      var t = [];
      return t.toString = function () {
        return this.map(function (t) {
          var n = e(t);
          return t[2] ? "@media ".concat(t[2], " {").concat(n, "}") : n;
        }).join("");
      }, t.i = function (e, n, r) {
        "string" == typeof e && (e = [[null, e, ""]]);
        var i = {};
        if (r) for (var s = 0; s < this.length; s++) {
          var o = this[s][0];
          null != o && (i[o] = !0);
        }

        for (var a = 0; a < e.length; a++) {
          var l = [].concat(e[a]);
          r && i[l[0]] || (n && (l[2] ? l[2] = "".concat(n, " and ").concat(l[2]) : l[2] = n), t.push(l));
        }
      }, t;
    };
  },
  388: function (e) {
    e.exports = function e(t, n, r) {
      function i(o, a) {
        if (!n[o]) {
          if (!t[o]) {
            if (s) return s(o, !0);
            throw new Error("Cannot find module '" + o + "'");
          }

          var l = n[o] = {
            exports: {}
          };
          t[o][0].call(l.exports, function (e) {
            return i(t[o][1][e] || e);
          }, l, l.exports, e, t, n, r);
        }

        return n[o].exports;
      }

      for (var s = void 0, o = 0; o < r.length; o++) i(r[o]);

      return i;
    }({
      1: [function (e, t, n) {
        (function (r, i, s, o, a, l, c, u, p) {
          var h = e("crypto");

          function d(e, t) {
            return function (e, t) {
              var n;
              if (void 0 === (n = "passthrough" !== t.algorithm ? h.createHash(t.algorithm) : new b()).write && (n.write = n.update, n.end = n.update), v(t, n).dispatch(e), n.update || n.end(""), n.digest) return n.digest("buffer" === t.encoding ? void 0 : t.encoding);
              var r = n.read();
              return "buffer" !== t.encoding ? r.toString(t.encoding) : r;
            }(e, t = m(e, t));
          }

          (n = t.exports = d).sha1 = function (e) {
            return d(e);
          }, n.keys = function (e) {
            return d(e, {
              excludeValues: !0,
              algorithm: "sha1",
              encoding: "hex"
            });
          }, n.MD5 = function (e) {
            return d(e, {
              algorithm: "md5",
              encoding: "hex"
            });
          }, n.keysMD5 = function (e) {
            return d(e, {
              algorithm: "md5",
              encoding: "hex",
              excludeValues: !0
            });
          };
          var f = h.getHashes ? h.getHashes().slice() : ["sha1", "md5"];
          f.push("passthrough");
          var _ = ["buffer", "hex", "binary", "base64"];

          function m(e, t) {
            t = t || {};
            var n = {};
            if (n.algorithm = t.algorithm || "sha1", n.encoding = t.encoding || "hex", n.excludeValues = !!t.excludeValues, n.algorithm = n.algorithm.toLowerCase(), n.encoding = n.encoding.toLowerCase(), n.ignoreUnknown = !0 === t.ignoreUnknown, n.respectType = !1 !== t.respectType, n.respectFunctionNames = !1 !== t.respectFunctionNames, n.respectFunctionProperties = !1 !== t.respectFunctionProperties, n.unorderedArrays = !0 === t.unorderedArrays, n.unorderedSets = !1 !== t.unorderedSets, n.unorderedObjects = !1 !== t.unorderedObjects, n.replacer = t.replacer || void 0, n.excludeKeys = t.excludeKeys || void 0, void 0 === e) throw new Error("Object argument required.");

            for (var r = 0; r < f.length; ++r) f[r].toLowerCase() === n.algorithm.toLowerCase() && (n.algorithm = f[r]);

            if (-1 === f.indexOf(n.algorithm)) throw new Error('Algorithm "' + n.algorithm + '"  not supported. supported values: ' + f.join(", "));
            if (-1 === _.indexOf(n.encoding) && "passthrough" !== n.algorithm) throw new Error('Encoding "' + n.encoding + '"  not supported. supported values: ' + _.join(", "));
            return n;
          }

          function g(e) {
            if ("function" == typeof e) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e));
          }

          function v(e, t, n) {
            function r(e) {
              return t.update ? t.update(e, "utf8") : t.write(e, "utf8");
            }

            return n = n || [], {
              dispatch: function (t) {
                return e.replacer && (t = e.replacer(t)), this["_" + (null === t ? "null" : typeof t)](t);
              },
              _object: function (t) {
                var i,
                    o = Object.prototype.toString.call(t),
                    a = /\[object (.*)\]/i.exec(o);
                if (a = (a = a ? a[1] : "unknown:[" + o + "]").toLowerCase(), 0 <= (i = n.indexOf(t))) return this.dispatch("[CIRCULAR:" + i + "]");
                if (n.push(t), void 0 !== s && s.isBuffer && s.isBuffer(t)) return r("buffer:"), r(t);

                if ("object" === a || "function" === a || "asyncfunction" === a) {
                  var l = Object.keys(t);
                  e.unorderedObjects && (l = l.sort()), !1 === e.respectType || g(t) || l.splice(0, 0, "prototype", "__proto__", "constructor"), e.excludeKeys && (l = l.filter(function (t) {
                    return !e.excludeKeys(t);
                  })), r("object:" + l.length + ":");
                  var c = this;
                  return l.forEach(function (n) {
                    c.dispatch(n), r(":"), e.excludeValues || c.dispatch(t[n]), r(",");
                  });
                }

                if (!this["_" + a]) {
                  if (e.ignoreUnknown) return r("[" + a + "]");
                  throw new Error('Unknown object type "' + a + '"');
                }

                this["_" + a](t);
              },
              _array: function (t, i) {
                i = void 0 !== i ? i : !1 !== e.unorderedArrays;
                var s = this;
                if (r("array:" + t.length + ":"), !i || t.length <= 1) return t.forEach(function (e) {
                  return s.dispatch(e);
                });
                var o = [],
                    a = t.map(function (t) {
                  var r = new b(),
                      i = n.slice();
                  return v(e, r, i).dispatch(t), o = o.concat(i.slice(n.length)), r.read().toString();
                });
                return n = n.concat(o), a.sort(), this._array(a, !1);
              },
              _date: function (e) {
                return r("date:" + e.toJSON());
              },
              _symbol: function (e) {
                return r("symbol:" + e.toString());
              },
              _error: function (e) {
                return r("error:" + e.toString());
              },
              _boolean: function (e) {
                return r("bool:" + e.toString());
              },
              _string: function (e) {
                r("string:" + e.length + ":"), r(e.toString());
              },
              _function: function (t) {
                r("fn:"), g(t) ? this.dispatch("[native]") : this.dispatch(t.toString()), !1 !== e.respectFunctionNames && this.dispatch("function-name:" + String(t.name)), e.respectFunctionProperties && this._object(t);
              },
              _number: function (e) {
                return r("number:" + e.toString());
              },
              _xml: function (e) {
                return r("xml:" + e.toString());
              },
              _null: function () {
                return r("Null");
              },
              _undefined: function () {
                return r("Undefined");
              },
              _regexp: function (e) {
                return r("regex:" + e.toString());
              },
              _uint8array: function (e) {
                return r("uint8array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _uint8clampedarray: function (e) {
                return r("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _int8array: function (e) {
                return r("uint8array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _uint16array: function (e) {
                return r("uint16array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _int16array: function (e) {
                return r("uint16array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _uint32array: function (e) {
                return r("uint32array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _int32array: function (e) {
                return r("uint32array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _float32array: function (e) {
                return r("float32array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _float64array: function (e) {
                return r("float64array:"), this.dispatch(Array.prototype.slice.call(e));
              },
              _arraybuffer: function (e) {
                return r("arraybuffer:"), this.dispatch(new Uint8Array(e));
              },
              _url: function (e) {
                return r("url:" + e.toString());
              },
              _map: function (t) {
                r("map:");
                var n = Array.from(t);
                return this._array(n, !1 !== e.unorderedSets);
              },
              _set: function (t) {
                r("set:");
                var n = Array.from(t);
                return this._array(n, !1 !== e.unorderedSets);
              },
              _file: function (e) {
                return r("file:"), this.dispatch([e.name, e.size, e.type, e.lastModfied]);
              },
              _blob: function () {
                if (e.ignoreUnknown) return r("[blob]");
                throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
              },
              _domwindow: function () {
                return r("domwindow");
              },
              _bigint: function (e) {
                return r("bigint:" + e.toString());
              },
              _process: function () {
                return r("process");
              },
              _timer: function () {
                return r("timer");
              },
              _pipe: function () {
                return r("pipe");
              },
              _tcp: function () {
                return r("tcp");
              },
              _udp: function () {
                return r("udp");
              },
              _tty: function () {
                return r("tty");
              },
              _statwatcher: function () {
                return r("statwatcher");
              },
              _securecontext: function () {
                return r("securecontext");
              },
              _connection: function () {
                return r("connection");
              },
              _zlib: function () {
                return r("zlib");
              },
              _context: function () {
                return r("context");
              },
              _nodescript: function () {
                return r("nodescript");
              },
              _httpparser: function () {
                return r("httpparser");
              },
              _dataview: function () {
                return r("dataview");
              },
              _signal: function () {
                return r("signal");
              },
              _fsevent: function () {
                return r("fsevent");
              },
              _tlswrap: function () {
                return r("tlswrap");
              }
            };
          }

          function b() {
            return {
              buf: "",
              write: function (e) {
                this.buf += e;
              },
              end: function (e) {
                this.buf += e;
              },
              read: function () {
                return this.buf;
              }
            };
          }

          n.writeToStream = function (e, t, n) {
            return void 0 === n && (n = t, t = {}), v(t = m(e, t), n).dispatch(e);
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/");
      }, {
        buffer: 3,
        crypto: 5,
        lYpoI2: 10
      }],
      2: [function (e, t, n) {
        (function (e, t, r, i, s, o, a, l, c) {
          !function (e) {
            var t = "undefined" != typeof Uint8Array ? Uint8Array : Array,
                n = "+".charCodeAt(0),
                r = "/".charCodeAt(0),
                i = "0".charCodeAt(0),
                s = "a".charCodeAt(0),
                o = "A".charCodeAt(0),
                a = "-".charCodeAt(0),
                l = "_".charCodeAt(0);

            function c(e) {
              var t = e.charCodeAt(0);
              return t === n || t === a ? 62 : t === r || t === l ? 63 : t < i ? -1 : t < i + 10 ? t - i + 26 + 26 : t < o + 26 ? t - o : t < s + 26 ? t - s + 26 : void 0;
            }

            e.toByteArray = function (e) {
              var n, r;
              if (0 < e.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
              var i = e.length,
                  s = "=" === e.charAt(i - 2) ? 2 : "=" === e.charAt(i - 1) ? 1 : 0,
                  o = new t(3 * e.length / 4 - s),
                  a = 0 < s ? e.length - 4 : e.length,
                  l = 0;

              function u(e) {
                o[l++] = e;
              }

              for (n = 0; n < a; n += 4, 0) u((16711680 & (r = c(e.charAt(n)) << 18 | c(e.charAt(n + 1)) << 12 | c(e.charAt(n + 2)) << 6 | c(e.charAt(n + 3)))) >> 16), u((65280 & r) >> 8), u(255 & r);

              return 2 == s ? u(255 & (r = c(e.charAt(n)) << 2 | c(e.charAt(n + 1)) >> 4)) : 1 == s && (u((r = c(e.charAt(n)) << 10 | c(e.charAt(n + 1)) << 4 | c(e.charAt(n + 2)) >> 2) >> 8 & 255), u(255 & r)), o;
            }, e.fromByteArray = function (e) {
              var t,
                  n,
                  r,
                  i,
                  s = e.length % 3,
                  o = "";

              function a(e) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e);
              }

              for (t = 0, r = e.length - s; t < r; t += 3) o += a((i = n = (e[t] << 16) + (e[t + 1] << 8) + e[t + 2]) >> 18 & 63) + a(i >> 12 & 63) + a(i >> 6 & 63) + a(63 & i);

              switch (s) {
                case 1:
                  o += a((n = e[e.length - 1]) >> 2), o += a(n << 4 & 63), o += "==";
                  break;

                case 2:
                  o += a((n = (e[e.length - 2] << 8) + e[e.length - 1]) >> 10), o += a(n >> 4 & 63), o += a(n << 2 & 63), o += "=";
              }

              return o;
            };
          }(void 0 === n ? this.base64js = {} : n);
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, {
        buffer: 3,
        lYpoI2: 10
      }],
      3: [function (e, t, n) {
        (function (t, r, i, s, o, a, l, c, u) {
          var p = e("base64-js"),
              h = e("ieee754");

          function i(e, t, n) {
            if (!(this instanceof i)) return new i(e, t, n);
            var r,
                s,
                o,
                a,
                l,
                c = typeof e;
            if ("base64" === t && "string" == c) for (e = (r = e).trim ? r.trim() : r.replace(/^\s+|\s+$/g, ""); e.length % 4 != 0;) e += "=";
            if ("number" == c) s = A(e);else if ("string" == c) s = i.byteLength(e, t);else {
              if ("object" != c) throw new Error("First argument needs to be a number, array or string.");
              s = A(e.length);
            }
            if (i._useTypedArrays ? o = i._augment(new Uint8Array(s)) : ((o = this).length = s, o._isBuffer = !0), i._useTypedArrays && "number" == typeof e.byteLength) o._set(e);else if (C(l = e) || i.isBuffer(l) || l && "object" == typeof l && "number" == typeof l.length) for (a = 0; a < s; a++) i.isBuffer(e) ? o[a] = e.readUInt8(a) : o[a] = e[a];else if ("string" == c) o.write(e, 0, t);else if ("number" == c && !i._useTypedArrays && !n) for (a = 0; a < s; a++) o[a] = 0;
            return o;
          }

          function d(e, t, n, r) {
            r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 1 < e.length, "Trying to read beyond buffer length"));
            var i,
                s = e.length;
            if (!(s <= t)) return n ? (i = e[t], t + 1 < s && (i |= e[t + 1] << 8)) : (i = e[t] << 8, t + 1 < s && (i |= e[t + 1])), i;
          }

          function f(e, t, n, r) {
            r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 3 < e.length, "Trying to read beyond buffer length"));
            var i,
                s = e.length;
            if (!(s <= t)) return n ? (t + 2 < s && (i = e[t + 2] << 16), t + 1 < s && (i |= e[t + 1] << 8), i |= e[t], t + 3 < s && (i += e[t + 3] << 24 >>> 0)) : (t + 1 < s && (i = e[t + 1] << 16), t + 2 < s && (i |= e[t + 2] << 8), t + 3 < s && (i |= e[t + 3]), i += e[t] << 24 >>> 0), i;
          }

          function _(e, t, n, r) {
            if (r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 1 < e.length, "Trying to read beyond buffer length")), !(e.length <= t)) {
              var i = d(e, t, n, !0);
              return 32768 & i ? -1 * (65535 - i + 1) : i;
            }
          }

          function m(e, t, n, r) {
            if (r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 3 < e.length, "Trying to read beyond buffer length")), !(e.length <= t)) {
              var i = f(e, t, n, !0);
              return 2147483648 & i ? -1 * (4294967295 - i + 1) : i;
            }
          }

          function g(e, t, n, r) {
            return r || (N("boolean" == typeof n, "missing or invalid endian"), N(t + 3 < e.length, "Trying to read beyond buffer length")), h.read(e, t, n, 23, 4);
          }

          function v(e, t, n, r) {
            return r || (N("boolean" == typeof n, "missing or invalid endian"), N(t + 7 < e.length, "Trying to read beyond buffer length")), h.read(e, t, n, 52, 8);
          }

          function b(e, t, n, r, i) {
            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 1 < e.length, "trying to write beyond buffer length"), L(t, 65535));
            var s = e.length;
            if (!(s <= n)) for (var o = 0, a = Math.min(s - n, 2); o < a; o++) e[n + o] = (t & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o);
          }

          function x(e, t, n, r, i) {
            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < e.length, "trying to write beyond buffer length"), L(t, 4294967295));
            var s = e.length;
            if (!(s <= n)) for (var o = 0, a = Math.min(s - n, 4); o < a; o++) e[n + o] = t >>> 8 * (r ? o : 3 - o) & 255;
          }

          function y(e, t, n, r, i) {
            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 1 < e.length, "Trying to write beyond buffer length"), I(t, 32767, -32768)), e.length <= n || b(e, 0 <= t ? t : 65535 + t + 1, n, r, i);
          }

          function w(e, t, n, r, i) {
            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < e.length, "Trying to write beyond buffer length"), I(t, 2147483647, -2147483648)), e.length <= n || x(e, 0 <= t ? t : 4294967295 + t + 1, n, r, i);
          }

          function S(e, t, n, r, i) {
            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < e.length, "Trying to write beyond buffer length"), F(t, 34028234663852886e22, -34028234663852886e22)), e.length <= n || h.write(e, t, n, r, 23, 4);
          }

          function M(e, t, n, r, i) {
            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 7 < e.length, "Trying to write beyond buffer length"), F(t, 17976931348623157e292, -17976931348623157e292)), e.length <= n || h.write(e, t, n, r, 52, 8);
          }

          n.Buffer = i, n.SlowBuffer = i, n.INSPECT_MAX_BYTES = 50, i.poolSize = 8192, i._useTypedArrays = function () {
            try {
              var e = new ArrayBuffer(0),
                  t = new Uint8Array(e);
              return t.foo = function () {
                return 42;
              }, 42 === t.foo() && "function" == typeof t.subarray;
            } catch (e) {
              return !1;
            }
          }(), i.isEncoding = function (e) {
            switch (String(e).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;

              default:
                return !1;
            }
          }, i.isBuffer = function (e) {
            return !(null == e || !e._isBuffer);
          }, i.byteLength = function (e, t) {
            var n;

            switch (e += "", t || "utf8") {
              case "hex":
                n = e.length / 2;
                break;

              case "utf8":
              case "utf-8":
                n = k(e).length;
                break;

              case "ascii":
              case "binary":
              case "raw":
                n = e.length;
                break;

              case "base64":
                n = P(e).length;
                break;

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n = 2 * e.length;
                break;

              default:
                throw new Error("Unknown encoding");
            }

            return n;
          }, i.concat = function (e, t) {
            if (N(C(e), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e.length) return new i(0);
            if (1 === e.length) return e[0];
            if ("number" != typeof t) for (s = t = 0; s < e.length; s++) t += e[s].length;

            for (var n = new i(t), r = 0, s = 0; s < e.length; s++) {
              var o = e[s];
              o.copy(n, r), r += o.length;
            }

            return n;
          }, i.prototype.write = function (e, t, n, r) {
            var s;
            isFinite(t) ? isFinite(n) || (r = n, n = void 0) : (s = r, r = t, t = n, n = s), t = Number(t) || 0;
            var o,
                a,
                l,
                c,
                u,
                p,
                h,
                d = this.length - t;

            switch ((!n || d < (n = Number(n))) && (n = d), r = String(r || "utf8").toLowerCase()) {
              case "hex":
                o = function (e, t, n, r) {
                  n = Number(n) || 0;
                  var s = e.length - n;
                  (!r || s < (r = Number(r))) && (r = s);
                  var o = t.length;
                  N(o % 2 == 0, "Invalid hex string"), o / 2 < r && (r = o / 2);

                  for (var a = 0; a < r; a++) {
                    var l = parseInt(t.substr(2 * a, 2), 16);
                    N(!isNaN(l), "Invalid hex string"), e[n + a] = l;
                  }

                  return i._charsWritten = 2 * a, a;
                }(this, e, t, n);

                break;

              case "utf8":
              case "utf-8":
                this, u = e, p = t, h = n, o = i._charsWritten = D(k(u), this, p, h);
                break;

              case "ascii":
              case "binary":
                o = function (e, t, n, r) {
                  return i._charsWritten = D(function (e) {
                    for (var t = [], n = 0; n < e.length; n++) t.push(255 & e.charCodeAt(n));

                    return t;
                  }(t), e, n, r);
                }(this, e, t, n);

                break;

              case "base64":
                this, a = e, l = t, c = n, o = i._charsWritten = D(P(a), this, l, c);
                break;

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o = function (e, t, n, r) {
                  return i._charsWritten = D(function (e) {
                    for (var t, n, r, i = [], s = 0; s < e.length; s++) n = (t = e.charCodeAt(s)) >> 8, r = t % 256, i.push(r), i.push(n);

                    return i;
                  }(t), e, n, r);
                }(this, e, t, n);

                break;

              default:
                throw new Error("Unknown encoding");
            }

            return o;
          }, i.prototype.toString = function (e, t, n) {
            var r,
                i,
                s,
                o,
                a = this;
            if (e = String(e || "utf8").toLowerCase(), t = Number(t) || 0, (n = void 0 !== n ? Number(n) : n = a.length) === t) return "";

            switch (e) {
              case "hex":
                r = function (e, t, n) {
                  var r = e.length;
                  (!t || t < 0) && (t = 0), (!n || n < 0 || r < n) && (n = r);

                  for (var i = "", s = t; s < n; s++) i += R(e[s]);

                  return i;
                }(a, t, n);

                break;

              case "utf8":
              case "utf-8":
                r = function (e, t, n) {
                  var r = "",
                      i = "";
                  n = Math.min(e.length, n);

                  for (var s = t; s < n; s++) e[s] <= 127 ? (r += O(i) + String.fromCharCode(e[s]), i = "") : i += "%" + e[s].toString(16);

                  return r + O(i);
                }(a, t, n);

                break;

              case "ascii":
              case "binary":
                r = function (e, t, n) {
                  var r = "";
                  n = Math.min(e.length, n);

                  for (var i = t; i < n; i++) r += String.fromCharCode(e[i]);

                  return r;
                }(a, t, n);

                break;

              case "base64":
                i = a, o = n, r = 0 === (s = t) && o === i.length ? p.fromByteArray(i) : p.fromByteArray(i.slice(s, o));
                break;

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r = function (e, t, n) {
                  for (var r = e.slice(t, n), i = "", s = 0; s < r.length; s += 2) i += String.fromCharCode(r[s] + 256 * r[s + 1]);

                  return i;
                }(a, t, n);

                break;

              default:
                throw new Error("Unknown encoding");
            }

            return r;
          }, i.prototype.toJSON = function () {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          }, i.prototype.copy = function (e, t, n, r) {
            if (n = n || 0, r || 0 === r || (r = this.length), t = t || 0, r !== n && 0 !== e.length && 0 !== this.length) {
              N(n <= r, "sourceEnd < sourceStart"), N(0 <= t && t < e.length, "targetStart out of bounds"), N(0 <= n && n < this.length, "sourceStart out of bounds"), N(0 <= r && r <= this.length, "sourceEnd out of bounds"), r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
              var s = r - n;
              if (s < 100 || !i._useTypedArrays) for (var o = 0; o < s; o++) e[o + t] = this[o + n];else e._set(this.subarray(n, n + s), t);
            }
          }, i.prototype.slice = function (e, t) {
            var n = this.length;
            if (e = E(e, n, 0), t = E(t, n, n), i._useTypedArrays) return i._augment(this.subarray(e, t));

            for (var r = t - e, s = new i(r, void 0, !0), o = 0; o < r; o++) s[o] = this[o + e];

            return s;
          }, i.prototype.get = function (e) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e);
          }, i.prototype.set = function (e, t) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e, t);
          }, i.prototype.readUInt8 = function (e, t) {
            if (t || (N(null != e, "missing offset"), N(e < this.length, "Trying to read beyond buffer length")), !(e >= this.length)) return this[e];
          }, i.prototype.readUInt16LE = function (e, t) {
            return d(this, e, !0, t);
          }, i.prototype.readUInt16BE = function (e, t) {
            return d(this, e, !1, t);
          }, i.prototype.readUInt32LE = function (e, t) {
            return f(this, e, !0, t);
          }, i.prototype.readUInt32BE = function (e, t) {
            return f(this, e, !1, t);
          }, i.prototype.readInt8 = function (e, t) {
            if (t || (N(null != e, "missing offset"), N(e < this.length, "Trying to read beyond buffer length")), !(e >= this.length)) return 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
          }, i.prototype.readInt16LE = function (e, t) {
            return _(this, e, !0, t);
          }, i.prototype.readInt16BE = function (e, t) {
            return _(this, e, !1, t);
          }, i.prototype.readInt32LE = function (e, t) {
            return m(this, e, !0, t);
          }, i.prototype.readInt32BE = function (e, t) {
            return m(this, e, !1, t);
          }, i.prototype.readFloatLE = function (e, t) {
            return g(this, e, !0, t);
          }, i.prototype.readFloatBE = function (e, t) {
            return g(this, e, !1, t);
          }, i.prototype.readDoubleLE = function (e, t) {
            return v(this, e, !0, t);
          }, i.prototype.readDoubleBE = function (e, t) {
            return v(this, e, !1, t);
          }, i.prototype.writeUInt8 = function (e, t, n) {
            n || (N(null != e, "missing value"), N(null != t, "missing offset"), N(t < this.length, "trying to write beyond buffer length"), L(e, 255)), t >= this.length || (this[t] = e);
          }, i.prototype.writeUInt16LE = function (e, t, n) {
            b(this, e, t, !0, n);
          }, i.prototype.writeUInt16BE = function (e, t, n) {
            b(this, e, t, !1, n);
          }, i.prototype.writeUInt32LE = function (e, t, n) {
            x(this, e, t, !0, n);
          }, i.prototype.writeUInt32BE = function (e, t, n) {
            x(this, e, t, !1, n);
          }, i.prototype.writeInt8 = function (e, t, n) {
            n || (N(null != e, "missing value"), N(null != t, "missing offset"), N(t < this.length, "Trying to write beyond buffer length"), I(e, 127, -128)), t >= this.length || (0 <= e ? this.writeUInt8(e, t, n) : this.writeUInt8(255 + e + 1, t, n));
          }, i.prototype.writeInt16LE = function (e, t, n) {
            y(this, e, t, !0, n);
          }, i.prototype.writeInt16BE = function (e, t, n) {
            y(this, e, t, !1, n);
          }, i.prototype.writeInt32LE = function (e, t, n) {
            w(this, e, t, !0, n);
          }, i.prototype.writeInt32BE = function (e, t, n) {
            w(this, e, t, !1, n);
          }, i.prototype.writeFloatLE = function (e, t, n) {
            S(this, e, t, !0, n);
          }, i.prototype.writeFloatBE = function (e, t, n) {
            S(this, e, t, !1, n);
          }, i.prototype.writeDoubleLE = function (e, t, n) {
            M(this, e, t, !0, n);
          }, i.prototype.writeDoubleBE = function (e, t, n) {
            M(this, e, t, !1, n);
          }, i.prototype.fill = function (e, t, n) {
            if (e = e || 0, t = t || 0, n = n || this.length, "string" == typeof e && (e = e.charCodeAt(0)), N("number" == typeof e && !isNaN(e), "value is not a number"), N(t <= n, "end < start"), n !== t && 0 !== this.length) {
              N(0 <= t && t < this.length, "start out of bounds"), N(0 <= n && n <= this.length, "end out of bounds");

              for (var r = t; r < n; r++) this[r] = e;
            }
          }, i.prototype.inspect = function () {
            for (var e = [], t = this.length, r = 0; r < t; r++) if (e[r] = R(this[r]), r === n.INSPECT_MAX_BYTES) {
              e[r + 1] = "...";
              break;
            }

            return "<Buffer " + e.join(" ") + ">";
          }, i.prototype.toArrayBuffer = function () {
            if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (i._useTypedArrays) return new i(this).buffer;

            for (var e = new Uint8Array(this.length), t = 0, n = e.length; t < n; t += 1) e[t] = this[t];

            return e.buffer;
          };
          var T = i.prototype;

          function E(e, t, n) {
            return "number" != typeof e ? n : t <= (e = ~~e) ? t : 0 <= e || 0 <= (e += t) ? e : 0;
          }

          function A(e) {
            return (e = ~~Math.ceil(+e)) < 0 ? 0 : e;
          }

          function C(e) {
            return (Array.isArray || function (e) {
              return "[object Array]" === Object.prototype.toString.call(e);
            })(e);
          }

          function R(e) {
            return e < 16 ? "0" + e.toString(16) : e.toString(16);
          }

          function k(e) {
            for (var t = [], n = 0; n < e.length; n++) {
              var r = e.charCodeAt(n);
              if (r <= 127) t.push(e.charCodeAt(n));else {
                var i = n;
                55296 <= r && r <= 57343 && n++;

                for (var s = encodeURIComponent(e.slice(i, n + 1)).substr(1).split("%"), o = 0; o < s.length; o++) t.push(parseInt(s[o], 16));
              }
            }

            return t;
          }

          function P(e) {
            return p.toByteArray(e);
          }

          function D(e, t, n, r) {
            for (var i = 0; i < r && !(i + n >= t.length || i >= e.length); i++) t[i + n] = e[i];

            return i;
          }

          function O(e) {
            try {
              return decodeURIComponent(e);
            } catch (e) {
              return String.fromCharCode(65533);
            }
          }

          function L(e, t) {
            N("number" == typeof e, "cannot write a non-number as a number"), N(0 <= e, "specified a negative value for writing an unsigned value"), N(e <= t, "value is larger than maximum value for type"), N(Math.floor(e) === e, "value has a fractional component");
          }

          function I(e, t, n) {
            N("number" == typeof e, "cannot write a non-number as a number"), N(e <= t, "value larger than maximum allowed value"), N(n <= e, "value smaller than minimum allowed value"), N(Math.floor(e) === e, "value has a fractional component");
          }

          function F(e, t, n) {
            N("number" == typeof e, "cannot write a non-number as a number"), N(e <= t, "value larger than maximum allowed value"), N(n <= e, "value smaller than minimum allowed value");
          }

          function N(e, t) {
            if (!e) throw new Error(t || "Failed assertion");
          }

          i._augment = function (e) {
            return e._isBuffer = !0, e._get = e.get, e._set = e.set, e.get = T.get, e.set = T.set, e.write = T.write, e.toString = T.toString, e.toLocaleString = T.toString, e.toJSON = T.toJSON, e.copy = T.copy, e.slice = T.slice, e.readUInt8 = T.readUInt8, e.readUInt16LE = T.readUInt16LE, e.readUInt16BE = T.readUInt16BE, e.readUInt32LE = T.readUInt32LE, e.readUInt32BE = T.readUInt32BE, e.readInt8 = T.readInt8, e.readInt16LE = T.readInt16LE, e.readInt16BE = T.readInt16BE, e.readInt32LE = T.readInt32LE, e.readInt32BE = T.readInt32BE, e.readFloatLE = T.readFloatLE, e.readFloatBE = T.readFloatBE, e.readDoubleLE = T.readDoubleLE, e.readDoubleBE = T.readDoubleBE, e.writeUInt8 = T.writeUInt8, e.writeUInt16LE = T.writeUInt16LE, e.writeUInt16BE = T.writeUInt16BE, e.writeUInt32LE = T.writeUInt32LE, e.writeUInt32BE = T.writeUInt32BE, e.writeInt8 = T.writeInt8, e.writeInt16LE = T.writeInt16LE, e.writeInt16BE = T.writeInt16BE, e.writeInt32LE = T.writeInt32LE, e.writeInt32BE = T.writeInt32BE, e.writeFloatLE = T.writeFloatLE, e.writeFloatBE = T.writeFloatBE, e.writeDoubleLE = T.writeDoubleLE, e.writeDoubleBE = T.writeDoubleBE, e.fill = T.fill, e.inspect = T.inspect, e.toArrayBuffer = T.toArrayBuffer, e;
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, {
        "base64-js": 2,
        buffer: 3,
        ieee754: 11,
        lYpoI2: 10
      }],
      4: [function (e, t, n) {
        (function (n, r, i, s, o, a, l, c, u) {
          i = e("buffer").Buffer;
          var p = new i(4);
          p.fill(0), t.exports = {
            hash: function (e, t, n, r) {
              return i.isBuffer(e) || (e = new i(e)), function (e, t, n) {
                for (var r = new i(t), s = n ? r.writeInt32BE : r.writeInt32LE, o = 0; o < e.length; o++) s.call(r, e[o], 4 * o, !0);

                return r;
              }(t(function (e, t) {
                var n;
                e.length % 4 != 0 && (n = e.length + (4 - e.length % 4), e = i.concat([e, p], n));

                for (var r = [], s = t ? e.readInt32BE : e.readInt32LE, o = 0; o < e.length; o += 4) r.push(s.call(e, o));

                return r;
              }(e, r), 8 * e.length), n, r);
            }
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, {
        buffer: 3,
        lYpoI2: 10
      }],
      5: [function (e, t, n) {
        (function (t, r, i, s, o, a, l, c, u) {
          i = e("buffer").Buffer;
          var p = e("./sha"),
              h = e("./sha256"),
              d = e("./rng"),
              f = {
            sha1: p,
            sha256: h,
            md5: e("./md5")
          },
              _ = 64,
              m = new i(_);

          function g(e, t) {
            var n = f[e = e || "sha1"],
                r = [];
            return n || v("algorithm:", e, "is not yet supported"), {
              update: function (e) {
                return i.isBuffer(e) || (e = new i(e)), r.push(e), e.length, this;
              },
              digest: function (e) {
                var s = i.concat(r),
                    o = t ? function (e, t, n) {
                  i.isBuffer(t) || (t = new i(t)), i.isBuffer(n) || (n = new i(n)), t.length > _ ? t = e(t) : t.length < _ && (t = i.concat([t, m], _));

                  for (var r = new i(_), s = new i(_), o = 0; o < _; o++) r[o] = 54 ^ t[o], s[o] = 92 ^ t[o];

                  var a = e(i.concat([r, n]));
                  return e(i.concat([s, a]));
                }(n, t, s) : n(s);
                return r = null, e ? o.toString(e) : o;
              }
            };
          }

          function v() {
            var e = [].slice.call(arguments).join(" ");
            throw new Error([e, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }

          m.fill(0), n.createHash = function (e) {
            return g(e);
          }, n.createHmac = g, n.randomBytes = function (e, t) {
            if (!t || !t.call) return new i(d(e));

            try {
              t.call(this, void 0, new i(d(e)));
            } catch (e) {
              t(e);
            }
          }, function (e, t) {
            for (var n in e) t(e[n]);
          }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function (e) {
            n[e] = function () {
              v("sorry,", e, "is not implemented yet");
            };
          });
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, {
        "./md5": 6,
        "./rng": 7,
        "./sha": 8,
        "./sha256": 9,
        buffer: 3,
        lYpoI2: 10
      }],
      6: [function (e, t, n) {
        (function (n, r, i, s, o, a, l, c, u) {
          var p = e("./helpers");

          function h(e, t) {
            e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;

            for (var n = 1732584193, r = -271733879, i = -1732584194, s = 271733878, o = 0; o < e.length; o += 16) {
              var a = n,
                  l = r,
                  c = i,
                  u = s;
              n = f(n, r, i, s, e[o + 0], 7, -680876936), s = f(s, n, r, i, e[o + 1], 12, -389564586), i = f(i, s, n, r, e[o + 2], 17, 606105819), r = f(r, i, s, n, e[o + 3], 22, -1044525330), n = f(n, r, i, s, e[o + 4], 7, -176418897), s = f(s, n, r, i, e[o + 5], 12, 1200080426), i = f(i, s, n, r, e[o + 6], 17, -1473231341), r = f(r, i, s, n, e[o + 7], 22, -45705983), n = f(n, r, i, s, e[o + 8], 7, 1770035416), s = f(s, n, r, i, e[o + 9], 12, -1958414417), i = f(i, s, n, r, e[o + 10], 17, -42063), r = f(r, i, s, n, e[o + 11], 22, -1990404162), n = f(n, r, i, s, e[o + 12], 7, 1804603682), s = f(s, n, r, i, e[o + 13], 12, -40341101), i = f(i, s, n, r, e[o + 14], 17, -1502002290), n = _(n, r = f(r, i, s, n, e[o + 15], 22, 1236535329), i, s, e[o + 1], 5, -165796510), s = _(s, n, r, i, e[o + 6], 9, -1069501632), i = _(i, s, n, r, e[o + 11], 14, 643717713), r = _(r, i, s, n, e[o + 0], 20, -373897302), n = _(n, r, i, s, e[o + 5], 5, -701558691), s = _(s, n, r, i, e[o + 10], 9, 38016083), i = _(i, s, n, r, e[o + 15], 14, -660478335), r = _(r, i, s, n, e[o + 4], 20, -405537848), n = _(n, r, i, s, e[o + 9], 5, 568446438), s = _(s, n, r, i, e[o + 14], 9, -1019803690), i = _(i, s, n, r, e[o + 3], 14, -187363961), r = _(r, i, s, n, e[o + 8], 20, 1163531501), n = _(n, r, i, s, e[o + 13], 5, -1444681467), s = _(s, n, r, i, e[o + 2], 9, -51403784), i = _(i, s, n, r, e[o + 7], 14, 1735328473), n = m(n, r = _(r, i, s, n, e[o + 12], 20, -1926607734), i, s, e[o + 5], 4, -378558), s = m(s, n, r, i, e[o + 8], 11, -2022574463), i = m(i, s, n, r, e[o + 11], 16, 1839030562), r = m(r, i, s, n, e[o + 14], 23, -35309556), n = m(n, r, i, s, e[o + 1], 4, -1530992060), s = m(s, n, r, i, e[o + 4], 11, 1272893353), i = m(i, s, n, r, e[o + 7], 16, -155497632), r = m(r, i, s, n, e[o + 10], 23, -1094730640), n = m(n, r, i, s, e[o + 13], 4, 681279174), s = m(s, n, r, i, e[o + 0], 11, -358537222), i = m(i, s, n, r, e[o + 3], 16, -722521979), r = m(r, i, s, n, e[o + 6], 23, 76029189), n = m(n, r, i, s, e[o + 9], 4, -640364487), s = m(s, n, r, i, e[o + 12], 11, -421815835), i = m(i, s, n, r, e[o + 15], 16, 530742520), n = g(n, r = m(r, i, s, n, e[o + 2], 23, -995338651), i, s, e[o + 0], 6, -198630844), s = g(s, n, r, i, e[o + 7], 10, 1126891415), i = g(i, s, n, r, e[o + 14], 15, -1416354905), r = g(r, i, s, n, e[o + 5], 21, -57434055), n = g(n, r, i, s, e[o + 12], 6, 1700485571), s = g(s, n, r, i, e[o + 3], 10, -1894986606), i = g(i, s, n, r, e[o + 10], 15, -1051523), r = g(r, i, s, n, e[o + 1], 21, -2054922799), n = g(n, r, i, s, e[o + 8], 6, 1873313359), s = g(s, n, r, i, e[o + 15], 10, -30611744), i = g(i, s, n, r, e[o + 6], 15, -1560198380), r = g(r, i, s, n, e[o + 13], 21, 1309151649), n = g(n, r, i, s, e[o + 4], 6, -145523070), s = g(s, n, r, i, e[o + 11], 10, -1120210379), i = g(i, s, n, r, e[o + 2], 15, 718787259), r = g(r, i, s, n, e[o + 9], 21, -343485551), n = v(n, a), r = v(r, l), i = v(i, c), s = v(s, u);
            }

            return Array(n, r, i, s);
          }

          function d(e, t, n, r, i, s) {
            return v((o = v(v(t, e), v(r, s))) << (a = i) | o >>> 32 - a, n);
            var o, a;
          }

          function f(e, t, n, r, i, s, o) {
            return d(t & n | ~t & r, e, t, i, s, o);
          }

          function _(e, t, n, r, i, s, o) {
            return d(t & r | n & ~r, e, t, i, s, o);
          }

          function m(e, t, n, r, i, s, o) {
            return d(t ^ n ^ r, e, t, i, s, o);
          }

          function g(e, t, n, r, i, s, o) {
            return d(n ^ (t | ~r), e, t, i, s, o);
          }

          function v(e, t) {
            var n = (65535 & e) + (65535 & t);
            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;
          }

          t.exports = function (e) {
            return p.hash(e, h, 16);
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, {
        "./helpers": 4,
        buffer: 3,
        lYpoI2: 10
      }],
      7: [function (e, t, n) {
        (function (e, n, r, i, s, o, a, l, c) {
          var u;
          u = function (e) {
            for (var t, n = new Array(e), r = 0; r < e; r++) 0 == (3 & r) && (t = 4294967296 * Math.random()), n[r] = t >>> ((3 & r) << 3) & 255;

            return n;
          }, t.exports = u;
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, {
        buffer: 3,
        lYpoI2: 10
      }],
      8: [function (e, t, n) {
        (function (n, r, i, s, o, a, l, c, u) {
          var p = e("./helpers");

          function h(e, t) {
            e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;

            for (var n, r, i, s, o, a = Array(80), l = 1732584193, c = -271733879, u = -1732584194, p = 271733878, h = -1009589776, _ = 0; _ < e.length; _ += 16) {
              for (var m = l, g = c, v = u, b = p, x = h, y = 0; y < 80; y++) {
                a[y] = y < 16 ? e[_ + y] : f(a[y - 3] ^ a[y - 8] ^ a[y - 14] ^ a[y - 16], 1);
                var w = d(d(f(l, 5), (i = c, s = u, o = p, (r = y) < 20 ? i & s | ~i & o : !(r < 40) && r < 60 ? i & s | i & o | s & o : i ^ s ^ o)), d(d(h, a[y]), (n = y) < 20 ? 1518500249 : n < 40 ? 1859775393 : n < 60 ? -1894007588 : -899497514));
                h = p, p = u, u = f(c, 30), c = l, l = w;
              }

              l = d(l, m), c = d(c, g), u = d(u, v), p = d(p, b), h = d(h, x);
            }

            return Array(l, c, u, p, h);
          }

          function d(e, t) {
            var n = (65535 & e) + (65535 & t);
            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;
          }

          function f(e, t) {
            return e << t | e >>> 32 - t;
          }

          t.exports = function (e) {
            return p.hash(e, h, 20, !0);
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, {
        "./helpers": 4,
        buffer: 3,
        lYpoI2: 10
      }],
      9: [function (e, t, n) {
        (function (n, r, i, s, o, a, l, c, u) {
          function p(e, t) {
            var n = (65535 & e) + (65535 & t);
            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;
          }

          function h(e, t) {
            return e >>> t | e << 32 - t;
          }

          function d(e, t) {
            var n,
                r,
                i,
                s,
                o,
                a,
                l,
                c,
                u,
                d,
                f = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298),
                _ = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225),
                m = new Array(64);

            e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;

            for (var g, v, b, x, y, w, S, M, T = 0; T < e.length; T += 16) {
              n = _[0], r = _[1], i = _[2], s = _[3], o = _[4], a = _[5], l = _[6], c = _[7];

              for (var E = 0; E < 64; E++) m[E] = E < 16 ? e[E + T] : p(p(p(h(M = m[E - 2], 17) ^ h(M, 19) ^ M >>> 10, m[E - 7]), h(S = m[E - 15], 7) ^ h(S, 18) ^ S >>> 3), m[E - 16]), u = p(p(p(p(c, h(w = o, 6) ^ h(w, 11) ^ h(w, 25)), (y = o) & a ^ ~y & l), f[E]), m[E]), d = p(h(x = n, 2) ^ h(x, 13) ^ h(x, 22), (g = n) & (v = r) ^ g & (b = i) ^ v & b), c = l, l = a, a = o, o = p(s, u), s = i, i = r, r = n, n = p(u, d);

              _[0] = p(n, _[0]), _[1] = p(r, _[1]), _[2] = p(i, _[2]), _[3] = p(s, _[3]), _[4] = p(o, _[4]), _[5] = p(a, _[5]), _[6] = p(l, _[6]), _[7] = p(c, _[7]);
            }

            return _;
          }

          var f = e("./helpers");

          t.exports = function (e) {
            return f.hash(e, d, 32, !0);
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, {
        "./helpers": 4,
        buffer: 3,
        lYpoI2: 10
      }],
      10: [function (e, t, n) {
        (function (e, n, r, i, s, o, a, l, c) {
          function u() {}

          (e = t.exports = {}).nextTick = function () {
            var e = "undefined" != typeof window && window.setImmediate,
                t = "undefined" != typeof window && window.postMessage && window.addEventListener;
            if (e) return function (e) {
              return window.setImmediate(e);
            };

            if (t) {
              var n = [];
              return window.addEventListener("message", function (e) {
                var t = e.source;
                t !== window && null !== t || "process-tick" !== e.data || (e.stopPropagation(), 0 < n.length && n.shift()());
              }, !0), function (e) {
                n.push(e), window.postMessage("process-tick", "*");
              };
            }

            return function (e) {
              setTimeout(e, 0);
            };
          }(), e.title = "browser", e.browser = !0, e.env = {}, e.argv = [], e.on = u, e.addListener = u, e.once = u, e.off = u, e.removeListener = u, e.removeAllListeners = u, e.emit = u, e.binding = function (e) {
            throw new Error("process.binding is not supported");
          }, e.cwd = function () {
            return "/";
          }, e.chdir = function (e) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, {
        buffer: 3,
        lYpoI2: 10
      }],
      11: [function (e, t, n) {
        (function (e, t, r, i, s, o, a, l, c) {
          n.read = function (e, t, n, r, i) {
            var s,
                o,
                a = 8 * i - r - 1,
                l = (1 << a) - 1,
                c = l >> 1,
                u = -7,
                p = n ? i - 1 : 0,
                h = n ? -1 : 1,
                d = e[t + p];

            for (p += h, s = d & (1 << -u) - 1, d >>= -u, u += a; 0 < u; s = 256 * s + e[t + p], p += h, u -= 8);

            for (o = s & (1 << -u) - 1, s >>= -u, u += r; 0 < u; o = 256 * o + e[t + p], p += h, u -= 8);

            if (0 === s) s = 1 - c;else {
              if (s === l) return o ? NaN : 1 / 0 * (d ? -1 : 1);
              o += Math.pow(2, r), s -= c;
            }
            return (d ? -1 : 1) * o * Math.pow(2, s - r);
          }, n.write = function (e, t, n, r, i, s) {
            var o,
                a,
                l,
                c = 8 * s - i - 1,
                u = (1 << c) - 1,
                p = u >> 1,
                h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                d = r ? 0 : s - 1,
                f = r ? 1 : -1,
                _ = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;

            for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, o = u) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), 2 <= (t += 1 <= o + p ? h / l : h * Math.pow(2, 1 - p)) * l && (o++, l /= 2), u <= o + p ? (a = 0, o = u) : 1 <= o + p ? (a = (t * l - 1) * Math.pow(2, i), o += p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, i), o = 0)); 8 <= i; e[n + d] = 255 & a, d += f, a /= 256, i -= 8);

            for (o = o << i | a, c += i; 0 < c; e[n + d] = 255 & o, d += f, o /= 256, c -= 8);

            e[n + d - f] |= 128 * _;
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
      }, {
        buffer: 3,
        lYpoI2: 10
      }]
    }, {}, [1])(1);
  },
  701: function (e) {
    var t = [];

    function n(e) {
      for (var n = -1, r = 0; r < t.length; r++) if (t[r].identifier === e) {
        n = r;
        break;
      }

      return n;
    }

    function r(e, r) {
      for (var s = {}, o = [], a = 0; a < e.length; a++) {
        var l = e[a],
            c = r.base ? l[0] + r.base : l[0],
            u = s[c] || 0,
            p = "".concat(c, " ").concat(u);
        s[c] = u + 1;
        var h = n(p),
            d = {
          css: l[1],
          media: l[2],
          sourceMap: l[3],
          supports: l[4],
          layer: l[5]
        };
        if (-1 !== h) t[h].references++, t[h].updater(d);else {
          var f = i(d, r);
          r.byIndex = a, t.splice(a, 0, {
            identifier: p,
            updater: f,
            references: 1
          });
        }
        o.push(p);
      }

      return o;
    }

    function i(e, t) {
      var n = t.domAPI(t);
      return n.update(e), function (t) {
        if (t) {
          if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return;
          n.update(e = t);
        } else n.remove();
      };
    }

    e.exports = function (e, i) {
      var s = r(e = e || [], i = i || {});
      return function (e) {
        e = e || [];

        for (var o = 0; o < s.length; o++) {
          var a = n(s[o]);
          t[a].references--;
        }

        for (var l = r(e, i), c = 0; c < s.length; c++) {
          var u = n(s[c]);
          0 === t[u].references && (t[u].updater(), t.splice(u, 1));
        }

        s = l;
      };
    };
  },
  182: function (e) {
    e.exports = function (e) {
      var t = document.createElement("style");
      return e.setAttributes(t, e.attributes), e.insert(t, e.options), t;
    };
  },
  850: function (e, t, n) {
    e.exports = function (e) {
      var t = n.nc;
      t && e.setAttribute("nonce", t);
    };
  },
  236: function (e) {
    e.exports = function (e) {
      var t = e.insertStyleElement(e);
      return {
        update: function (n) {
          !function (e, t, n) {
            var r = "";
            n.supports && (r += "@supports (".concat(n.supports, ") {")), n.media && (r += "@media ".concat(n.media, " {"));
            var i = void 0 !== n.layer;
            i && (r += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")), r += n.css, i && (r += "}"), n.media && (r += "}"), n.supports && (r += "}");
            var s = n.sourceMap;
            s && "undefined" != typeof btoa && (r += "\n/", r += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), r += "/"), t.styleTagTransform(r, e, t.options);
          }(t, e, n);
        },
        remove: function () {
          !function (e) {
            if (null === e.parentNode) return !1;
            e.parentNode.removeChild(e);
          }(t);
        }
      };
    };
  },
  213: function (e) {
    e.exports = function (e, t) {
      if (t.styleSheet) t.styleSheet.cssText = e;else {
        for (; t.firstChild;) t.removeChild(t.firstChild);

        t.appendChild(document.createTextNode(e));
      }
    };
  },
  1: function (e) {
    self, e.exports = function () {
      var e = {
        820: function (e, t, n) {
          var r = n(537),
              i = n.n(r),
              s = n(645),
              o = n.n(s)()(i());
          o.push([e.id, ".treejs {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.treejs *:after,\n.treejs *:before {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.treejs > .treejs-node {\n  padding-left: 0;\n}\n.treejs .treejs-nodes {\n  list-style: none;\n  padding-left: 18px;\n  margin: 0;\n  overflow: hidden;\n  -webkit-transition: height 150ms ease-out, opacity 150ms ease-out;\n  -o-transition: height 150ms ease-out, opacity 150ms ease-out;\n  transition: height 150ms ease-out, opacity 150ms ease-out;\n}\n.treejs .treejs-node {\n  cursor: pointer;\n  overflow: hidden;\n}\n.treejs .treejs-node.treejs-placeholder {\n  padding-left: 18px;\n}\n.treejs .treejs-switcher {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n  -webkit-transition: -webkit-transform 150ms ease-out;\n  transition: -webkit-transform 150ms ease-out;\n  -o-transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out, -webkit-transform 150ms ease-out;\n}\n.treejs .treejs-switcher:before {\n  position: absolute;\n  top: 8px;\n  left: 6px;\n  display: block;\n  content: ' ';\n  border: 4px solid transparent;\n  border-top: 4px solid rgba(245, 245, 245, 0.7);\n  -webkit-transition: border-color 150ms;\n  -o-transition: border-color 150ms;\n  transition: border-color 150ms;\n}\n.treejs .treejs-switcher:hover:before {\n  border-top: 4px solid rgba(245, 245, 245, 0.96);\n}\n.treejs .treejs-node__close > .treejs-switcher {\n  -webkit-transform: rotate(-90deg);\n      -ms-transform: rotate(-90deg);\n          transform: rotate(-90deg);\n}\n.treejs .treejs-node__close > .treejs-nodes {\n  height: 0;\n}\n.treejs .treejs-checkbox {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n}\n.treejs .treejs-checkbox:before {\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n  cursor: pointer;\n  position: absolute;\n  top: 2px;\n  content: ' ';\n  display: block;\n  width: 16px;\n  height: 16px;\n  border: 1px solid #d9d9d9;\n  border-radius: 2px;\n}\n.treejs .treejs-checkbox:hover:before {\n  -webkit-box-shadow: 0 0 2px 1px #1890ff;\n          box-shadow: 0 0 2px 1px #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 4px;\n  left: 5px;\n  width: 5px;\n  height: 9px;\n  border: 2px solid #fff;\n  border-top: none;\n  border-left: none;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg);\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 9px;\n  left: 3px;\n  width: 10px;\n  height: 2px;\n  background-color: #fff;\n}\n.treejs .treejs-node__disabled {\n  cursor: not-allowed;\n  color: rgba(255, 255, 255, 0.25);\n}\n.treejs .treejs-node__disabled .treejs-checkbox {\n  cursor: not-allowed;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:before {\n  cursor: not-allowed;\n  border-color: #d9d9d9 !important;\n  background-color: #f5f5f5 !important;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:hover:before {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.treejs .treejs-node__disabled .treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled .treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-label {\n  vertical-align: middle;\n}\n", "", {
            version: 3,
            sources: ["webpack://./src/index.less"],
            names: [],
            mappings: "AAKA;EACE,8BAAA;UAAA,sBAAA;EACA,eAAA;EACA,kBAAA;EACA,yBAAA;KAAA,sBAAA;MAAA,qBAAA;UAAA,iBAAA;AAJF;AAAA;;EAQI,8BAAA;UAAA,sBAAA;AAJJ;AAOE;EACE,eAAA;AALJ;AAPA;EAgBI,gBAAA;EACA,kBAAA;EACA,SAAA;EACA,gBAAA;EACA,iEAAA;EAAA,4DAAA;EAAA,yDAAA;AANJ;AAdA;EAwBI,eAAA;EACA,gBAAA;AAPJ;AASI;EACE,kBAAA;AAPN;AArBA;EAiCI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;EACA,oDAAA;EAAA,4CAAA;EAAA,uCAAA;EAAA,oCAAA;EAAA,sEAAA;AATJ;AAWI;EACE,kBAAA;EACA,QAAA;EACA,SAAA;EACA,cAAA;EACA,YAAA;EACA,6BAAA;EACA,8CAAA;EACA,sCAAA;EAAA,iCAAA;EAAA,8BAAA;AATN;AAWI;EACE,+CAAA;AATN;AA3CA;EAwDI,iCAAA;MAAA,6BAAA;UAAA,yBAAA;AAVJ;AA9CA;EA2DI,SAAA;AAVJ;AAjDA;EA+DI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;AAXJ;AAaI;EACE,4BAAA;EAAA,uBAAA;EAAA,oBAAA;EACA,eAAA;EACA,kBAAA;EACA,QAAA;EACA,YAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,yBAAA;EACA,kBAAA;AAXN;AAaI;EACE,uCAAA;UAAA,+BAAA;AAXN;AAgBM;EACE,yBAAA;EACA,qBAAA;AAdR;AAgBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,UAAA;EACA,WAAA;EACA,sBAAA;EACA,gBAAA;EACA,iBAAA;EACA,gCAAA;MAAA,4BAAA;UAAA,wBAAA;AAdR;AAoBM;EACE,yBAAA;EACA,qBAAA;AAlBR;AAoBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;EACA,WAAA;EACA,sBAAA;AAlBR;AAvGA;EA+HI,mBAAA;EACA,gCAAA;AArBJ;AA3GA;EAkIM,mBAAA;AApBN;AAqBM;EACE,mBAAA;EACA,gCAAA;EACA,oCAAA;AAnBR;AAqBM;EACE,mCAAA;UAAA,2BAAA;AAnBR;AAwBQ;EACE,qBAAA;AAtBV;AA4BQ;EACE,yBAAA;AA1BV;AAiCM;EACE,qBAAA;AA/BR;AAqCM;EACE,yBAAA;AAnCR;AAlIA;EA2KI,sBAAA;AAtCJ",
            sourcesContent: ["@color-disable: #d4d4d4;\n@bgcolor-disable: #f5f5f5;\n@greyborder: #d9d9d9;\n@bluebg: #1890ff;\n\n.treejs {\n  box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  user-select: none;\n\n  *:after,\n  *:before {\n    box-sizing: border-box;\n  }\n\n  & > .treejs-node {\n    padding-left: 0;\n  }\n\n  .treejs-nodes {\n    list-style: none;\n    padding-left: 18px;\n    margin: 0; //  for default ul...\n    overflow: hidden;\n    transition: height 150ms ease-out, opacity 150ms ease-out;\n  }\n\n  .treejs-node {\n    cursor: pointer;\n    overflow: hidden;\n\n    &.treejs-placeholder {\n      padding-left: 18px;\n    }\n  }\n\n  .treejs-switcher {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n    transition: transform 150ms ease-out;\n\n    &:before {\n      position: absolute;\n      top: 8px;\n      left: 6px;\n      display: block;\n      content: ' ';\n      border: 4px solid transparent;\n      border-top: 4px solid rgba(245, 245, 245, 0.7);\n      transition: border-color 150ms;\n    }\n    &:hover:before {\n      border-top: 4px solid rgba(245, 245, 245, 0.96);\n    }\n  }\n  .treejs-node__close > .treejs-switcher {\n    transform: rotate(-90deg);\n  }\n  .treejs-node__close > .treejs-nodes {\n    height: 0;\n  }\n\n  .treejs-checkbox {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n\n    &:before {\n      transition: all 0.3s;\n      cursor: pointer;\n      position: absolute;\n      top: 2px;\n      content: ' ';\n      display: block;\n      width: 16px;\n      height: 16px;\n      border: 1px solid @greyborder;\n      border-radius: 2px;\n    }\n    &:hover:before {\n      box-shadow: 0 0 2px 1px @bluebg;\n    }\n  }\n  .treejs-node__checked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 4px;\n        left: 5px;\n        width: 5px;\n        height: 9px;\n        border: 2px solid #fff;\n        border-top: none;\n        border-left: none;\n        transform: rotate(45deg);\n      }\n    }\n  }\n  .treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 9px;\n        left: 3px;\n        width: 10px;\n        height: 2px;\n        background-color: #fff;\n      }\n    }\n  }\n\n  .treejs-node__disabled {\n    cursor: not-allowed;\n    color: rgba(255, 255, 255, 0.25);\n    .treejs-checkbox {\n      cursor: not-allowed;\n      &:before {\n        cursor: not-allowed;\n        border-color: @greyborder !important;\n        background-color: @bgcolor-disable !important;\n      }\n      &:hover:before {\n        box-shadow: none !important;\n      }\n    }\n    .treejs-node__checked {\n      & > .treejs-checkbox {\n        &:after {\n          border-color: @greyborder;\n        }\n      }\n    }\n    .treejs-node__halfchecked {\n      & > .treejs-checkbox {\n        &:after {\n          background-color: @greyborder;\n        }\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__checked {\n    & > .treejs-checkbox {\n      &:after {\n        border-color: @greyborder;\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:after {\n        background-color: @greyborder;\n      }\n    }\n  }\n\n  .treejs-label {\n    vertical-align: middle;\n  }\n}\n"],
            sourceRoot: ""
          }]), t.Z = o;
        },
        645: function (e) {
          e.exports = function (e) {
            var t = [];
            return t.toString = function () {
              return this.map(function (t) {
                var n = "",
                    r = void 0 !== t[5];
                return t[4] && (n += "@supports (".concat(t[4], ") {")), t[2] && (n += "@media ".concat(t[2], " {")), r && (n += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")), n += e(t), r && (n += "}"), t[2] && (n += "}"), t[4] && (n += "}"), n;
              }).join("");
            }, t.i = function (e, n, r, i, s) {
              "string" == typeof e && (e = [[null, e, void 0]]);
              var o = {};
              if (r) for (var a = 0; a < this.length; a++) {
                var l = this[a][0];
                null != l && (o[l] = !0);
              }

              for (var c = 0; c < e.length; c++) {
                var u = [].concat(e[c]);
                r && o[u[0]] || (void 0 !== s && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = s), n && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = n) : u[2] = n), i && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = i) : u[4] = "".concat(i)), t.push(u));
              }
            }, t;
          };
        },
        537: function (e) {
          e.exports = function (e) {
            var t = e[1],
                n = e[3];
            if (!n) return t;

            if ("function" == typeof btoa) {
              var r = btoa(unescape(encodeURIComponent(JSON.stringify(n)))),
                  i = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r),
                  s = "/*# ".concat(i, " */"),
                  o = n.sources.map(function (e) {
                return "/*# sourceURL=".concat(n.sourceRoot || "").concat(e, " */");
              });
              return [t].concat(o).concat([s]).join("\n");
            }

            return [t].join("\n");
          };
        },
        379: function (e) {
          var t = [];

          function n(e) {
            for (var n = -1, r = 0; r < t.length; r++) if (t[r].identifier === e) {
              n = r;
              break;
            }

            return n;
          }

          function r(e, r) {
            for (var s = {}, o = [], a = 0; a < e.length; a++) {
              var l = e[a],
                  c = r.base ? l[0] + r.base : l[0],
                  u = s[c] || 0,
                  p = "".concat(c, " ").concat(u);
              s[c] = u + 1;
              var h = n(p),
                  d = {
                css: l[1],
                media: l[2],
                sourceMap: l[3],
                supports: l[4],
                layer: l[5]
              };
              if (-1 !== h) t[h].references++, t[h].updater(d);else {
                var f = i(d, r);
                r.byIndex = a, t.splice(a, 0, {
                  identifier: p,
                  updater: f,
                  references: 1
                });
              }
              o.push(p);
            }

            return o;
          }

          function i(e, t) {
            var n = t.domAPI(t);
            return n.update(e), function (t) {
              if (t) {
                if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return;
                n.update(e = t);
              } else n.remove();
            };
          }

          e.exports = function (e, i) {
            var s = r(e = e || [], i = i || {});
            return function (e) {
              e = e || [];

              for (var o = 0; o < s.length; o++) {
                var a = n(s[o]);
                t[a].references--;
              }

              for (var l = r(e, i), c = 0; c < s.length; c++) {
                var u = n(s[c]);
                0 === t[u].references && (t[u].updater(), t.splice(u, 1));
              }

              s = l;
            };
          };
        },
        216: function (e) {
          e.exports = function (e) {
            var t = document.createElement("style");
            return e.setAttributes(t, e.attributes), e.insert(t, e.options), t;
          };
        },
        636: function (e, t, n) {
          e.exports = function (e) {
            var t = n.nc;
            t && e.setAttribute("nonce", t);
          };
        },
        795: function (e) {
          e.exports = function (e) {
            var t = e.insertStyleElement(e);
            return {
              update: function (n) {
                !function (e, t, n) {
                  var r = "";
                  n.supports && (r += "@supports (".concat(n.supports, ") {")), n.media && (r += "@media ".concat(n.media, " {"));
                  var i = void 0 !== n.layer;
                  i && (r += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")), r += n.css, i && (r += "}"), n.media && (r += "}"), n.supports && (r += "}");
                  var s = n.sourceMap;
                  s && "undefined" != typeof btoa && (r += "\n/", r += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), r += "/"), t.styleTagTransform(r, e, t.options);
                }(t, e, n);
              },
              remove: function () {
                !function (e) {
                  if (null === e.parentNode) return !1;
                  e.parentNode.removeChild(e);
                }(t);
              }
            };
          };
        },
        589: function (e) {
          e.exports = function (e, t) {
            if (t.styleSheet) t.styleSheet.cssText = e;else {
              for (; t.firstChild;) t.removeChild(t.firstChild);

              t.appendChild(document.createTextNode(e));
            }
          };
        }
      },
          t = {};

      function n(r) {
        var i = t[r];
        if (void 0 !== i) return i.exports;
        var s = t[r] = {
          id: r,
          exports: {}
        };
        return e[r](s, s.exports, n), s.exports;
      }

      n.n = function (e) {
        var t = e && e.__esModule ? function () {
          return e.default;
        } : function () {
          return e;
        };
        return n.d(t, {
          a: t
        }), t;
      }, n.d = function (e, t) {
        for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
          enumerable: !0,
          get: t[r]
        });
      }, n.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }, n.nc = void 0;
      var r = {};
      return function () {
        n.d(r, {
          default: function () {
            return C;
          }
        });
        var e = n(379),
            t = n.n(e),
            i = n(795),
            s = n.n(i),
            o = n(636),
            a = n.n(o),
            l = n(216),
            c = n.n(l),
            u = n(589),
            p = n.n(u),
            h = n(820),
            d = {};
        h.Z && h.Z.locals && (d.locals = h.Z.locals);
        var f,
            _ = 0,
            m = {};
        m.styleTagTransform = p(), m.setAttributes = a(), m.insert = function (e, t) {
          (t.target || document.head).appendChild(e);
        }, m.domAPI = s(), m.insertStyleElement = c(), d.use = function (e) {
          return m.options = e || {}, _++ || (f = t()(h.Z, m)), d;
        }, d.unuse = function () {
          _ > 0 && ! --_ && (f(), f = null);
        };
        var g = d;

        function v(e, t) {
          return function (e) {
            if (Array.isArray(e)) return e;
          }(e) || function (e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];

            if (null != n) {
              var r,
                  i,
                  s = [],
                  o = !0,
                  a = !1;

              try {
                for (n = n.call(e); !(o = (r = n.next()).done) && (s.push(r.value), !t || s.length !== t); o = !0);
              } catch (e) {
                a = !0, i = e;
              } finally {
                try {
                  o || null == n.return || n.return();
                } finally {
                  if (a) throw i;
                }
              }

              return s;
            }
          }(e, t) || function (e, t) {
            if (e) {
              if ("string" == typeof e) return b(e, t);
              var n = Object.prototype.toString.call(e).slice(8, -1);
              return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? b(e, t) : void 0;
            }
          }(e, t) || function () {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }

        function b(e, t) {
          (null == t || t > e.length) && (t = e.length);

          for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];

          return r;
        }

        function x(e, t) {
          var n = Object.keys(e);

          if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })), n.push.apply(n, r);
          }

          return n;
        }

        function y(e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? x(Object(n), !0).forEach(function (t) {
              w(e, t, n[t]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
            });
          }

          return e;
        }

        function w(e, t, n) {
          return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : e[t] = n, e;
        }

        function S(e, t) {
          for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
          }
        }

        function M(e) {
          var t = {};
          return e.reduce(function (e, n) {
            return t[n] || (t[n] = !0, e.push(n)), e;
          }, []);
        }

        function T(e, t) {
          requestAnimationFrame(function () {
            t.enter(), requestAnimationFrame(function () {
              t.active(), setTimeout(function () {
                t.leave();
              }, e);
            });
          });
        }

        function E(e, t) {
          try {
            var n = e.liElementsById[t.parent.id];
            n.classList.contains("treejs-node__close") || n.getElementsByClassName("treejs-switcher")[0].click();
          } catch (e) {
            return;
          }

          Object.prototype.hasOwnProperty.call(t, "parent") && E(e, t.parent);
        }

        function A(e, t) {
          var n = e.liElementsById[t.id];
          n.classList.contains("treejs-node__close") && n.getElementsByClassName("treejs-switcher")[0].click(), Object.prototype.hasOwnProperty.call(t, "children") && t.children.forEach(function (t) {
            return A(e, t);
          });
        }

        var C = function () {
          function e(t, n) {
            !function (e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            }(this, e), g.use({
              target: "string" == typeof this.container ? document.querySelector(this.container) : this.container
            }), this.treeNodes = [], this.nodesById = {}, this.leafNodesById = {}, this.liElementsById = {}, this.willUpdateNodesById = {}, this.container = t, this.options = Object.assign({
              values: [],
              disables: [],
              loaded: null,
              closeDepth: null
            }, n), Object.defineProperties(this, {
              values: {
                get: function () {
                  return this.getValues();
                },
                set: function (e) {
                  this.setValues(M(e));
                }
              },
              disables: {
                get: function () {
                  return this.getDisables();
                },
                set: function (e) {
                  this.setDisables(M(e));
                }
              },
              selectedNodes: {
                get: function () {
                  var e = [],
                      t = this.nodesById;
                  return Object.keys(t).forEach(function (n) {
                    if (Object.prototype.hasOwnProperty.call(t, n) && (1 === t[n].status || 2 === t[n].status)) {
                      var r = y({}, t[n]);
                      delete r.parent, delete r.children, e.push(r);
                    }
                  }), e;
                }
              },
              disabledNodes: {
                get: function () {
                  var e = [],
                      t = this.nodesById;
                  return Object.keys(t).forEach(function (n) {
                    if (Object.prototype.hasOwnProperty.call(t, n) && t[n].disabled) {
                      var r = y({}, t[n]);
                      delete r.parent, e.push(r);
                    }
                  }), e;
                }
              }
            }), this.init(this.options.data);
          }

          var t, n, r;
          return t = e, r = [{
            key: "onSwitcherClick",
            value: function (e) {
              var t = e.parentNode,
                  n = t.lastChild,
                  r = n.scrollHeight;
              t.classList.contains("treejs-node__close") ? T(150, {
                enter: function () {
                  n.style.height = 0, n.style.opacity = 0;
                },
                active: function () {
                  n.style.height = "".concat(r, "px"), n.style.opacity = 1;
                },
                leave: function () {
                  n.style.height = "", n.style.opacity = "", t.classList.remove("treejs-node__close");
                }
              }) : T(150, {
                enter: function () {
                  n.style.height = "".concat(r, "px"), n.style.opacity = 1;
                },
                active: function () {
                  n.style.height = 0, n.style.opacity = 0;
                },
                leave: function () {
                  n.style.height = "", n.style.opacity = "", t.classList.add("treejs-node__close");
                }
              });
            }
          }, {
            key: "parseTreeData",
            value: function (e) {
              var t,
                  n = (t = e, JSON.parse(JSON.stringify(t))),
                  r = {},
                  i = {},
                  s = [],
                  o = [];
              return function e(t, n) {
                t.forEach(function (t) {
                  r[t.id] = t, t.checked && s.push(t.id), t.disabled && o.push(t.id), n && (t.parent = n), t.children && t.children.length ? e(t.children, t) : i[t.id] = t;
                });
              }(n), {
                treeNodes: n,
                nodesById: r,
                leafNodesById: i,
                defaultValues: s,
                defaultDisables: o
              };
            }
          }, {
            key: "createRootEle",
            value: function () {
              var e = document.createElement("div");
              return e.classList.add("treejs"), e;
            }
          }, {
            key: "createUlEle",
            value: function () {
              var e = document.createElement("ul");
              return e.classList.add("treejs-nodes"), e;
            }
          }, {
            key: "createLiEle",
            value: function (e, t) {
              var n = document.createElement("li");

              if (n.classList.add("treejs-node"), t && n.classList.add("treejs-node__close"), e.children && e.children.length) {
                var r = document.createElement("span");
                r.classList.add("treejs-switcher"), n.appendChild(r);
              } else n.classList.add("treejs-placeholder");

              var i = document.createElement("span");
              i.classList.add("treejs-checkbox"), n.appendChild(i);
              var s = document.createElement("span");
              s.classList.add("treejs-label");
              var o = document.createTextNode(e.text);
              return s.appendChild(o), n.appendChild(s), n.nodeId = e.id, n;
            }
          }], (n = [{
            key: "init",
            value: function (t) {
              var n = e.parseTreeData(t),
                  r = n.treeNodes,
                  i = n.nodesById,
                  s = n.leafNodesById,
                  o = n.defaultValues,
                  a = n.defaultDisables;
              this.treeNodes = r, this.nodesById = i, this.leafNodesById = s, this.render(this.treeNodes);
              var l = this.options,
                  c = l.values,
                  u = l.disables,
                  p = l.loaded;
              c && c.length ? this.setValues(c) : o && o.length && this.setValues(o), u && u.length ? this.setDisables(u) : a && a.length && this.setDisables(a), "function" == typeof p && p.call(this);
            }
          }, {
            key: "render",
            value: function (t) {
              var n = e.createRootEle();
              n.appendChild(this.buildTree(t, 0)), this.bindEvent(n);
              var r = "string" == typeof this.container ? document.querySelector(this.container) : this.container;
              !function (e) {
                for (; e.firstChild;) e.removeChild(e.firstChild);
              }(r), r.appendChild(n);
            }
          }, {
            key: "buildTree",
            value: function (t, n) {
              var r = this,
                  i = e.createUlEle();
              return t && t.length && t.forEach(function (t) {
                var s = e.createLiEle(t, n === r.options.closeDepth - 1);
                r.liElementsById[t.id] = s;
                var o = null;
                t.children && t.children.length && (o = r.buildTree(t.children, n + 1)), o && s.appendChild(o), i.appendChild(s);
              }), i;
            }
          }, {
            key: "bindEvent",
            value: function (t) {
              var n = this;
              t.addEventListener("click", function (t) {
                var r = t.target;
                "SPAN" === r.nodeName && r.classList.contains("treejs-checkbox") ? n.onItemClick(r.parentNode.nodeId) : "SPAN" === r.nodeName && r.classList.contains("treejs-label") ? n.onItemLabelClick(r.parentNode.nodeId) : "LI" === r.nodeName && r.classList.contains("treejs-node") ? n.onItemClick(r.nodeId) : "SPAN" === r.nodeName && r.classList.contains("treejs-switcher") && e.onSwitcherClick(r);
              }, !1);
            }
          }, {
            key: "onItemClick",
            value: function (e) {
              var t = this.nodesById[e],
                  n = this.options.onChange;
              t.disabled || (this.setValue(e), this.updateLiElements()), n && n.call(this);
            }
          }, {
            key: "onItemLabelClick",
            value: function (e) {
              var t = this.options.onItemLabelClick;
              t && t.call(this, e);
            }
          }, {
            key: "setValue",
            value: function (e) {
              var t = this.nodesById[e];

              if (t) {
                var n = t.status,
                    r = 1 === n || 2 === n ? 0 : 2;
                t.status = r, this.markWillUpdateNode(t), this.walkUp(t, "status"), this.walkDown(t, "status");
              }
            }
          }, {
            key: "getValues",
            value: function () {
              var e = this,
                  t = [];
              return Object.keys(this.leafNodesById).forEach(function (n) {
                Object.prototype.hasOwnProperty.call(e.leafNodesById, n) && (1 !== e.leafNodesById[n].status && 2 !== e.leafNodesById[n].status || t.push(n));
              }), t;
            }
          }, {
            key: "setValues",
            value: function (e) {
              var t = this;
              this.emptyNodesCheckStatus(), e.forEach(function (e) {
                t.setValue(e);
              }), this.updateLiElements();
              var n = this.options.onChange;
              n && n.call(this);
            }
          }, {
            key: "setDisable",
            value: function (e) {
              var t = this.nodesById[e];
              t && (t.disabled || (t.disabled = !0, this.markWillUpdateNode(t), this.walkUp(t, "disabled"), this.walkDown(t, "disabled")));
            }
          }, {
            key: "getDisables",
            value: function () {
              var e = this,
                  t = [];
              return Object.keys(this.leafNodesById).forEach(function (n) {
                Object.prototype.hasOwnProperty.call(e.leafNodesById, n) && e.leafNodesById[n].disabled && t.push(n);
              }), t;
            }
          }, {
            key: "setDisables",
            value: function (e) {
              var t = this;
              this.emptyNodesDisable(), e.forEach(function (e) {
                t.setDisable(e);
              }), this.updateLiElements();
            }
          }, {
            key: "emptyNodesCheckStatus",
            value: function () {
              this.willUpdateNodesById = this.getSelectedNodesById(), Object.values(this.willUpdateNodesById).forEach(function (e) {
                e.disabled || (e.status = 0);
              });
            }
          }, {
            key: "emptyNodesDisable",
            value: function () {
              this.willUpdateNodesById = this.getDisabledNodesById(), Object.values(this.willUpdateNodesById).forEach(function (e) {
                e.disabled = !1;
              });
            }
          }, {
            key: "getSelectedNodesById",
            value: function () {
              return Object.entries(this.nodesById).reduce(function (e, t) {
                var n = v(t, 2),
                    r = n[0],
                    i = n[1];
                return 1 !== i.status && 2 !== i.status || (e[r] = i), e;
              }, {});
            }
          }, {
            key: "getDisabledNodesById",
            value: function () {
              return Object.entries(this.nodesById).reduce(function (e, t) {
                var n = v(t, 2),
                    r = n[0],
                    i = n[1];
                return i.disabled && (e[r] = i), e;
              }, {});
            }
          }, {
            key: "updateLiElements",
            value: function () {
              var e = this;
              Object.values(this.willUpdateNodesById).forEach(function (t) {
                e.updateLiElement(t);
              }), this.willUpdateNodesById = {};
            }
          }, {
            key: "markWillUpdateNode",
            value: function (e) {
              this.willUpdateNodesById[e.id] = e;
            }
          }, {
            key: "walkUp",
            value: function (e, t) {
              var n = e.parent;

              if (n) {
                if ("status" === t) {
                  var r,
                      i = n.children.reduce(function (e, t) {
                    return Number.isNaN(t.status) ? e : e + t.status;
                  }, 0);
                  if (r = i ? i === 2 * n.children.length ? 2 : 1 : 0, n.status === r) return;
                  n.status = r;
                } else {
                  var s = n.children.reduce(function (e, t) {
                    return e && t.disabled;
                  }, !0);
                  if (n.disabled === s) return;
                  n.disabled = s;
                }

                this.markWillUpdateNode(n), this.walkUp(n, t);
              }
            }
          }, {
            key: "walkDown",
            value: function (e, t) {
              var n = this;
              e.children && e.children.length && e.children.forEach(function (r) {
                "status" === t && r.disabled || (r[t] = e[t], n.markWillUpdateNode(r), n.walkDown(r, t));
              });
            }
          }, {
            key: "updateLiElement",
            value: function (e) {
              var t = this.liElementsById[e.id].classList;

              switch (e.status) {
                case 0:
                  t.remove("treejs-node__halfchecked", "treejs-node__checked");
                  break;

                case 1:
                  t.remove("treejs-node__checked"), t.add("treejs-node__halfchecked");
                  break;

                case 2:
                  t.remove("treejs-node__halfchecked"), t.add("treejs-node__checked");
              }

              switch (e.disabled) {
                case !0:
                  t.contains("treejs-node__disabled") || t.add("treejs-node__disabled");
                  break;

                case !1:
                  t.contains("treejs-node__disabled") && t.remove("treejs-node__disabled");
              }
            }
          }, {
            key: "collapseAll",
            value: function () {
              var e = this;
              Object.keys(this.leafNodesById).forEach(function (t) {
                var n = e.leafNodesById[t];
                E(e, n);
              });
            }
          }, {
            key: "expandAll",
            value: function () {
              A(this, this.treeNodes[0]);
            }
          }]) && S(t.prototype, n), r && S(t, r), Object.defineProperty(t, "prototype", {
            writable: !1
          }), e;
        }();
      }(), r.default;
    }();
  },
  819: function (e, t) {
    !function (e) {
      const t = "tp";

      function n(e) {
        return t => n => {
          if (!t && void 0 === n) return {
            succeeded: !1,
            value: void 0
          };
          if (t && void 0 === n) return {
            succeeded: !0,
            value: void 0
          };
          const r = e(n);
          return void 0 !== r ? {
            succeeded: !0,
            value: r
          } : {
            succeeded: !1,
            value: void 0
          };
        };
      }

      function r(e) {
        return {
          custom: t => n(t)(e),
          boolean: n(e => "boolean" == typeof e ? e : void 0)(e),
          number: n(e => "number" == typeof e ? e : void 0)(e),
          string: n(e => "string" == typeof e ? e : void 0)(e),
          function: n(e => "function" == typeof e ? e : void 0)(e),
          constant: t => n(e => e === t ? t : void 0)(e),
          raw: n(e => e)(e),
          object: t => n(e => {
            if (null !== (n = e) && "object" == typeof n) return function (e, t) {
              return Object.keys(t).reduce((n, r) => {
                if (void 0 === n) return;
                const i = (0, t[r])(e[r]);
                return i.succeeded ? Object.assign(Object.assign({}, n), {
                  [r]: i.value
                }) : void 0;
              }, {});
            }(e, t);
            var n;
          })(e),
          array: t => n(e => {
            if (Array.isArray(e)) return n = t, e.reduce((e, t) => {
              if (void 0 === e) return;
              const r = n(t);
              return r.succeeded && void 0 !== r.value ? [...e, r.value] : void 0;
            }, []);
            var n;
          })(e)
        };
      }

      const i = {
        optional: r(!0),
        required: r(!1)
      };

      function s(e, t, n, r) {
        return new (n || (n = Promise))(function (i, s) {
          function o(e) {
            try {
              l(r.next(e));
            } catch (e) {
              s(e);
            }
          }

          function a(e) {
            try {
              l(r.throw(e));
            } catch (e) {
              s(e);
            }
          }

          function l(e) {
            var t;
            e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {
              e(t);
            })).then(o, a);
          }

          l((r = r.apply(e, t || [])).next());
        });
      }

      function o(e) {
        return s(this, void 0, void 0, function* () {
          const t = new Image();
          return t.crossOrigin = "anonymous", new Promise((n, r) => {
            t.src = e, t.onload = () => {
              n(t);
            }, t.onerror = r;
          });
        });
      }

      const a = (l = "img", (e, n) => [t, "-", l, "v", e ? `_${e}` : "", n ? `-${n}` : ""].join(""));
      var l;

      class c {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(a()), t.viewProps.bindClassModifiers(this.element), this.input = e.createElement("input"), this.input.classList.add(a("input")), this.input.setAttribute("type", "file"), this.input.setAttribute("accept", t.extensions.join(",")), this.image_ = e.createElement("img"), this.image_.classList.add(a("image")), this.image_.classList.add(a(`image_${t.imageFit}`)), this.image_.crossOrigin = "anonymous", this.image_.onclick = e => {
            t.clickCallback ? t.clickCallback(e, this.input) : this.input.click();
          }, this.element.classList.add(a("area_root")), this.element.appendChild(this.image_), this.element.appendChild(this.input);
        }

        changeImage(e) {
          this.image_.src = e;
        }

        changeDraggingState(e) {
          const t = this.element;
          e ? null == t || t.classList.add(a("area_dragging")) : null == t || t.classList.remove(a("area_dragging"));
        }

      }

      let u = null;

      class p {
        constructor(e, t) {
          this.value = t.value, this.viewProps = t.viewProps, this.view = new c(e, {
            viewProps: this.viewProps,
            extensions: t.extensions,
            imageFit: t.imageFit,
            clickCallback: t.clickCallback
          }), this.onFile = this.onFile.bind(this), this.onDrop = this.onDrop.bind(this), this.onDragOver = this.onDragOver.bind(this), this.onDragLeave = this.onDragLeave.bind(this), this.view.input.addEventListener("change", this.onFile), this.view.element.addEventListener("drop", this.onDrop), this.view.element.addEventListener("dragover", this.onDragOver), this.view.element.addEventListener("dragleave", this.onDragLeave), this.viewProps.handleDispose(() => {
            this.view.input.removeEventListener("change", this.onFile), this.view.input.removeEventListener("drop", this.onDrop), this.view.input.removeEventListener("dragover", this.onDragOver), this.view.input.removeEventListener("dragleave", this.onDragLeave);
          }), this.value.emitter.on("change", this.handleValueChange.bind(this)), this.handleValueChange();
        }

        onFile(e) {
          const t = (null == e ? void 0 : e.target).files;
          if (!t || !t.length) return;
          const n = t[0];
          this.setValue(n);
        }

        onDrop(e) {
          return s(this, void 0, void 0, function* () {
            e.preventDefault();

            try {
              const {
                dataTransfer: t
              } = e,
                    n = null == t ? void 0 : t.files[0];
              if (n) this.setValue(n);else {
                const e = null == t ? void 0 : t.getData("url");
                if (!e) throw new Error("No url");
                this.setValue(e);
              }
            } catch (e) {
              console.error("Could not parse the dropped image", e);
            } finally {
              this.view.changeDraggingState(!1);
            }
          });
        }

        onDragOver(e) {
          e.preventDefault(), this.view.changeDraggingState(!0);
        }

        onDragLeave() {
          this.view.changeDraggingState(!1);
        }

        handleImage(e) {
          return s(this, void 0, void 0, function* () {
            e instanceof HTMLImageElement ? this.updateImage(e.src) : "string" != typeof e && e ? yield this.setValue(e) : ("placeholder" !== e && e || (e = (yield this.handlePlaceholderImage()).src), this.updateImage(e));
          });
        }

        updateImage(e) {
          this.view.changeImage(e);
        }

        setValue(e) {
          return s(this, void 0, void 0, function* () {
            if (e instanceof HTMLImageElement) this.value.setRawValue(e);else if (e instanceof File) {
              const t = URL.createObjectURL(e) + "#" + e.name;
              e.src = t;
              const n = yield o(t).catch(() => {});
              this.value.setRawValue(n || e);
            } else e ? this.value.setRawValue(yield o(e)) : this.value.setRawValue(yield this.handlePlaceholderImage());
          });
        }

        handleValueChange() {
          this.handleImage(this.value.rawValue);
        }

        handlePlaceholderImage() {
          return s(this, void 0, void 0, function* () {
            return u || (u = yield function () {
              const e = document.createElement("canvas");
              e.width = 320, e.height = 50;
              const t = e.getContext("2d");
              return t.fillStyle = "#00000004", t.fillRect(0, 0, e.width, e.height), t.fillStyle = "#eee", t.font = '1.25rem "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace', t.textAlign = "center", t.textBaseline = "middle", t.fillText("No image", .5 * e.width, .5 * e.height), new Promise(t => {
                e.toBlob(e => {
                  const n = new Image();
                  n.src = URL.createObjectURL(e), n.isPlaceholder = !0, n.onload = () => {
                    t(n);
                  };
                });
              });
            }()), u;
          });
        }

      }

      const h = [".jpg", ".png", ".gif"],
            d = {
        id: "input-image",
        type: "input",
        css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:0.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:inline-flex;height:auto !important;max-height:calc(var(--bld-us) * 3);border-radius:4px;position:relative}.tp-imgv.tp-v-disabled{opacity:0.5}.tp-imgv_input{width:0;height:0;pointer-events:none;visibility:hidden}.tp-imgv_image{width:100%;height:-webkit-max-content;height:-moz-max-content;height:max-content;max-height:calc(var(--bld-us) * 3);border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity 0.16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:4px;opacity:0.6}",

        accept(e, t) {
          if (!(e instanceof HTMLImageElement || "string" == typeof e)) return null;

          const n = i,
                r = function (e, t) {
            const n = i.required.object(t)(e);
            return n.succeeded ? n.value : void 0;
          }(t, {
            view: n.required.constant("input-image"),
            acceptUrl: n.optional.boolean,
            clickCallback: n.optional.function,
            imageFit: n.optional.custom(e => "contain" === e || "cover" === e ? e : void 0),
            extensions: n.optional.array(n.required.string)
          });

          return r ? {
            initialValue: e,
            params: r
          } : null;
        },

        binding: {
          reader: e => e => void 0 !== e.src ? "" === e.src ? "placeholder" : e.src : e,
          writer: e => (e, t) => {
            e.write(t);
          }
        },

        controller(e) {
          var t, n;
          return new p(e.document, {
            value: e.value,
            imageFit: null !== (t = e.params.imageFit) && void 0 !== t ? t : "cover",
            clickCallback: e.params.clickCallback,
            viewProps: e.viewProps,
            extensions: null !== (n = e.params.extensions) && void 0 !== n ? n : h
          });
        }

      };
      e.plugin = d, Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }(t);
  },
  665: function (e, t) {
    !function (e) {
      class t {
        constructor(e) {
          this.controller_ = e;
        }

        get disabled() {
          return this.controller_.viewProps.get("disabled");
        }

        set disabled(e) {
          this.controller_.viewProps.set("disabled", e);
        }

        get hidden() {
          return this.controller_.viewProps.get("hidden");
        }

        set hidden(e) {
          this.controller_.viewProps.set("hidden", e);
        }

        dispose() {
          this.controller_.viewProps.set("disposed", !0);
        }

      }

      class n {
        constructor(e) {
          this.target = e;
        }

      }

      class r extends n {
        constructor(e, t, n, r) {
          super(e), this.value = t, this.presetKey = n, this.last = null == r || r;
        }

      }

      class i extends n {
        constructor(e, t, n) {
          super(e), this.value = t, this.presetKey = n;
        }

      }

      class s extends n {
        constructor(e, t) {
          super(e), this.expanded = t;
        }

      }

      function o(e) {
        return null == e;
      }

      function a(e, t) {
        if (e.length !== t.length) return !1;

        for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;

        return !0;
      }

      const l = {
        alreadydisposed: () => "View has been already disposed",
        invalidparams: e => `Invalid parameters for '${e.name}'`,
        nomatchingcontroller: e => `No matching controller for '${e.key}'`,
        nomatchingview: e => `No matching view for '${JSON.stringify(e.params)}'`,
        notbindable: () => "Value is not bindable",
        propertynotfound: e => `Property '${e.name}' not found`,
        shouldneverhappen: () => "This error should never happen"
      };

      class c {
        constructor(e) {
          var t;
          this.message = null !== (t = l[e.type](e.context)) && void 0 !== t ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type;
        }

        static alreadyDisposed() {
          return new c({
            type: "alreadydisposed"
          });
        }

        static notBindable() {
          return new c({
            type: "notbindable"
          });
        }

        static propertyNotFound(e) {
          return new c({
            type: "propertynotfound",
            context: {
              name: e
            }
          });
        }

        static shouldNeverHappen() {
          return new c({
            type: "shouldneverhappen"
          });
        }

      }

      class u {
        constructor(e, t, n) {
          this.obj_ = e, this.key_ = t, this.presetKey_ = null != n ? n : t;
        }

        static isBindable(e) {
          return null !== e && "object" == typeof e;
        }

        get key() {
          return this.key_;
        }

        get presetKey() {
          return this.presetKey_;
        }

        read() {
          return this.obj_[this.key_];
        }

        write(e) {
          this.obj_[this.key_] = e;
        }

        writeProperty(e, t) {
          const n = this.read();
          if (!u.isBindable(n)) throw c.notBindable();
          if (!(e in n)) throw c.propertyNotFound(e);
          n[e] = t;
        }

      }

      class p extends t {
        get label() {
          return this.controller_.props.get("label");
        }

        set label(e) {
          this.controller_.props.set("label", e);
        }

        get title() {
          var e;
          return null !== (e = this.controller_.valueController.props.get("title")) && void 0 !== e ? e : "";
        }

        set title(e) {
          this.controller_.valueController.props.set("title", e);
        }

        on(e, t) {
          const r = t.bind(this);
          return this.controller_.valueController.emitter.on(e, () => {
            r(new n(this));
          }), this;
        }

      }

      class h {
        constructor() {
          this.observers_ = {};
        }

        on(e, t) {
          let n = this.observers_[e];
          return n || (n = this.observers_[e] = []), n.push({
            handler: t
          }), this;
        }

        off(e, t) {
          const n = this.observers_[e];
          return n && (this.observers_[e] = n.filter(e => e.handler !== t)), this;
        }

        emit(e, t) {
          const n = this.observers_[e];
          n && n.forEach(e => {
            e.handler(t);
          });
        }

      }

      const d = "tp";

      function f(e) {
        return (t, n) => [d, "-", e, "v", t ? `_${t}` : "", n ? `-${n}` : ""].join("");
      }

      function _(e) {
        return e.rawValue;
      }

      function m(e, t) {
        var n, r;
        e.emitter.on("change", (n = _, r = t, e => r(n(e)))), t(e.rawValue);
      }

      function g(e, t, n) {
        m(e.value(t), n);
      }

      function v(e, t) {
        return n => {
          !function (e, t, n) {
            n ? e.classList.add(t) : e.classList.remove(t);
          }(e, t, n);
        };
      }

      function b(e, t) {
        m(e, e => {
          t.textContent = null != e ? e : "";
        });
      }

      const x = f("btn");

      class y {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(x()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("button");
          n.classList.add(x("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
          const r = e.createElement("div");
          r.classList.add(x("t")), b(t.props.value("title"), r), this.buttonElement.appendChild(r);
        }

      }

      class w {
        constructor(e, t) {
          this.emitter = new h(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new y(e, {
            props: this.props,
            viewProps: this.viewProps
          }), this.view.buttonElement.addEventListener("click", this.onClick_);
        }

        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }

      }

      class S {
        constructor(e, t) {
          var n;
          this.constraint_ = null == t ? void 0 : t.constraint, this.equals_ = null !== (n = null == t ? void 0 : t.equals) && void 0 !== n ? n : (e, t) => e === t, this.emitter = new h(), this.rawValue_ = e;
        }

        get constraint() {
          return this.constraint_;
        }

        get rawValue() {
          return this.rawValue_;
        }

        set rawValue(e) {
          this.setRawValue(e, {
            forceEmit: !1,
            last: !0
          });
        }

        setRawValue(e, t) {
          const n = null != t ? t : {
            forceEmit: !1,
            last: !0
          },
                r = this.constraint_ ? this.constraint_.constrain(e) : e;
          (!this.equals_(this.rawValue_, r) || n.forceEmit) && (this.emitter.emit("beforechange", {
            sender: this
          }), this.rawValue_ = r, this.emitter.emit("change", {
            options: n,
            rawValue: r,
            sender: this
          }));
        }

      }

      class M {
        constructor(e) {
          this.emitter = new h(), this.value_ = e;
        }

        get rawValue() {
          return this.value_;
        }

        set rawValue(e) {
          this.setRawValue(e, {
            forceEmit: !1,
            last: !0
          });
        }

        setRawValue(e, t) {
          const n = null != t ? t : {
            forceEmit: !1,
            last: !0
          };
          (this.value_ !== e || n.forceEmit) && (this.emitter.emit("beforechange", {
            sender: this
          }), this.value_ = e, this.emitter.emit("change", {
            options: n,
            rawValue: this.value_,
            sender: this
          }));
        }

      }

      function T(e, t) {
        const n = null == t ? void 0 : t.constraint,
              r = null == t ? void 0 : t.equals;
        return n || r ? new S(e, t) : new M(e);
      }

      class E {
        constructor(e) {
          this.emitter = new h(), this.valMap_ = e;

          for (const e in this.valMap_) this.valMap_[e].emitter.on("change", () => {
            this.emitter.emit("change", {
              key: e,
              sender: this
            });
          });
        }

        static createCore(e) {
          return Object.keys(e).reduce((t, n) => Object.assign(t, {
            [n]: T(e[n])
          }), {});
        }

        static fromObject(e) {
          const t = this.createCore(e);
          return new E(t);
        }

        get(e) {
          return this.valMap_[e].rawValue;
        }

        set(e, t) {
          this.valMap_[e].rawValue = t;
        }

        value(e) {
          return this.valMap_[e];
        }

      }

      function A(e) {
        return t => n => {
          if (!t && void 0 === n) return {
            succeeded: !1,
            value: void 0
          };
          if (t && void 0 === n) return {
            succeeded: !0,
            value: void 0
          };
          const r = e(n);
          return void 0 !== r ? {
            succeeded: !0,
            value: r
          } : {
            succeeded: !1,
            value: void 0
          };
        };
      }

      function C(e) {
        return {
          custom: t => A(t)(e),
          boolean: A(e => "boolean" == typeof e ? e : void 0)(e),
          number: A(e => "number" == typeof e ? e : void 0)(e),
          string: A(e => "string" == typeof e ? e : void 0)(e),
          function: A(e => "function" == typeof e ? e : void 0)(e),
          constant: t => A(e => e === t ? t : void 0)(e),
          raw: A(e => e)(e),
          object: t => A(e => {
            if (null !== (n = e) && "object" == typeof n) return function (e, t) {
              return Object.keys(t).reduce((n, r) => {
                if (void 0 === n) return;
                const i = (0, t[r])(e[r]);
                return i.succeeded ? Object.assign(Object.assign({}, n), {
                  [r]: i.value
                }) : void 0;
              }, {});
            }(e, t);
            var n;
          })(e),
          array: t => A(e => {
            if (Array.isArray(e)) return n = t, e.reduce((e, t) => {
              if (void 0 === e) return;
              const r = n(t);
              return r.succeeded && void 0 !== r.value ? [...e, r.value] : void 0;
            }, []);
            var n;
          })(e)
        };
      }

      const R = {
        optional: C(!0),
        required: C(!1)
      };

      function k(e, t) {
        const n = R.required.object(t)(e);
        return n.succeeded ? n.value : void 0;
      }

      const P = f(""),
            D = {
        veryfirst: "vfst",
        first: "fst",
        last: "lst",
        verylast: "vlst"
      };

      class O {
        constructor(e) {
          this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
          const t = this.view.element;
          this.blade.value("positions").emitter.on("change", () => {
            ["veryfirst", "first", "last", "verylast"].forEach(e => {
              t.classList.remove(P(void 0, D[e]));
            }), this.blade.get("positions").forEach(e => {
              t.classList.add(P(void 0, D[e]));
            });
          }), this.viewProps.handleDispose(() => {
            !function (e) {
              e && e.parentElement && e.parentElement.removeChild(e);
            }(t);
          });
        }

        get parent() {
          return this.parent_;
        }

      }

      const L = "http://www.w3.org/2000/svg";

      function I(e) {
        e.offsetHeight;
      }

      function F(e) {
        return void 0 !== e.ontouchstart;
      }

      function N() {
        return new Function("return this")().document;
      }

      const U = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
      };

      function B(e, t) {
        const n = e.createElementNS(L, "svg");
        return n.innerHTML = U[t], n;
      }

      function j(e, t, n) {
        e.insertBefore(t, e.children[n]);
      }

      function z(e) {
        e.parentElement && e.parentElement.removeChild(e);
      }

      function V(e) {
        for (; e.children.length > 0;) e.removeChild(e.children[0]);
      }

      function G(e) {
        return e.relatedTarget ? e.relatedTarget : "explicitOriginalTarget" in e ? e.explicitOriginalTarget : null;
      }

      const H = f("lbl");

      class W {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(H()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("div");
          n.classList.add(H("l")), g(t.props, "label", t => {
            o(t) ? this.element.classList.add(H(void 0, "nol")) : (this.element.classList.remove(H(void 0, "nol")), function (e) {
              for (; e.childNodes.length > 0;) e.removeChild(e.childNodes[0]);
            }(n), n.appendChild(function (e, t) {
              const n = e.createDocumentFragment();
              return t.split("\n").map(t => e.createTextNode(t)).forEach((t, r) => {
                r > 0 && n.appendChild(e.createElement("br")), n.appendChild(t);
              }), n;
            }(e, t)));
          }), this.element.appendChild(n), this.labelElement = n;
          const r = e.createElement("div");
          r.classList.add(H("v")), this.element.appendChild(r), this.valueElement = r;
        }

      }

      class K extends O {
        constructor(e, t) {
          const n = t.valueController.viewProps;
          super(Object.assign(Object.assign({}, t), {
            view: new W(e, {
              props: t.props,
              viewProps: n
            }),
            viewProps: n
          })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
        }

      }

      const X = {
        id: "button",
        type: "blade",

        accept(e) {
          const t = R,
                n = k(e, {
            title: t.required.string,
            view: t.required.constant("button"),
            label: t.optional.string
          });
          return n ? {
            params: n
          } : null;
        },

        controller: e => new K(e.document, {
          blade: e.blade,
          props: E.fromObject({
            label: e.params.label
          }),
          valueController: new w(e.document, {
            props: E.fromObject({
              title: e.params.title
            }),
            viewProps: e.viewProps
          })
        }),
        api: e => e.controller instanceof K && e.controller.valueController instanceof w ? new p(e.controller) : null
      };

      class q extends O {
        constructor(e) {
          super(e), this.value = e.value;
        }

      }

      function Y() {
        return new E({
          positions: T([], {
            equals: a
          })
        });
      }

      class Z extends E {
        constructor(e) {
          super(e);
        }

        static create(e) {
          const t = {
            completed: !0,
            expanded: e,
            expandedHeight: null,
            shouldFixHeight: !1,
            temporaryExpanded: null
          },
                n = E.createCore(t);
          return new Z(n);
        }

        get styleExpanded() {
          var e;
          return null !== (e = this.get("temporaryExpanded")) && void 0 !== e ? e : this.get("expanded");
        }

        get styleHeight() {
          if (!this.styleExpanded) return "0";
          const e = this.get("expandedHeight");
          return this.get("shouldFixHeight") && !o(e) ? `${e}px` : "auto";
        }

        bindExpandedClass(e, t) {
          const n = () => {
            this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
          };

          g(this, "expanded", n), g(this, "temporaryExpanded", n);
        }

        cleanUpTransition() {
          this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0);
        }

      }

      function J(e, t) {
        t.style.height = e.styleHeight;
      }

      function $(e, t) {
        e.value("expanded").emitter.on("beforechange", () => {
          e.set("completed", !1), o(e.get("expandedHeight")) && e.set("expandedHeight", function (e, t) {
            let n = 0;
            return function (e, t) {
              const n = e.style.transition;
              e.style.transition = "none", t(), e.style.transition = n;
            }(t, () => {
              e.set("expandedHeight", null), e.set("temporaryExpanded", !0), I(t), n = t.clientHeight, e.set("temporaryExpanded", null), I(t);
            }), n;
          }(e, t)), e.set("shouldFixHeight", !0), I(t);
        }), e.emitter.on("change", () => {
          J(e, t);
        }), J(e, t), t.addEventListener("transitionend", t => {
          "height" === t.propertyName && e.cleanUpTransition();
        });
      }

      class Q extends t {
        constructor(e, t) {
          super(e), this.rackApi_ = t;
        }

      }

      class ee {
        constructor(e) {
          this.emitter = new h(), this.items_ = [], this.cache_ = new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e;
        }

        get items() {
          return this.items_;
        }

        allItems() {
          return Array.from(this.cache_);
        }

        find(e) {
          for (const t of this.allItems()) if (e(t)) return t;

          return null;
        }

        includes(e) {
          return this.cache_.has(e);
        }

        add(e, t) {
          if (this.includes(e)) throw c.shouldNeverHappen();
          const n = void 0 !== t ? t : this.items_.length;
          this.items_.splice(n, 0, e), this.cache_.add(e);
          const r = this.extract_(e);
          r && (r.emitter.on("add", this.onSubListAdd_), r.emitter.on("remove", this.onSubListRemove_), r.allItems().forEach(e => {
            this.cache_.add(e);
          })), this.emitter.emit("add", {
            index: n,
            item: e,
            root: this,
            target: this
          });
        }

        remove(e) {
          const t = this.items_.indexOf(e);
          if (t < 0) return;
          this.items_.splice(t, 1), this.cache_.delete(e);
          const n = this.extract_(e);
          n && (n.emitter.off("add", this.onSubListAdd_), n.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
            index: t,
            item: e,
            root: this,
            target: this
          });
        }

        onSubListAdd_(e) {
          this.cache_.add(e.item), this.emitter.emit("add", {
            index: e.index,
            item: e.item,
            root: this,
            target: e.target
          });
        }

        onSubListRemove_(e) {
          this.cache_.delete(e.item), this.emitter.emit("remove", {
            index: e.index,
            item: e.item,
            root: this,
            target: e.target
          });
        }

      }

      class te extends t {
        constructor(e) {
          super(e), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new h(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
        }

        get label() {
          return this.controller_.props.get("label");
        }

        set label(e) {
          this.controller_.props.set("label", e);
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

        refresh() {
          this.controller_.binding.read();
        }

        onBindingChange_(e) {
          const t = e.sender.target.read();
          this.emitter_.emit("change", {
            event: new r(this, t, this.controller_.binding.target.presetKey, e.options.last)
          });
        }

      }

      class ne extends K {
        constructor(e, t) {
          super(e, t), this.binding = t.binding;
        }

      }

      class re extends t {
        constructor(e) {
          super(e), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new h(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
        }

        get label() {
          return this.controller_.props.get("label");
        }

        set label(e) {
          this.controller_.props.set("label", e);
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

        refresh() {
          this.controller_.binding.read();
        }

        onBindingUpdate_(e) {
          const t = e.sender.target.read();
          this.emitter_.emit("update", {
            event: new i(this, t, this.controller_.binding.target.presetKey)
          });
        }

      }

      class ie extends K {
        constructor(e, t) {
          super(e, t), this.binding = t.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
            this.binding.dispose();
          });
        }

      }

      function se(e) {
        return e instanceof le ? e.apiSet_ : e instanceof Q ? e.rackApi_.apiSet_ : null;
      }

      function oe(e, t) {
        const n = e.find(e => e.controller_ === t);
        if (!n) throw c.shouldNeverHappen();
        return n;
      }

      function ae(e, t, n) {
        if (!u.isBindable(e)) throw c.notBindable();
        return new u(e, t, n);
      }

      class le extends t {
        constructor(e, t) {
          super(e), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new h(), this.apiSet_ = new ee(se), this.pool_ = t;
          const n = this.controller_.rack;
          n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), n.emitter.on("inputchange", this.onRackInputChange_), n.emitter.on("monitorupdate", this.onRackMonitorUpdate_), n.children.forEach(e => {
            this.setUpApi_(e);
          });
        }

        get children() {
          return this.controller_.rack.children.map(e => oe(this.apiSet_, e));
        }

        addInput(e, t, n) {
          const r = n || {},
                i = this.controller_.view.element.ownerDocument,
                s = this.pool_.createInput(i, ae(e, t, r.presetKey), r),
                o = new te(s);
          return this.add(o, r.index);
        }

        addMonitor(e, t, n) {
          const r = n || {},
                i = this.controller_.view.element.ownerDocument,
                s = this.pool_.createMonitor(i, ae(e, t), r),
                o = new re(s);
          return this.add(o, r.index);
        }

        addFolder(e) {
          return function (e, t) {
            return e.addBlade(Object.assign(Object.assign({}, t), {
              view: "folder"
            }));
          }(this, e);
        }

        addButton(e) {
          return function (e, t) {
            return e.addBlade(Object.assign(Object.assign({}, t), {
              view: "button"
            }));
          }(this, e);
        }

        addSeparator(e) {
          return function (e, t) {
            const n = t || {};
            return e.addBlade(Object.assign(Object.assign({}, n), {
              view: "separator"
            }));
          }(this, e);
        }

        addTab(e) {
          return function (e, t) {
            return e.addBlade(Object.assign(Object.assign({}, t), {
              view: "tab"
            }));
          }(this, e);
        }

        add(e, t) {
          this.controller_.rack.add(e.controller_, t);
          const n = this.apiSet_.find(t => t.controller_ === e.controller_);
          return n && this.apiSet_.remove(n), this.apiSet_.add(e), e;
        }

        remove(e) {
          this.controller_.rack.remove(e.controller_);
        }

        addBlade(e) {
          const t = this.controller_.view.element.ownerDocument,
                n = this.pool_.createBlade(t, e),
                r = this.pool_.createBladeApi(n);
          return this.add(r, e.index);
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

        setUpApi_(e) {
          this.apiSet_.find(t => t.controller_ === e) || this.apiSet_.add(this.pool_.createBladeApi(e));
        }

        onRackAdd_(e) {
          this.setUpApi_(e.bladeController);
        }

        onRackRemove_(e) {
          if (e.isRoot) {
            const t = oe(this.apiSet_, e.bladeController);
            this.apiSet_.remove(t);
          }
        }

        onRackInputChange_(e) {
          const t = e.bladeController;

          if (t instanceof ne) {
            const n = oe(this.apiSet_, t),
                  i = t.binding;
            this.emitter_.emit("change", {
              event: new r(n, i.target.read(), i.target.presetKey, e.options.last)
            });
          } else if (t instanceof q) {
            const n = oe(this.apiSet_, t);
            this.emitter_.emit("change", {
              event: new r(n, t.value.rawValue, void 0, e.options.last)
            });
          }
        }

        onRackMonitorUpdate_(e) {
          if (!(e.bladeController instanceof ie)) throw c.shouldNeverHappen();
          const t = oe(this.apiSet_, e.bladeController),
                n = e.bladeController.binding;
          this.emitter_.emit("update", {
            event: new i(t, n.target.read(), n.target.presetKey)
          });
        }

      }

      class ce extends Q {
        constructor(e, t) {
          super(e, new le(e.rackController, t)), this.emitter_ = new h(), this.controller_.foldable.value("expanded").emitter.on("change", e => {
            this.emitter_.emit("fold", {
              event: new s(this, e.sender.rawValue)
            });
          }), this.rackApi_.on("change", e => {
            this.emitter_.emit("change", {
              event: e
            });
          }), this.rackApi_.on("update", e => {
            this.emitter_.emit("update", {
              event: e
            });
          });
        }

        get expanded() {
          return this.controller_.foldable.get("expanded");
        }

        set expanded(e) {
          this.controller_.foldable.set("expanded", e);
        }

        get title() {
          return this.controller_.props.get("title");
        }

        set title(e) {
          this.controller_.props.set("title", e);
        }

        get children() {
          return this.rackApi_.children;
        }

        addInput(e, t, n) {
          return this.rackApi_.addInput(e, t, n);
        }

        addMonitor(e, t, n) {
          return this.rackApi_.addMonitor(e, t, n);
        }

        addFolder(e) {
          return this.rackApi_.addFolder(e);
        }

        addButton(e) {
          return this.rackApi_.addButton(e);
        }

        addSeparator(e) {
          return this.rackApi_.addSeparator(e);
        }

        addTab(e) {
          return this.rackApi_.addTab(e);
        }

        add(e, t) {
          return this.rackApi_.add(e, t);
        }

        remove(e) {
          this.rackApi_.remove(e);
        }

        addBlade(e) {
          return this.rackApi_.addBlade(e);
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

      }

      class ue extends O {
        constructor(e) {
          super({
            blade: e.blade,
            view: e.view,
            viewProps: e.rackController.viewProps
          }), this.rackController = e.rackController;
        }

      }

      class pe {
        constructor(e, t) {
          const n = f(t.viewName);
          this.element = e.createElement("div"), this.element.classList.add(n()), t.viewProps.bindClassModifiers(this.element);
        }

      }

      function he(e) {
        return e instanceof _e ? e.rack : e instanceof ue ? e.rackController.rack : null;
      }

      function de(e) {
        const t = he(e);
        return t ? t.bcSet_ : null;
      }

      class fe {
        constructor(e) {
          var t;
          this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new h(), this.blade_ = null != e ? e : null, null === (t = this.blade_) || void 0 === t || t.value("positions").emitter.on("change", this.onBladePositionsChange_), this.bcSet_ = new ee(de), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
        }

        get children() {
          return this.bcSet_.items;
        }

        add(e, t) {
          e.parent && e.parent.remove(e), e.parent_ = this, this.bcSet_.add(e, t);
        }

        remove(e) {
          e.parent_ = null, this.bcSet_.remove(e);
        }

        find(e) {
          return this.bcSet_.allItems().filter(t => t instanceof e);
        }

        onSetAdd_(e) {
          this.updatePositions_();
          const t = e.target === e.root;
          if (this.emitter.emit("add", {
            bladeController: e.item,
            index: e.index,
            isRoot: t,
            sender: this
          }), !t) return;
          const n = e.item;
          if (n.viewProps.emitter.on("change", this.onChildViewPropsChange_), n.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), n.viewProps.handleDispose(this.onChildDispose_), n instanceof ne) n.binding.emitter.on("change", this.onChildInputChange_);else if (n instanceof ie) n.binding.emitter.on("update", this.onChildMonitorUpdate_);else if (n instanceof q) n.value.emitter.on("change", this.onChildValueChange_);else {
            const e = he(n);

            if (e) {
              const t = e.emitter;
              t.on("layout", this.onDescendantLayout_), t.on("inputchange", this.onDescendantInputChange_), t.on("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }

        onSetRemove_(e) {
          this.updatePositions_();
          const t = e.target === e.root;
          if (this.emitter.emit("remove", {
            bladeController: e.item,
            isRoot: t,
            sender: this
          }), !t) return;
          const n = e.item;
          if (n instanceof ne) n.binding.emitter.off("change", this.onChildInputChange_);else if (n instanceof ie) n.binding.emitter.off("update", this.onChildMonitorUpdate_);else if (n instanceof q) n.value.emitter.off("change", this.onChildValueChange_);else {
            const e = he(n);

            if (e) {
              const t = e.emitter;
              t.off("layout", this.onDescendantLayout_), t.off("inputchange", this.onDescendantInputChange_), t.off("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }

        updatePositions_() {
          const e = this.bcSet_.items.filter(e => !e.viewProps.get("hidden")),
                t = e[0],
                n = e[e.length - 1];
          this.bcSet_.items.forEach(e => {
            const r = [];
            e === t && (r.push("first"), this.blade_ && !this.blade_.get("positions").includes("veryfirst") || r.push("veryfirst")), e === n && (r.push("last"), this.blade_ && !this.blade_.get("positions").includes("verylast") || r.push("verylast")), e.blade.set("positions", r);
          });
        }

        onChildPositionsChange_() {
          this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
          });
        }

        onChildViewPropsChange_(e) {
          this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
          });
        }

        onChildDispose_() {
          this.bcSet_.items.filter(e => e.viewProps.get("disposed")).forEach(e => {
            this.bcSet_.remove(e);
          });
        }

        onChildInputChange_(e) {
          const t = function (e, t) {
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              if (r instanceof ne && r.binding === t) return r;
            }

            return null;
          }(this.find(ne), e.sender);

          if (!t) throw c.shouldNeverHappen();
          this.emitter.emit("inputchange", {
            bladeController: t,
            options: e.options,
            sender: this
          });
        }

        onChildMonitorUpdate_(e) {
          const t = function (e, t) {
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              if (r instanceof ie && r.binding === t) return r;
            }

            return null;
          }(this.find(ie), e.sender);

          if (!t) throw c.shouldNeverHappen();
          this.emitter.emit("monitorupdate", {
            bladeController: t,
            sender: this
          });
        }

        onChildValueChange_(e) {
          const t = function (e, t) {
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              if (r instanceof q && r.value === t) return r;
            }

            return null;
          }(this.find(q), e.sender);

          if (!t) throw c.shouldNeverHappen();
          this.emitter.emit("inputchange", {
            bladeController: t,
            options: e.options,
            sender: this
          });
        }

        onDescendantLayout_(e) {
          this.updatePositions_(), this.emitter.emit("layout", {
            sender: this
          });
        }

        onDescendantInputChange_(e) {
          this.emitter.emit("inputchange", {
            bladeController: e.bladeController,
            options: e.options,
            sender: this
          });
        }

        onDescendantMonitorUpdate_(e) {
          this.emitter.emit("monitorupdate", {
            bladeController: e.bladeController,
            sender: this
          });
        }

        onBladePositionsChange_() {
          this.updatePositions_();
        }

      }

      class _e extends O {
        constructor(e, t) {
          super(Object.assign(Object.assign({}, t), {
            view: new pe(e, {
              viewName: "brk",
              viewProps: t.viewProps
            })
          })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
          const n = new fe(t.root ? void 0 : t.blade);
          n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), this.rack = n, this.viewProps.handleDispose(() => {
            for (let e = this.rack.children.length - 1; e >= 0; e--) this.rack.children[e].viewProps.set("disposed", !0);
          });
        }

        onRackAdd_(e) {
          e.isRoot && j(this.view.element, e.bladeController.view.element, e.index);
        }

        onRackRemove_(e) {
          e.isRoot && z(e.bladeController.view.element);
        }

      }

      const me = f("cnt");

      class ge {
        constructor(e, t) {
          this.className_ = f(t.viewName || "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), me()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), g(this.foldable_, "completed", v(this.element, this.className_(void 0, "cpl")));
          const n = e.createElement("button");
          n.classList.add(this.className_("b")), g(t.props, "title", e => {
            o(e) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
          }), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
          const r = e.createElement("div");
          r.classList.add(this.className_("t")), b(t.props.value("title"), r), this.buttonElement.appendChild(r), this.titleElement = r;
          const i = e.createElement("div");
          i.classList.add(this.className_("m")), this.buttonElement.appendChild(i);
          const s = t.containerElement;
          s.classList.add(this.className_("c")), this.element.appendChild(s), this.containerElement = s;
        }

      }

      class ve extends ue {
        constructor(e, t) {
          var n;
          const r = Z.create(null === (n = t.expanded) || void 0 === n || n),
                i = new _e(e, {
            blade: t.blade,
            root: t.root,
            viewProps: t.viewProps
          });
          super(Object.assign(Object.assign({}, t), {
            rackController: i,
            view: new ge(e, {
              containerElement: i.view.element,
              foldable: r,
              props: t.props,
              viewName: t.root ? "rot" : void 0,
              viewProps: t.viewProps
            })
          })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = r, $(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition();
          }), this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition();
          }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
        }

        get document() {
          return this.view.element.ownerDocument;
        }

        onTitleClick_() {
          this.foldable.set("expanded", !this.foldable.get("expanded"));
        }

      }

      const be = {
        id: "folder",
        type: "blade",

        accept(e) {
          const t = R,
                n = k(e, {
            title: t.required.string,
            view: t.required.constant("folder"),
            expanded: t.optional.boolean
          });
          return n ? {
            params: n
          } : null;
        },

        controller: e => new ve(e.document, {
          blade: e.blade,
          expanded: e.params.expanded,
          props: E.fromObject({
            title: e.params.title
          }),
          viewProps: e.viewProps
        }),
        api: e => e.controller instanceof ve ? new ce(e.controller, e.pool) : null
      };

      class xe extends q {
        constructor(e, t) {
          const n = t.valueController.viewProps;
          super(Object.assign(Object.assign({}, t), {
            value: t.valueController.value,
            view: new W(e, {
              props: t.props,
              viewProps: n
            }),
            viewProps: n
          })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
        }

      }

      class ye extends t {}

      const we = f("spr");

      class Se {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(we()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("hr");
          n.classList.add(we("r")), this.element.appendChild(n);
        }

      }

      class Me extends O {
        constructor(e, t) {
          super(Object.assign(Object.assign({}, t), {
            view: new Se(e, {
              viewProps: t.viewProps
            })
          }));
        }

      }

      const Te = {
        id: "separator",
        type: "blade",

        accept(e) {
          const t = k(e, {
            view: R.required.constant("separator")
          });
          return t ? {
            params: t
          } : null;
        },

        controller: e => new Me(e.document, {
          blade: e.blade,
          viewProps: e.viewProps
        }),
        api: e => e.controller instanceof Me ? new ye(e.controller) : null
      },
            Ee = f("");

      function Ae(e, t) {
        return v(e, Ee(void 0, t));
      }

      class Ce extends E {
        constructor(e) {
          super(e);
        }

        static create(e) {
          var t, n;
          const r = null != e ? e : {},
                i = {
            disabled: null !== (t = r.disabled) && void 0 !== t && t,
            disposed: !1,
            hidden: null !== (n = r.hidden) && void 0 !== n && n
          },
                s = E.createCore(i);
          return new Ce(s);
        }

        bindClassModifiers(e) {
          g(this, "disabled", Ae(e, "disabled")), g(this, "hidden", Ae(e, "hidden"));
        }

        bindDisabled(e) {
          g(this, "disabled", t => {
            e.disabled = t;
          });
        }

        bindTabIndex(e) {
          g(this, "disabled", t => {
            e.tabIndex = t ? -1 : 0;
          });
        }

        handleDispose(e) {
          this.value("disposed").emitter.on("change", t => {
            t && e();
          });
        }

      }

      const Re = f("tbi");

      class ke {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(Re()), t.viewProps.bindClassModifiers(this.element), g(t.props, "selected", e => {
            e ? this.element.classList.add(Re(void 0, "sel")) : this.element.classList.remove(Re(void 0, "sel"));
          });
          const n = e.createElement("button");
          n.classList.add(Re("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
          const r = e.createElement("div");
          r.classList.add(Re("t")), b(t.props.value("title"), r), this.buttonElement.appendChild(r), this.titleElement = r;
        }

      }

      class Pe {
        constructor(e, t) {
          this.emitter = new h(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new ke(e, {
            props: t.props,
            viewProps: t.viewProps
          }), this.view.buttonElement.addEventListener("click", this.onClick_);
        }

        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }

      }

      class De {
        constructor(e, t) {
          this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new Pe(e, {
            props: t.itemProps,
            viewProps: Ce.create()
          }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new _e(e, {
            blade: Y(),
            viewProps: Ce.create()
          }), this.props = t.props, g(this.props, "selected", e => {
            this.itemController.props.set("selected", e), this.contentController.viewProps.set("hidden", !e);
          });
        }

        get itemController() {
          return this.ic_;
        }

        get contentController() {
          return this.cc_;
        }

        onItemClick_() {
          this.props.set("selected", !0);
        }

      }

      class Oe {
        constructor(e, t) {
          this.controller_ = e, this.rackApi_ = t;
        }

        get title() {
          var e;
          return null !== (e = this.controller_.itemController.props.get("title")) && void 0 !== e ? e : "";
        }

        set title(e) {
          this.controller_.itemController.props.set("title", e);
        }

        get selected() {
          return this.controller_.props.get("selected");
        }

        set selected(e) {
          this.controller_.props.set("selected", e);
        }

        get children() {
          return this.rackApi_.children;
        }

        addButton(e) {
          return this.rackApi_.addButton(e);
        }

        addFolder(e) {
          return this.rackApi_.addFolder(e);
        }

        addSeparator(e) {
          return this.rackApi_.addSeparator(e);
        }

        addTab(e) {
          return this.rackApi_.addTab(e);
        }

        add(e, t) {
          this.rackApi_.add(e, t);
        }

        remove(e) {
          this.rackApi_.remove(e);
        }

        addInput(e, t, n) {
          return this.rackApi_.addInput(e, t, n);
        }

        addMonitor(e, t, n) {
          return this.rackApi_.addMonitor(e, t, n);
        }

        addBlade(e) {
          return this.rackApi_.addBlade(e);
        }

      }

      class Le extends Q {
        constructor(e, t) {
          super(e, new le(e.rackController, t)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.emitter_ = new h(), this.pageApiMap_ = new Map(), this.rackApi_.on("change", e => {
            this.emitter_.emit("change", {
              event: e
            });
          }), this.rackApi_.on("update", e => {
            this.emitter_.emit("update", {
              event: e
            });
          }), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach(e => {
            this.setUpPageApi_(e);
          });
        }

        get pages() {
          return this.controller_.pageSet.items.map(e => {
            const t = this.pageApiMap_.get(e);
            if (!t) throw c.shouldNeverHappen();
            return t;
          });
        }

        addPage(e) {
          const t = this.controller_.view.element.ownerDocument,
                n = new De(t, {
            itemProps: E.fromObject({
              selected: !1,
              title: e.title
            }),
            props: E.fromObject({
              selected: !1
            })
          });
          this.controller_.add(n, e.index);
          const r = this.pageApiMap_.get(n);
          if (!r) throw c.shouldNeverHappen();
          return r;
        }

        removePage(e) {
          this.controller_.remove(e);
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

        setUpPageApi_(e) {
          const t = this.rackApi_.apiSet_.find(t => t.controller_ === e.contentController);
          if (!t) throw c.shouldNeverHappen();
          const n = new Oe(e, t);
          this.pageApiMap_.set(e, n);
        }

        onPageAdd_(e) {
          this.setUpPageApi_(e.item);
        }

        onPageRemove_(e) {
          if (!this.pageApiMap_.get(e.item)) throw c.shouldNeverHappen();
          this.pageApiMap_.delete(e.item);
        }

      }

      const Ie = f("tab");

      class Fe {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(Ie(), me()), t.viewProps.bindClassModifiers(this.element), m(t.empty, v(this.element, Ie(void 0, "nop")));
          const n = e.createElement("div");
          n.classList.add(Ie("i")), this.element.appendChild(n), this.itemsElement = n;
          const r = t.contentsElement;
          r.classList.add(Ie("c")), this.element.appendChild(r), this.contentsElement = r;
        }

      }

      class Ne extends ue {
        constructor(e, t) {
          const n = new _e(e, {
            blade: t.blade,
            viewProps: t.viewProps
          }),
                r = T(!0);
          super({
            blade: t.blade,
            rackController: n,
            view: new Fe(e, {
              contentsElement: n.view.element,
              empty: r,
              viewProps: t.viewProps
            })
          }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onPageSelectedChange_ = this.onPageSelectedChange_.bind(this), this.pageSet_ = new ee(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.empty_ = r, this.applyPages_();
        }

        get pageSet() {
          return this.pageSet_;
        }

        add(e, t) {
          this.pageSet_.add(e, null != t ? t : this.pageSet_.items.length);
        }

        remove(e) {
          this.pageSet_.remove(this.pageSet_.items[e]);
        }

        applyPages_() {
          this.keepSelection_(), this.empty_.rawValue = 0 === this.pageSet_.items.length;
        }

        onPageAdd_(e) {
          const t = e.item;
          j(this.view.itemsElement, t.itemController.view.element, e.index), this.rackController.rack.add(t.contentController, e.index), t.props.value("selected").emitter.on("change", this.onPageSelectedChange_), this.applyPages_();
        }

        onPageRemove_(e) {
          const t = e.item;
          z(t.itemController.view.element), this.rackController.rack.remove(t.contentController), t.props.value("selected").emitter.off("change", this.onPageSelectedChange_), this.applyPages_();
        }

        keepSelection_() {
          if (0 === this.pageSet_.items.length) return;
          const e = this.pageSet_.items.findIndex(e => e.props.get("selected"));
          e < 0 ? this.pageSet_.items.forEach((e, t) => {
            e.props.set("selected", 0 === t);
          }) : this.pageSet_.items.forEach((t, n) => {
            t.props.set("selected", n === e);
          });
        }

        onPageSelectedChange_(e) {
          if (e.rawValue) {
            const t = this.pageSet_.items.findIndex(t => t.props.value("selected") === e.sender);
            this.pageSet_.items.forEach((e, n) => {
              e.props.set("selected", n === t);
            });
          } else this.keepSelection_();
        }

      }

      const Ue = {
        id: "tab",
        type: "blade",

        accept(e) {
          const t = R,
                n = k(e, {
            pages: t.required.array(t.required.object({
              title: t.required.string
            })),
            view: t.required.constant("tab")
          });
          return n && 0 !== n.pages.length ? {
            params: n
          } : null;
        },

        controller(e) {
          const t = new Ne(e.document, {
            blade: e.blade,
            viewProps: e.viewProps
          });
          return e.params.pages.forEach(n => {
            const r = new De(e.document, {
              itemProps: E.fromObject({
                selected: !1,
                title: n.title
              }),
              props: E.fromObject({
                selected: !1
              })
            });
            t.add(r);
          }), t;
        },

        api: e => e.controller instanceof Ne ? new Le(e.controller, e.pool) : null
      };

      class Be {
        constructor() {
          this.disabled = !1, this.emitter = new h();
        }

        dispose() {}

        tick() {
          this.disabled || this.emitter.emit("tick", {
            sender: this
          });
        }

      }

      class je {
        constructor(e, t) {
          this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new h(), this.interval_ = t, this.setTimer_();
        }

        get disabled() {
          return this.disabled_;
        }

        set disabled(e) {
          this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_();
        }

        dispose() {
          this.clearTimer_();
        }

        clearTimer_() {
          if (null === this.timerId_) return;
          const e = this.doc_.defaultView;
          e && e.clearInterval(this.timerId_), this.timerId_ = null;
        }

        setTimer_() {
          if (this.clearTimer_(), this.interval_ <= 0) return;
          const e = this.doc_.defaultView;
          e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
        }

        onTick_() {
          this.disabled_ || this.emitter.emit("tick", {
            sender: this
          });
        }

      }

      class ze {
        constructor(e) {
          this.constraints = e;
        }

        constrain(e) {
          return this.constraints.reduce((e, t) => t.constrain(e), e);
        }

      }

      function Ve(e, t) {
        if (e instanceof t) return e;

        if (e instanceof ze) {
          const n = e.constraints.reduce((e, n) => e || (n instanceof t ? n : null), null);
          if (n) return n;
        }

        return null;
      }

      class Ge {
        constructor(e) {
          this.options = e;
        }

        constrain(e) {
          const t = this.options;
          return 0 === t.length || t.filter(t => t.value === e).length > 0 ? e : t[0].value;
        }

      }

      class He {
        constructor(e) {
          this.maxValue = e.max, this.minValue = e.min;
        }

        constrain(e) {
          let t = e;
          return o(this.minValue) || (t = Math.max(t, this.minValue)), o(this.maxValue) || (t = Math.min(t, this.maxValue)), t;
        }

      }

      class We {
        constructor(e) {
          this.step = e;
        }

        constrain(e) {
          return (e < 0 ? -Math.round(-e / this.step) : Math.round(e / this.step)) * this.step;
        }

      }

      const Ke = f("lst");

      class Xe {
        constructor(e, t) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(Ke()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("select");
          n.classList.add(Ke("s")), g(this.props_, "options", t => {
            V(n), t.forEach((t, r) => {
              const i = e.createElement("option");
              i.dataset.index = String(r), i.textContent = t.text, i.value = String(t.value), n.appendChild(i);
            });
          }), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.selectElement = n;
          const r = e.createElement("div");
          r.classList.add(Ke("m")), r.appendChild(B(e, "dropdown")), this.element.appendChild(r), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, this.update_();
        }

        update_() {
          this.selectElement.value = String(this.value_.rawValue);
        }

        onValueChange_() {
          this.update_();
        }

      }

      class qe {
        constructor(e, t) {
          this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new Xe(e, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
        }

        onSelectChange_(e) {
          const t = e.currentTarget.selectedOptions.item(0);
          if (!t) return;
          const n = Number(t.dataset.index);
          this.value.rawValue = this.props.get("options")[n].value;
        }

      }

      const Ye = f("pop");

      class Ze {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(Ye()), t.viewProps.bindClassModifiers(this.element), m(t.shows, v(this.element, Ye(void 0, "v")));
        }

      }

      class Je {
        constructor(e, t) {
          this.shows = T(!1), this.viewProps = t.viewProps, this.view = new Ze(e, {
            shows: this.shows,
            viewProps: this.viewProps
          });
        }

      }

      const $e = f("txt");

      class Qe {
        constructor(e, t) {
          this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add($e()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
          const n = e.createElement("input");
          n.classList.add($e("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh();
        }

        refresh() {
          const e = this.props_.get("formatter");
          this.inputElement.value = e(this.value_.rawValue);
        }

        onChange_() {
          this.refresh();
        }

      }

      class et {
        constructor(e, t) {
          this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new Qe(e, {
            props: t.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.view.inputElement.addEventListener("change", this.onInputChange_);
        }

        onInputChange_(e) {
          const t = e.currentTarget.value,
                n = this.parser_(t);
          o(n) || (this.value.rawValue = n), this.view.refresh();
        }

      }

      function tt(e) {
        return "false" !== e && !!e;
      }

      function nt(e) {
        return function (e) {
          return String(e);
        }(e);
      }

      class rt {
        constructor(e) {
          this.text = e;
        }

        evaluate() {
          return Number(this.text);
        }

        toString() {
          return this.text;
        }

      }

      const it = {
        "**": (e, t) => Math.pow(e, t),
        "*": (e, t) => e * t,
        "/": (e, t) => e / t,
        "%": (e, t) => e % t,
        "+": (e, t) => e + t,
        "-": (e, t) => e - t,
        "<<": (e, t) => e << t,
        ">>": (e, t) => e >> t,
        ">>>": (e, t) => e >>> t,
        "&": (e, t) => e & t,
        "^": (e, t) => e ^ t,
        "|": (e, t) => e | t
      };

      class st {
        constructor(e, t, n) {
          this.left = t, this.operator = e, this.right = n;
        }

        evaluate() {
          const e = it[this.operator];
          if (!e) throw new Error(`unexpected binary operator: '${this.operator}`);
          return e(this.left.evaluate(), this.right.evaluate());
        }

        toString() {
          return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ");
        }

      }

      const ot = {
        "+": e => e,
        "-": e => -e,
        "~": e => ~e
      };

      class at {
        constructor(e, t) {
          this.operator = e, this.expression = t;
        }

        evaluate() {
          const e = ot[this.operator];
          if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
          return e(this.expression.evaluate());
        }

        toString() {
          return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
        }

      }

      function lt(e) {
        return (t, n) => {
          for (let r = 0; r < e.length; r++) {
            const i = e[r](t, n);
            if ("" !== i) return i;
          }

          return "";
        };
      }

      function ct(e, t) {
        var n;
        const r = e.substr(t).match(/^\s+/);
        return null !== (n = r && r[0]) && void 0 !== n ? n : "";
      }

      function ut(e, t) {
        var n;
        const r = e.substr(t).match(/^[0-9]+/);
        return null !== (n = r && r[0]) && void 0 !== n ? n : "";
      }

      function pt(e, t) {
        const n = e.substr(t, 1);
        if (t += 1, "e" !== n.toLowerCase()) return "";

        const r = function (e, t) {
          const n = ut(e, t);
          if ("" !== n) return n;
          const r = e.substr(t, 1);
          if ("-" !== r && "+" !== r) return "";
          const i = ut(e, t += 1);
          return "" === i ? "" : r + i;
        }(e, t);

        return "" === r ? "" : n + r;
      }

      function ht(e, t) {
        const n = e.substr(t, 1);
        if ("0" === n) return n;

        const r = function (e, t) {
          const n = e.substr(t, 1);
          return n.match(/^[1-9]$/) ? n : "";
        }(e, t);

        return t += r.length, "" === r ? "" : r + ut(e, t);
      }

      const dt = lt([function (e, t) {
        const n = ht(e, t);
        if (t += n.length, "" === n) return "";
        const r = e.substr(t, 1);
        if (t += r.length, "." !== r) return "";
        const i = ut(e, t);
        return n + r + i + pt(e, t += i.length);
      }, function (e, t) {
        const n = e.substr(t, 1);
        if (t += n.length, "." !== n) return "";
        const r = ut(e, t);
        return t += r.length, "" === r ? "" : n + r + pt(e, t);
      }, function (e, t) {
        const n = ht(e, t);
        return t += n.length, "" === n ? "" : n + pt(e, t);
      }]);

      const ft = lt([function (e, t) {
        const n = e.substr(t, 2);
        if (t += n.length, "0b" !== n.toLowerCase()) return "";

        const r = function (e, t) {
          var n;
          const r = e.substr(t).match(/^[01]+/);
          return null !== (n = r && r[0]) && void 0 !== n ? n : "";
        }(e, t);

        return "" === r ? "" : n + r;
      }, function (e, t) {
        const n = e.substr(t, 2);
        if (t += n.length, "0o" !== n.toLowerCase()) return "";

        const r = function (e, t) {
          var n;
          const r = e.substr(t).match(/^[0-7]+/);
          return null !== (n = r && r[0]) && void 0 !== n ? n : "";
        }(e, t);

        return "" === r ? "" : n + r;
      }, function (e, t) {
        const n = e.substr(t, 2);
        if (t += n.length, "0x" !== n.toLowerCase()) return "";

        const r = function (e, t) {
          var n;
          const r = e.substr(t).match(/^[0-9a-f]+/i);
          return null !== (n = r && r[0]) && void 0 !== n ? n : "";
        }(e, t);

        return "" === r ? "" : n + r;
      }]),
            _t = lt([ft, dt]);

      function mt(e, t) {
        return function (e, t) {
          const n = _t(e, t);

          return t += n.length, "" === n ? null : {
            evaluable: new rt(n),
            cursor: t
          };
        }(e, t) || function (e, t) {
          const n = e.substr(t, 1);
          if (t += n.length, "(" !== n) return null;
          const r = bt(e, t);
          if (!r) return null;
          t = r.cursor, t += ct(e, t).length;
          const i = e.substr(t, 1);
          return t += i.length, ")" !== i ? null : {
            evaluable: r.evaluable,
            cursor: t
          };
        }(e, t);
      }

      function gt(e, t, n) {
        n += ct(t, n).length;
        const r = e.filter(e => t.startsWith(e, n))[0];
        return r ? (n += r.length, {
          cursor: n += ct(t, n).length,
          operator: r
        }) : null;
      }

      const vt = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce((e, t) => function (e, t) {
        return (n, r) => {
          const i = e(n, r);
          if (!i) return null;
          r = i.cursor;
          let s = i.evaluable;

          for (;;) {
            const i = gt(t, n, r);
            if (!i) break;
            r = i.cursor;
            const o = e(n, r);
            if (!o) return null;
            r = o.cursor, s = new st(i.operator, s, o.evaluable);
          }

          return s ? {
            cursor: r,
            evaluable: s
          } : null;
        };
      }(e, t), function e(t, n) {
        const r = mt(t, n);
        if (r) return r;
        const i = t.substr(n, 1);
        if (n += i.length, "+" !== i && "-" !== i && "~" !== i) return null;
        const s = e(t, n);
        return s ? {
          cursor: n = s.cursor,
          evaluable: new at(i, s.evaluable)
        } : null;
      });

      function bt(e, t) {
        return t += ct(e, t).length, vt(e, t);
      }

      function xt(e) {
        var t;

        const n = function (e) {
          const t = bt(e, 0);
          return t ? t.cursor + ct(e, t.cursor).length !== e.length ? null : t.evaluable : null;
        }(e);

        return null !== (t = null == n ? void 0 : n.evaluate()) && void 0 !== t ? t : null;
      }

      function yt(e) {
        if ("number" == typeof e) return e;

        if ("string" == typeof e) {
          const t = xt(e);
          if (!o(t)) return t;
        }

        return 0;
      }

      function wt(e) {
        return String(e);
      }

      function St(e) {
        return t => t.toFixed(Math.max(Math.min(e, 20), 0));
      }

      const Mt = St(0);

      function Tt(e) {
        return Mt(e) + "%";
      }

      function Et(e) {
        return String(e);
      }

      function At(e) {
        return e;
      }

      function Ct(e, t) {
        for (; e.length < t;) e.push(void 0);
      }

      function Rt(e) {
        const t = [];
        return Ct(t, e), T(t);
      }

      function kt(e) {
        const t = e.indexOf(void 0);
        return t < 0 ? e : e.slice(0, t);
      }

      function Pt({
        primary: e,
        secondary: t,
        forward: n,
        backward: r
      }) {
        let i = !1;

        function s(e) {
          i || (i = !0, e(), i = !1);
        }

        e.emitter.on("change", r => {
          s(() => {
            t.setRawValue(n(e, t), r.options);
          });
        }), t.emitter.on("change", i => {
          s(() => {
            e.setRawValue(r(e, t), i.options);
          }), s(() => {
            t.setRawValue(n(e, t), i.options);
          });
        }), s(() => {
          t.setRawValue(n(e, t), {
            forceEmit: !1,
            last: !0
          });
        });
      }

      function Dt(e, t) {
        const n = e * (t.altKey ? .1 : 1) * (t.shiftKey ? 10 : 1);
        return t.upKey ? +n : t.downKey ? -n : 0;
      }

      function Ot(e) {
        return {
          altKey: e.altKey,
          downKey: "ArrowDown" === e.key,
          shiftKey: e.shiftKey,
          upKey: "ArrowUp" === e.key
        };
      }

      function Lt(e) {
        return {
          altKey: e.altKey,
          downKey: "ArrowLeft" === e.key,
          shiftKey: e.shiftKey,
          upKey: "ArrowRight" === e.key
        };
      }

      function It(e) {
        return function (e) {
          return "ArrowUp" === e || "ArrowDown" === e;
        }(e) || "ArrowLeft" === e || "ArrowRight" === e;
      }

      function Ft(e, t) {
        const n = t.ownerDocument.defaultView,
              r = t.getBoundingClientRect();
        return {
          x: e.pageX - ((n && n.scrollX || 0) + r.left),
          y: e.pageY - ((n && n.scrollY || 0) + r.top)
        };
      }

      class Nt {
        constructor(e) {
          this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new h(), e.addEventListener("touchstart", this.onTouchStart_, {
            passive: !1
          }), e.addEventListener("touchmove", this.onTouchMove_, {
            passive: !0
          }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_);
        }

        computePosition_(e) {
          const t = this.elem_.getBoundingClientRect();
          return {
            bounds: {
              width: t.width,
              height: t.height
            },
            point: e ? {
              x: e.x,
              y: e.y
            } : null
          };
        }

        onMouseDown_(e) {
          var t;
          e.preventDefault(), null === (t = e.currentTarget) || void 0 === t || t.focus();
          const n = this.elem_.ownerDocument;
          n.addEventListener("mousemove", this.onDocumentMouseMove_), n.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
            altKey: e.altKey,
            data: this.computePosition_(Ft(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey
          });
        }

        onDocumentMouseMove_(e) {
          this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(Ft(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey
          });
        }

        onDocumentMouseUp_(e) {
          const t = this.elem_.ownerDocument;
          t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
            altKey: e.altKey,
            data: this.computePosition_(Ft(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey
          });
        }

        onTouchStart_(e) {
          e.preventDefault();
          const t = e.targetTouches.item(0),
                n = this.elem_.getBoundingClientRect();
          this.emitter.emit("down", {
            altKey: e.altKey,
            data: this.computePosition_(t ? {
              x: t.clientX - n.left,
              y: t.clientY - n.top
            } : void 0),
            sender: this,
            shiftKey: e.shiftKey
          }), this.lastTouch_ = t;
        }

        onTouchMove_(e) {
          const t = e.targetTouches.item(0),
                n = this.elem_.getBoundingClientRect();
          this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(t ? {
              x: t.clientX - n.left,
              y: t.clientY - n.top
            } : void 0),
            sender: this,
            shiftKey: e.shiftKey
          }), this.lastTouch_ = t;
        }

        onTouchEnd_(e) {
          var t;
          const n = null !== (t = e.targetTouches.item(0)) && void 0 !== t ? t : this.lastTouch_,
                r = this.elem_.getBoundingClientRect();
          this.emitter.emit("up", {
            altKey: e.altKey,
            data: this.computePosition_(n ? {
              x: n.clientX - r.left,
              y: n.clientY - r.top
            } : void 0),
            sender: this,
            shiftKey: e.shiftKey
          });
        }

      }

      function Ut(e, t, n, r, i) {
        return r + (e - t) / (n - t) * (i - r);
      }

      function Bt(e) {
        return String(e.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
      }

      function jt(e, t, n) {
        return Math.min(Math.max(e, t), n);
      }

      function zt(e, t) {
        return (e % t + t) % t;
      }

      const Vt = f("txt");

      class Gt {
        constructor(e, t) {
          this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Vt(), Vt(void 0, "num")), t.arrayPosition && this.element.classList.add(Vt(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("input");
          n.classList.add(Vt("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Vt()), this.inputElement.classList.add(Vt("i"));
          const r = e.createElement("div");
          r.classList.add(Vt("k")), this.element.appendChild(r), this.knobElement = r;
          const i = e.createElementNS(L, "svg");
          i.classList.add(Vt("g")), this.knobElement.appendChild(i);
          const s = e.createElementNS(L, "path");
          s.classList.add(Vt("gb")), i.appendChild(s), this.guideBodyElem_ = s;
          const o = e.createElementNS(L, "path");
          o.classList.add(Vt("gh")), i.appendChild(o), this.guideHeadElem_ = o;
          const a = e.createElement("div");
          a.classList.add(f("tt")()), this.knobElement.appendChild(a), this.tooltipElem_ = a, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh();
        }

        onDraggingChange_(e) {
          if (null === e.rawValue) return void this.element.classList.remove(Vt(void 0, "drg"));
          this.element.classList.add(Vt(void 0, "drg"));
          const t = e.rawValue / this.props_.get("draggingScale"),
                n = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
                r = jt(-n, -4, 4);
          this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n + r},0 L${n},4 L${n + r},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
          const i = this.props_.get("formatter");
          this.tooltipElem_.textContent = i(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`;
        }

        refresh() {
          const e = this.props_.get("formatter");
          this.inputElement.value = e(this.value.rawValue);
        }

        onChange_() {
          this.refresh();
        }

      }

      class Ht {
        constructor(e, t) {
          this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = T(null), this.view = new Gt(e, {
            arrayPosition: t.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
          const n = new Nt(this.view.knobElement);
          n.emitter.on("down", this.onPointerDown_), n.emitter.on("move", this.onPointerMove_), n.emitter.on("up", this.onPointerUp_);
        }

        onInputChange_(e) {
          const t = e.currentTarget.value,
                n = this.parser_(t);
          o(n) || (this.value.rawValue = n), this.view.refresh();
        }

        onInputKeyDown_(e) {
          const t = Dt(this.baseStep_, Ot(e));
          0 !== t && this.value.setRawValue(this.value.rawValue + t, {
            forceEmit: !1,
            last: !1
          });
        }

        onInputKeyUp_(e) {
          0 !== Dt(this.baseStep_, Ot(e)) && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }

        onPointerDown_() {
          this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
        }

        computeDraggingValue_(e) {
          if (!e.point) return null;
          const t = e.point.x - e.bounds.width / 2;
          return this.originRawValue_ + t * this.props.get("draggingScale");
        }

        onPointerMove_(e) {
          const t = this.computeDraggingValue_(e.data);
          null !== t && (this.value.setRawValue(t, {
            forceEmit: !1,
            last: !1
          }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
        }

        onPointerUp_(e) {
          const t = this.computeDraggingValue_(e.data);
          null !== t && (this.value.setRawValue(t, {
            forceEmit: !0,
            last: !0
          }), this.dragging_.rawValue = null);
        }

      }

      const Wt = f("sld");

      class Kt {
        constructor(e, t) {
          this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Wt()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("div");
          n.classList.add(Wt("t")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.trackElement = n;
          const r = e.createElement("div");
          r.classList.add(Wt("k")), this.trackElement.appendChild(r), this.knobElement = r, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_();
        }

        update_() {
          const e = jt(Ut(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
          this.knobElement.style.width = `${e}%`;
        }

        onChange_() {
          this.update_();
        }

      }

      class Xt {
        constructor(e, t) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new Kt(e, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new Nt(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
        }

        handlePointerEvent_(e, t) {
          e.point && this.value.setRawValue(Ut(jt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), t);
        }

        onPointerDownOrMove_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerUp_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
          });
        }

        onKeyDown_(e) {
          const t = Dt(this.baseStep_, Lt(e));
          0 !== t && this.value.setRawValue(this.value.rawValue + t, {
            forceEmit: !1,
            last: !1
          });
        }

        onKeyUp_(e) {
          0 !== Dt(this.baseStep_, Lt(e)) && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }

      }

      const qt = f("sldtxt");

      class Yt {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(qt());
          const n = e.createElement("div");
          n.classList.add(qt("s")), this.sliderView_ = t.sliderView, n.appendChild(this.sliderView_.element), this.element.appendChild(n);
          const r = e.createElement("div");
          r.classList.add(qt("t")), this.textView_ = t.textView, r.appendChild(this.textView_.element), this.element.appendChild(r);
        }

      }

      class Zt {
        constructor(e, t) {
          this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new Xt(e, {
            baseStep: t.baseStep,
            props: t.sliderProps,
            value: t.value,
            viewProps: this.viewProps
          }), this.textC_ = new Ht(e, {
            baseStep: t.baseStep,
            parser: t.parser,
            props: t.textProps,
            value: t.value,
            viewProps: t.viewProps
          }), this.view = new Yt(e, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
          });
        }

        get sliderController() {
          return this.sliderC_;
        }

        get textController() {
          return this.textC_;
        }

      }

      function Jt(e, t) {
        e.write(t);
      }

      function $t(e) {
        const t = R;
        return Array.isArray(e) ? t.required.array(t.required.object({
          text: t.required.string,
          value: t.required.raw
        }))(e).value : "object" == typeof e ? t.required.raw(e).value : void 0;
      }

      function Qt(e) {
        if ("inline" === e || "popup" === e) return e;
      }

      function en(e) {
        const t = R;
        return t.required.object({
          max: t.optional.number,
          min: t.optional.number,
          step: t.optional.number
        })(e).value;
      }

      function tn(e) {
        if (Array.isArray(e)) return e;
        const t = [];
        return Object.keys(e).forEach(n => {
          t.push({
            text: n,
            value: e[n]
          });
        }), t;
      }

      function nn(e) {
        return o(e) ? null : new Ge(tn(e));
      }

      function rn(e) {
        const t = e ? Ve(e, Ge) : null;
        return t ? t.options : null;
      }

      function sn(e, t) {
        const n = e && Ve(e, We);
        return n ? Bt(n.step) : Math.max(Bt(t), 2);
      }

      function on(e) {
        const t = function (e) {
          const t = e ? Ve(e, We) : null;
          return t ? t.step : null;
        }(e);

        return null != t ? t : 1;
      }

      function an(e, t) {
        var n;
        const r = e && Ve(e, We),
              i = Math.abs(null !== (n = null == r ? void 0 : r.step) && void 0 !== n ? n : t);
        return 0 === i ? .1 : Math.pow(10, Math.floor(Math.log10(i)) - 1);
      }

      const ln = f("ckb");

      class cn {
        constructor(e, t) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(ln()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("label");
          n.classList.add(ln("l")), this.element.appendChild(n);
          const r = e.createElement("input");
          r.classList.add(ln("i")), r.type = "checkbox", n.appendChild(r), this.inputElement = r, t.viewProps.bindDisabled(this.inputElement);
          const i = e.createElement("div");
          i.classList.add(ln("w")), n.appendChild(i);
          const s = B(e, "check");
          i.appendChild(s), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
        }

        update_() {
          this.inputElement.checked = this.value.rawValue;
        }

        onValueChange_() {
          this.update_();
        }

      }

      class un {
        constructor(e, t) {
          this.onInputChange_ = this.onInputChange_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new cn(e, {
            value: this.value,
            viewProps: this.viewProps
          }), this.view.inputElement.addEventListener("change", this.onInputChange_);
        }

        onInputChange_(e) {
          const t = e.currentTarget;
          this.value.rawValue = t.checked;
        }

      }

      const pn = {
        id: "input-bool",
        type: "input",
        accept: (e, t) => {
          if ("boolean" != typeof e) return null;
          const n = k(t, {
            options: R.optional.custom($t)
          });
          return n ? {
            initialValue: e,
            params: n
          } : null;
        },
        binding: {
          reader: e => tt,
          constraint: e => function (e) {
            const t = [],
                  n = nn(e.options);
            return n && t.push(n), new ze(t);
          }(e.params),
          writer: e => Jt
        },
        controller: e => {
          var t;
          const n = e.document,
                r = e.value,
                i = e.constraint;
          return i && Ve(i, Ge) ? new qe(n, {
            props: E.fromObject({
              options: null !== (t = rn(i)) && void 0 !== t ? t : []
            }),
            value: r,
            viewProps: e.viewProps
          }) : new un(n, {
            value: r,
            viewProps: e.viewProps
          });
        }
      },
            hn = f("col");

      class dn {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(hn()), t.foldable.bindExpandedClass(this.element, hn(void 0, "expanded")), g(t.foldable, "completed", v(this.element, hn(void 0, "cpl")));
          const n = e.createElement("div");
          n.classList.add(hn("h")), this.element.appendChild(n);
          const r = e.createElement("div");
          r.classList.add(hn("s")), n.appendChild(r), this.swatchElement = r;
          const i = e.createElement("div");

          if (i.classList.add(hn("t")), n.appendChild(i), this.textElement = i, "inline" === t.pickerLayout) {
            const t = e.createElement("div");
            t.classList.add(hn("p")), this.element.appendChild(t), this.pickerElement = t;
          } else this.pickerElement = null;
        }

      }

      function fn(e, t, n) {
        const r = zt(e, 360),
              i = jt(t / 100, 0, 1),
              s = jt(n / 100, 0, 1),
              o = s * i,
              a = o * (1 - Math.abs(r / 60 % 2 - 1)),
              l = s - o;
        let c, u, p;
        return [c, u, p] = r >= 0 && r < 60 ? [o, a, 0] : r >= 60 && r < 120 ? [a, o, 0] : r >= 120 && r < 180 ? [0, o, a] : r >= 180 && r < 240 ? [0, a, o] : r >= 240 && r < 300 ? [a, 0, o] : [o, 0, a], [255 * (c + l), 255 * (u + l), 255 * (p + l)];
      }

      function _n(e) {
        return [e[0], e[1], e[2]];
      }

      function mn(e, t) {
        return [e[0], e[1], e[2], t];
      }

      const gn = {
        hsl: {
          hsl: (e, t, n) => [e, t, n],
          hsv: function (e, t, n) {
            const r = n + t * (100 - Math.abs(2 * n - 100)) / 200;
            return [e, 0 !== r ? t * (100 - Math.abs(2 * n - 100)) / r : 0, n + t * (100 - Math.abs(2 * n - 100)) / 200];
          },
          rgb: function (e, t, n) {
            const r = (e % 360 + 360) % 360,
                  i = jt(t / 100, 0, 1),
                  s = jt(n / 100, 0, 1),
                  o = (1 - Math.abs(2 * s - 1)) * i,
                  a = o * (1 - Math.abs(r / 60 % 2 - 1)),
                  l = s - o / 2;
            let c, u, p;
            return [c, u, p] = r >= 0 && r < 60 ? [o, a, 0] : r >= 60 && r < 120 ? [a, o, 0] : r >= 120 && r < 180 ? [0, o, a] : r >= 180 && r < 240 ? [0, a, o] : r >= 240 && r < 300 ? [a, 0, o] : [o, 0, a], [255 * (c + l), 255 * (u + l), 255 * (p + l)];
          }
        },
        hsv: {
          hsl: function (e, t, n) {
            const r = 100 - Math.abs(n * (200 - t) / 100 - 100);
            return [e, 0 !== r ? t * n / r : 0, n * (200 - t) / 200];
          },
          hsv: (e, t, n) => [e, t, n],
          rgb: fn
        },
        rgb: {
          hsl: function (e, t, n) {
            const r = jt(e / 255, 0, 1),
                  i = jt(t / 255, 0, 1),
                  s = jt(n / 255, 0, 1),
                  o = Math.max(r, i, s),
                  a = Math.min(r, i, s),
                  l = o - a;
            let c = 0,
                u = 0;
            const p = (a + o) / 2;
            return 0 !== l && (u = l / (1 - Math.abs(o + a - 1)), c = r === o ? (i - s) / l : i === o ? 2 + (s - r) / l : 4 + (r - i) / l, c = c / 6 + (c < 0 ? 1 : 0)), [360 * c, 100 * u, 100 * p];
          },
          hsv: function (e, t, n) {
            const r = jt(e / 255, 0, 1),
                  i = jt(t / 255, 0, 1),
                  s = jt(n / 255, 0, 1),
                  o = Math.max(r, i, s),
                  a = o - Math.min(r, i, s);
            let l;
            return l = 0 === a ? 0 : o === r ? ((i - s) / a % 6 + 6) % 6 * 60 : o === i ? 60 * ((s - r) / a + 2) : 60 * ((r - i) / a + 4), [l, 100 * (0 === o ? 0 : a / o), 100 * o];
          },
          rgb: (e, t, n) => [e, t, n]
        }
      };
      const vn = {
        hsl: e => {
          var t;
          return [zt(e[0], 360), jt(e[1], 0, 100), jt(e[2], 0, 100), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)];
        },
        hsv: e => {
          var t;
          return [zt(e[0], 360), jt(e[1], 0, 100), jt(e[2], 0, 100), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)];
        },
        rgb: e => {
          var t;
          return [jt(e[0], 0, 255), jt(e[1], 0, 255), jt(e[2], 0, 255), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)];
        }
      };

      function bn(e, t) {
        return "object" == typeof e && !o(e) && t in e && "number" == typeof e[t];
      }

      class xn {
        constructor(e, t) {
          this.mode_ = t, this.comps_ = vn[t](e);
        }

        static black() {
          return new xn([0, 0, 0], "rgb");
        }

        static fromObject(e) {
          const t = "a" in e ? [e.r, e.g, e.b, e.a] : [e.r, e.g, e.b];
          return new xn(t, "rgb");
        }

        static toRgbaObject(e) {
          return e.toRgbaObject();
        }

        static isRgbColorObject(e) {
          return bn(e, "r") && bn(e, "g") && bn(e, "b");
        }

        static isRgbaColorObject(e) {
          return this.isRgbColorObject(e) && bn(e, "a");
        }

        static isColorObject(e) {
          return this.isRgbColorObject(e);
        }

        static equals(e, t) {
          if (e.mode_ !== t.mode_) return !1;
          const n = e.comps_,
                r = t.comps_;

          for (let e = 0; e < n.length; e++) if (n[e] !== r[e]) return !1;

          return !0;
        }

        get mode() {
          return this.mode_;
        }

        getComponents(e) {
          return mn((t = _n(this.comps_), n = this.mode_, r = e || this.mode_, gn[n][r](...t)), this.comps_[3]);
          var t, n, r;
        }

        toRgbaObject() {
          const e = this.getComponents("rgb");
          return {
            r: e[0],
            g: e[1],
            b: e[2],
            a: e[3]
          };
        }

      }

      const yn = f("colp");

      class wn {
        constructor(e, t) {
          this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(yn());
          const n = e.createElement("div");
          n.classList.add(yn("hsv"));
          const r = e.createElement("div");
          r.classList.add(yn("sv")), this.svPaletteView_ = t.svPaletteView, r.appendChild(this.svPaletteView_.element), n.appendChild(r);
          const i = e.createElement("div");
          i.classList.add(yn("h")), this.hPaletteView_ = t.hPaletteView, i.appendChild(this.hPaletteView_.element), n.appendChild(i), this.element.appendChild(n);
          const s = e.createElement("div");

          if (s.classList.add(yn("rgb")), this.textView_ = t.textView, s.appendChild(this.textView_.element), this.element.appendChild(s), t.alphaViews) {
            this.alphaViews_ = {
              palette: t.alphaViews.palette,
              text: t.alphaViews.text
            };
            const n = e.createElement("div");
            n.classList.add(yn("a"));
            const r = e.createElement("div");
            r.classList.add(yn("ap")), r.appendChild(this.alphaViews_.palette.element), n.appendChild(r);
            const i = e.createElement("div");
            i.classList.add(yn("at")), i.appendChild(this.alphaViews_.text.element), n.appendChild(i), this.element.appendChild(n);
          }
        }

        get allFocusableElements() {
          const e = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map(e => e.inputElement)];
          return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e;
        }

      }

      function Sn(e) {
        const t = R;
        return k(e, {
          alpha: t.optional.boolean,
          expanded: t.optional.boolean,
          picker: t.optional.custom(Qt)
        });
      }

      function Mn(e) {
        return e ? .1 : 1;
      }

      function Tn(e, t) {
        const n = e.match(/^(.+)%$/);
        return n ? Math.min(.01 * parseFloat(n[1]) * t, t) : Math.min(parseFloat(e), t);
      }

      const En = {
        deg: e => e,
        grad: e => 360 * e / 400,
        rad: e => 360 * e / (2 * Math.PI),
        turn: e => 360 * e
      };

      function An(e) {
        const t = e.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
        if (!t) return parseFloat(e);
        const n = parseFloat(t[1]),
              r = t[2];
        return En[r](n);
      }

      const Cn = {
        "func.rgb": e => {
          const t = e.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!t) return null;
          const n = [Tn(t[1], 255), Tn(t[2], 255), Tn(t[3], 255)];
          return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : new xn(n, "rgb");
        },
        "func.rgba": e => {
          const t = e.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!t) return null;
          const n = [Tn(t[1], 255), Tn(t[2], 255), Tn(t[3], 255), Tn(t[4], 1)];
          return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : new xn(n, "rgb");
        },
        "func.hsl": e => {
          const t = e.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!t) return null;
          const n = [An(t[1]), Tn(t[2], 100), Tn(t[3], 100)];
          return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : new xn(n, "hsl");
        },
        "func.hsla": e => {
          const t = e.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!t) return null;
          const n = [An(t[1]), Tn(t[2], 100), Tn(t[3], 100), Tn(t[4], 1)];
          return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : new xn(n, "hsl");
        },
        "hex.rgb": e => {
          const t = e.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
          if (t) return new xn([parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)], "rgb");
          const n = e.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
          return n ? new xn([parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16)], "rgb") : null;
        },
        "hex.rgba": e => {
          const t = e.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
          if (t) return new xn([parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16), Ut(parseInt(t[4] + t[4], 16), 0, 255, 0, 1)], "rgb");
          const n = e.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
          return n ? new xn([parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16), Ut(parseInt(n[4], 16), 0, 255, 0, 1)], "rgb") : null;
        }
      };

      function Rn(e) {
        return Object.keys(Cn).reduce((t, n) => t || ((0, Cn[n])(e) ? n : null), null);
      }

      const kn = e => {
        const t = Rn(e);
        return t ? Cn[t](e) : null;
      };

      function Pn(e) {
        return "func.hsla" === e || "func.rgba" === e || "hex.rgba" === e;
      }

      function Dn(e) {
        if ("string" == typeof e) {
          const t = kn(e);
          if (t) return t;
        }

        return xn.black();
      }

      function On(e) {
        const t = jt(Math.floor(e), 0, 255).toString(16);
        return 1 === t.length ? `0${t}` : t;
      }

      function Ln(e, t = "#") {
        return `${t}${_n(e.getComponents("rgb")).map(On).join("")}`;
      }

      function In(e, t = "#") {
        const n = e.getComponents("rgb");
        return `${t}${[n[0], n[1], n[2], 255 * n[3]].map(On).join("")}`;
      }

      function Fn(e) {
        const t = St(0);
        return `rgb(${_n(e.getComponents("rgb")).map(e => t(e)).join(", ")})`;
      }

      function Nn(e) {
        const t = St(2),
              n = St(0);
        return `rgba(${e.getComponents("rgb").map((e, r) => (3 === r ? t : n)(e)).join(", ")})`;
      }

      const Un = {
        "func.hsl": function (e) {
          const t = [St(0), Tt, Tt];
          return `hsl(${_n(e.getComponents("hsl")).map((e, n) => t[n](e)).join(", ")})`;
        },
        "func.hsla": function (e) {
          const t = [St(0), Tt, Tt, St(2)];
          return `hsla(${e.getComponents("hsl").map((e, n) => t[n](e)).join(", ")})`;
        },
        "func.rgb": Fn,
        "func.rgba": Nn,
        "hex.rgb": Ln,
        "hex.rgba": In
      };

      function Bn(e) {
        return Un[e];
      }

      const jn = f("apl");

      class zn {
        constructor(e, t) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(jn()), t.viewProps.bindTabIndex(this.element);
          const n = e.createElement("div");
          n.classList.add(jn("b")), this.element.appendChild(n);
          const r = e.createElement("div");
          r.classList.add(jn("c")), n.appendChild(r), this.colorElem_ = r;
          const i = e.createElement("div");
          i.classList.add(jn("m")), this.element.appendChild(i), this.markerElem_ = i;
          const s = e.createElement("div");
          s.classList.add(jn("p")), this.markerElem_.appendChild(s), this.previewElem_ = s, this.update_();
        }

        update_() {
          const e = this.value.rawValue,
                t = e.getComponents("rgb"),
                n = new xn([t[0], t[1], t[2], 0], "rgb"),
                r = new xn([t[0], t[1], t[2], 255], "rgb"),
                i = ["to right", Nn(n), Nn(r)];
          this.colorElem_.style.background = `linear-gradient(${i.join(",")})`, this.previewElem_.style.backgroundColor = Nn(e);
          const s = Ut(t[3], 0, 1, 0, 100);
          this.markerElem_.style.left = `${s}%`;
        }

        onValueChange_() {
          this.update_();
        }

      }

      class Vn {
        constructor(e, t) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new zn(e, {
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new Nt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
        }

        handlePointerEvent_(e, t) {
          if (!e.point) return;
          const n = e.point.x / e.bounds.width,
                r = this.value.rawValue,
                [i, s, o] = r.getComponents("hsv");
          this.value.setRawValue(new xn([i, s, o, n], "hsv"), t);
        }

        onPointerDown_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerMove_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerUp_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
          });
        }

        onKeyDown_(e) {
          const t = Dt(Mn(!0), Lt(e));
          if (0 === t) return;
          const n = this.value.rawValue,
                [r, i, s, o] = n.getComponents("hsv");
          this.value.setRawValue(new xn([r, i, s, o + t], "hsv"), {
            forceEmit: !1,
            last: !1
          });
        }

        onKeyUp_(e) {
          0 !== Dt(Mn(!0), Lt(e)) && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }

      }

      const Gn = f("coltxt");

      class Hn {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(Gn());
          const n = e.createElement("div");
          n.classList.add(Gn("m")), this.modeElem_ = function (e) {
            const t = e.createElement("select");
            return t.appendChild([{
              text: "RGB",
              value: "rgb"
            }, {
              text: "HSL",
              value: "hsl"
            }, {
              text: "HSV",
              value: "hsv"
            }].reduce((t, n) => {
              const r = e.createElement("option");
              return r.textContent = n.text, r.value = n.value, t.appendChild(r), t;
            }, e.createDocumentFragment())), t;
          }(e), this.modeElem_.classList.add(Gn("ms")), n.appendChild(this.modeSelectElement);
          const r = e.createElement("div");
          r.classList.add(Gn("mm")), r.appendChild(B(e, "dropdown")), n.appendChild(r), this.element.appendChild(n);
          const i = e.createElement("div");
          i.classList.add(Gn("w")), this.element.appendChild(i), this.textsElem_ = i, this.textViews_ = t.textViews, this.applyTextViews_(), m(t.colorMode, e => {
            this.modeElem_.value = e;
          });
        }

        get modeSelectElement() {
          return this.modeElem_;
        }

        get textViews() {
          return this.textViews_;
        }

        set textViews(e) {
          this.textViews_ = e, this.applyTextViews_();
        }

        applyTextViews_() {
          V(this.textsElem_);
          const e = this.element.ownerDocument;
          this.textViews_.forEach(t => {
            const n = e.createElement("div");
            n.classList.add(Gn("c")), n.appendChild(t.element), this.textsElem_.appendChild(n);
          });
        }

      }

      const Wn = St(0),
            Kn = {
        rgb: () => new He({
          min: 0,
          max: 255
        }),
        hsl: e => new He(0 === e ? {
          min: 0,
          max: 360
        } : {
          min: 0,
          max: 100
        }),
        hsv: e => new He(0 === e ? {
          min: 0,
          max: 360
        } : {
          min: 0,
          max: 100
        })
      };

      function Xn(e, t, n) {
        return new Ht(e, {
          arrayPosition: 0 === n ? "fst" : 2 === n ? "lst" : "mid",
          baseStep: Mn(!1),
          parser: t.parser,
          props: E.fromObject({
            draggingScale: 1,
            formatter: Wn
          }),
          value: T(0, {
            constraint: Kn[t.colorMode](n)
          }),
          viewProps: t.viewProps
        });
      }

      class qn {
        constructor(e, t) {
          this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.parser_ = t.parser, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = T(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new Hn(e, {
            colorMode: this.colorMode,
            textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
          }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
        }

        createComponentControllers_(e) {
          const t = {
            colorMode: this.colorMode.rawValue,
            parser: this.parser_,
            viewProps: this.viewProps
          },
                n = [Xn(e, t, 0), Xn(e, t, 1), Xn(e, t, 2)];
          return n.forEach((e, t) => {
            Pt({
              primary: this.value,
              secondary: e.value,
              forward: e => e.rawValue.getComponents(this.colorMode.rawValue)[t],
              backward: (e, n) => {
                const r = this.colorMode.rawValue,
                      i = e.rawValue.getComponents(r);
                return i[t] = n.rawValue, new xn(mn(_n(i), i[3]), r);
              }
            });
          }), n;
        }

        onModeSelectChange_(e) {
          const t = e.currentTarget;
          this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view];
        }

      }

      const Yn = f("hpl");

      class Zn {
        constructor(e, t) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Yn()), t.viewProps.bindTabIndex(this.element);
          const n = e.createElement("div");
          n.classList.add(Yn("c")), this.element.appendChild(n);
          const r = e.createElement("div");
          r.classList.add(Yn("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_();
        }

        update_() {
          const e = this.value.rawValue,
                [t] = e.getComponents("hsv");
          this.markerElem_.style.backgroundColor = Fn(new xn([t, 100, 100], "hsv"));
          const n = Ut(t, 0, 360, 0, 100);
          this.markerElem_.style.left = `${n}%`;
        }

        onValueChange_() {
          this.update_();
        }

      }

      class Jn {
        constructor(e, t) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Zn(e, {
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new Nt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
        }

        handlePointerEvent_(e, t) {
          if (!e.point) return;
          const n = Ut(jt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 359),
                r = this.value.rawValue,
                [, i, s, o] = r.getComponents("hsv");
          this.value.setRawValue(new xn([n, i, s, o], "hsv"), t);
        }

        onPointerDown_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerMove_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerUp_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
          });
        }

        onKeyDown_(e) {
          const t = Dt(Mn(!1), Lt(e));
          if (0 === t) return;
          const n = this.value.rawValue,
                [r, i, s, o] = n.getComponents("hsv");
          this.value.setRawValue(new xn([r + t, i, s, o], "hsv"), {
            forceEmit: !1,
            last: !1
          });
        }

        onKeyUp_(e) {
          0 !== Dt(Mn(!1), Lt(e)) && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }

      }

      const $n = f("svp");

      class Qn {
        constructor(e, t) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add($n()), t.viewProps.bindTabIndex(this.element);
          const n = e.createElement("canvas");
          n.height = 64, n.width = 64, n.classList.add($n("c")), this.element.appendChild(n), this.canvasElement = n;
          const r = e.createElement("div");
          r.classList.add($n("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_();
        }

        update_() {
          const e = function (e) {
            const t = e.ownerDocument.defaultView;
            return t && "document" in t ? e.getContext("2d") : null;
          }(this.canvasElement);

          if (!e) return;
          const t = this.value.rawValue.getComponents("hsv"),
                n = this.canvasElement.width,
                r = this.canvasElement.height,
                i = e.getImageData(0, 0, n, r),
                s = i.data;

          for (let e = 0; e < r; e++) for (let i = 0; i < n; i++) {
            const o = Ut(i, 0, n, 0, 100),
                  a = Ut(e, 0, r, 100, 0),
                  l = fn(t[0], o, a),
                  c = 4 * (e * n + i);
            s[c] = l[0], s[c + 1] = l[1], s[c + 2] = l[2], s[c + 3] = 255;
          }

          e.putImageData(i, 0, 0);
          const o = Ut(t[1], 0, 100, 0, 100);
          this.markerElem_.style.left = `${o}%`;
          const a = Ut(t[2], 0, 100, 100, 0);
          this.markerElem_.style.top = `${a}%`;
        }

        onValueChange_() {
          this.update_();
        }

      }

      class er {
        constructor(e, t) {
          this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Qn(e, {
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new Nt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
        }

        handlePointerEvent_(e, t) {
          if (!e.point) return;
          const n = Ut(e.point.x, 0, e.bounds.width, 0, 100),
                r = Ut(e.point.y, 0, e.bounds.height, 100, 0),
                [i,,, s] = this.value.rawValue.getComponents("hsv");
          this.value.setRawValue(new xn([i, n, r, s], "hsv"), t);
        }

        onPointerDown_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerMove_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerUp_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
          });
        }

        onKeyDown_(e) {
          It(e.key) && e.preventDefault();
          const [t, n, r, i] = this.value.rawValue.getComponents("hsv"),
                s = Mn(!1),
                o = Dt(s, Lt(e)),
                a = Dt(s, Ot(e));
          0 === o && 0 === a || this.value.setRawValue(new xn([t, n + o, r + a, i], "hsv"), {
            forceEmit: !1,
            last: !1
          });
        }

        onKeyUp_(e) {
          const t = Mn(!1),
                n = Dt(t, Lt(e)),
                r = Dt(t, Ot(e));
          0 === n && 0 === r || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }

      }

      class tr {
        constructor(e, t) {
          this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new Jn(e, {
            value: this.value,
            viewProps: this.viewProps
          }), this.svPaletteC_ = new er(e, {
            value: this.value,
            viewProps: this.viewProps
          }), this.alphaIcs_ = t.supportsAlpha ? {
            palette: new Vn(e, {
              value: this.value,
              viewProps: this.viewProps
            }),
            text: new Ht(e, {
              parser: xt,
              baseStep: .1,
              props: E.fromObject({
                draggingScale: .01,
                formatter: St(2)
              }),
              value: T(0, {
                constraint: new He({
                  min: 0,
                  max: 1
                })
              }),
              viewProps: this.viewProps
            })
          } : null, this.alphaIcs_ && Pt({
            primary: this.value,
            secondary: this.alphaIcs_.text.value,
            forward: e => e.rawValue.getComponents()[3],
            backward: (e, t) => {
              const n = e.rawValue.getComponents();
              return n[3] = t.rawValue, new xn(n, e.rawValue.mode);
            }
          }), this.textC_ = new qn(e, {
            parser: xt,
            value: this.value,
            viewProps: this.viewProps
          }), this.view = new wn(e, {
            alphaViews: this.alphaIcs_ ? {
              palette: this.alphaIcs_.palette.view,
              text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: t.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textView: this.textC_.view
          });
        }

        get textController() {
          return this.textC_;
        }

      }

      const nr = f("colsw");

      class rr {
        constructor(e, t) {
          this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(nr()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("div");
          n.classList.add(nr("sw")), this.element.appendChild(n), this.swatchElem_ = n;
          const r = e.createElement("button");
          r.classList.add(nr("b")), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r, this.update_();
        }

        update_() {
          const e = this.value.rawValue;
          this.swatchElem_.style.backgroundColor = In(e);
        }

        onValueChange_() {
          this.update_();
        }

      }

      class ir {
        constructor(e, t) {
          this.value = t.value, this.viewProps = t.viewProps, this.view = new rr(e, {
            value: this.value,
            viewProps: this.viewProps
          });
        }

      }

      class sr {
        constructor(e, t) {
          this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Z.create(t.expanded), this.swatchC_ = new ir(e, {
            value: this.value,
            viewProps: this.viewProps
          });
          const n = this.swatchC_.view.buttonElement;
          n.addEventListener("blur", this.onButtonBlur_), n.addEventListener("click", this.onButtonClick_), this.textC_ = new et(e, {
            parser: t.parser,
            props: E.fromObject({
              formatter: t.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
          }), this.view = new dn(e, {
            foldable: this.foldable_,
            pickerLayout: t.pickerLayout
          }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = "popup" === t.pickerLayout ? new Je(e, {
            viewProps: this.viewProps
          }) : null;
          const r = new tr(e, {
            supportsAlpha: t.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
          });
          r.view.allFocusableElements.forEach(e => {
            e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_);
          }), this.pickerC_ = r, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(r.view.element), Pt({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: e => e.rawValue,
            backward: (e, t) => t.rawValue
          })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), $(this.foldable_, this.view.pickerElement));
        }

        get textController() {
          return this.textC_;
        }

        onButtonBlur_(e) {
          if (!this.popC_) return;
          const t = this.view.element,
                n = e.relatedTarget;
          n && t.contains(n) || (this.popC_.shows.rawValue = !1);
        }

        onButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
        }

        onPopupChildBlur_(e) {
          if (!this.popC_) return;
          const t = this.popC_.view.element,
                n = G(e);
          n && t.contains(n) || n && n === this.swatchC_.view.buttonElement && !F(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
        }

        onPopupChildKeydown_(e) {
          this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.swatchC_.view.buttonElement.focus();
        }

      }

      function or(e) {
        return xn.isColorObject(e) ? xn.fromObject(e) : xn.black();
      }

      function ar(e) {
        return _n(e.getComponents("rgb")).reduce((e, t) => e << 8 | 255 & Math.floor(t), 0);
      }

      function lr(e) {
        return e.getComponents("rgb").reduce((e, t, n) => e << 8 | 255 & Math.floor(3 === n ? 255 * t : t), 0) >>> 0;
      }

      function cr(e) {
        return "number" != typeof e ? xn.black() : new xn([(t = e) >> 16 & 255, t >> 8 & 255, 255 & t], "rgb");
        var t;
      }

      function ur(e) {
        return "number" != typeof e ? xn.black() : new xn([(t = e) >> 24 & 255, t >> 16 & 255, t >> 8 & 255, Ut(255 & t, 0, 255, 0, 1)], "rgb");
        var t;
      }

      function pr(e, t) {
        const n = t.toRgbaObject();
        e.writeProperty("r", n.r), e.writeProperty("g", n.g), e.writeProperty("b", n.b), e.writeProperty("a", n.a);
      }

      function hr(e, t) {
        const n = t.toRgbaObject();
        e.writeProperty("r", n.r), e.writeProperty("g", n.g), e.writeProperty("b", n.b);
      }

      function dr(e) {
        return "alpha" in e && !0 === e.alpha;
      }

      function fr(e) {
        return e ? e => In(e, "0x") : e => Ln(e, "0x");
      }

      const _r = {
        id: "input-color-number",
        type: "input",
        accept: (e, t) => {
          if ("number" != typeof e) return null;
          if (!("view" in t)) return null;
          if ("color" !== t.view) return null;
          const n = Sn(t);
          return n ? {
            initialValue: e,
            params: n
          } : null;
        },
        binding: {
          reader: e => dr(e.params) ? ur : cr,
          equals: xn.equals,
          writer: e => function (e) {
            const t = e ? lr : ar;
            return (e, n) => {
              Jt(e, t(n));
            };
          }(dr(e.params))
        },
        controller: e => {
          const t = dr(e.params),
                n = "expanded" in e.params ? e.params.expanded : void 0,
                r = "picker" in e.params ? e.params.picker : void 0;
          return new sr(e.document, {
            expanded: null != n && n,
            formatter: fr(t),
            parser: kn,
            pickerLayout: null != r ? r : "popup",
            supportsAlpha: t,
            value: e.value,
            viewProps: e.viewProps
          });
        }
      };
      const mr = {
        id: "input-color-object",
        type: "input",
        accept: (e, t) => {
          if (!xn.isColorObject(e)) return null;
          const n = Sn(t);
          return n ? {
            initialValue: e,
            params: n
          } : null;
        },
        binding: {
          reader: e => or,
          equals: xn.equals,
          writer: e => {
            return t = e.initialValue, xn.isRgbaColorObject(t) ? pr : hr;
            var t;
          }
        },
        controller: e => {
          const t = xn.isRgbaColorObject(e.initialValue),
                n = "expanded" in e.params ? e.params.expanded : void 0,
                r = "picker" in e.params ? e.params.picker : void 0,
                i = t ? In : Ln;
          return new sr(e.document, {
            expanded: null != n && n,
            formatter: i,
            parser: kn,
            pickerLayout: null != r ? r : "popup",
            supportsAlpha: t,
            value: e.value,
            viewProps: e.viewProps
          });
        }
      },
            gr = {
        id: "input-color-string",
        type: "input",
        accept: (e, t) => {
          if ("string" != typeof e) return null;
          if ("view" in t && "text" === t.view) return null;
          if (!Rn(e)) return null;
          const n = Sn(t);
          return n ? {
            initialValue: e,
            params: n
          } : null;
        },
        binding: {
          reader: e => Dn,
          equals: xn.equals,
          writer: e => {
            const t = Rn(e.initialValue);
            if (!t) throw c.shouldNeverHappen();
            return function (e) {
              const t = Bn(e);
              return (e, n) => {
                Jt(e, t(n));
              };
            }(t);
          }
        },
        controller: e => {
          const t = Rn(e.initialValue);
          if (!t) throw c.shouldNeverHappen();
          const n = Bn(t),
                r = "expanded" in e.params ? e.params.expanded : void 0,
                i = "picker" in e.params ? e.params.picker : void 0;
          return new sr(e.document, {
            expanded: null != r && r,
            formatter: n,
            parser: kn,
            pickerLayout: null != i ? i : "popup",
            supportsAlpha: Pn(t),
            value: e.value,
            viewProps: e.viewProps
          });
        }
      };

      class vr {
        constructor(e) {
          this.components = e.components, this.asm_ = e.assembly;
        }

        constrain(e) {
          const t = this.asm_.toComponents(e).map((e, t) => {
            var n, r;
            return null !== (r = null === (n = this.components[t]) || void 0 === n ? void 0 : n.constrain(e)) && void 0 !== r ? r : e;
          });
          return this.asm_.fromComponents(t);
        }

      }

      const br = f("pndtxt");

      class xr {
        constructor(e, t) {
          this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(br()), this.textViews.forEach(t => {
            const n = e.createElement("div");
            n.classList.add(br("a")), n.appendChild(t.element), this.element.appendChild(n);
          });
        }

      }

      class yr {
        constructor(e, t) {
          this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map((n, r) => function (e, t, n) {
            return new Ht(e, {
              arrayPosition: 0 === n ? "fst" : n === t.axes.length - 1 ? "lst" : "mid",
              baseStep: t.axes[n].baseStep,
              parser: t.parser,
              props: t.axes[n].textProps,
              value: T(0, {
                constraint: t.axes[n].constraint
              }),
              viewProps: t.viewProps
            });
          }(e, t, r)), this.acs_.forEach((e, n) => {
            Pt({
              primary: this.value,
              secondary: e.value,
              forward: e => t.assembly.toComponents(e.rawValue)[n],
              backward: (e, r) => {
                const i = t.assembly.toComponents(e.rawValue);
                return i[n] = r.rawValue, t.assembly.fromComponents(i);
              }
            });
          }), this.view = new xr(e, {
            textViews: this.acs_.map(e => e.view)
          });
        }

      }

      function wr(e) {
        const t = [],
              n = function (e) {
          return "step" in e && !o(e.step) ? new We(e.step) : null;
        }(e);

        n && t.push(n);

        const r = function (e) {
          return "max" in e && !o(e.max) || "min" in e && !o(e.min) ? new He({
            max: e.max,
            min: e.min
          }) : null;
        }(e);

        r && t.push(r);
        const i = nn(e.options);
        return i && t.push(i), new ze(t);
      }

      function Sr(e) {
        const [t, n] = function (e) {
          const t = e ? Ve(e, He) : null;
          return t ? [t.minValue, t.maxValue] : [void 0, void 0];
        }(e);

        return [null != t ? t : 0, null != n ? n : 100];
      }

      const Mr = {
        id: "input-number",
        type: "input",
        accept: (e, t) => {
          if ("number" != typeof e) return null;
          const n = R,
                r = k(t, {
            format: n.optional.function,
            max: n.optional.number,
            min: n.optional.number,
            options: n.optional.custom($t),
            step: n.optional.number
          });
          return r ? {
            initialValue: e,
            params: r
          } : null;
        },
        binding: {
          reader: e => yt,
          constraint: e => wr(e.params),
          writer: e => Jt
        },
        controller: e => {
          var t, n;
          const r = e.value,
                i = e.constraint;
          if (i && Ve(i, Ge)) return new qe(e.document, {
            props: E.fromObject({
              options: null !== (t = rn(i)) && void 0 !== t ? t : []
            }),
            value: r,
            viewProps: e.viewProps
          });
          const s = null !== (n = "format" in e.params ? e.params.format : void 0) && void 0 !== n ? n : St(sn(i, r.rawValue));

          if (i && Ve(i, He)) {
            const [t, n] = Sr(i);
            return new Zt(e.document, {
              baseStep: on(i),
              parser: xt,
              sliderProps: E.fromObject({
                maxValue: n,
                minValue: t
              }),
              textProps: E.fromObject({
                draggingScale: an(i, r.rawValue),
                formatter: s
              }),
              value: r,
              viewProps: e.viewProps
            });
          }

          return new Ht(e.document, {
            baseStep: on(i),
            parser: xt,
            props: E.fromObject({
              draggingScale: an(i, r.rawValue),
              formatter: s
            }),
            value: r,
            viewProps: e.viewProps
          });
        }
      };

      class Tr {
        constructor(e = 0, t = 0) {
          this.x = e, this.y = t;
        }

        getComponents() {
          return [this.x, this.y];
        }

        static isObject(e) {
          if (o(e)) return !1;
          const t = e.x,
                n = e.y;
          return "number" == typeof t && "number" == typeof n;
        }

        static equals(e, t) {
          return e.x === t.x && e.y === t.y;
        }

        toObject() {
          return {
            x: this.x,
            y: this.y
          };
        }

      }

      const Er = {
        toComponents: e => e.getComponents(),
        fromComponents: e => new Tr(...e)
      },
            Ar = f("p2d");

      class Cr {
        constructor(e, t) {
          this.element = e.createElement("div"), this.element.classList.add(Ar()), t.viewProps.bindClassModifiers(this.element), m(t.expanded, v(this.element, Ar(void 0, "expanded")));
          const n = e.createElement("div");
          n.classList.add(Ar("h")), this.element.appendChild(n);
          const r = e.createElement("button");
          r.classList.add(Ar("b")), r.appendChild(B(e, "p2dpad")), t.viewProps.bindDisabled(r), n.appendChild(r), this.buttonElement = r;
          const i = e.createElement("div");

          if (i.classList.add(Ar("t")), n.appendChild(i), this.textElement = i, "inline" === t.pickerLayout) {
            const t = e.createElement("div");
            t.classList.add(Ar("p")), this.element.appendChild(t), this.pickerElement = t;
          } else this.pickerElement = null;
        }

      }

      const Rr = f("p2dp");

      class kr {
        constructor(e, t) {
          this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t.invertsY, this.maxValue_ = t.maxValue, this.element = e.createElement("div"), this.element.classList.add(Rr()), "popup" === t.layout && this.element.classList.add(Rr(void 0, "p"));
          const n = e.createElement("div");
          n.classList.add(Rr("p")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.padElement = n;
          const r = e.createElementNS(L, "svg");
          r.classList.add(Rr("g")), this.padElement.appendChild(r), this.svgElem_ = r;
          const i = e.createElementNS(L, "line");
          i.classList.add(Rr("ax")), i.setAttributeNS(null, "x1", "0"), i.setAttributeNS(null, "y1", "50%"), i.setAttributeNS(null, "x2", "100%"), i.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(i);
          const s = e.createElementNS(L, "line");
          s.classList.add(Rr("ax")), s.setAttributeNS(null, "x1", "50%"), s.setAttributeNS(null, "y1", "0"), s.setAttributeNS(null, "x2", "50%"), s.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(s);
          const o = e.createElementNS(L, "line");
          o.classList.add(Rr("l")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(o), this.lineElem_ = o;
          const a = e.createElement("div");
          a.classList.add(Rr("m")), this.padElement.appendChild(a), this.markerElem_ = a, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
        }

        get allFocusableElements() {
          return [this.padElement];
        }

        update_() {
          const [e, t] = this.value.rawValue.getComponents(),
                n = this.maxValue_,
                r = Ut(e, -n, +n, 0, 100),
                i = Ut(t, -n, +n, 0, 100),
                s = this.invertsY_ ? 100 - i : i;
          this.lineElem_.setAttributeNS(null, "x2", `${r}%`), this.lineElem_.setAttributeNS(null, "y2", `${s}%`), this.markerElem_.style.left = `${r}%`, this.markerElem_.style.top = `${s}%`;
        }

        onValueChange_() {
          this.update_();
        }

        onFoldableChange_() {
          this.update_();
        }

      }

      function Pr(e, t, n) {
        return [Dt(t[0], Lt(e)), Dt(t[1], Ot(e)) * (n ? 1 : -1)];
      }

      class Dr {
        constructor(e, t) {
          this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.baseSteps_ = t.baseSteps, this.maxValue_ = t.maxValue, this.invertsY_ = t.invertsY, this.view = new kr(e, {
            invertsY: this.invertsY_,
            layout: t.layout,
            maxValue: this.maxValue_,
            value: this.value,
            viewProps: this.viewProps
          }), this.ptHandler_ = new Nt(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
        }

        handlePointerEvent_(e, t) {
          if (!e.point) return;
          const n = this.maxValue_,
                r = Ut(e.point.x, 0, e.bounds.width, -n, +n),
                i = Ut(this.invertsY_ ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -n, +n);
          this.value.setRawValue(new Tr(r, i), t);
        }

        onPointerDown_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerMove_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
          });
        }

        onPointerUp_(e) {
          this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
          });
        }

        onPadKeyDown_(e) {
          It(e.key) && e.preventDefault();
          const [t, n] = Pr(e, this.baseSteps_, this.invertsY_);
          0 === t && 0 === n || this.value.setRawValue(new Tr(this.value.rawValue.x + t, this.value.rawValue.y + n), {
            forceEmit: !1,
            last: !1
          });
        }

        onPadKeyUp_(e) {
          const [t, n] = Pr(e, this.baseSteps_, this.invertsY_);
          0 === t && 0 === n || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
          });
        }

      }

      class Or {
        constructor(e, t) {
          var n, r;
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Z.create(t.expanded), this.popC_ = "popup" === t.pickerLayout ? new Je(e, {
            viewProps: this.viewProps
          }) : null;
          const i = new Dr(e, {
            baseSteps: [t.axes[0].baseStep, t.axes[1].baseStep],
            invertsY: t.invertsY,
            layout: t.pickerLayout,
            maxValue: t.maxValue,
            value: this.value,
            viewProps: this.viewProps
          });
          i.view.allFocusableElements.forEach(e => {
            e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_);
          }), this.pickerC_ = i, this.textC_ = new yr(e, {
            assembly: Er,
            axes: t.axes,
            parser: t.parser,
            value: this.value,
            viewProps: this.viewProps
          }), this.view = new Cr(e, {
            expanded: this.foldable_.value("expanded"),
            pickerLayout: t.pickerLayout,
            viewProps: this.viewProps
          }), this.view.textElement.appendChild(this.textC_.view.element), null === (n = this.view.buttonElement) || void 0 === n || n.addEventListener("blur", this.onPadButtonBlur_), null === (r = this.view.buttonElement) || void 0 === r || r.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Pt({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: e => e.rawValue,
            backward: (e, t) => t.rawValue
          })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), $(this.foldable_, this.view.pickerElement));
        }

        onPadButtonBlur_(e) {
          if (!this.popC_) return;
          const t = this.view.element,
                n = e.relatedTarget;
          n && t.contains(n) || (this.popC_.shows.rawValue = !1);
        }

        onPadButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
        }

        onPopupChildBlur_(e) {
          if (!this.popC_) return;
          const t = this.popC_.view.element,
                n = G(e);
          n && t.contains(n) || n && n === this.view.buttonElement && !F(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
        }

        onPopupChildKeydown_(e) {
          this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.view.buttonElement.focus();
        }

      }

      function Lr(e) {
        return Tr.isObject(e) ? new Tr(e.x, e.y) : new Tr();
      }

      function Ir(e, t) {
        e.writeProperty("x", t.x), e.writeProperty("y", t.y);
      }

      function Fr(e) {
        if (!e) return;
        const t = [];
        return o(e.step) || t.push(new We(e.step)), o(e.max) && o(e.min) || t.push(new He({
          max: e.max,
          min: e.min
        })), new ze(t);
      }

      function Nr(e, t) {
        const n = e && Ve(e, He);
        if (n) return Math.max(Math.abs(n.minValue || 0), Math.abs(n.maxValue || 0));
        const r = on(e);
        return Math.max(10 * Math.abs(r), 10 * Math.abs(t));
      }

      function Ur(e, t) {
        const n = t instanceof vr ? t.components[0] : void 0,
              r = t instanceof vr ? t.components[1] : void 0,
              i = Nr(n, e.x),
              s = Nr(r, e.y);
        return Math.max(i, s);
      }

      function Br(e, t) {
        return {
          baseStep: on(t),
          constraint: t,
          textProps: E.fromObject({
            draggingScale: an(t, e),
            formatter: St(sn(t, e))
          })
        };
      }

      function jr(e) {
        if (!("y" in e)) return !1;
        const t = e.y;
        return !!t && "inverted" in t && !!t.inverted;
      }

      const zr = {
        id: "input-point2d",
        type: "input",
        accept: (e, t) => {
          if (!Tr.isObject(e)) return null;
          const n = R,
                r = k(t, {
            expanded: n.optional.boolean,
            picker: n.optional.custom(Qt),
            x: n.optional.custom(en),
            y: n.optional.object({
              inverted: n.optional.boolean,
              max: n.optional.number,
              min: n.optional.number,
              step: n.optional.number
            })
          });
          return r ? {
            initialValue: e,
            params: r
          } : null;
        },
        binding: {
          reader: e => Lr,
          constraint: e => {
            return t = e.params, new vr({
              assembly: Er,
              components: [Fr("x" in t ? t.x : void 0), Fr("y" in t ? t.y : void 0)]
            });
            var t;
          },
          equals: Tr.equals,
          writer: e => Ir
        },
        controller: e => {
          const t = e.document,
                n = e.value,
                r = e.constraint;
          if (!(r instanceof vr)) throw c.shouldNeverHappen();
          const i = "expanded" in e.params ? e.params.expanded : void 0,
                s = "picker" in e.params ? e.params.picker : void 0;
          return new Or(t, {
            axes: [Br(n.rawValue.x, r.components[0]), Br(n.rawValue.y, r.components[1])],
            expanded: null != i && i,
            invertsY: jr(e.params),
            maxValue: Ur(n.rawValue, r),
            parser: xt,
            pickerLayout: null != s ? s : "popup",
            value: n,
            viewProps: e.viewProps
          });
        }
      };

      class Vr {
        constructor(e = 0, t = 0, n = 0) {
          this.x = e, this.y = t, this.z = n;
        }

        getComponents() {
          return [this.x, this.y, this.z];
        }

        static isObject(e) {
          if (o(e)) return !1;
          const t = e.x,
                n = e.y,
                r = e.z;
          return "number" == typeof t && "number" == typeof n && "number" == typeof r;
        }

        static equals(e, t) {
          return e.x === t.x && e.y === t.y && e.z === t.z;
        }

        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z
          };
        }

      }

      const Gr = {
        toComponents: e => e.getComponents(),
        fromComponents: e => new Vr(...e)
      };

      function Hr(e) {
        return Vr.isObject(e) ? new Vr(e.x, e.y, e.z) : new Vr();
      }

      function Wr(e, t) {
        e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z);
      }

      function Kr(e) {
        if (!e) return;
        const t = [];
        return o(e.step) || t.push(new We(e.step)), o(e.max) && o(e.min) || t.push(new He({
          max: e.max,
          min: e.min
        })), new ze(t);
      }

      function Xr(e, t) {
        return {
          baseStep: on(t),
          constraint: t,
          textProps: E.fromObject({
            draggingScale: an(t, e),
            formatter: St(sn(t, e))
          })
        };
      }

      const qr = {
        id: "input-point3d",
        type: "input",
        accept: (e, t) => {
          if (!Vr.isObject(e)) return null;
          const n = R,
                r = k(t, {
            x: n.optional.custom(en),
            y: n.optional.custom(en),
            z: n.optional.custom(en)
          });
          return r ? {
            initialValue: e,
            params: r
          } : null;
        },
        binding: {
          reader: e => Hr,
          constraint: e => {
            return t = e.params, new vr({
              assembly: Gr,
              components: [Kr("x" in t ? t.x : void 0), Kr("y" in t ? t.y : void 0), Kr("z" in t ? t.z : void 0)]
            });
            var t;
          },
          equals: Vr.equals,
          writer: e => Wr
        },
        controller: e => {
          const t = e.value,
                n = e.constraint;
          if (!(n instanceof vr)) throw c.shouldNeverHappen();
          return new yr(e.document, {
            assembly: Gr,
            axes: [Xr(t.rawValue.x, n.components[0]), Xr(t.rawValue.y, n.components[1]), Xr(t.rawValue.z, n.components[2])],
            parser: xt,
            value: t,
            viewProps: e.viewProps
          });
        }
      };

      class Yr {
        constructor(e = 0, t = 0, n = 0, r = 0) {
          this.x = e, this.y = t, this.z = n, this.w = r;
        }

        getComponents() {
          return [this.x, this.y, this.z, this.w];
        }

        static isObject(e) {
          if (o(e)) return !1;
          const t = e.x,
                n = e.y,
                r = e.z,
                i = e.w;
          return "number" == typeof t && "number" == typeof n && "number" == typeof r && "number" == typeof i;
        }

        static equals(e, t) {
          return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
        }

        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
          };
        }

      }

      const Zr = {
        toComponents: e => e.getComponents(),
        fromComponents: e => new Yr(...e)
      };

      function Jr(e) {
        return Yr.isObject(e) ? new Yr(e.x, e.y, e.z, e.w) : new Yr();
      }

      function $r(e, t) {
        e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z), e.writeProperty("w", t.w);
      }

      function Qr(e) {
        if (!e) return;
        const t = [];
        return o(e.step) || t.push(new We(e.step)), o(e.max) && o(e.min) || t.push(new He({
          max: e.max,
          min: e.min
        })), new ze(t);
      }

      const ei = {
        id: "input-point4d",
        type: "input",
        accept: (e, t) => {
          if (!Yr.isObject(e)) return null;
          const n = R,
                r = k(t, {
            x: n.optional.custom(en),
            y: n.optional.custom(en),
            z: n.optional.custom(en),
            w: n.optional.custom(en)
          });
          return r ? {
            initialValue: e,
            params: r
          } : null;
        },
        binding: {
          reader: e => Jr,
          constraint: e => {
            return t = e.params, new vr({
              assembly: Zr,
              components: [Qr("x" in t ? t.x : void 0), Qr("y" in t ? t.y : void 0), Qr("z" in t ? t.z : void 0), Qr("w" in t ? t.w : void 0)]
            });
            var t;
          },
          equals: Yr.equals,
          writer: e => $r
        },
        controller: e => {
          const t = e.value,
                n = e.constraint;
          if (!(n instanceof vr)) throw c.shouldNeverHappen();
          return new yr(e.document, {
            assembly: Zr,
            axes: t.rawValue.getComponents().map((e, t) => {
              return r = e, {
                baseStep: on(i = n.components[t]),
                constraint: i,
                textProps: E.fromObject({
                  draggingScale: an(i, r),
                  formatter: St(sn(i, r))
                })
              };
              var r, i;
            }),
            parser: xt,
            value: t,
            viewProps: e.viewProps
          });
        }
      };
      const ti = {
        id: "input-string",
        type: "input",
        accept: (e, t) => {
          if ("string" != typeof e) return null;
          const n = k(t, {
            options: R.optional.custom($t)
          });
          return n ? {
            initialValue: e,
            params: n
          } : null;
        },
        binding: {
          reader: e => Et,
          constraint: e => function (e) {
            const t = [],
                  n = nn(e.options);
            return n && t.push(n), new ze(t);
          }(e.params),
          writer: e => Jt
        },
        controller: e => {
          var t;
          const n = e.document,
                r = e.value,
                i = e.constraint;
          return i && Ve(i, Ge) ? new qe(n, {
            props: E.fromObject({
              options: null !== (t = rn(i)) && void 0 !== t ? t : []
            }),
            value: r,
            viewProps: e.viewProps
          }) : new et(n, {
            parser: e => e,
            props: E.fromObject({
              formatter: At
            }),
            value: r,
            viewProps: e.viewProps
          });
        }
      },
            ni = {
        defaultInterval: 200,
        defaultLineCount: 3
      },
            ri = f("mll");

      class ii {
        constructor(e, t) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(ri()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("textarea");
          n.classList.add(ri("i")), n.style.height = `calc(var(--bld-us) * ${t.lineCount})`, n.readOnly = !0, t.viewProps.bindDisabled(n), this.element.appendChild(n), this.textareaElem_ = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
        }

        update_() {
          const e = this.textareaElem_,
                t = e.scrollTop === e.scrollHeight - e.clientHeight,
                n = [];
          this.value.rawValue.forEach(e => {
            void 0 !== e && n.push(this.formatter_(e));
          }), e.textContent = n.join("\n"), t && (e.scrollTop = e.scrollHeight);
        }

        onValueUpdate_() {
          this.update_();
        }

      }

      class si {
        constructor(e, t) {
          this.value = t.value, this.viewProps = t.viewProps, this.view = new ii(e, {
            formatter: t.formatter,
            lineCount: t.lineCount,
            value: this.value,
            viewProps: this.viewProps
          });
        }

      }

      const oi = f("sgl");

      class ai {
        constructor(e, t) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(oi()), t.viewProps.bindClassModifiers(this.element);
          const n = e.createElement("input");
          n.classList.add(oi("i")), n.readOnly = !0, n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
        }

        update_() {
          const e = this.value.rawValue,
                t = e[e.length - 1];
          this.inputElement.value = void 0 !== t ? this.formatter_(t) : "";
        }

        onValueUpdate_() {
          this.update_();
        }

      }

      class li {
        constructor(e, t) {
          this.value = t.value, this.viewProps = t.viewProps, this.view = new ai(e, {
            formatter: t.formatter,
            value: this.value,
            viewProps: this.viewProps
          });
        }

      }

      const ci = {
        id: "monitor-bool",
        type: "monitor",
        accept: (e, t) => {
          if ("boolean" != typeof e) return null;
          const n = k(t, {
            lineCount: R.optional.number
          });
          return n ? {
            initialValue: e,
            params: n
          } : null;
        },
        binding: {
          reader: e => tt
        },
        controller: e => {
          var t;
          return 1 === e.value.rawValue.length ? new li(e.document, {
            formatter: nt,
            value: e.value,
            viewProps: e.viewProps
          }) : new si(e.document, {
            formatter: nt,
            lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
            value: e.value,
            viewProps: e.viewProps
          });
        }
      };

      class ui {
        constructor() {
          this.emitter = new h(), this.index_ = -1;
        }

        get index() {
          return this.index_;
        }

        set index(e) {
          this.index_ !== e && (this.index_ = e, this.emitter.emit("change", {
            index: e,
            sender: this
          }));
        }

      }

      const pi = f("grl");

      class hi {
        constructor(e, t) {
          this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(pi()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.minValue_ = t.minValue, this.maxValue_ = t.maxValue, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
          const n = e.createElementNS(L, "svg");
          n.classList.add(pi("g")), n.style.height = `calc(var(--bld-us) * ${t.lineCount})`, this.element.appendChild(n), this.svgElem_ = n;
          const r = e.createElementNS(L, "polyline");
          this.svgElem_.appendChild(r), this.lineElem_ = r;
          const i = e.createElement("div");
          i.classList.add(pi("t"), f("tt")()), this.element.appendChild(i), this.tooltipElem_ = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
        }

        get graphElement() {
          return this.svgElem_;
        }

        update_() {
          const e = this.svgElem_.getBoundingClientRect(),
                t = this.value.rawValue.length - 1,
                n = this.minValue_,
                r = this.maxValue_,
                i = [];
          this.value.rawValue.forEach((s, o) => {
            if (void 0 === s) return;
            const a = Ut(o, 0, t, 0, e.width),
                  l = Ut(s, n, r, e.height, 0);
            i.push([a, l].join(","));
          }), this.lineElem_.setAttributeNS(null, "points", i.join(" "));
          const s = this.tooltipElem_,
                o = this.value.rawValue[this.cursor_.index];
          if (void 0 === o) return void s.classList.remove(pi("t", "a"));
          const a = Ut(this.cursor_.index, 0, t, 0, e.width),
                l = Ut(o, n, r, e.height, 0);
          s.style.left = `${a}px`, s.style.top = `${l}px`, s.textContent = `${this.formatter_(o)}`, s.classList.contains(pi("t", "a")) || (s.classList.add(pi("t", "a"), pi("t", "in")), I(s), s.classList.remove(pi("t", "in")));
        }

        onValueUpdate_() {
          this.update_();
        }

        onCursorChange_() {
          this.update_();
        }

      }

      class di {
        constructor(e, t) {
          if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = new ui(), this.view = new hi(e, {
            cursor: this.cursor_,
            formatter: t.formatter,
            lineCount: t.lineCount,
            maxValue: t.maxValue,
            minValue: t.minValue,
            value: this.value,
            viewProps: this.viewProps
          }), F(e)) {
            const e = new Nt(this.view.element);
            e.emitter.on("down", this.onGraphPointerDown_), e.emitter.on("move", this.onGraphPointerMove_), e.emitter.on("up", this.onGraphPointerUp_);
          } else this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        }

        onGraphMouseLeave_() {
          this.cursor_.index = -1;
        }

        onGraphMouseMove_(e) {
          const t = this.view.element.getBoundingClientRect();
          this.cursor_.index = Math.floor(Ut(e.offsetX, 0, t.width, 0, this.value.rawValue.length));
        }

        onGraphPointerDown_(e) {
          this.onGraphPointerMove_(e);
        }

        onGraphPointerMove_(e) {
          e.data.point ? this.cursor_.index = Math.floor(Ut(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.index = -1;
        }

        onGraphPointerUp_() {
          this.cursor_.index = -1;
        }

      }

      function fi(e) {
        return "format" in e && !o(e.format) ? e.format : St(2);
      }

      function _i(e) {
        return "view" in e && "graph" === e.view;
      }

      const mi = {
        id: "monitor-number",
        type: "monitor",
        accept: (e, t) => {
          if ("number" != typeof e) return null;
          const n = R,
                r = k(t, {
            format: n.optional.function,
            lineCount: n.optional.number,
            max: n.optional.number,
            min: n.optional.number,
            view: n.optional.string
          });
          return r ? {
            initialValue: e,
            params: r
          } : null;
        },
        binding: {
          defaultBufferSize: e => _i(e) ? 64 : 1,
          reader: e => yt
        },
        controller: e => _i(e.params) ? function (e) {
          var t, n, r;
          return new di(e.document, {
            formatter: fi(e.params),
            lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
            maxValue: null !== (n = "max" in e.params ? e.params.max : null) && void 0 !== n ? n : 100,
            minValue: null !== (r = "min" in e.params ? e.params.min : null) && void 0 !== r ? r : 0,
            value: e.value,
            viewProps: e.viewProps
          });
        }(e) : function (e) {
          var t;
          return 1 === e.value.rawValue.length ? new li(e.document, {
            formatter: fi(e.params),
            value: e.value,
            viewProps: e.viewProps
          }) : new si(e.document, {
            formatter: fi(e.params),
            lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
            value: e.value,
            viewProps: e.viewProps
          });
        }(e)
      },
            gi = {
        id: "monitor-string",
        type: "monitor",
        accept: (e, t) => {
          if ("string" != typeof e) return null;
          const n = R,
                r = k(t, {
            lineCount: n.optional.number,
            multiline: n.optional.boolean
          });
          return r ? {
            initialValue: e,
            params: r
          } : null;
        },
        binding: {
          reader: e => Et
        },
        controller: e => {
          var t;
          const n = e.value;
          return n.rawValue.length > 1 || "multiline" in e.params && e.params.multiline ? new si(e.document, {
            formatter: At,
            lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
            value: n,
            viewProps: e.viewProps
          }) : new li(e.document, {
            formatter: At,
            value: n,
            viewProps: e.viewProps
          });
        }
      };

      class vi {
        constructor(e) {
          this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e.reader, this.writer = e.writer, this.emitter = new h(), this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.target = e.target, this.read();
        }

        read() {
          const e = this.target.read();
          void 0 !== e && (this.value.rawValue = this.reader(e));
        }

        write_(e) {
          this.writer(this.target, e);
        }

        onValueChange_(e) {
          this.write_(e.rawValue), this.emitter.emit("change", {
            options: e.options,
            rawValue: e.rawValue,
            sender: this
          });
        }

      }

      class bi {
        constructor(e) {
          this.onTick_ = this.onTick_.bind(this), this.reader_ = e.reader, this.target = e.target, this.emitter = new h(), this.value = e.value, this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
        }

        dispose() {
          this.ticker.dispose();
        }

        read() {
          const e = this.target.read();
          if (void 0 === e) return;
          const t = this.value.rawValue,
                n = this.reader_(e);
          this.value.rawValue = function (e, t) {
            const n = [...kt(e), t];
            return n.length > e.length ? n.splice(0, n.length - e.length) : Ct(n, e.length), n;
          }(t, n), this.emitter.emit("update", {
            rawValue: n,
            sender: this
          });
        }

        onTick_(e) {
          this.read();
        }

      }

      function xi(e, t) {
        return 0 === t ? new Be() : new je(e, null != t ? t : ni.defaultInterval);
      }

      class yi {
        constructor() {
          this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
          };
        }

        getAll() {
          return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors];
        }

        register(e) {
          "blade" === e.type ? this.pluginsMap_.blades.unshift(e) : "input" === e.type ? this.pluginsMap_.inputs.unshift(e) : "monitor" === e.type && this.pluginsMap_.monitors.unshift(e);
        }

        createInput(e, t, n) {
          if (o(t.read())) throw new c({
            context: {
              key: t.key
            },
            type: "nomatchingcontroller"
          });
          const r = this.pluginsMap_.inputs.reduce((r, i) => r || function (e, t) {
            const n = e.accept(t.target.read(), t.params);
            if (o(n)) return null;
            const r = R,
                  i = {
              target: t.target,
              initialValue: n.initialValue,
              params: n.params
            },
                  s = e.binding.reader(i),
                  a = e.binding.constraint ? e.binding.constraint(i) : void 0,
                  l = T(s(n.initialValue), {
              constraint: a,
              equals: e.binding.equals
            }),
                  c = new vi({
              reader: s,
              target: t.target,
              value: l,
              writer: e.binding.writer(i)
            }),
                  u = r.optional.boolean(t.params.disabled).value,
                  p = r.optional.boolean(t.params.hidden).value,
                  h = e.controller({
              constraint: a,
              document: t.document,
              initialValue: n.initialValue,
              params: n.params,
              value: c.value,
              viewProps: Ce.create({
                disabled: u,
                hidden: p
              })
            }),
                  d = r.optional.string(t.params.label).value;
            return new ne(t.document, {
              binding: c,
              blade: Y(),
              props: E.fromObject({
                label: d || t.target.key
              }),
              valueController: h
            });
          }(i, {
            document: e,
            target: t,
            params: n
          }), null);
          if (r) return r;
          throw new c({
            context: {
              key: t.key
            },
            type: "nomatchingcontroller"
          });
        }

        createMonitor(e, t, n) {
          const r = this.pluginsMap_.monitors.reduce((r, i) => r || function (e, t) {
            var n, r, i;
            const s = R,
                  a = e.accept(t.target.read(), t.params);
            if (o(a)) return null;

            const l = {
              target: t.target,
              initialValue: a.initialValue,
              params: a.params
            },
                  c = e.binding.reader(l),
                  u = null !== (r = null !== (n = s.optional.number(t.params.bufferSize).value) && void 0 !== n ? n : e.binding.defaultBufferSize && e.binding.defaultBufferSize(a.params)) && void 0 !== r ? r : 1,
                  p = s.optional.number(t.params.interval).value,
                  h = new bi({
              reader: c,
              target: t.target,
              ticker: xi(t.document, p),
              value: Rt(u)
            }),
                  d = s.optional.boolean(t.params.disabled).value,
                  f = s.optional.boolean(t.params.hidden).value,
                  _ = e.controller({
              document: t.document,
              params: a.params,
              value: h.value,
              viewProps: Ce.create({
                disabled: d,
                hidden: f
              })
            }),
                  m = null !== (i = s.optional.string(t.params.label).value) && void 0 !== i ? i : t.target.key;

            return new ie(t.document, {
              binding: h,
              blade: Y(),
              props: E.fromObject({
                label: m
              }),
              valueController: _
            });
          }(i, {
            document: e,
            params: n,
            target: t
          }), null);
          if (r) return r;
          throw new c({
            context: {
              key: t.key
            },
            type: "nomatchingcontroller"
          });
        }

        createBlade(e, t) {
          const n = this.pluginsMap_.blades.reduce((n, r) => n || function (e, t) {
            const n = e.accept(t.params);
            if (!n) return null;
            const r = R.optional.boolean(t.params.disabled).value,
                  i = R.optional.boolean(t.params.hidden).value;
            return e.controller({
              blade: Y(),
              document: t.document,
              params: Object.assign(Object.assign({}, n.params), {
                disabled: r,
                hidden: i
              }),
              viewProps: Ce.create({
                disabled: r,
                hidden: i
              })
            });
          }(r, {
            document: e,
            params: t
          }), null);
          if (!n) throw new c({
            type: "nomatchingview",
            context: {
              params: t
            }
          });
          return n;
        }

        createBladeApi(e) {
          if (e instanceof ne) return new te(e);
          if (e instanceof ie) return new re(e);
          if (e instanceof _e) return new le(e, this);
          const t = this.pluginsMap_.blades.reduce((t, n) => t || n.api({
            controller: e,
            pool: this
          }), null);
          if (!t) throw c.shouldNeverHappen();
          return t;
        }

      }

      class wi extends t {
        constructor(e) {
          super(e), this.emitter_ = new h(), this.controller_.valueController.value.emitter.on("change", e => {
            this.emitter_.emit("change", {
              event: new r(this, e.rawValue)
            });
          });
        }

        get label() {
          return this.controller_.props.get("label");
        }

        set label(e) {
          this.controller_.props.set("label", e);
        }

        get options() {
          return this.controller_.valueController.props.get("options");
        }

        set options(e) {
          this.controller_.valueController.props.set("options", e);
        }

        get value() {
          return this.controller_.valueController.value.rawValue;
        }

        set value(e) {
          this.controller_.valueController.value.rawValue = e;
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

      }

      class Si extends t {
        constructor(e) {
          super(e), this.emitter_ = new h(), this.controller_.valueController.value.emitter.on("change", e => {
            this.emitter_.emit("change", {
              event: new r(this, e.rawValue)
            });
          });
        }

        get label() {
          return this.controller_.props.get("label");
        }

        set label(e) {
          this.controller_.props.set("label", e);
        }

        get maxValue() {
          return this.controller_.valueController.sliderController.props.get("maxValue");
        }

        set maxValue(e) {
          this.controller_.valueController.sliderController.props.set("maxValue", e);
        }

        get minValue() {
          return this.controller_.valueController.sliderController.props.get("minValue");
        }

        set minValue(e) {
          this.controller_.valueController.sliderController.props.set("minValue", e);
        }

        get value() {
          return this.controller_.valueController.value.rawValue;
        }

        set value(e) {
          this.controller_.valueController.value.rawValue = e;
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

      }

      class Mi extends t {
        constructor(e) {
          super(e), this.emitter_ = new h(), this.controller_.valueController.value.emitter.on("change", e => {
            this.emitter_.emit("change", {
              event: new r(this, e.rawValue)
            });
          });
        }

        get label() {
          return this.controller_.props.get("label");
        }

        set label(e) {
          this.controller_.props.set("label", e);
        }

        get formatter() {
          return this.controller_.valueController.props.get("formatter");
        }

        set formatter(e) {
          this.controller_.valueController.props.set("formatter", e);
        }

        get value() {
          return this.controller_.valueController.value.rawValue;
        }

        set value(e) {
          this.controller_.valueController.value.rawValue = e;
        }

        on(e, t) {
          const n = t.bind(this);
          return this.emitter_.on(e, e => {
            n(e.event);
          }), this;
        }

      }

      const Ti = {
        id: "list",
        type: "blade",

        accept(e) {
          const t = R,
                n = k(e, {
            options: t.required.custom($t),
            value: t.required.raw,
            view: t.required.constant("list"),
            label: t.optional.string
          });
          return n ? {
            params: n
          } : null;
        },

        controller(e) {
          const t = new qe(e.document, {
            props: E.fromObject({
              options: tn(e.params.options)
            }),
            value: T(e.params.value),
            viewProps: e.viewProps
          });
          return new xe(e.document, {
            blade: e.blade,
            props: E.fromObject({
              label: e.params.label
            }),
            valueController: t
          });
        },

        api: e => e.controller instanceof xe && e.controller.valueController instanceof qe ? new wi(e.controller) : null
      };

      class Ei extends ce {
        constructor(e, t) {
          super(e, t);
        }

        get element() {
          return this.controller_.view.element;
        }

        importPreset(e) {
          (function (e, t) {
            e.forEach(e => {
              const n = t[e.presetKey];
              void 0 !== n && e.write(n);
            });
          })(this.controller_.rackController.rack.find(ne).map(e => e.binding.target), e), this.refresh();
        }

        exportPreset() {
          return this.controller_.rackController.rack.find(ne).map(e => e.binding.target).reduce((e, t) => Object.assign(e, {
            [t.presetKey]: t.read()
          }), {});
        }

        refresh() {
          this.controller_.rackController.rack.find(ne).forEach(e => {
            e.binding.read();
          }), this.controller_.rackController.rack.find(ie).forEach(e => {
            e.binding.read();
          });
        }

      }

      class Ai extends ve {
        constructor(e, t) {
          super(e, {
            expanded: t.expanded,
            blade: t.blade,
            props: t.props,
            root: !0,
            viewProps: t.viewProps
          });
        }

      }

      const Ci = {
        id: "slider",
        type: "blade",

        accept(e) {
          const t = R,
                n = k(e, {
            max: t.required.number,
            min: t.required.number,
            view: t.required.constant("slider"),
            format: t.optional.function,
            label: t.optional.string,
            value: t.optional.number
          });
          return n ? {
            params: n
          } : null;
        },

        controller(e) {
          var t, n;
          const r = null !== (t = e.params.value) && void 0 !== t ? t : 0,
                i = new Zt(e.document, {
            baseStep: 1,
            parser: xt,
            sliderProps: E.fromObject({
              maxValue: e.params.max,
              minValue: e.params.min
            }),
            textProps: E.fromObject({
              draggingScale: an(void 0, r),
              formatter: null !== (n = e.params.format) && void 0 !== n ? n : wt
            }),
            value: T(r),
            viewProps: e.viewProps
          });
          return new xe(e.document, {
            blade: e.blade,
            props: E.fromObject({
              label: e.params.label
            }),
            valueController: i
          });
        },

        api: e => e.controller instanceof xe && e.controller.valueController instanceof Zt ? new Si(e.controller) : null
      },
            Ri = {
        id: "text",
        type: "blade",

        accept(e) {
          const t = R,
                n = k(e, {
            parse: t.required.function,
            value: t.required.raw,
            view: t.required.constant("text"),
            format: t.optional.function,
            label: t.optional.string
          });
          return n ? {
            params: n
          } : null;
        },

        controller(e) {
          var t;
          const n = new et(e.document, {
            parser: e.params.parse,
            props: E.fromObject({
              formatter: null !== (t = e.params.format) && void 0 !== t ? t : e => String(e)
            }),
            value: T(e.params.value),
            viewProps: e.viewProps
          });
          return new xe(e.document, {
            blade: e.blade,
            props: E.fromObject({
              label: e.params.label
            }),
            valueController: n
          });
        },

        api: e => e.controller instanceof xe && e.controller.valueController instanceof et ? new Mi(e.controller) : null
      };

      function ki(e, t, n) {
        if (e.querySelector(`style[data-tp-style=${t}]`)) return;
        const r = e.createElement("style");
        r.dataset.tpStyle = t, r.textContent = n, e.head.appendChild(r);
      }

      const Pi = new class {
        constructor(e) {
          const [t, n] = e.split("-"),
                r = t.split(".");
          this.major = parseInt(r[0], 10), this.minor = parseInt(r[1], 10), this.patch = parseInt(r[2], 10), this.prerelease = null != n ? n : null;
        }

        toString() {
          const e = [this.major, this.minor, this.patch].join(".");
          return null !== this.prerelease ? [e, this.prerelease].join("-") : e;
        }

      }("3.0.8");
      e.BladeApi = t, e.ButtonApi = p, e.FolderApi = ce, e.InputBindingApi = te, e.ListApi = wi, e.MonitorBindingApi = re, e.Pane = class extends Ei {
        constructor(e) {
          var t;

          const n = e || {},
                r = null !== (t = n.document) && void 0 !== t ? t : N(),
                i = function () {
            const e = new yi();
            return [zr, qr, ei, ti, Mr, gr, mr, _r, pn, ci, gi, mi, X, be, Te, Ue].forEach(t => {
              e.register(t);
            }), e;
          }();

          super(new Ai(r, {
            expanded: n.expanded,
            blade: Y(),
            props: E.fromObject({
              title: n.title
            }),
            viewProps: Ce.create()
          }), i), this.pool_ = i, this.containerElem_ = n.container || function (e) {
            const t = e.createElement("div");
            return t.classList.add(f("dfw")()), e.body && e.body.appendChild(t), t;
          }(r), this.containerElem_.appendChild(this.element), this.doc_ = r, this.usesDefaultWrapper_ = !n.container, this.setUpDefaultPlugins_();
        }

        get document() {
          if (!this.doc_) throw c.alreadyDisposed();
          return this.doc_;
        }

        dispose() {
          const e = this.containerElem_;
          if (!e) throw c.alreadyDisposed();

          if (this.usesDefaultWrapper_) {
            const t = e.parentElement;
            t && t.removeChild(e);
          }

          this.containerElem_ = null, this.doc_ = null, super.dispose();
        }

        registerPlugin(e) {
          ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach(e => {
            this.pool_.register(e), this.embedPluginStyle_(e);
          });
        }

        embedPluginStyle_(e) {
          e.css && ki(this.document, `plugin-${e.id}`, e.css);
        }

        setUpDefaultPlugins_() {
          ki(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach(e => {
            this.embedPluginStyle_(e);
          }), this.registerPlugin({
            plugins: [Ci, Ti, Ue, Ri]
          });
        }

      }, e.SeparatorApi = ye, e.SliderApi = Si, e.TabApi = Le, e.TabPageApi = Oe, e.TextApi = Mi, e.TpChangeEvent = r, e.VERSION = Pi, Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }(t);
  },
  23: function (__unused_webpack_module, __webpackgi_exports__, __webpackgi_require__) {
    __webpackgi_require__.d(__webpackgi_exports__, {
      Q: function () {
        return DRACOLoader2;
      }
    });

    var three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpackgi_require__(365),
        three__WEBPACK_IMPORTED_MODULE_1__ = __webpackgi_require__(927);

    class DRACOLoader2 extends three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__._ {
      constructor(e) {
        super(e), this.encoderPending = null, this.encoderConfig = {
          type: "js"
        }, this.setDecoderPath("https://cdn.jsdelivr.net/gh/google/draco@1.4.1/javascript/"), this.setDecoderConfig({
          type: "js"
        });
      }

      async loadAsync(e, t) {
        const n = await super.loadAsync(e, t);
        return n ? new three__WEBPACK_IMPORTED_MODULE_1__.Kj0(n, new three__WEBPACK_IMPORTED_MODULE_1__.Wid()) : void 0;
      }

      preload(e = !0, t = !1) {
        return e && super.preload(), t && this.initEncoder(), this;
      }

      async initEncoder() {
        if (this.encoderPending) return this.encoderPending;

        const useJS = "object" != typeof WebAssembly || "js" === this.encoderConfig.type,
              librariesPending = [],
              libLoader = this._loadLibrary.bind(this);

        return useJS ? librariesPending.push(libLoader("draco_encoder.js", "text")) : (librariesPending.push(libLoader("draco_wasm_wrapper.js", "text")), librariesPending.push(libLoader("draco_encoder.wasm", "arraybuffer"))), this.encoderPending = Promise.all(librariesPending).then(libraries => {
          var _a;

          const jsContent = libraries[0];
          return useJS || (this.encoderConfig.wasmBinary = libraries[1]), null === (_a = eval(jsContent + "\nDracoEncoderModule;")) || void 0 === _a ? void 0 : _a();
        }), this.encoderPending;
      }

      async initDecoder() {
        var _a;

        await this._initDecoder();
        const jsContent = await fetch(this.workerSourceURL).then(async e => e.text()).then(e => {
          const t = e.indexOf("/* worker */");
          if (t < 1) throw new Error("unable to load decoder module");
          return e.substring(0, t - 1);
        });
        return null === (_a = eval(jsContent + "\nDracoDecoderModule;")) || void 0 === _a ? void 0 : _a();
      }

    }
  }
},
    __webpackgi_module_cache__ = {};

function __webpackgi_require__(e) {
  var t = __webpackgi_module_cache__[e];
  if (void 0 !== t) return t.exports;
  var n = __webpackgi_module_cache__[e] = {
    id: e,
    exports: {}
  };
  return __webpackgi_modules__[e].call(n.exports, n, n.exports, __webpackgi_require__), n.exports;
}

__webpackgi_require__.n = function (e) {
  var t = e && e.__esModule ? function () {
    return e.default;
  } : function () {
    return e;
  };
  return __webpackgi_require__.d(t, {
    a: t
  }), t;
}, __webpackgi_require__.d = function (e, t) {
  for (var n in t) __webpackgi_require__.o(t, n) && !__webpackgi_require__.o(e, n) && Object.defineProperty(e, n, {
    enumerable: !0,
    get: t[n]
  });
}, __webpackgi_require__.o = function (e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}, __webpackgi_require__.r = function (e) {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
    value: "Module"
  }), Object.defineProperty(e, "__esModule", {
    value: !0
  });
};
var __webpackgi_exports__ = {};
!function () {
  __webpackgi_require__.d(__webpackgi_exports__, {
    LY2: function () {
      return i.LY2;
    },
    HRj: function () {
      return qt;
    },
    li4: function () {
      return rT;
    },
    FO5: function () {
      return iT;
    },
    Nlh: function () {
      return $M;
    },
    QvI: function () {
      return zs;
    },
    JHp: function () {
      return ao;
    },
    bGH: function () {
      return i.bGH;
    },
    NDo: function () {
      return i.NDo;
    },
    gSk: function () {
      return i.gSk;
    },
    WMw: function () {
      return i.WMw;
    },
    OTo: function () {
      return i.OTo;
    },
    Se2: function () {
      return i.Se2;
    },
    cum: function () {
      return i.cum;
    },
    Mig: function () {
      return i.Mig;
    },
    B$7: function () {
      return Is;
    },
    i_9: function () {
      return i.i_9;
    },
    m7l: function () {
      return i.m7l;
    },
    sYA: function () {
      return i.sYA;
    },
    Xcj: function () {
      return i.Xcj;
    },
    mzJ: function () {
      return i.mzJ;
    },
    ZZA: function () {
      return i.ZZA;
    },
    $Ph: function () {
      return tu;
    },
    T__: function () {
      return i.T__;
    },
    HkE: function () {
      return i.HkE;
    },
    tGC: function () {
      return i.tGC;
    },
    g1S: function () {
      return Vx;
    },
    I$C: function () {
      return Zx;
    },
    QIH: function () {
      return Fs;
    },
    _JE: function () {
      return Vm;
    },
    ksm: function () {
      return js;
    },
    jl_: function () {
      return Ui;
    },
    b7R: function () {
      return es;
    },
    BDV: function () {
      return ki;
    },
    Ea_: function () {
      return Vi;
    },
    qff: function () {
      return Ui;
    },
    tmC: function () {
      return Li;
    },
    BON: function () {
      return As;
    },
    P40: function () {
      return Zi;
    },
    wLL: function () {
      return ys;
    },
    iHO: function () {
      return Ki;
    },
    BbS: function () {
      return i.BbS;
    },
    kqm: function () {
      return i.kqm;
    },
    Hmr: function () {
      return i.Hmr;
    },
    SJI: function () {
      return i.SJI;
    },
    mTL: function () {
      return i.mTL;
    },
    y8_: function () {
      return i.y8_;
    },
    _Li: function () {
      return i._Li;
    },
    g56: function () {
      return Xc;
    },
    bj3: function () {
      return Y;
    },
    z81: function () {
      return i.z81;
    },
    _MY: function () {
      return i._MY;
    },
    yEv: function () {
      return _x;
    },
    dFZ: function () {
      return Qc;
    },
    N$j: function () {
      return i.N$j;
    },
    _YM: function () {
      return i._YM;
    },
    TUj: function () {
      return i.TUj;
    },
    ZzF: function () {
      return i.ZzF;
    },
    qzb: function () {
      return P;
    },
    GQ: function () {
      return i.GQ;
    },
    nvb: function () {
      return i.nvb;
    },
    DvJ: function () {
      return i.DvJ;
    },
    fQA: function () {
      return i.fQA;
    },
    cPz: function () {
      return Aa;
    },
    TlE: function () {
      return i.TlE;
    },
    u9r: function () {
      return i.u9r;
    },
    s4_: function () {
      return i.s4_;
    },
    T95: function () {
      return i.T95;
    },
    CtF: function () {
      return i.CtF;
    },
    V1s: function () {
      return i.V1s;
    },
    jOv: function () {
      return nt;
    },
    Rki: function () {
      return i.Rki;
    },
    itZ: function () {
      return Iu;
    },
    qKx: function () {
      return Fu;
    },
    vlJ: function () {
      return lT;
    },
    nPO: function () {
      return uT;
    },
    zcQ: function () {
      return ku;
    },
    GH1: function () {
      return Du;
    },
    ROQ: function () {
      return i.ROQ;
    },
    YN5: function () {
      return i.YN5;
    },
    BVQ: function () {
      return i.BVQ;
    },
    YT8: function () {
      return i.YT8;
    },
    YGz: function () {
      return i.YGz;
    },
    trn: function () {
      return i.trn;
    },
    zf8: function () {
      return i.zf8;
    },
    uWy: function () {
      return i.uWy;
    },
    SUY: function () {
      return i.SUY;
    },
    Ilk: function () {
      return i.Ilk;
    },
    R2R: function () {
      return i.R2R;
    },
    epp: function () {
      return i.epp;
    },
    GD$: function () {
      return Ni;
    },
    EB7: function () {
      return i.EB7;
    },
    DqL: function () {
      return i.DqL;
    },
    _3: function () {
      return i._3;
    },
    b_z: function () {
      return i.b_z;
    },
    OCn: function () {
      return fT;
    },
    _am: function () {
      return i._am;
    },
    kB7: function () {
      return Oo;
    },
    fY$: function () {
      return i.fY$;
    },
    vxC: function () {
      return i.vxC;
    },
    BtG: function () {
      return i.BtG;
    },
    cBK: function () {
      return i.cBK;
    },
    g8_: function () {
      return i.g8_;
    },
    AXT: function () {
      return i.AXT;
    },
    yj7: function () {
      return i.yj7;
    },
    dYG: function () {
      return i.dYG;
    },
    tm_: function () {
      return i.tm_;
    },
    S2y: function () {
      return i.S2y;
    },
    B02: function () {
      return i.B02;
    },
    PeU: function () {
      return i.PeU;
    },
    Hyl: function () {
      return i.Hyl;
    },
    Wqd: function () {
      return i.Wqd;
    },
    Xaj: function () {
      return i.Xaj;
    },
    DUb: function () {
      return mu;
    },
    dZ3: function () {
      return i.dZ3;
    },
    m_w: function () {
      return i.m_w;
    },
    fHI: function () {
      return i.fHI;
    },
    LBq: function () {
      return i.LBq;
    },
    dHf: function () {
      return YM;
    },
    Qww: function () {
      return ur.Q;
    },
    CGV: function () {
      return ZM;
    },
    JUT: function () {
      return i.JUT;
    },
    p3g: function () {
      return i.p3g;
    },
    IEO: function () {
      return i.IEO;
    },
    CN8: function () {
      return i.CN8;
    },
    zob: function () {
      return i.zob;
    },
    yxD: function () {
      return i.yxD;
    },
    CUS: function () {
      return mx;
    },
    A5E: function () {
      return i.A5E;
    },
    zqG: function () {
      return Ac;
    },
    PfX: function () {
      return ls;
    },
    Q1o: function () {
      return Qi;
    },
    jfJ: function () {
      return i.jfJ;
    },
    T_J: function () {
      return i.T_J;
    },
    tEQ: function () {
      return i.tEQ;
    },
    gb4: function () {
      return Ri;
    },
    qkB: function () {
      return i.qkB;
    },
    cvk: function () {
      return Ju;
    },
    HWo: function () {
      return Qu;
    },
    brP: function () {
      return i.brP;
    },
    $YQ: function () {
      return i.$YQ;
    },
    yNB: function () {
      return Uo;
    },
    h7x: function () {
      return xc;
    },
    Ox3: function () {
      return i.Ox3;
    },
    qtn: function () {
      return Os;
    },
    cBI: function () {
      return i.cBI;
    },
    cU9: function () {
      return i.cU9;
    },
    DT1: function () {
      return i.DT1;
    },
    Kgo: function () {
      return i.Kgo;
    },
    ehD: function () {
      return i.ehD;
    },
    fhJ: function () {
      return so;
    },
    y1s: function () {
      return oo;
    },
    fSK: function () {
      return i.fSK;
    },
    Vdb: function () {
      return i.Vdb;
    },
    l8J: function () {
      return i.l8J;
    },
    dj0: function () {
      return i.dj0;
    },
    QM0: function () {
      return i.QM0;
    },
    OIS: function () {
      return gb;
    },
    q8b: function () {
      return cc;
    },
    TOt: function () {
      return i.TOt;
    },
    xaN: function () {
      return f;
    },
    Ny0: function () {
      return i.Ny0;
    },
    Zof: function () {
      return cs;
    },
    eD: function () {
      return i.eD;
    },
    jwo: function () {
      return i.jwo;
    },
    dSO: function () {
      return i.dSO;
    },
    Bf4: function () {
      return i.Bf4;
    },
    USm: function () {
      return i.USm;
    },
    pBf: function () {
      return i.pBf;
    },
    $Vf: function () {
      return i.$Vf;
    },
    O7d: function () {
      return i.O7d;
    },
    ksq: function () {
      return Gb;
    },
    gXf: function () {
      return Bc;
    },
    hH6: function () {
      return i.hH6;
    },
    esl: function () {
      return i.esl;
    },
    e62: function () {
      return i.e62;
    },
    a$l: function () {
      return i.a$l;
    },
    OM3: function () {
      return i.OM3;
    },
    VzW: function () {
      return i.VzW;
    },
    ybr: function () {
      return i.ybr;
    },
    yo9: function () {
      return i.yo9;
    },
    Zxw: function () {
      return i.Zxw;
    },
    JfN: function () {
      return i.JfN;
    },
    $Bt: function () {
      return _c;
    },
    Wzm: function () {
      return i.Wzm;
    },
    Wl3: function () {
      return i.Wl3;
    },
    iWj: function () {
      return i.iWj;
    },
    DNz: function () {
      return io;
    },
    m1M: function () {
      return Xs;
    },
    ylh: function () {
      return i.ylh;
    },
    v9Y: function () {
      return i.v9Y;
    },
    LSk: function () {
      return i.LSk;
    },
    LHE: function () {
      return Mc;
    },
    KE0: function () {
      return RM;
    },
    KCF: function () {
      return CM;
    },
    a4n: function () {
      return zx;
    },
    zIH: function () {
      return Kn;
    },
    Hfk: function () {
      return sr;
    },
    png: function () {
      return ir;
    },
    Eb_: function () {
      return or;
    },
    BT2: function () {
      return Yb;
    },
    _8p: function () {
      return jx;
    },
    hkn: function () {
      return Nt;
    },
    GFY: function () {
      return Gs;
    },
    w$m: function () {
      return i.w$m;
    },
    ksN: function () {
      return i.ksN;
    },
    j4z: function () {
      return i.j4z;
    },
    OAl: function () {
      return i.OAl;
    },
    VLJ: function () {
      return i.VLJ;
    },
    C73: function () {
      return Yc;
    },
    ZAu: function () {
      return i.ZAu;
    },
    ibP: function () {
      return zi;
    },
    _fI: function () {
      return Ni;
    },
    hUN: function () {
      return Xu;
    },
    cLu: function () {
      return i.cLu;
    },
    vmT: function () {
      return i.vmT;
    },
    Qpg: function () {
      return i.Qpg;
    },
    So8: function () {
      return i.So8;
    },
    eOv: function () {
      return XC;
    },
    Wjw: function () {
      return i.Wjw;
    },
    cJO: function () {
      return i.cJO;
    },
    QRU: function () {
      return i.QRU;
    },
    S3k: function () {
      return i.S3k;
    },
    PpQ: function () {
      return i.PpQ;
    },
    AHu: function () {
      return i.AHu;
    },
    q_9: function () {
      return Zt;
    },
    ZRs: function () {
      return i.ZRs;
    },
    oqc: function () {
      return i.oqc;
    },
    T_x: function () {
      return Oi;
    },
    lb7: function () {
      return i.lb7;
    },
    L5s: function () {
      return i.L5s;
    },
    $TI: function () {
      return i.$TI;
    },
    SPe: function () {
      return i.SPe;
    },
    aVm: function () {
      return i.aVm;
    },
    j87: function () {
      return i.j87;
    },
    RNb: function () {
      return i.RNb;
    },
    Kz5: function () {
      return i.Kz5;
    },
    vpT: function () {
      return i.vpT;
    },
    kB5: function () {
      return i.kB5;
    },
    _C8: function () {
      return i._C8;
    },
    Syv: function () {
      return i.Syv;
    },
    NMF: function () {
      return i.NMF;
    },
    pIN: function () {
      return i.pIN;
    },
    eMJ: function () {
      return i.eMJ;
    },
    rN7: function () {
      return hm;
    },
    iUp: function () {
      return dm;
    },
    GFd: function () {
      return fx;
    },
    x5V: function () {
      return i.x5V;
    },
    tUh: function () {
      return i.tUh;
    },
    z8B: function () {
      return i.z8B;
    },
    GZb: function () {
      return i.GZb;
    },
    p7y: function () {
      return i.p7y;
    },
    S9g: function () {
      return i.S9g;
    },
    Zr5: function () {
      return i.Zr5;
    },
    vCF: function () {
      return i.vCF;
    },
    yt0: function () {
      return i.yt0;
    },
    uXU: function () {
      return i.uXU;
    },
    _kC: function () {
      return i._kC;
    },
    lk7: function () {
      return i.lk7;
    },
    x12: function () {
      return i.x12;
    },
    Zzh: function () {
      return i.Zzh;
    },
    nls: function () {
      return i.nls;
    },
    g_z: function () {
      return i.g_z;
    },
    U7: function () {
      return i.U7;
    },
    FT0: function () {
      return i.FT0;
    },
    blk: function () {
      return i.blk;
    },
    ejS: function () {
      return i.ejS;
    },
    rnI: function () {
      return i.rnI;
    },
    wem: function () {
      return i.wem;
    },
    lfu: function () {
      return i.lfu;
    },
    FDw: function () {
      return i.FDw;
    },
    lRj: function () {
      return i.lRj;
    },
    D1R: function () {
      return i.D1R;
    },
    qyh: function () {
      return i.qyh;
    },
    GUF: function () {
      return i.GUF;
    },
    EoG: function () {
      return i.EoG;
    },
    aNw: function () {
      return i.aNw;
    },
    Zp0: function () {
      return i.Zp0;
    },
    lLk: function () {
      return i.lLk;
    },
    jAl: function () {
      return i.jAl;
    },
    uEv: function () {
      return i.uEv;
    },
    YKA: function () {
      return i.YKA;
    },
    cRx: function () {
      return i.cRx;
    },
    Y8D: function () {
      return i.Y8D;
    },
    RsA: function () {
      return i.RsA;
    },
    Y0m: function () {
      return $b;
    },
    F5T: function () {
      return i.F5T;
    },
    EDU: function () {
      return vT;
    },
    z$Q: function () {
      return BA;
    },
    KA8: function () {
      return jt;
    },
    XUj: function () {
      return jA;
    },
    Me$: function () {
      return zA;
    },
    u7G: function () {
      return i.u7G;
    },
    PEk: function () {
      return Yt;
    },
    BG4: function () {
      return gT;
    },
    M8C: function () {
      return i.M8C;
    },
    Vkp: function () {
      return i.Vkp;
    },
    yGw: function () {
      return i.yGw;
    },
    Sm8: function () {
      return i.Sm8;
    },
    Kj0: function () {
      return i.Kj0;
    },
    vBJ: function () {
      return i.vBJ;
    },
    lRF: function () {
      return i.lRF;
    },
    Lun: function () {
      return i.Lun;
    },
    YBo: function () {
      return i.YBo;
    },
    kaV: function () {
      return i.kaV;
    },
    RSm: function () {
      return i.RSm;
    },
    xoR: function () {
      return i.xoR;
    },
    EJi: function () {
      return i.EJi;
    },
    Wid: function () {
      return i.Wid;
    },
    iuj: function () {
      return Ht;
    },
    IKL: function () {
      return i.IKL;
    },
    r_: function () {
      return i.r_;
    },
    OoA: function () {
      return i.OoA;
    },
    qhX: function () {
      return i.qhX;
    },
    qPT: function () {
      return lo;
    },
    M5h: function () {
      return i.M5h;
    },
    Ns1: function () {
      return i.Ns1;
    },
    TyD: function () {
      return i.TyD;
    },
    vZf: function () {
      return i.vZf;
    },
    HTd: function () {
      return i.HTd;
    },
    aH4: function () {
      return i.aH4;
    },
    YLQ: function () {
      return i.YLQ;
    },
    BVF: function () {
      return i.BVF;
    },
    MyG: function () {
      return i.MyG;
    },
    jFi: function () {
      return i.jFi;
    },
    aCh: function () {
      return i.aCh;
    },
    uL9: function () {
      return i.uL9;
    },
    TNj: function () {
      return uu;
    },
    IFH: function () {
      return i.IFH;
    },
    bdR: function () {
      return i.bdR;
    },
    kM_: function () {
      return Lo;
    },
    M6v: function () {
      return i.M6v;
    },
    RvT: function () {
      return i.RvT;
    },
    dUE: function () {
      return i.dUE;
    },
    oe_: function () {
      return ux;
    },
    BuN: function () {
      return px;
    },
    Tme: function () {
      return i.Tme;
    },
    N9P: function () {
      return st;
    },
    Gql: function () {
      return i.Gql;
    },
    $XY: function () {
      return qn;
    },
    O9d: function () {
      return Bo;
    },
    zEO: function () {
      return rt;
    },
    qfx: function () {
      return KA;
    },
    PA7: function () {
      return i.PA7;
    },
    REq: function () {
      return i.REq;
    },
    pQR: function () {
      return i.pQR;
    },
    ghN: function () {
      return i.ghN;
    },
    Hy8: function () {
      return i.Hy8;
    },
    Wpd: function () {
      return i.Wpd;
    },
    LgZ: function () {
      return i.LgZ;
    },
    iWC: function () {
      return i.iWC;
    },
    mqn: function () {
      return oR;
    },
    iKG: function () {
      return i.iKG;
    },
    _iA: function () {
      return i._iA;
    },
    ntZ: function () {
      return i.ntZ;
    },
    anP: function () {
      return i.anP;
    },
    X2e: function () {
      return XM;
    },
    FCo: function () {
      return YA;
    },
    jjw: function () {
      return i.jjw;
    },
    y$t: function () {
      return i.y$t;
    },
    cPb: function () {
      return i.cPb;
    },
    lmx: function () {
      return gc;
    },
    JOQ: function () {
      return i.JOQ;
    },
    BKK: function () {
      return i.BKK;
    },
    _12: function () {
      return i._12;
    },
    tJx: function () {
      return i.tJx;
    },
    cek: function () {
      return i.cek;
    },
    xG9: function () {
      return i.xG9;
    },
    woe: function () {
      return i.woe;
    },
    UY4: function () {
      return i.UY4;
    },
    aq0: function () {
      return i.aq0;
    },
    ujx: function () {
      return i.ujx;
    },
    Uol: function () {
      return i.Uol;
    },
    JiH: function () {
      return nC;
    },
    VYz: function () {
      return i.VYz;
    },
    EsW: function () {
      return po;
    },
    iUV: function () {
      return i.iUV;
    },
    tf: function () {
      return i.tf;
    },
    ZQ6: function () {
      return i.ZQ6;
    },
    mXe: function () {
      return i.mXe;
    },
    _fP: function () {
      return i._fP;
    },
    iLg: function () {
      return i.iLg;
    },
    zbs: function () {
      return i.zbs;
    },
    UZH: function () {
      return i.UZH;
    },
    mSO: function () {
      return i.mSO;
    },
    wk1: function () {
      return i.wk1;
    },
    E2K: function () {
      return i.E2K;
    },
    FUD: function () {
      return i.FUD;
    },
    pKu: function () {
      return i.pKu;
    },
    GG6: function () {
      return i.GG6;
    },
    Gih: function () {
      return i.Gih;
    },
    iiP: function () {
      return i.iiP;
    },
    SvJ: function () {
      return i.SvJ;
    },
    ptH: function () {
      return i.ptH;
    },
    jZA: function () {
      return i.jZA;
    },
    y2t: function () {
      return i.y2t;
    },
    gi4: function () {
      return i.gi4;
    },
    Djp: function () {
      return i.Djp;
    },
    BG$: function () {
      return i.BG$;
    },
    NYV: function () {
      return i.NYV;
    },
    xJs: function () {
      return i.xJs;
    },
    bsb: function () {
      return i.bsb;
    },
    ekQ: function () {
      return i.ekQ;
    },
    CaW: function () {
      return i.CaW;
    },
    eaV: function () {
      return i.eaV;
    },
    BFQ: function () {
      return i.BFQ;
    },
    v3W: function () {
      return i.v3W;
    },
    ILR: function () {
      return i.ILR;
    },
    UCm: function () {
      return i.UCm;
    },
    Inb: function () {
      return i.Inb;
    },
    LgE: function () {
      return i.LgE;
    },
    fto: function () {
      return i.fto;
    },
    l0P: function () {
      return i.l0P;
    },
    vCx: function () {
      return i.vCx;
    },
    _AM: function () {
      return i._AM;
    },
    wuA: function () {
      return i.wuA;
    },
    av9: function () {
      return i.av9;
    },
    CtA: function () {
      return i.CtA;
    },
    BvQ: function () {
      return Nc;
    },
    FZJ: function () {
      return Hu;
    },
    FIo: function () {
      return i.FIo;
    },
    zHn: function () {
      return i.zHn;
    },
    iMs: function () {
      return i.iMs;
    },
    T_f: function () {
      return i.T_f;
    },
    hEm: function () {
      return i.hEm;
    },
    D9w: function () {
      return i.D9w;
    },
    sHH: function () {
      return Wc;
    },
    CdI: function () {
      return i.CdI;
    },
    rpg: function () {
      return i.rpg;
    },
    ce8: function () {
      return i.ce8;
    },
    rOj: function () {
      return i.rOj;
    },
    P6m: function () {
      return qb;
    },
    JA6: function () {
      return Xb;
    },
    V4E: function () {
      return i.V4E;
    },
    o8S: function () {
      return i.o8S;
    },
    flB: function () {
      return ft;
    },
    DUH: function () {
      return qM;
    },
    KI_: function () {
      return i.KI_;
    },
    iLN: function () {
      return Do;
    },
    jsw: function () {
      return np;
    },
    i6Z: function () {
      return Ao;
    },
    vfv: function () {
      return Jb;
    },
    xsS: function () {
      return i.xsS;
    },
    ov0: function () {
      return Ea;
    },
    cQH: function () {
      return tt;
    },
    WdD: function () {
      return i.WdD;
    },
    Vj0: function () {
      return i.Vj0;
    },
    jyz: function () {
      return i.jyz;
    },
    Mn1: function () {
      return Ot;
    },
    Hlq: function () {
      return It;
    },
    Fi7: function () {
      return Vc;
    },
    Tn7: function () {
      return i.Tn7;
    },
    bnF: function () {
      return i.bnF;
    },
    HW6: function () {
      return i.HW6;
    },
    oa8: function () {
      return i.oa8;
    },
    T_1: function () {
      return i.T_1;
    },
    zHJ: function () {
      return eC;
    },
    iDF: function () {
      return i.iDF;
    },
    iAb: function () {
      return i.iAb;
    },
    d4E: function () {
      return Xm;
    },
    lBg: function () {
      return GC;
    },
    JeJ: function () {
      return qm;
    },
    FKY: function () {
      return r;
    },
    zlZ: function () {
      return gx;
    },
    vkg: function () {
      return Qt;
    },
    brh: function () {
      return vx;
    },
    kZK: function () {
      return _C;
    },
    puG: function () {
      return HC;
    },
    OdW: function () {
      return i.OdW;
    },
    _YX: function () {
      return i._YX;
    },
    TUv: function () {
      return i.TUv;
    },
    wcA: function () {
      return i.wcA;
    },
    Hw6: function () {
      return i.Hw6;
    },
    aLr: function () {
      return i.aLr;
    },
    Aip: function () {
      return i.Aip;
    },
    xo$: function () {
      return i.xo$;
    },
    bIn: function () {
      return aR;
    },
    $V: function () {
      return i.$V;
    },
    lDi: function () {
      return i.lDi;
    },
    gti: function () {
      return i.gti;
    },
    PMe: function () {
      return i.PMe;
    },
    iwP: function () {
      return Ls;
    },
    FvO: function () {
      return i.FvO;
    },
    jyi: function () {
      return i.jyi;
    },
    xeV: function () {
      return i.xeV;
    },
    k74: function () {
      return i.k74;
    },
    RlZ: function () {
      return i.RlZ;
    },
    KhW: function () {
      return i.KhW;
    },
    HgB: function () {
      return i.HgB;
    },
    W2J: function () {
      return i.W2J;
    },
    JWc: function () {
      return i.JWc;
    },
    u37: function () {
      return i.u37;
    },
    Z6B: function () {
      return i.Z6B;
    },
    QZ1: function () {
      return i.QZ1;
    },
    Ir4: function () {
      return i.Ir4;
    },
    NwF: function () {
      return i.NwF;
    },
    Wbm: function () {
      return i.Wbm;
    },
    N4l: function () {
      return i.N4l;
    },
    ej9: function () {
      return ZA;
    },
    QmN: function () {
      return i.QmN;
    },
    IOt: function () {
      return i.IOt;
    },
    NOD: function () {
      return Ru;
    },
    L5g: function () {
      return i.L5g;
    },
    H$k: function () {
      return i.H$k;
    },
    MP$: function () {
      return i.MP$;
    },
    cuP: function () {
      return hC;
    },
    xEZ: function () {
      return i.xEZ;
    },
    dpR: function () {
      return i.dpR;
    },
    wOD: function () {
      return su;
    },
    KNb: function () {
      return Bs;
    },
    Rk2: function () {
      return _o;
    },
    IiN: function () {
      return mo;
    },
    Cne: function () {
      return i.Cne;
    },
    XvJ: function () {
      return i.XvJ;
    },
    XZw: function () {
      return i.XZw;
    },
    FE5: function () {
      return i.FE5;
    },
    lVp: function () {
      return vc;
    },
    CJI: function () {
      return i.CJI;
    },
    z$h: function () {
      return i.z$h;
    },
    UlW: function () {
      return i.UlW;
    },
    WwZ: function () {
      return i.WwZ;
    },
    Lcc: function () {
      return i.Lcc;
    },
    WXh: function () {
      return i.WXh;
    },
    Vjr: function () {
      return JA;
    },
    LuM: function () {
      return VC;
    },
    LP5: function () {
      return AC;
    },
    xfE: function () {
      return i.xfE;
    },
    qlB: function () {
      return i.qlB;
    },
    lCJ: function () {
      return i.lCJ;
    },
    WTc: function () {
      return i.WTc;
    },
    rAo: function () {
      return i.rAo;
    },
    LZj: function () {
      return fo;
    },
    xWb: function () {
      return i.xWb;
    },
    gH0: function () {
      return i.gH0;
    },
    rBU: function () {
      return i.rBU;
    },
    rDY: function () {
      return i.rDY;
    },
    ywz: function () {
      return i.ywz;
    },
    wJv: function () {
      return i.wJv;
    },
    JQ4: function () {
      return i.JQ4;
    },
    k0A: function () {
      return i.k0A;
    },
    irR: function () {
      return i.irR;
    },
    LsT: function () {
      return i.LsT;
    },
    q5h: function () {
      return Cs;
    },
    TKh: function () {
      return Es;
    },
    tyg: function () {
      return Ts;
    },
    Ro5: function () {
      return Yi;
    },
    dwk: function () {
      return i.dwk;
    },
    FM8: function () {
      return i.FM8;
    },
    Pa4: function () {
      return i.Pa4;
    },
    Ltg: function () {
      return i.Ltg;
    },
    yC1: function () {
      return i.yC1;
    },
    lHq: function () {
      return Au;
    },
    fO1: function () {
      return i.fO1;
    },
    oMA: function () {
      return to;
    },
    JzW: function () {
      return t;
    },
    b5g: function () {
      return i.b5g;
    },
    Ywn: function () {
      return i.Ywn;
    },
    GVz: function () {
      return i.GVz;
    },
    oAp: function () {
      return i.oAp;
    },
    kFz: function () {
      return i.kFz;
    },
    p7A: function () {
      return i.p7A;
    },
    dd2: function () {
      return i.dd2;
    },
    CP7: function () {
      return i.CP7;
    },
    fQK: function () {
      return i.fQK;
    },
    Wd$: function () {
      return Km;
    },
    Uk6: function () {
      return i.Uk6;
    },
    _sL: function () {
      return i._sL;
    },
    Pnf: function () {
      return i.Pnf;
    },
    c8b: function () {
      return i.c8b;
    },
    _lf: function () {
      return i._lf;
    },
    ad5: function () {
      return i.ad5;
    },
    sZV: function () {
      return ws;
    },
    TfA: function () {
      return xs;
    },
    sKX: function () {
      return Ps;
    },
    UdM: function () {
      return bs;
    },
    P0y: function () {
      return Wi;
    },
    L_r: function () {
      return i.L_r;
    },
    Bve: function () {
      return Gm;
    },
    UeO: function () {
      return pr;
    },
    $nx: function () {
      return Gx;
    },
    Bk6: function () {
      return Zn;
    },
    y4l: function () {
      return tn;
    },
    pQ0: function () {
      return Ds;
    },
    wXW: function () {
      return hE;
    },
    r5x: function () {
      return cE;
    },
    MSI: function () {
      return _E;
    },
    jtH: function () {
      return lc;
    },
    T0T: function () {
      return fc;
    },
    gAb: function () {
      return uR;
    },
    iwT: function () {
      return Nu;
    },
    je_: function () {
      return pR;
    },
    wBP: function () {
      return dc;
    },
    Zs7: function () {
      return OE;
    },
    x7s: function () {
      return qE;
    },
    d73: function () {
      return JT;
    },
    RG9: function () {
      return X;
    },
    mvg: function () {
      return $T;
    },
    XMc: function () {
      return uE;
    },
    N7M: function () {
      return aE;
    },
    iv: function () {
      return dE;
    },
    n55: function () {
      return vt;
    },
    IaC: function () {
      return qT;
    },
    $MY: function () {
      return $s;
    },
    wJl: function () {
      return Zs;
    },
    zVI: function () {
      return tE;
    },
    DpF: function () {
      return Yu;
    },
    nNb: function () {
      return Bi;
    },
    cqZ: function () {
      return ji;
    },
    KlC: function () {
      return Io;
    },
    KVn: function () {
      return L;
    },
    oau: function () {
      return DE;
    },
    aw9: function () {
      return Kt;
    },
    leS: function () {
      return ut;
    },
    Dxg: function () {
      return y;
    },
    O5A: function () {
      return _t;
    },
    wCn: function () {
      return yt;
    },
    Bi6: function () {
      return wt;
    },
    fi_: function () {
      return $E;
    },
    TT: function () {
      return wE;
    },
    q2Z: function () {
      return qC;
    },
    NyK: function () {
      return Z;
    },
    bgu: function () {
      return Mt;
    },
    kcS: function () {
      return St;
    },
    ivY: function () {
      return T;
    },
    _HO: function () {
      return H;
    },
    tpL: function () {
      return W;
    },
    LjN: function () {
      return ts;
    },
    iFs: function () {
      return ns;
    },
    qTg: function () {
      return v;
    },
    Wtl: function () {
      return Pi;
    },
    DmK: function () {
      return Di;
    },
    Hx7: function () {
      return Te;
    },
    imt: function () {
      return Se;
    },
    US6: function () {
      return HE;
    },
    vZs: function () {
      return Fo;
    },
    lmu: function () {
      return gt;
    },
    SvO: function () {
      return bt;
    },
    omp: function () {
      return iC;
    },
    utz: function () {
      return eE;
    },
    TFV: function () {
      return no;
    },
    hrz: function () {
      return w;
    },
    JKM: function () {
      return ME;
    },
    jZf: function () {
      return lR;
    },
    RjL: function () {
      return CC;
    },
    RRI: function () {
      return WE;
    },
    RUq: function () {
      return dC;
    },
    _t4: function () {
      return Je;
    },
    YHh: function () {
      return $e;
    },
    R8g: function () {
      return I;
    },
    Bbl: function () {
      return $t;
    },
    V9r: function () {
      return b;
    },
    PZ2: function () {
      return x;
    },
    w7A: function () {
      return _;
    },
    N6S: function () {
      return U;
    },
    Uxp: function () {
      return B;
    },
    tAz: function () {
      return N;
    },
    R$F: function () {
      return z;
    },
    N33: function () {
      return j;
    },
    gw2: function () {
      return Ns;
    },
    KlU: function () {
      return F;
    },
    wo6: function () {
      return Rt;
    },
    H4P: function () {
      return M;
    },
    swA: function () {
      return Gi;
    },
    _Z3: function () {
      return Hi;
    },
    ivc: function () {
      return Bi;
    },
    rZ1: function () {
      return ji;
    },
    CpZ: function () {
      return JE;
    },
    dyc: function () {
      return E;
    },
    MxZ: function () {
      return oC;
    },
    btp: function () {
      return aC;
    },
    mXy: function () {
      return sC;
    },
    Ej0: function () {
      return lt;
    },
    ep4: function () {
      return Wt;
    },
    DQP: function () {
      return ct;
    },
    V7q: function () {
      return Tt;
    },
    zEk: function () {
      return Dt;
    },
    qfq: function () {
      return Et;
    },
    piB: function () {
      return R;
    },
    rrF: function () {
      return Ii;
    },
    naq: function () {
      return Fi;
    },
    p5I: function () {
      return hc;
    },
    GpE: function () {
      return m;
    },
    t$v: function () {
      return ZT;
    },
    tdn: function () {
      return Bu;
    },
    Y9t: function () {
      return ju;
    },
    DH3: function () {
      return pE;
    },
    uxM: function () {
      return bT;
    },
    zH3: function () {
      return xT;
    },
    MLs: function () {
      return Vs;
    },
    YM4: function () {
      return pc;
    },
    B3r: function () {
      return cR;
    },
    iAx: function () {
      return yT;
    },
    lDn: function () {
      return G;
    },
    TIc: function () {
      return Ct;
    },
    xsC: function () {
      return mE;
    },
    zOc: function () {
      return At;
    },
    r46: function () {
      return LE;
    },
    z2C: function () {
      return C;
    },
    _X$: function () {
      return Jt;
    },
    _yn: function () {
      return Lt;
    },
    Dyg: function () {
      return mt;
    },
    cUc: function () {
      return Gt;
    },
    Ctq: function () {
      return oE;
    },
    k5b: function () {
      return rE;
    },
    kZl: function () {
      return yE;
    },
    OCg: function () {
      return RE;
    },
    YjH: function () {
      return XE;
    },
    Ui8: function () {
      return bx;
    },
    ij3: function () {
      return lE;
    },
    YPW: function () {
      return iE;
    },
    Bg1: function () {
      return JC;
    },
    kon: function () {
      return S;
    },
    F2z: function () {
      return YT;
    },
    pJF: function () {
      return GA;
    },
    knz: function () {
      return i.knz;
    },
    Ejo: function () {
      return g;
    },
    BgY: function () {
      return Ae;
    },
    qCG: function () {
      return xe;
    },
    HD9: function () {
      return Me;
    },
    fEB: function () {
      return ye;
    },
    Udc: function () {
      return ht;
    },
    ZQg: function () {
      return pt;
    },
    ofC: function () {
      return K;
    },
    yRy: function () {
      return kt;
    },
    _NL: function () {
      return Hm;
    },
    LCA: function () {
      return at;
    },
    j1w: function () {
      return ot;
    },
    i8J: function () {
      return gR;
    },
    p7C: function () {
      return jc;
    },
    ZAS: function () {
      return Vu;
    },
    VWG: function () {
      return mT;
    },
    pQ7: function () {
      return Uu;
    },
    jc8: function () {
      return Vt;
    },
    BL_: function () {
      return QT;
    },
    T8U: function () {
      return ps;
    },
    TD6: function () {
      return us;
    },
    akS: function () {
      return wT;
    },
    QKE: function () {
      return ST;
    },
    dKx: function () {
      return A;
    },
    OvX: function () {
      return hR;
    },
    VsW: function () {
      return uc;
    },
    aPg: function () {
      return q;
    },
    LFn: function () {
      return Pt;
    },
    wey: function () {
      return XT;
    },
    MaE: function () {
      return Xe;
    },
    s4x: function () {
      return Ye;
    },
    FJA: function () {
      return ze;
    },
    vIA: function () {
      return Ke;
    },
    Spv: function () {
      return Qe;
    },
    w8l: function () {
      return Ze;
    },
    riG: function () {
      return qe;
    },
    Kbh: function () {
      return Ge;
    },
    t8K: function () {
      return He;
    },
    Q7n: function () {
      return Ve;
    },
    KGF: function () {
      return We;
    },
    e5: function () {
      return V;
    },
    Rik: function () {
      return Rs;
    },
    GZo: function () {
      return ks;
    },
    Bds: function () {
      return Ji;
    },
    HTu: function () {
      return $i;
    },
    cTq: function () {
      return xt;
    },
    X_Y: function () {
      return Js;
    },
    dA8: function () {
      return Ys;
    },
    bwS: function () {
      return sE;
    },
    P4F: function () {
      return aT;
    },
    Pd0: function () {
      return Yn;
    },
    Pjo: function () {
      return nE;
    },
    Tum: function () {
      return Jn;
    },
    dRH: function () {
      return Qn;
    },
    RX0: function () {
      return $n;
    },
    cWm: function () {
      return fE;
    },
    NC9: function () {
      return oT;
    },
    $Re: function () {
      return Ss;
    },
    Xo9: function () {
      return Ms;
    },
    LNO: function () {
      return Xi;
    },
    iZP: function () {
      return qi;
    }
  });

  var e = {};
  __webpackgi_require__.r(e), __webpackgi_require__.d(e, {
    KHR_DF_CHANNEL_RGBSDA_ALPHA: function () {
      return th;
    },
    KHR_DF_CHANNEL_RGBSDA_BLUE: function () {
      return $p;
    },
    KHR_DF_CHANNEL_RGBSDA_DEPTH: function () {
      return eh;
    },
    KHR_DF_CHANNEL_RGBSDA_GREEN: function () {
      return Jp;
    },
    KHR_DF_CHANNEL_RGBSDA_RED: function () {
      return Zp;
    },
    KHR_DF_CHANNEL_RGBSDA_STENCIL: function () {
      return Qp;
    },
    KHR_DF_FLAG_ALPHA_PREMULTIPLIED: function () {
      return vp;
    },
    KHR_DF_FLAG_ALPHA_STRAIGHT: function () {
      return gp;
    },
    KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT: function () {
      return lp;
    },
    KHR_DF_MODEL_ASTC: function () {
      return _p;
    },
    KHR_DF_MODEL_ETC1: function () {
      return dp;
    },
    KHR_DF_MODEL_ETC1S: function () {
      return mp;
    },
    KHR_DF_MODEL_ETC2: function () {
      return fp;
    },
    KHR_DF_MODEL_RGBSDA: function () {
      return hp;
    },
    KHR_DF_MODEL_UNSPECIFIED: function () {
      return pp;
    },
    KHR_DF_PRIMARIES_ACES: function () {
      return Hp;
    },
    KHR_DF_PRIMARIES_ACESCC: function () {
      return Wp;
    },
    KHR_DF_PRIMARIES_ADOBERGB: function () {
      return Yp;
    },
    KHR_DF_PRIMARIES_BT2020: function () {
      return Vp;
    },
    KHR_DF_PRIMARIES_BT601_EBU: function () {
      return jp;
    },
    KHR_DF_PRIMARIES_BT601_SMPTE: function () {
      return zp;
    },
    KHR_DF_PRIMARIES_BT709: function () {
      return Bp;
    },
    KHR_DF_PRIMARIES_CIEXYZ: function () {
      return Gp;
    },
    KHR_DF_PRIMARIES_DISPLAYP3: function () {
      return qp;
    },
    KHR_DF_PRIMARIES_NTSC1953: function () {
      return Kp;
    },
    KHR_DF_PRIMARIES_PAL525: function () {
      return Xp;
    },
    KHR_DF_PRIMARIES_UNSPECIFIED: function () {
      return Up;
    },
    KHR_DF_SAMPLE_DATATYPE_EXPONENT: function () {
      return ih;
    },
    KHR_DF_SAMPLE_DATATYPE_FLOAT: function () {
      return nh;
    },
    KHR_DF_SAMPLE_DATATYPE_LINEAR: function () {
      return sh;
    },
    KHR_DF_SAMPLE_DATATYPE_SIGNED: function () {
      return rh;
    },
    KHR_DF_TRANSFER_ACESCC: function () {
      return Ip;
    },
    KHR_DF_TRANSFER_ACESCCT: function () {
      return Fp;
    },
    KHR_DF_TRANSFER_ADOBERGB: function () {
      return Np;
    },
    KHR_DF_TRANSFER_BT1886: function () {
      return Ep;
    },
    KHR_DF_TRANSFER_DCIP3: function () {
      return Pp;
    },
    KHR_DF_TRANSFER_HLG_EOTF: function () {
      return Cp;
    },
    KHR_DF_TRANSFER_HLG_OETF: function () {
      return Ap;
    },
    KHR_DF_TRANSFER_ITU: function () {
      return wp;
    },
    KHR_DF_TRANSFER_LINEAR: function () {
      return xp;
    },
    KHR_DF_TRANSFER_NTSC: function () {
      return Sp;
    },
    KHR_DF_TRANSFER_PAL625_EOTF: function () {
      return Op;
    },
    KHR_DF_TRANSFER_PAL_OETF: function () {
      return Dp;
    },
    KHR_DF_TRANSFER_PQ_EOTF: function () {
      return Rp;
    },
    KHR_DF_TRANSFER_PQ_OETF: function () {
      return kp;
    },
    KHR_DF_TRANSFER_SLOG: function () {
      return Mp;
    },
    KHR_DF_TRANSFER_SLOG2: function () {
      return Tp;
    },
    KHR_DF_TRANSFER_SRGB: function () {
      return yp;
    },
    KHR_DF_TRANSFER_ST240: function () {
      return Lp;
    },
    KHR_DF_TRANSFER_UNSPECIFIED: function () {
      return bp;
    },
    KHR_DF_VENDORID_KHRONOS: function () {
      return cp;
    },
    KHR_DF_VERSION: function () {
      return up;
    },
    KHR_SUPERCOMPRESSION_BASISLZ: function () {
      return sp;
    },
    KHR_SUPERCOMPRESSION_NONE: function () {
      return ip;
    },
    KHR_SUPERCOMPRESSION_ZLIB: function () {
      return ap;
    },
    KHR_SUPERCOMPRESSION_ZSTD: function () {
      return op;
    },
    KTX2Container: function () {
      return O_;
    },
    VK_FORMAT_A1R5G5B5_UNORM_PACK16: function () {
      return fh;
    },
    VK_FORMAT_A2B10G10R10_SINT_PACK32: function () {
      return $h;
    },
    VK_FORMAT_A2B10G10R10_SNORM_PACK32: function () {
      return Zh;
    },
    VK_FORMAT_A2B10G10R10_UINT_PACK32: function () {
      return Jh;
    },
    VK_FORMAT_A2B10G10R10_UNORM_PACK32: function () {
      return Yh;
    },
    VK_FORMAT_A2R10G10B10_SINT_PACK32: function () {
      return qh;
    },
    VK_FORMAT_A2R10G10B10_SNORM_PACK32: function () {
      return Kh;
    },
    VK_FORMAT_A2R10G10B10_UINT_PACK32: function () {
      return Xh;
    },
    VK_FORMAT_A2R10G10B10_UNORM_PACK32: function () {
      return Wh;
    },
    VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: function () {
      return D_;
    },
    VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: function () {
      return P_;
    },
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: function () {
      return C_;
    },
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK: function () {
      return qf;
    },
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK: function () {
      return Xf;
    },
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: function () {
      return T_;
    },
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK: function () {
      return Vf;
    },
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK: function () {
      return zf;
    },
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: function () {
      return E_;
    },
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK: function () {
      return Hf;
    },
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK: function () {
      return Gf;
    },
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: function () {
      return A_;
    },
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK: function () {
      return Kf;
    },
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK: function () {
      return Wf;
    },
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: function () {
      return R_;
    },
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK: function () {
      return Zf;
    },
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK: function () {
      return Yf;
    },
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: function () {
      return k_;
    },
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK: function () {
      return $f;
    },
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK: function () {
      return Jf;
    },
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: function () {
      return g_;
    },
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK: function () {
      return Ef;
    },
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK: function () {
      return Tf;
    },
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: function () {
      return v_;
    },
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK: function () {
      return Cf;
    },
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK: function () {
      return Af;
    },
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: function () {
      return b_;
    },
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK: function () {
      return kf;
    },
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK: function () {
      return Rf;
    },
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: function () {
      return x_;
    },
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK: function () {
      return Df;
    },
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK: function () {
      return Pf;
    },
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: function () {
      return y_;
    },
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK: function () {
      return Lf;
    },
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK: function () {
      return Of;
    },
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: function () {
      return w_;
    },
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK: function () {
      return Ff;
    },
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK: function () {
      return If;
    },
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: function () {
      return S_;
    },
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK: function () {
      return Uf;
    },
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK: function () {
      return Nf;
    },
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: function () {
      return M_;
    },
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK: function () {
      return jf;
    },
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK: function () {
      return Bf;
    },
    VK_FORMAT_B10G11R11_UFLOAT_PACK32: function () {
      return Gd;
    },
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: function () {
      return r_;
    },
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: function () {
      return l_;
    },
    VK_FORMAT_B4G4R4A4_UNORM_PACK16: function () {
      return ch;
    },
    VK_FORMAT_B5G5R5A1_UNORM_PACK16: function () {
      return dh;
    },
    VK_FORMAT_B5G6R5_UNORM_PACK16: function () {
      return ph;
    },
    VK_FORMAT_B8G8R8A8_SINT: function () {
      return Gh;
    },
    VK_FORMAT_B8G8R8A8_SNORM: function () {
      return zh;
    },
    VK_FORMAT_B8G8R8A8_SRGB: function () {
      return Hh;
    },
    VK_FORMAT_B8G8R8A8_UINT: function () {
      return Vh;
    },
    VK_FORMAT_B8G8R8A8_UNORM: function () {
      return jh;
    },
    VK_FORMAT_B8G8R8_SINT: function () {
      return Oh;
    },
    VK_FORMAT_B8G8R8_SNORM: function () {
      return Ph;
    },
    VK_FORMAT_B8G8R8_SRGB: function () {
      return Lh;
    },
    VK_FORMAT_B8G8R8_UINT: function () {
      return Dh;
    },
    VK_FORMAT_B8G8R8_UNORM: function () {
      return kh;
    },
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK: function () {
      return tf;
    },
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK: function () {
      return ef;
    },
    VK_FORMAT_BC1_RGB_SRGB_BLOCK: function () {
      return Qd;
    },
    VK_FORMAT_BC1_RGB_UNORM_BLOCK: function () {
      return $d;
    },
    VK_FORMAT_BC2_SRGB_BLOCK: function () {
      return rf;
    },
    VK_FORMAT_BC2_UNORM_BLOCK: function () {
      return nf;
    },
    VK_FORMAT_BC3_SRGB_BLOCK: function () {
      return of;
    },
    VK_FORMAT_BC3_UNORM_BLOCK: function () {
      return sf;
    },
    VK_FORMAT_BC4_SNORM_BLOCK: function () {
      return lf;
    },
    VK_FORMAT_BC4_UNORM_BLOCK: function () {
      return af;
    },
    VK_FORMAT_BC5_SNORM_BLOCK: function () {
      return uf;
    },
    VK_FORMAT_BC5_UNORM_BLOCK: function () {
      return cf;
    },
    VK_FORMAT_BC6H_SFLOAT_BLOCK: function () {
      return hf;
    },
    VK_FORMAT_BC6H_UFLOAT_BLOCK: function () {
      return pf;
    },
    VK_FORMAT_BC7_SRGB_BLOCK: function () {
      return ff;
    },
    VK_FORMAT_BC7_UNORM_BLOCK: function () {
      return df;
    },
    VK_FORMAT_D16_UNORM: function () {
      return Wd;
    },
    VK_FORMAT_D16_UNORM_S8_UINT: function () {
      return Yd;
    },
    VK_FORMAT_D24_UNORM_S8_UINT: function () {
      return Zd;
    },
    VK_FORMAT_D32_SFLOAT: function () {
      return Xd;
    },
    VK_FORMAT_D32_SFLOAT_S8_UINT: function () {
      return Jd;
    },
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: function () {
      return Hd;
    },
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK: function () {
      return Mf;
    },
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK: function () {
      return Sf;
    },
    VK_FORMAT_EAC_R11_SNORM_BLOCK: function () {
      return wf;
    },
    VK_FORMAT_EAC_R11_UNORM_BLOCK: function () {
      return yf;
    },
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: function () {
      return vf;
    },
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: function () {
      return gf;
    },
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: function () {
      return xf;
    },
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: function () {
      return bf;
    },
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: function () {
      return mf;
    },
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: function () {
      return _f;
    },
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: function () {
      return n_;
    },
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: function () {
      return a_;
    },
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: function () {
      return d_;
    },
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: function () {
      return c_;
    },
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: function () {
      return f_;
    },
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: function () {
      return u_;
    },
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: function () {
      return __;
    },
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: function () {
      return p_;
    },
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: function () {
      return m_;
    },
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: function () {
      return h_;
    },
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: function () {
      return t_;
    },
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16: function () {
      return e_;
    },
    VK_FORMAT_R10X6_UNORM_PACK16: function () {
      return Qf;
    },
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: function () {
      return o_;
    },
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16: function () {
      return s_;
    },
    VK_FORMAT_R12X4_UNORM_PACK16: function () {
      return i_;
    },
    VK_FORMAT_R16G16B16A16_SFLOAT: function () {
      return vd;
    },
    VK_FORMAT_R16G16B16A16_SINT: function () {
      return gd;
    },
    VK_FORMAT_R16G16B16A16_SNORM: function () {
      return _d;
    },
    VK_FORMAT_R16G16B16A16_UINT: function () {
      return md;
    },
    VK_FORMAT_R16G16B16A16_UNORM: function () {
      return fd;
    },
    VK_FORMAT_R16G16B16_SFLOAT: function () {
      return dd;
    },
    VK_FORMAT_R16G16B16_SINT: function () {
      return hd;
    },
    VK_FORMAT_R16G16B16_SNORM: function () {
      return ud;
    },
    VK_FORMAT_R16G16B16_UINT: function () {
      return pd;
    },
    VK_FORMAT_R16G16B16_UNORM: function () {
      return cd;
    },
    VK_FORMAT_R16G16_SFLOAT: function () {
      return ld;
    },
    VK_FORMAT_R16G16_SINT: function () {
      return ad;
    },
    VK_FORMAT_R16G16_SNORM: function () {
      return sd;
    },
    VK_FORMAT_R16G16_UINT: function () {
      return od;
    },
    VK_FORMAT_R16G16_UNORM: function () {
      return id;
    },
    VK_FORMAT_R16_SFLOAT: function () {
      return rd;
    },
    VK_FORMAT_R16_SINT: function () {
      return nd;
    },
    VK_FORMAT_R16_SNORM: function () {
      return ed;
    },
    VK_FORMAT_R16_UINT: function () {
      return td;
    },
    VK_FORMAT_R16_UNORM: function () {
      return Qh;
    },
    VK_FORMAT_R32G32B32A32_SFLOAT: function () {
      return kd;
    },
    VK_FORMAT_R32G32B32A32_SINT: function () {
      return Rd;
    },
    VK_FORMAT_R32G32B32A32_UINT: function () {
      return Cd;
    },
    VK_FORMAT_R32G32B32_SFLOAT: function () {
      return Ad;
    },
    VK_FORMAT_R32G32B32_SINT: function () {
      return Ed;
    },
    VK_FORMAT_R32G32B32_UINT: function () {
      return Td;
    },
    VK_FORMAT_R32G32_SFLOAT: function () {
      return Md;
    },
    VK_FORMAT_R32G32_SINT: function () {
      return Sd;
    },
    VK_FORMAT_R32G32_UINT: function () {
      return wd;
    },
    VK_FORMAT_R32_SFLOAT: function () {
      return yd;
    },
    VK_FORMAT_R32_SINT: function () {
      return xd;
    },
    VK_FORMAT_R32_UINT: function () {
      return bd;
    },
    VK_FORMAT_R4G4B4A4_UNORM_PACK16: function () {
      return lh;
    },
    VK_FORMAT_R4G4_UNORM_PACK8: function () {
      return ah;
    },
    VK_FORMAT_R5G5B5A1_UNORM_PACK16: function () {
      return hh;
    },
    VK_FORMAT_R5G6B5_UNORM_PACK16: function () {
      return uh;
    },
    VK_FORMAT_R64G64B64A64_SFLOAT: function () {
      return Vd;
    },
    VK_FORMAT_R64G64B64A64_SINT: function () {
      return zd;
    },
    VK_FORMAT_R64G64B64A64_UINT: function () {
      return jd;
    },
    VK_FORMAT_R64G64B64_SFLOAT: function () {
      return Bd;
    },
    VK_FORMAT_R64G64B64_SINT: function () {
      return Ud;
    },
    VK_FORMAT_R64G64B64_UINT: function () {
      return Nd;
    },
    VK_FORMAT_R64G64_SFLOAT: function () {
      return Fd;
    },
    VK_FORMAT_R64G64_SINT: function () {
      return Id;
    },
    VK_FORMAT_R64G64_UINT: function () {
      return Ld;
    },
    VK_FORMAT_R64_SFLOAT: function () {
      return Od;
    },
    VK_FORMAT_R64_SINT: function () {
      return Dd;
    },
    VK_FORMAT_R64_UINT: function () {
      return Pd;
    },
    VK_FORMAT_R8G8B8A8_SINT: function () {
      return Uh;
    },
    VK_FORMAT_R8G8B8A8_SNORM: function () {
      return Fh;
    },
    VK_FORMAT_R8G8B8A8_SRGB: function () {
      return Bh;
    },
    VK_FORMAT_R8G8B8A8_UINT: function () {
      return Nh;
    },
    VK_FORMAT_R8G8B8A8_UNORM: function () {
      return Ih;
    },
    VK_FORMAT_R8G8B8_SINT: function () {
      return Ch;
    },
    VK_FORMAT_R8G8B8_SNORM: function () {
      return Eh;
    },
    VK_FORMAT_R8G8B8_SRGB: function () {
      return Rh;
    },
    VK_FORMAT_R8G8B8_UINT: function () {
      return Ah;
    },
    VK_FORMAT_R8G8B8_UNORM: function () {
      return Th;
    },
    VK_FORMAT_R8G8_SINT: function () {
      return Sh;
    },
    VK_FORMAT_R8G8_SNORM: function () {
      return yh;
    },
    VK_FORMAT_R8G8_SRGB: function () {
      return Mh;
    },
    VK_FORMAT_R8G8_UINT: function () {
      return wh;
    },
    VK_FORMAT_R8G8_UNORM: function () {
      return xh;
    },
    VK_FORMAT_R8_SINT: function () {
      return vh;
    },
    VK_FORMAT_R8_SNORM: function () {
      return mh;
    },
    VK_FORMAT_R8_SRGB: function () {
      return bh;
    },
    VK_FORMAT_R8_UINT: function () {
      return gh;
    },
    VK_FORMAT_R8_UNORM: function () {
      return _h;
    },
    VK_FORMAT_S8_UINT: function () {
      return qd;
    },
    VK_FORMAT_UNDEFINED: function () {
      return oh;
    },
    VK_FORMAT_X8_D24_UNORM_PACK32: function () {
      return Kd;
    },
    read: function () {
      return j_;
    },
    write: function () {
      return G_;
    }
  });
  var t,
      n = {};
  __webpackgi_require__.r(n), __webpackgi_require__.d(n, {
    AsyncCompress: function () {
      return Sv;
    },
    AsyncDecompress: function () {
      return Bv;
    },
    AsyncDeflate: function () {
      return _v;
    },
    AsyncGunzip: function () {
      return Av;
    },
    AsyncGzip: function () {
      return Sv;
    },
    AsyncInflate: function () {
      return bv;
    },
    AsyncUnzipInflate: function () {
      return hb;
    },
    AsyncUnzlib: function () {
      return Iv;
    },
    AsyncZipDeflate: function () {
      return ob;
    },
    AsyncZlib: function () {
      return Pv;
    },
    Compress: function () {
      return wv;
    },
    DecodeUTF8: function () {
      return Xv;
    },
    Decompress: function () {
      return Uv;
    },
    Deflate: function () {
      return fv;
    },
    EncodeUTF8: function () {
      return qv;
    },
    Gunzip: function () {
      return Ev;
    },
    Gzip: function () {
      return wv;
    },
    Inflate: function () {
      return vv;
    },
    Unzip: function () {
      return db;
    },
    UnzipInflate: function () {
      return pb;
    },
    UnzipPassThrough: function () {
      return ub;
    },
    Unzlib: function () {
      return Lv;
    },
    Zip: function () {
      return ab;
    },
    ZipDeflate: function () {
      return sb;
    },
    ZipPassThrough: function () {
      return ib;
    },
    Zlib: function () {
      return kv;
    },
    compress: function () {
      return Mv;
    },
    compressSync: function () {
      return Tv;
    },
    decompress: function () {
      return jv;
    },
    decompressSync: function () {
      return zv;
    },
    deflate: function () {
      return mv;
    },
    deflateSync: function () {
      return gv;
    },
    gunzip: function () {
      return Cv;
    },
    gunzipSync: function () {
      return Rv;
    },
    gzip: function () {
      return Mv;
    },
    gzipSync: function () {
      return Tv;
    },
    inflate: function () {
      return xv;
    },
    inflateSync: function () {
      return yv;
    },
    strFromU8: function () {
      return Zv;
    },
    strToU8: function () {
      return Yv;
    },
    unzip: function () {
      return fb;
    },
    unzipSync: function () {
      return _b;
    },
    unzlib: function () {
      return Fv;
    },
    unzlibSync: function () {
      return Nv;
    },
    zip: function () {
      return lb;
    },
    zipSync: function () {
      return cb;
    },
    zlib: function () {
      return Dv;
    },
    zlibSync: function () {
      return Ov;
    }
  }), function (e) {
    e[e.Error = -2] = "Error", e[e.Destroyed = -1] = "Destroyed", e[e.None = 0] = "None", e[e.Running = 1] = "Running", e[e.Paused = 2] = "Paused";
  }(t || (t = {}));

  class r {
    constructor() {
      this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
    }

    addEventListener(e, t) {
      const n = this._eventListeners;
      void 0 === n[e] && (n[e] = []), n[e].includes(t) || n[e].push(t);
    }

    hasEventListener(e, t) {
      const n = this._eventListeners;
      return void 0 !== n[e] && n[e].includes(t);
    }

    removeEventListener(e, t) {
      const n = this._eventListeners[e];

      if (void 0 !== n) {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      }
    }

    dispatchEvent(e) {
      const t = this._eventListeners[e.type];

      if (void 0 !== t) {
        e.target = this;
        const n = t.slice(0);

        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
      }
    }

  }

  var i = __webpackgi_require__(927);

  const s = {
    uniforms: {
      tDiffuse: {
        value: null
      },
      opacity: {
        value: 1
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"
  };

  class o {
    constructor() {
      this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
    }

    setSize() {}

    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }

  }

  const a = new i.iKG(-1, 1, 1, -1, 0, 1),
        l = new i.u9r();
  l.setAttribute("position", new i.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), l.setAttribute("uv", new i.a$l([0, 2, 0, 0, 2, 0], 2));

  class c {
    constructor(e) {
      this._mesh = new i.Kj0(l, e);
    }

    dispose() {
      this._mesh.geometry.dispose();
    }

    render(e) {
      e.render(this._mesh, a);
    }

    get material() {
      return this._mesh.material;
    }

    set material(e) {
      this._mesh.material = e;
    }

  }

  class u extends o {
    constructor(e, t) {
      super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof i.jyz ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = i.rDY.clone(e.uniforms), this.material = new i.jyz({
        defines: Object.assign({}, e.defines),
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader
      })), this.fsQuad = new c(this.material), this.useExistingRenderTarget = !1;
    }

    render(e, t, n) {
      this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (this.useExistingRenderTarget || e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
    }

  }

  class p extends o {
    constructor(e, t) {
      super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
    }

    render(e, t, n) {
      const r = e.getContext(),
            i = e.state;
      let s, o;
      i.buffers.color.setMask(!1), i.buffers.depth.setMask(!1), i.buffers.color.setLocked(!0), i.buffers.depth.setLocked(!0), this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), i.buffers.stencil.setTest(!0), i.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), i.buffers.stencil.setFunc(r.ALWAYS, s, 4294967295), i.buffers.stencil.setClear(o), i.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), i.buffers.color.setLocked(!1), i.buffers.depth.setLocked(!1), i.buffers.stencil.setLocked(!1), i.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), i.buffers.stencil.setLocked(!0);
    }

  }

  class h extends o {
    constructor() {
      super(), this.needsSwap = !1;
    }

    render(e) {
      e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
    }

  }

  new i.iKG(-1, 1, 1, -1, 0, 1);
  const d = new i.u9r();
  d.setAttribute("position", new i.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), d.setAttribute("uv", new i.a$l([0, 2, 0, 0, 2, 0], 2));

  class f extends class {
    constructor(e, t) {
      if (this.renderer = e, void 0 === t) {
        const n = e.getSize(new i.FM8());
        this._pixelRatio = e.getPixelRatio(), this._width = n.width, this._height = n.height, (t = new i.dd2(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1";
      } else this._pixelRatio = 1, this._width = t.width, this._height = t.height;

      this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === s && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === u && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new u(s), this.clock = new i.SUY();
    }

    swapBuffers() {
      const e = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = e;
    }

    addPass(e) {
      this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }

    insertPass(e, t) {
      this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }

    removePass(e) {
      const t = this.passes.indexOf(e);
      -1 !== t && this.passes.splice(t, 1);
    }

    isLastEnabledPass(e) {
      for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return !1;

      return !0;
    }

    render(e) {
      void 0 === e && (e = this.clock.getDelta());
      const t = this.renderer.getRenderTarget();
      let n = !1;

      for (let t = 0, r = this.passes.length; t < r; t++) {
        const r = this.passes[t];

        if (!1 !== r.enabled) {
          if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t), r.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), r.needsSwap) {
            if (n) {
              const t = this.renderer.getContext(),
                    n = this.renderer.state.buffers.stencil;
              n.setFunc(t.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), n.setFunc(t.EQUAL, 1, 4294967295);
            }

            this.swapBuffers();
          }

          void 0 !== p && (r instanceof p ? n = !0 : r instanceof h && (n = !1));
        }
      }

      this.renderer.setRenderTarget(t);
    }

    reset(e) {
      if (void 0 === e) {
        const t = this.renderer.getSize(new i.FM8());
        this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }

      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
    }

    setSize(e, t) {
      this._width = e, this._height = t;
      const n = this._width * this._pixelRatio,
            r = this._height * this._pixelRatio;
      this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);

      for (let e = 0; e < this.passes.length; e++) this.passes[e].setSize(n, r);
    }

    setPixelRatio(e) {
      this._pixelRatio = e, this.setSize(this._width, this._height);
    }

  } {
    constructor(e, t) {
      super(e, t);
    }

    setPixelRatio(e, t = !0) {
      const n = this.setSize;
      t || (this.setSize = () => {}), super.setPixelRatio(e), t || (this.setSize = n);
    }

  }

  function _(e, t) {
    let n;

    do {
      n = Object.getOwnPropertyDescriptor(e, t);
    } while (!n && (e = Object.getPrototypeOf(e)));

    return n;
  }

  function m(e, t, n = !1, r = !1) {
    const i = _(e, t);

    return !!(null == i ? void 0 : i.set) || n && !1 !== (null == i ? void 0 : i.writable) && void 0 === (null == i ? void 0 : i.get) || r && !i;
  }

  function g(e, t, n, r = !1, i = !1) {
    return !(!e || !m(e, t, r, i) || (e[t] = n, 0));
  }

  function v(e, t) {
    for (; e.length > 0;) {
      if (!t) return;
      const n = e.splice(0, 1)[0];

      if (!(n.length < 1)) {
        if (!(n in t)) return console.error("invalid access, check", n, t), t;
        t = t[n];
      }
    }

    return t;
  }

  function b(e, t) {
    return Object.keys(e).find(n => e[n] === t);
  }

  function x(e, ...t) {
    return "function" == typeof e && (e = e(...t)), e;
  }

  function y(e, t, n) {
    for (const r of n) {
      const n = e[r];
      void 0 !== n && g(t, r, n, !0);
    }
  }

  function w(e) {
    return e.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
  }

  function S(e, t, n) {
    return e.replace(new RegExp(w(t), "g"), n);
  }

  String.raw;

  const M = (e, ...t) => String.raw({
    raw: e
  }, ...t),
        T = (e, ...t) => String.raw({
    raw: e
  }, ...t),
        E = (e, ...t) => String.raw({
    raw: e
  }, ...t),
        A = (e, ...t) => {
    let n = String.raw({
      raw: e
    }, ...t);
    return n = S(n, "%", "%25"), n = S(n, "> <", "><"), n = S(n, "; }", ";}"), n = S(n, "<", "%3c"), n = S(n, ">", "%3e"), n = S(n, '"', "'"), n = S(n, "#", "%23"), n = S(n, "{", "%7b"), n = S(n, "}", "%7d"), n = S(n, "|", "%7c"), n = S(n, "^", "%5e"), n = S(n, "`", "%60"), n = S(n, "@", "%40"), n = S(n, "&", "&amp;"), "data:image/svg+xml;charset=UTF-8," + n;
  };

  function C(e) {
    if (!e) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
    return (t, n) => {
      let r;
      Object.defineProperty(t, n, {
        get: () => r,

        set(t) {
          var i;
          if (r === t) return;
          r = t;
          const s = [n, t];
          if ("string" == typeof e) null === (i = this[e]) || void 0 === i || i.call(this, ...s);else if ("function" == typeof e) {
            let t = !1;

            if (e.name) {
              let n = this;

              for (; n;) {
                if (n[e.name] === e) {
                  e.call(this, ...s), t = !0;
                  break;
                }

                n = Object.getPrototypeOf(n);
              }
            }

            t || (e.name && this[e.name].name === `bound ${e.name}` ? this[e.name](...s) : e(...s));
          }
        }

      });
    };
  }

  function R(e, t) {
    for (const n of t) if (!e.includes(n)) return !1;

    return !0;
  }

  String.prototype.replaceAll || (String.prototype.replaceAll = function (e, t) {
    return "[object regexp]" === Object.prototype.toString.call(e).toLowerCase() ? this.replace(e, t) : this.replace(new RegExp(e, "g"), t);
  });

  class k {
    constructor(e = 0, t = 0) {
      k.prototype.isVector2 = !0, this.x = e, this.y = t;
    }

    get width() {
      return this.x;
    }

    set width(e) {
      this.x = e;
    }

    get height() {
      return this.y;
    }

    set height(e) {
      this.y = e;
    }

    set(e, t) {
      return this.x = e, this.y = t, this;
    }

    setScalar(e) {
      return this.x = e, this.y = e, this;
    }

    setX(e) {
      return this.x = e, this;
    }

    setY(e) {
      return this.y = e, this;
    }

    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;

        case 1:
          this.y = t;
          break;

        default:
          throw new Error("index is out of range: " + e);
      }

      return this;
    }

    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        default:
          throw new Error("index is out of range: " + e);
      }
    }

    clone() {
      return new this.constructor(this.x, this.y);
    }

    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }

    add(e) {
      return this.x += e.x, this.y += e.y, this;
    }

    addScalar(e) {
      return this.x += e, this.y += e, this;
    }

    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }

    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }

    sub(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }

    subScalar(e) {
      return this.x -= e, this.y -= e, this;
    }

    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }

    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this;
    }

    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }

    divide(e) {
      return this.x /= e.x, this.y /= e.y, this;
    }

    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }

    applyMatrix3(e) {
      const t = this.x,
            n = this.y,
            r = e.elements;
      return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
    }

    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
    }

    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
    }

    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
    }

    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
    }

    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }

    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }

    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }

    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }

    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }

    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }

    dot(e) {
      return this.x * e.x + this.y * e.y;
    }

    cross(e) {
      return this.x * e.y - this.y * e.x;
    }

    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }

    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }

    normalize() {
      return this.divideScalar(this.length() || 1);
    }

    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }

    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }

    distanceToSquared(e) {
      const t = this.x - e.x,
            n = this.y - e.y;
      return t * t + n * n;
    }

    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }

    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }

    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }

    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
    }

    equals(e) {
      return e.x === this.x && e.y === this.y;
    }

    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this;
    }

    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }

    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this;
    }

    rotateAround(e, t) {
      const n = Math.cos(t),
            r = Math.sin(t),
            i = this.x - e.x,
            s = this.y - e.y;
      return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this;
    }

    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }

    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }

  }

  class P extends i.ZzF {
    expandByObject(e, t = !1, n = !1) {
      var r;
      if (!1 === (null === (r = e.userData) || void 0 === r ? void 0 : r.bboxVisible)) return this;
      if (!e.visible && n) return this;
      e.updateWorldMatrix(!1, !1);
      const i = e.geometry;
      if (void 0 !== i) if (t && null != i.attributes && void 0 !== i.attributes.position) {
        const t = i.attributes.position;

        for (let n = 0, r = t.count; n < r; n++) O.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld), this.expandByPoint(O);
      } else null === i.boundingBox && i.computeBoundingBox(), D.copy(i.boundingBox), D.applyMatrix4(e.matrixWorld), this.union(D);
      const s = e.children;

      for (let e = 0, r = s.length; e < r; e++) this.expandByObject(s[e], t, n);

      return this;
    }

    expandByObjects(e, t = !1, n = !1) {
      for (let r = 0, i = e.length; r < i; r++) this.expandByObject(e[r], t, n);

      return this;
    }

    getPoints() {
      return [new i.Pa4(this.min.x, this.min.y, this.min.z), new i.Pa4(this.min.x, this.min.y, this.max.z), new i.Pa4(this.min.x, this.max.y, this.min.z), new i.Pa4(this.min.x, this.max.y, this.max.z), new i.Pa4(this.max.x, this.min.y, this.min.z), new i.Pa4(this.max.x, this.min.y, this.max.z), new i.Pa4(this.max.x, this.max.y, this.min.z), new i.Pa4(this.max.x, this.max.y, this.max.z)];
    }

    getScreenSpaceBounds(e) {
      const t = this.getPoints(),
            n = new i.TUj();

      for (const r of t) {
        const t = r.project(e);
        n.min.min(t), n.max.max(t);
      }

      return n;
    }

  }

  const D = new P(),
        O = new i.Pa4();

  function L(e, t) {
    let n, r;
    if (Array.isArray(e)) for (const i of e) {
      const e = L(i, t);
      void 0 === n || void 0 === r ? (n = e.min.clone(), r = e.max.clone()) : (n.min(e.min), r.max(e.max));
    }
    const s = e;

    if (void 0 !== s.geometry) {
      const o = s.geometry.vertices;

      if (void 0 === o && void 0 !== s.geometry.attributes && "position" in s.geometry.attributes) {
        const o = new i.Pa4(),
              a = s.geometry.attributes.position;

        for (let i = 0; i < a.count * a.itemSize; i += a.itemSize) {
          o.set(a.array[i], a.array[i + 1], a.array[3]);
          const s = o.applyMatrix4(e.matrixWorld).project(t),
                l = new k(s.x, s.y);
          void 0 === n || void 0 === r ? (n = l.clone(), r = l.clone()) : (n.min(l), r.max(l));
        }
      } else for (const i of o) {
        const s = i.clone().applyMatrix4(e.matrixWorld).project(t),
              o = new k(s.x, s.y);
        void 0 === n || void 0 === r ? (n = o.clone(), r = o.clone()) : (n.min(o), r.max(o));
      }
    }

    if (void 0 !== e.children) for (const i of e.children) {
      const e = L(i, t);
      void 0 === n || void 0 === r ? (n = e.min.clone(), r = e.max.clone()) : (n.min(e.min), r.max(e.max));
    }
    return new i.TUj(n, r);
  }

  function I(e) {
    switch (e) {
      case i.rnI:
        return ["Linear", "( value )"];

      case i.knz:
        return ["sRGB", "( value )"];

      case 3005:
        return ["RGBM", "( value, 16.0 )"];

      default:
        return console.warn("utils: Unsupported encoding:", e), ["Linear", "( value )"];
    }
  }

  function F(e, t) {
    let n;
    return e && e.isTexture ? n = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = i.rnI, t && e && e.isTexture && e.format === i.wk1 && e.type === i.ywz && e.encoding === i.knz && (n = i.rnI), n;
  }

  function N(e, t) {
    const n = I(t);
    return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
  }

  function U(e, t, n) {
    return N(e + "TexelToLinear", F(t, n)) + "\n";
  }

  function B(e, t) {
    return N(e + "TexelToLinear", t) + "\n";
  }

  function j(e, t) {
    const n = I(t);
    return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
  }

  function z(e, t, n) {
    return j(e, F(t, n));
  }

  function V({
    uniforms: e,
    propKey: t,
    thisTarget: n = !1
  } = {}) {
    const r = !!e,
          i = !!t,
          s = n;
    return (n, o) => {
      const a = n => {
        const a = s ? n : r ? e : n.uniforms || n._uniforms;
        let l = i ? t : o;
        s && (l = "_" + l);
        let c = a[l];
        return c || (c = {
          value: null
        }, a[l] = c), c;
      };

      Object.defineProperty(n, o, {
        get() {
          return a(this).value;
        },

        set(e) {
          a(this).value = e, g(this, "uniformsNeedUpdate", !0, !0);
        }

      });
    };
  }

  function G(e, t, n = !1, r) {
    const i = !!t,
          s = !!e;
    return (o, a) => {
      const l = n => ({
        t: i ? t : n.defines || n._defines,
        p: s ? e : a
      });

      Object.defineProperty(o, a, {
        get() {
          const {
            t: e,
            p: t
          } = l(n ? this : this.material);
          return e[t];
        },

        set(e) {
          const {
            t: t,
            p: i
          } = l(n ? this : this.material);

          if (g(t, i, e, !0), "function" == typeof r) {
            const t = [i, e];

            if (r.name) {
              const e = this[r.name];
              e === r ? r.call(this, ...t) : e.name === `bound ${r.name}` ? e(...t) : r(...t);
            } else r(...t);
          } else g(n ? this : this.material, "needsUpdate", !0, !0);
        }

      });
    };
  }

  function H(e) {
    const t = new i.IEO(new Uint8Array([Math.floor(255 * e.r), Math.floor(255 * e.g), Math.floor(255 * e.b), 255]), 1, 1, i.wk1, i.ywz);
    return t.needsUpdate = !0, t.encoding = i.rnI, t;
  }

  function W(e) {
    const t = new i.IEO(new Uint8Array([Math.floor(255 * e.x), Math.floor(255 * e.y), Math.floor(255 * e.z), Math.floor(255 * e.w)]), 1, 1, i.wk1, i.ywz);
    return t.needsUpdate = !0, t;
  }

  function K(e, t, n) {
    const r = e.userData,
          {
      backgroundRender: i,
      transparentRender: s,
      shadowMapRender: o,
      mainRenderPass: a,
      opaqueRender: l,
      transmissionRender: c,
      sceneRender: u,
      screenSpaceRendering: p
    } = r;
    void 0 !== t.backgroundRender && (r.backgroundRender = t.backgroundRender), void 0 !== t.transparentRender && (r.transparentRender = t.transparentRender), void 0 !== t.shadowMapRender && (r.shadowMapRender = t.shadowMapRender), void 0 !== t.mainRenderPass && (r.mainRenderPass = t.mainRenderPass), void 0 !== t.opaqueRender && (r.opaqueRender = t.opaqueRender), void 0 !== t.sceneRender && (r.sceneRender = t.sceneRender), void 0 !== t.transmissionRender && (r.transmissionRender = t.transmissionRender), void 0 !== t.screenSpaceRendering && (r.screenSpaceRendering = t.screenSpaceRendering), n(), r.backgroundRender = i, r.transparentRender = s, r.shadowMapRender = o, r.mainRenderPass = a, r.opaqueRender = l, r.sceneRender = u, r.transmissionRender = c, r.screenSpaceRendering = p;
  }

  function X(e, t) {
    const n = .5 * new P().expandByObject(e, !0, !0).getSize(new i.Pa4()).length();
    void 0 === t && (t = e.userData.autoScaleRadius || 1);
    const r = t / n;
    return isFinite(r) && (e.userData.pseudoCentered ? e.children.forEach(e => {
      e.scale.multiplyScalar(r);
    }) : e.scale.multiplyScalar(r)), e.userData.autoScaled = !0, e.userData.autoScaleRadius = t, e.dispatchEvent({
      type: "objectUpdate"
    }), e;
  }

  function q(e, t = -1) {
    return function (e, t = 1e-4) {
      const n = t > 0;
      t = Math.max(t, Number.EPSILON);
      const r = {},
            s = e.getIndex(),
            o = e.getAttribute("position"),
            a = s ? s.count : o.count;
      let l = 0;
      const c = Object.keys(e.attributes),
            u = {},
            p = {},
            h = [],
            d = ["getX", "getY", "getZ", "getW"];

      for (let t = 0, n = c.length; t < n; t++) {
        const n = c[t];
        u[n] = [];
        const r = e.morphAttributes[n];
        r && (p[n] = new Array(r.length).fill().map(() => []));
      }

      const f = Math.log10(1 / t),
            _ = Math.pow(10, f);

      for (let t = 0; t < a; t++) {
        const i = s ? s.getX(t) : t;
        let o = "";

        for (let t = 0, r = c.length; t < r && n; t++) {
          const n = c[t],
                r = e.getAttribute(n),
                s = r.itemSize;

          for (let e = 0; e < s; e++) o += ~~(r[d[e]](i) * _) + ",";
        }

        if (n && o in r) h.push(r[o]);else {
          for (let t = 0, n = c.length; t < n; t++) {
            const n = c[t],
                  r = e.getAttribute(n),
                  s = e.morphAttributes[n],
                  o = r.itemSize,
                  a = u[n],
                  l = p[n];

            for (let e = 0; e < o; e++) {
              const t = d[e];
              if (a.push(r[t](i)), s) for (let e = 0, n = s.length; e < n; e++) l[e].push(s[e][t](i));
            }
          }

          n && (r[o] = l), h.push(l), l++;
        }
      }

      const m = e.clone();

      for (let t = 0, n = c.length; t < n; t++) {
        const n = c[t],
              r = e.getAttribute(n),
              s = new r.array.constructor(u[n]),
              o = new i.TlE(s, r.itemSize, r.normalized);
        if (m.setAttribute(n, o), n in p) for (let t = 0; t < p[n].length; t++) {
          const r = e.morphAttributes[n][t],
                s = new r.array.constructor(p[n][t]),
                o = new i.TlE(s, r.itemSize, r.normalized);
          m.morphAttributes[n][t] = o;
        }
      }

      return m.setIndex(h), m;
    }(e, t);
  }

  class Y extends r {
    constructor({
      animationLoop: e,
      canvas: t,
      alpha: n = !0,
      targetOptions: r
    }) {
      super(), this._isWebGL2 = !1, this._trackedTargets = [], this.dirty = !0, this._lastTime = 0, this.frameWaitTime = 0, this._passes = [], this._pipeline = [], this._passesNeedsUpdate = !0, this._displayCanvasScaling = 1, this._renderSize = new i.FM8(512, 512), this._frameCount = 0, this._tempTargets = {}, this.maxTempPerKey = 5, this._animationLoop = this._animationLoop.bind(this), this._processNewTarget = this._processNewTarget.bind(this), this._processNewTempTarget = this._processNewTempTarget.bind(this), this.trackTarget = this.trackTarget.bind(this), this.disposeTarget = this.disposeTarget.bind(this), this.createTarget = this.createTarget.bind(this), this.createTargetCustom = this.createTargetCustom.bind(this), this._renderer = new i.CP7({
        canvas: t,
        antialias: !0,
        alpha: n,
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0
      }), this._renderer.baseRenderer = this, this._renderer.setAnimationLoop(this._animationLoop), this._context = this._renderer.getContext(), this._isWebGL2 = this._renderer.capabilities.isWebGL2, this._renderSize = new i.FM8(t.clientWidth, t.clientHeight), this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling), this._renderer.toneMapping = i.uL9, this._renderer.toneMappingExposure = 1, this._renderer.outputEncoding = i.rnI, this._renderer.shadowMap.enabled = !0, this._renderer.shadowMap.type = i._MY, this._renderer.shadowMap.autoUpdate = !1, this.resetShadows(), r.isAntialiased = r.isAntialiased && this.isWebGL2, this._composerTarget = this.createTarget(r, !1), this._composerTarget.texture.name = "EffectComposer.rt1", this._composer = new f(this._renderer, this._composerTarget), e && this.addEventListener("animationLoop", e);
    }

    get composer() {
      return this._composer;
    }

    get passes() {
      return this._passes;
    }

    get isWebGL2() {
      return this._isWebGL2;
    }

    get composerTarget() {
      return this._composerTarget;
    }

    get renderSize() {
      return this._renderSize;
    }

    get displayCanvasScaling() {
      return this._displayCanvasScaling;
    }

    set displayCanvasScaling(e) {
      e !== this._displayCanvasScaling && (this._displayCanvasScaling = e, this.setSize(void 0, void 0, !0));
    }

    get frameCount() {
      return this._frameCount;
    }

    set pipeline(e) {
      this._pipeline = e, this._passesNeedsUpdate = !0;
    }

    get pipeline() {
      return this._pipeline;
    }

    refreshPipeline() {
      var e, t, n;
      const r = this._passes,
            i = [],
            s = {};

      for (const i of r) {
        if (!1 === i.enabled) continue;
        const r = {
          after: null !== (e = i.after) && void 0 !== e ? e : [],
          before: null !== (t = i.before) && void 0 !== t ? t : [],
          dependencies: new Set(null !== (n = i.required) && void 0 !== n ? n : [])
        };
        s[i.passId] = r;
      }

      for (const [e, t] of Object.entries(s)) {
        const n = new Set([...t.after, ...t.before]);
        t.dependencies.forEach(e => n.has(e) && n.delete(e)), n.forEach(n => {
          const r = s[n];

          if (r) {
            if (r.dependencies.has(e)) throw console.error("cyclic", e, n), "Cyclic dependency";
            t.dependencies.add(n);
          }
        });
      }

      for (;;) {
        let e = !1;
        const t = [...Object.entries(s)];

        for (const [n, o] of t) if (!i.includes(n) && R(i, o.dependencies.values())) {
          const t = Math.max(-1, ...o.after.map(e => i.indexOf(e))),
                a = Math.min(i.length, ...o.before.map(e => {
            const t = i.indexOf(e);
            return t < 0 ? i.length : t;
          }));
          if (t >= a) throw console.error(o, r, i, t, a), "Not possible";
          i.splice(o.after.length > 0 ? t + 1 : a, 0, n), e = !0, delete s[n];
        }

        if (Object.keys(s).length < 1) break;
        if (!e) throw console.log(t, s, i), "Not possible 2";
      }

      return this.pipeline = i, this.pipeline;
    }

    get context() {
      return this._context;
    }

    get rendererObject() {
      return this._renderer;
    }

    _animationLoop(e, t) {
      const n = e - this._lastTime;
      this._lastTime = e, this.frameWaitTime -= n, this.frameWaitTime > 0 || (this.frameWaitTime = 0, this.dispatchEvent({
        type: "animationLoop",
        deltaTime: n,
        time: e,
        renderer: this,
        xrFrame: t
      }));
    }

    get clock() {
      return this._composer.clock;
    }

    registerPass(e, t = !0) {
      var n;
      if (t) for (const t of [...this._passes]) e.passId === t.passId && this.unregisterPass(t);
      this._passes.push(e), null === (n = e.onRegister) || void 0 === n || n.call(e, this), this._passesNeedsUpdate = !0, this._updated();
    }

    unregisterPass(e) {
      var t;

      const n = this._passes.indexOf(e);

      n >= 0 && (null === (t = e.onUnregister) || void 0 === t || t.call(e, this), this._passes.splice(n, 1), this._passesNeedsUpdate = !0, this._updated());
    }

    setSize(e, t, n = !1) {
      !n && (e ? Math.abs(e - this._renderSize.width) : 0) + (t ? Math.abs(t - this._renderSize.height) : 0) < .1 || (e && (this._renderSize.width = e), t && (this._renderSize.height = t), this.rendererObject.xr.enabled || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling)), this._composer.setPixelRatio(this._displayCanvasScaling, !1), this._composer.setSize(this._renderSize.width, this._renderSize.height), this._trackedTargets.forEach(e => {
        const t = e,
              n = t.sizeMultiplier;

        if (n) {
          const e = this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * n);

          t.setSize(e.width, e.height);
        }
      }), this.dispatchEvent({
        type: "resize"
      }), this._updated(), this.reset());
    }

    blit(e, t, {
      viewport: n,
      material: r,
      shader: s,
      pass: o,
      clear: a = !0
    } = {}) {
      const l = this._composer.copyPass,
            {
        renderToScreen: c,
        material: u,
        uniforms: p,
        clear: h
      } = l;
      r && (l.material = r);

      const d = this._renderer.getViewport(new i.Ltg()),
            f = this._renderer.autoClear,
            _ = this._renderer.getRenderTarget();

      n && this._renderer.setViewport(new i.Ltg().fromArray(n)), this._renderer.autoClear = !1, l.uniforms = l.material.uniforms, l.renderToScreen = !1, l.clear = a, K(this._renderer, {
        sceneRender: !0,
        opaqueRender: !0,
        shadowMapRender: !1,
        backgroundRender: !1,
        transparentRender: !0,
        transmissionRender: !1
      }, () => {
        l.render(this._renderer, null != t ? t : null, {
          texture: e
        }, 0, !1);
      }), l.renderToScreen = c, l.clear = h, l.material = u, l.uniforms = p, this._renderer.autoClear = f, n && this._renderer.setViewport(d), this._renderer.setRenderTarget(_);
    }

    clearColor({
      r: e,
      g: t,
      b: n,
      a: r,
      target: s,
      depth: o = !0,
      stencil: a = !0
    }) {
      var l;

      const c = this._renderer.getClearColor(new i.Ilk()),
            u = this._renderer.getClearAlpha();

      this._renderer.setClearAlpha(null != r ? r : u), this._renderer.setClearColor(new i.Ilk(null != e ? e : c.r, null != t ? t : c.g, null != n ? n : c.b));

      const p = this._renderer.getRenderTarget(),
            h = this._renderer.getActiveCubeFace(),
            d = this._renderer.getActiveMipmapLevel();

      this._renderer.setRenderTarget(null !== (l = s) && void 0 !== l ? l : null), this._renderer.clear(!0, o, a), this._renderer.setRenderTarget(p, h, d), this._renderer.setClearColor(c), this._renderer.setClearAlpha(u);
    }

    renderModel(e, t) {
      this._renderer.render(e.modelObject, t.cameraObject);
    }

    renderScene(e) {
      const t = e.activeCamera;
      t && this.renderModel(e, t);
    }

    _updated() {
      this.dispatchEvent({
        type: "update"
      });
    }

    render() {
      var e;
      this._passesNeedsUpdate && this.refreshPasses();

      for (const t of this._passes) t.passObject.enabled && (null === (e = t.update) || void 0 === e || e.call(t));

      this._composer.render(), this._frameCount += 1, this.dirty = !1;
    }

    updateDirty() {
      this.dirty = this.dirty || this._passes.findIndex(e => e.dirty) >= 0;
    }

    reset() {
      this._frameCount = 0, this.dirty = !0;
    }

    resetShadows() {
      this._renderer.shadowMap.needsUpdate = !0;
    }

    refreshPasses() {
      if (!this._passesNeedsUpdate) return;
      this._passesNeedsUpdate = !1;
      const e = [];

      for (const t of this._pipeline) {
        const n = this._passes.find(e => e.passId === t);

        n ? e.push(n.passObject) : console.warn("Unable to find pass: ", t);
      }

      this._composer.passes.forEach(e => this._composer.removePass(e)), e.forEach(e => this._composer.addPass(e)), this._updated();
    }

    dispose() {
      this._renderer.dispose();
    }

    trackTarget(e) {
      this._trackedTargets.push(e);
    }

    removeTrackedTarget(e) {
      const t = this._trackedTargets.indexOf(e);

      t >= 0 && this._trackedTargets.splice(t, 1);
    }

    createTarget({
      sizeMultiplier: e,
      isAntialiased: t = !1,
      encoding: n = i.rnI,
      type: r = i.ywz,
      format: s = i.wk1,
      depthBuffer: o = !0,
      depthTexture: a = !1,
      size: l,
      textureCount: c = 1,
      ...u
    } = {}, p = !0) {
      t = t && this.isWebGL2, void 0 !== e && void 0 !== l && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."), l = l || this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * (e = e || 1));
      const h = a ? new i.$YQ(l.width, l.height, i.ywz) : void 0,
            d = this.createTargetCustom(c > 1 ? {
        width: l.width,
        height: l.height,
        count: c
      } : l, {
        encoding: n,
        type: r,
        format: s,
        depthBuffer: o,
        depthTexture: h
      }, c > 1 ? i.kFz : i.dd2);
      return this._processNewTarget(d, e, p), this._setTargetOptions(d, u), d;
    }

    _processNewTarget(e, t, n) {
      return void 0 !== t && (e.sizeMultiplier = t), n && this.trackTarget(e), e;
    }

    disposeTarget(e) {
      if (e) {
        if (e.isTemporary) return this.releaseTempTarget(e);
        this.removeTrackedTarget(e), e.dispose();
      }
    }

    createTargetCustom({
      width: e,
      height: t,
      count: n
    }, r = {}, s) {
      var o;
      const a = this._processNewTarget;
      let l = [e, t];

      if (n && n > 1 && l.push(n), (null == s ? void 0 : s.prototype) === i.oAp.prototype) {
        if (e !== t) throw "Width and height of cube render target must be equal";
        l = [e];
      }

      r = {
        format: i.wk1,
        minFilter: i.wem,
        magFilter: i.wem,
        generateMipmaps: !1,
        type: i.ywz,
        encoding: i.rnI,
        ...r
      };
      const c = [...l, r];
      return new class extends (null !== (o = s) && void 0 !== o ? o : i.dd2) {
        constructor(...e) {
          super(...e), Array.isArray(this.texture) ? this.texture.forEach(e => {
            e.encoding = r.encoding, e.toJSON = () => ({});
          }) : this.texture.toJSON = () => ({});
        }

        clone(e = !0) {
          if (this.isTemporary) throw "Cloning temporary render targets not supported";
          if (Array.isArray(this.texture)) throw "Cloning multiple render targets not supported";
          const t = super.clone();
          return t.texture.isRenderTargetTexture = !0, a(t, this.sizeMultiplier || 1, e);
        }

      }(...c);
    }

    getTempTarget(e = {}) {
      var t;
      const n = Z(e);
      let r;
      return (null === (t = this._tempTargets[n]) || void 0 === t ? void 0 : t.length) && (r = this._tempTargets[n].pop()), r ? this._setTargetOptions(r, e) : (r = this.createTarget(e), this._processNewTempTarget(r, n)), r;
    }

    _processNewTempTarget(e, t) {
      return e.isTemporary = !0, e.targetKey = t, void 0 === this._tempTargets[t] && (this._tempTargets[t] = []), e;
    }

    releaseTempTarget(e) {
      const t = e.targetKey;
      if (!t || !e.isTemporary) throw "Not a temp target";
      this._tempTargets[t].length > this.maxTempPerKey ? e.dispose() : this._tempTargets[t].push(e);
    }

    updateShaderProperties(e) {
      return e.uniforms.frameCount ? e.uniforms.frameCount.value = this.frameCount : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }

    _setTargetOptions(e, t) {
      var n, r, s;
      e.texture.minFilter = null !== (n = t.minFilter) && void 0 !== n ? n : i.wem, e.texture.magFilter = null !== (r = t.magFilter) && void 0 !== r ? r : i.wem, e.texture.generateMipmaps = null !== (s = t.generateMipmaps) && void 0 !== s && s, e.texture.generateMipmaps && e.texture.minFilter === i.wem && (e.texture.minFilter = i.FDw), e.texture.generateMipmaps || e.texture.minFilter !== i.FDw || (e.texture.minFilter = i.wem);
    }

  }

  function Z(e = {}) {
    var t, n;
    return [e.sizeMultiplier, e.isAntialiased, e.encoding, e.type, e.format, e.depthBuffer, e.depthTexture, null === (t = e.size) || void 0 === t ? void 0 : t.width, null === (n = e.size) || void 0 === n ? void 0 : n.height].join(";");
  }

  const J = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];

  function $() {
    const e = 4294967295 * Math.random() | 0,
          t = 4294967295 * Math.random() | 0,
          n = 4294967295 * Math.random() | 0,
          r = 4294967295 * Math.random() | 0;
    return (J[255 & e] + J[e >> 8 & 255] + J[e >> 16 & 255] + J[e >> 24 & 255] + "-" + J[255 & t] + J[t >> 8 & 255] + "-" + J[t >> 16 & 15 | 64] + J[t >> 24 & 255] + "-" + J[63 & n | 128] + J[n >> 8 & 255] + "-" + J[n >> 16 & 255] + J[n >> 24 & 255] + J[255 & r] + J[r >> 8 & 255] + J[r >> 16 & 255] + J[r >> 24 & 255]).toLowerCase();
  }

  function Q(e, t, n) {
    return Math.max(t, Math.min(n, e));
  }

  function ee(e, t, n) {
    return (1 - n) * e + n * t;
  }

  Math.PI, Math.PI;
  const te = 0,
        ne = 1,
        re = 3,
        ie = 4,
        se = 1006,
        oe = "srgb",
        ae = "srgb-linear";

  function le(e) {
    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
  }

  function ce(e) {
    return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055;
  }

  const ue = {
    [oe]: {
      [ae]: le
    },
    [ae]: {
      [oe]: ce
    }
  },
        pe = {
    legacyMode: !0,

    get workingColorSpace() {
      return ae;
    },

    set workingColorSpace(e) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },

    convert: function (e, t, n) {
      if (this.legacyMode || t === n || !t || !n) return e;

      if (ue[t] && void 0 !== ue[t][n]) {
        const r = ue[t][n];
        return e.r = r(e.r), e.g = r(e.g), e.b = r(e.b), e;
      }

      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function (e, t) {
      return this.convert(e, this.workingColorSpace, t);
    },
    toWorkingColorSpace: function (e, t) {
      return this.convert(e, t, this.workingColorSpace);
    }
  },
        he = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  },
        de = {
    r: 0,
    g: 0,
    b: 0
  },
        fe = {
    h: 0,
    s: 0,
    l: 0
  },
        _e = {
    h: 0,
    s: 0,
    l: 0
  };

  function me(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e;
  }

  function ge(e, t) {
    return t.r = e.r, t.g = e.g, t.b = e.b, t;
  }

  class ve {
    constructor(e, t, n) {
      return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n);
    }

    set(e) {
      return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this;
    }

    setScalar(e) {
      return this.r = e, this.g = e, this.b = e, this;
    }

    setHex(e, t = "srgb") {
      return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, pe.toWorkingColorSpace(this, t), this;
    }

    setRGB(e, t, n, r = "srgb-linear") {
      return this.r = e, this.g = t, this.b = n, pe.toWorkingColorSpace(this, r), this;
    }

    setHSL(e, t, n, r = "srgb-linear") {
      if (e = function (e, t) {
        return (e % t + t) % t;
      }(e, 1), t = Q(t, 0, 1), n = Q(n, 0, 1), 0 === t) this.r = this.g = this.b = n;else {
        const r = n <= .5 ? n * (1 + t) : n + t - n * t,
              i = 2 * n - r;
        this.r = me(i, r, e + 1 / 3), this.g = me(i, r, e), this.b = me(i, r, e - 1 / 3);
      }
      return pe.toWorkingColorSpace(this, r), this;
    }

    setStyle(e, t = "srgb") {
      function n(t) {
        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
      }

      let r;

      if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
        let e;
        const i = r[1],
              s = r[2];

        switch (i) {
          case "rgb":
          case "rgba":
            if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, pe.toWorkingColorSpace(this, t), n(e[4]), this;
            if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, pe.toWorkingColorSpace(this, t), n(e[4]), this;
            break;

          case "hsl":
          case "hsla":
            if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
              const r = parseFloat(e[1]) / 360,
                    i = parseInt(e[2], 10) / 100,
                    s = parseInt(e[3], 10) / 100;
              return n(e[4]), this.setHSL(r, i, s, t);
            }

        }
      } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
        const e = r[1],
              n = e.length;
        if (3 === n) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, pe.toWorkingColorSpace(this, t), this;
        if (6 === n) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, pe.toWorkingColorSpace(this, t), this;
      }

      return e && e.length > 0 ? this.setColorName(e, t) : this;
    }

    setColorName(e, t = "srgb") {
      const n = he[e.toLowerCase()];
      return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
    }

    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }

    copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }

    copySRGBToLinear(e) {
      return this.r = le(e.r), this.g = le(e.g), this.b = le(e.b), this;
    }

    copyLinearToSRGB(e) {
      return this.r = ce(e.r), this.g = ce(e.g), this.b = ce(e.b), this;
    }

    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }

    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }

    getHex(e = "srgb") {
      return pe.fromWorkingColorSpace(ge(this, de), e), Q(255 * de.r, 0, 255) << 16 ^ Q(255 * de.g, 0, 255) << 8 ^ Q(255 * de.b, 0, 255) << 0;
    }

    getHexString(e = "srgb") {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }

    getHSL(e, t = "srgb-linear") {
      pe.fromWorkingColorSpace(ge(this, de), t);
      const n = de.r,
            r = de.g,
            i = de.b,
            s = Math.max(n, r, i),
            o = Math.min(n, r, i);
      let a, l;
      const c = (o + s) / 2;
      if (o === s) a = 0, l = 0;else {
        const e = s - o;

        switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
          case n:
            a = (r - i) / e + (r < i ? 6 : 0);
            break;

          case r:
            a = (i - n) / e + 2;
            break;

          case i:
            a = (n - r) / e + 4;
        }

        a /= 6;
      }
      return e.h = a, e.s = l, e.l = c, e;
    }

    getRGB(e, t = "srgb-linear") {
      return pe.fromWorkingColorSpace(ge(this, de), t), e.r = de.r, e.g = de.g, e.b = de.b, e;
    }

    getStyle(e = "srgb") {
      return pe.fromWorkingColorSpace(ge(this, de), e), e !== oe ? `color(${e} ${de.r} ${de.g} ${de.b})` : `rgb(${255 * de.r | 0},${255 * de.g | 0},${255 * de.b | 0})`;
    }

    offsetHSL(e, t, n) {
      return this.getHSL(fe), fe.h += e, fe.s += t, fe.l += n, this.setHSL(fe.h, fe.s, fe.l), this;
    }

    add(e) {
      return this.r += e.r, this.g += e.g, this.b += e.b, this;
    }

    addColors(e, t) {
      return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
    }

    addScalar(e) {
      return this.r += e, this.g += e, this.b += e, this;
    }

    sub(e) {
      return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
    }

    multiply(e) {
      return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
    }

    multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this;
    }

    lerp(e, t) {
      return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
    }

    lerpColors(e, t, n) {
      return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
    }

    lerpHSL(e, t) {
      this.getHSL(fe), e.getHSL(_e);
      const n = ee(fe.h, _e.h, t),
            r = ee(fe.s, _e.s, t),
            i = ee(fe.l, _e.l, t);
      return this.setHSL(n, r, i), this;
    }

    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }

    fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }

    toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }

    fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }

    toJSON() {
      return this.getHex();
    }

    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }

  }

  ve.NAMES = he;
  const be = new Map();

  function xe(e) {
    return (t, n) => {
      const r = t.constructor;
      if (r === Object) throw new Error("All properties in an object are serialized by default");
      be.has(r) || be.set(r, []), be.get(r).push([e || n, n]);
    };
  }

  const ye = {
    obj: (e, t) => Object.fromEntries(Object.entries(e).map(([e, n]) => [e, Me(n, !1, t)])),
    vec4: e => ({
      x: e.x,
      y: e.y,
      z: e.z,
      w: e.w,
      isVector4: !0
    }),
    vec3: e => ({
      x: e.x,
      y: e.y,
      z: e.z,
      isVector3: !0
    }),
    vec2: e => ({
      x: e.x,
      y: e.y,
      isVector2: !0
    }),
    color: e => ({
      r: e.r,
      g: e.g,
      b: e.b,
      isColor: !0
    }),
    quat: e => ({
      x: e.x,
      y: e.y,
      z: e.z,
      w: e.w,
      isQuaternion: !0
    }),
    texture: (e, t) => {
      if (!(null == e ? void 0 : e.isTexture)) throw new Error("Expected a texture");
      if (e.isRenderTargetTexture) return;
      if (null == t ? void 0 : t.textures[e.uuid]) return {
        uuid: e.uuid,
        resource: "textures"
      };
      const n = e.source.data;
      e.userData.rootPath && (e.source.data = null);
      let r = e.toJSON(t);
      return e.userData.rootPath && (delete t.images[e.source.uuid], e.source.data = n), (null == t ? void 0 : t.textures) && (t.textures[r.uuid] || (t.textures[r.uuid] = r), r = {
        uuid: r.uuid,
        resource: "textures"
      }), r;
    },
    material: (e, t) => {
      var n;
      if (!(null == e ? void 0 : e.isMaterial)) throw new Error("Expected a material");
      if (null == t ? void 0 : t.materials[e.uuid]) return {
        uuid: e.uuid,
        resource: "materials"
      };
      e.userData.rootPath && console.error("TODO: handle material with root path");
      const r = null != t ? t : {
        textures: {},
        images: {}
      },
            i = {},
            s = {};

      for (const [t, o] of Object.entries(e)) if ((null === (n = o) || void 0 === n ? void 0 : n.isTexture) && !t.startsWith("_")) {
        const n = ye.texture(o, r);
        i[t] = n, s[t] = o, e[t] = n ? {
          isTexture: !0,
          toJSON: () => n
        } : null;
      }

      let o = e.toJSON(t);

      for (const [t, n] of Object.entries(s)) e[t] = n, delete s[t];

      if (t) {
        for (const [e, t] of Object.entries(i)) t && (o[e] = t);

        (null == t ? void 0 : t.materials) && (t.materials[o.uuid] || (t.materials[o.uuid] = o), o = {
          uuid: o.uuid,
          resource: "materials"
        });
      } else {
        for (const [e, t] of Object.entries(i)) o[e] = t.uuid;

        o.textures = Object.values(r.textures), o.images = Object.values(r.images);
      }

      return o;
    }
  },
        we = e => (t, n) => {
    var r, i;
    return null !== (i = null === (r = null == n ? void 0 : n.copy) || void 0 === r ? void 0 : r.call(n, t)) && void 0 !== i ? i : new e().copy(t);
  },
        Se = {
    obj: (e, t, n) => Object.assign(t, Object.fromEntries(Object.entries(e).map(([e, r]) => [e, Te(r, null == t ? void 0 : t[e], !1, n)]))),
    vec4: we(i.Ltg),
    vec3: we(i.Pa4),
    vec2: we(k),
    color: we(ve),
    quat: we(i._fP)
  };

  function Me(e, t, n) {
    var r, i;
    if ("function" == typeof e) return;
    if (Array.isArray(e)) return e.map(e => Me(e, !1, n));

    if ("object" != typeof e) {
      if ("number" == typeof e) {
        if (e === 1 / 0) return "Infinity";
        if (e === -1 / 0) return "-Infinity";
        if (isNaN(e)) return "NaN";
      }

      return e;
    }

    if (!e) return e;
    let s = null !== (r = e.constructor) && void 0 !== r ? r : Object;
    if (s === Object) return ye.obj(e, n);
    if (e.isVector2) return ye.vec2(e);
    if (e.isVector3) return ye.vec3(e);
    if (e.isVector4) return ye.vec4(e);
    if (e.isColor) return ye.color(e);
    if (e.isQuaternion) return ye.quat(e);
    if (e.isTexture) return ye.texture(e, n);
    if (e.isMaterial) return ye.material(e, n);
    if (!t && "function" == typeof e.toJSON) return e.toJSON(n);
    const o = {};

    for (; s && s !== Object;) null === (i = be.get(s)) || void 0 === i || i.forEach(([t, r]) => {
      const i = e[r];
      o[t] = Me(i, !1, n);
    }), s = Object.getPrototypeOf(s);

    return e.serializableClassId && (o.serializableClassId = e.serializableClassId), o;
  }

  function Te(e, t, n, r) {
    var i, s, o;
    let a = t;
    if (void 0 === e) return a;

    if ("number" == typeof t) {
      if ("Infinity" === e) return 1 / 0;
      if ("-Infinity" === e) return -1 / 0;
      if ("NaN" === e) return NaN;
      if ("number" == typeof e || !e) return e;
    }

    if (Array.isArray(e)) {
      const t = e.length;
      Array.isArray(a) || (a = []);

      for (let n = 0; n < t; n++) {
        const t = e[n],
              i = a.length > n ? Te(t, a[n], !1, r) : Te(t, void 0, !1, r);
        a.length <= n ? a.push(i) : a[n] = i;
      }

      return a;
    }

    let l = !1;
    if (e && e.resource && "string" == typeof e.resource && (e = null === (i = r[e.resource]) || void 0 === i ? void 0 : i[e.uuid], l = !0), !a && e && !l) if (e.serializableClassId) {
      const t = Ee.get(e.serializableClassId);
      t && (a = new t());
    } else "object" != typeof e || e.constructor && e.constructor !== Object || (a = {});
    if ("function" == typeof a) return console.error("cannot deserialize over function", a, e), a;

    if (e && "object" == typeof e) {
      if (e.isVector2) return Se.vec2(e, a);
      if (e.isVector3) return Se.vec3(e, a);
      if (e.isVector4) return Se.vec4(e, a);
      if (e.isColor) return Se.color(e, a);
      if (e.isQuaternion) return Se.quat(e, a);
    }

    if (null == e || null == a || "object" != typeof a || a.isTexture) return l && (e ? e.__useCount = e.__useCount ? e.__useCount + 1 : 1 : console.warn("probable error deserialize: resource not found.")), e;
    let c = null !== (s = a.constructor) && void 0 !== s ? s : Object;
    if (c === Object) return Se.obj(e, a, r);
    if (!n && "function" == typeof a.fromJSON) return a.isMaterial && Object.entries(e).forEach(([t, n]) => {
      var i;
      if (!n || !n.resource || "string" != typeof n.resource) return;
      const s = null === (i = r[n.resource]) || void 0 === i ? void 0 : i[n.uuid];
      e[t] = s || null;
    }), a.fromJSON(e, r), a;

    for (; c && c !== Object;) null === (o = be.get(c)) || void 0 === o || o.forEach(([t, n]) => {
      const i = a[n],
            s = Te(e[t], i, !1, r);
      s !== i && g(a, n, s, !0);
    }), c = Object.getPrototypeOf(c);

    return a;
  }

  const Ee = new Map();

  function Ae(e) {
    return t => (t = class extends t {
      constructor() {
        super(...arguments), this.serializableClassId = e;
      }

    }, Ee.set(e, t), t);
  }

  const Ce = {
    type: "change"
  },
        Re = {
    type: "start"
  },
        ke = {
    type: "end"
  };

  class Pe extends i.pBf {
    constructor(e, t) {
      super(), void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new i.Pa4(), this.minDistance = .01, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.maxZoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown"
      }, this.mouseButtons = {
        LEFT: i.RsA.ROTATE,
        MIDDLE: i.RsA.DOLLY,
        RIGHT: i.RsA.PAN
      }, this.touches = {
        ONE: i.QmN.ROTATE,
        TWO: i.QmN.DOLLY_PAN
      }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
        return a.phi;
      }, this.getAzimuthalAngle = function () {
        return a.theta;
      }, this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }, this.listenToKeyEvents = function (e) {
        e.addEventListener("keydown", H), this._domElementKeyEvents = e;
      }, this.saveState = function () {
        n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
      }, this.reset = function () {
        n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(Ce), n.update(), s = r.NONE;
      }, this.update = function () {
        const t = new i.Pa4(),
              h = new i._fP().setFromUnitVectors(e.up, new i.Pa4(0, 1, 0)),
              d = h.clone().invert(),
              f = new i.Pa4(),
              _ = new i._fP(),
              m = 2 * Math.PI;

        return function () {
          const e = n.object.position;
          t.copy(e).sub(n.target), t.applyQuaternion(h), a.setFromVector3(t), n.autoRotate && s === r.NONE && M(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (a.theta += l.theta * n.dampingFactor, a.phi += l.phi * n.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
          let i = n.minAzimuthAngle,
              g = n.maxAzimuthAngle;
          isFinite(i) && isFinite(g) && (i < -Math.PI ? i += m : i > Math.PI && (i -= m), g < -Math.PI ? g += m : g > Math.PI && (g -= m), a.theta = i <= g ? Math.max(i, Math.min(g, a.theta)) : a.theta > (i + g) / 2 ? Math.max(i, a.theta) : Math.min(g, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), n.enableDamping && (a.radius *= 1 + l.radius * n.dampingFactor), a.radius *= c, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), t.setFromSpherical(a), t.applyQuaternion(d), e.copy(n.target).add(t), n.object.lookAt(n.target);
          let v = !1;
          return !0 === n.enableDamping && Math.abs(l.theta) + Math.abs(l.phi) + Math.abs(l.radius) + u.length() > .001 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, l.radius *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor), v = !0) : (l.set(0, 0, 0), u.set(0, 0, 0)), c = 1, !!(p || v || f.distanceToSquared(n.object.position) > o || 8 * (1 - _.dot(n.object.quaternion)) > o) && (n.dispatchEvent(Ce), f.copy(n.object.position), _.copy(n.object.quaternion), p = !1, !0);
        };
      }(), this.stopDamping = function () {
        l.set(0, 0, 0), u.set(0, 0, 0);
      }, this.dispose = function () {
        n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", B), n.domElement.removeEventListener("pointercancel", V), n.domElement.removeEventListener("wheel", G), n.domElement.removeEventListener("pointermove", j), n.domElement.removeEventListener("pointerup", z), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", H);
      };
      const n = this,
            r = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let s = r.NONE;
      const o = 1e-6,
            a = new i.$V(),
            l = new i.$V();
      let c = 1;
      const u = new i.Pa4();
      let p = !1;

      const h = new i.FM8(),
            d = new i.FM8(),
            f = new i.FM8(),
            _ = new i.FM8(),
            m = new i.FM8(),
            g = new i.FM8(),
            v = new i.FM8(),
            b = new i.FM8(),
            x = new i.FM8(),
            y = [],
            w = {};

      function S() {
        return n.enableDamping ? 1 : Math.pow(.95, n.zoomSpeed);
      }

      function M(e) {
        l.theta -= e;
      }

      function T(e) {
        l.phi -= e;
      }

      this.rotateUp = T, this.rotateLeft = M;

      const E = function () {
        const e = new i.Pa4();
        return function (t, n) {
          e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), u.add(e);
        };
      }(),
            A = function () {
        const e = new i.Pa4();
        return function (t, r) {
          !0 === n.screenSpacePanning ? e.setFromMatrixColumn(r, 1) : (e.setFromMatrixColumn(r, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), u.add(e);
        };
      }(),
            C = function () {
        const e = new i.Pa4();
        return function (t, r) {
          const i = n.domElement;

          if (n.object.isPerspectiveCamera) {
            const s = n.object.position;
            e.copy(s).sub(n.target);
            let o = e.length();
            o *= Math.tan(n.object.fov / 2 * Math.PI / 180), E(2 * t * o / i.clientHeight, n.object.matrix), A(2 * r * o / i.clientHeight, n.object.matrix);
          } else n.object.isOrthographicCamera ? (E(t * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), A(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
        };
      }();

      function R(e, t = 0) {
        n.object.isPerspectiveCamera ? (c /= e, l.radius -= t, l.radius = Math.max(-n.maxZoomSpeed, Math.min(n.maxZoomSpeed, l.radius))) : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * e)), n.object.updateProjectionMatrix(), p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
      }

      function k(e, t = 0) {
        n.object.isPerspectiveCamera ? (c *= e, l.radius += t, l.radius = Math.max(-n.maxZoomSpeed, Math.min(n.maxZoomSpeed, l.radius))) : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / e)), n.object.updateProjectionMatrix(), p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
      }

      function P(e) {
        h.set(e.clientX, e.clientY);
      }

      function D(e) {
        _.set(e.clientX, e.clientY);
      }

      function O() {
        if (1 === y.length) h.set(y[0].pageX, y[0].pageY);else {
          const e = .5 * (y[0].pageX + y[1].pageX),
                t = .5 * (y[0].pageY + y[1].pageY);
          h.set(e, t);
        }
      }

      function L() {
        if (1 === y.length) _.set(y[0].pageX, y[0].pageY);else {
          const e = .5 * (y[0].pageX + y[1].pageX),
                t = .5 * (y[0].pageY + y[1].pageY);

          _.set(e, t);
        }
      }

      function I() {
        const e = y[0].pageX - y[1].pageX,
              t = y[0].pageY - y[1].pageY,
              n = Math.sqrt(e * e + t * t);
        v.set(0, n);
      }

      function F(e) {
        if (1 == y.length) d.set(e.pageX, e.pageY);else {
          const t = q(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
          d.set(n, r);
        }
        f.subVectors(d, h).multiplyScalar(n.rotateSpeed);
        const t = n.domElement;
        M(2 * Math.PI * f.x / t.clientHeight), T(2 * Math.PI * f.y / t.clientHeight), h.copy(d);
      }

      function N(e) {
        if (1 === y.length) m.set(e.pageX, e.pageY);else {
          const t = q(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
          m.set(n, r);
        }
        g.subVectors(m, _).multiplyScalar(n.panSpeed), C(g.x, g.y), _.copy(m);
      }

      function U(e) {
        const t = q(e),
              r = e.pageX - t.x,
              i = e.pageY - t.y,
              s = Math.sqrt(r * r + i * i);
        b.set(0, s), x.set(0, Math.pow(b.y / v.y, n.zoomSpeed)), R(x.y), v.copy(b);
      }

      function B(e) {
        !1 !== n.enabled && (0 === y.length && (n.domElement.setPointerCapture(e.pointerId), n.domElement.addEventListener("pointermove", j), n.domElement.addEventListener("pointerup", z)), function (e) {
          y.push(e);
        }(e), "touch" === e.pointerType ? function (e) {
          switch (X(e), y.length) {
            case 1:
              switch (n.touches.ONE) {
                case i.QmN.ROTATE:
                  if (!1 === n.enableRotate) return;
                  O(), s = r.TOUCH_ROTATE;
                  break;

                case i.QmN.PAN:
                  if (!1 === n.enablePan) return;
                  L(), s = r.TOUCH_PAN;
                  break;

                default:
                  s = r.NONE;
              }

              break;

            case 2:
              switch (n.touches.TWO) {
                case i.QmN.DOLLY_PAN:
                  if (!1 === n.enableZoom && !1 === n.enablePan) return;
                  n.enableZoom && I(), n.enablePan && L(), s = r.TOUCH_DOLLY_PAN;
                  break;

                case i.QmN.DOLLY_ROTATE:
                  if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                  n.enableZoom && I(), n.enableRotate && O(), s = r.TOUCH_DOLLY_ROTATE;
                  break;

                default:
                  s = r.NONE;
              }

              break;

            default:
              s = r.NONE;
          }

          s !== r.NONE && n.dispatchEvent(Re);
        }(e) : function (e) {
          let t;

          switch (e.button) {
            case 0:
              t = n.mouseButtons.LEFT;
              break;

            case 1:
              t = n.mouseButtons.MIDDLE;
              break;

            case 2:
              t = n.mouseButtons.RIGHT;
              break;

            default:
              t = -1;
          }

          switch (t) {
            case i.RsA.DOLLY:
              if (!1 === n.enableZoom) return;
              !function (e) {
                v.set(e.clientX, e.clientY);
              }(e), s = r.DOLLY;
              break;

            case i.RsA.ROTATE:
              if (e.ctrlKey || e.metaKey || e.shiftKey) {
                if (!1 === n.enablePan) return;
                D(e), s = r.PAN;
              } else {
                if (!1 === n.enableRotate) return;
                P(e), s = r.ROTATE;
              }

              break;

            case i.RsA.PAN:
              if (e.ctrlKey || e.metaKey || e.shiftKey) {
                if (!1 === n.enableRotate) return;
                P(e), s = r.ROTATE;
              } else {
                if (!1 === n.enablePan) return;
                D(e), s = r.PAN;
              }

              break;

            default:
              s = r.NONE;
          }

          s !== r.NONE && n.dispatchEvent(Re);
        }(e));
      }

      function j(e) {
        !1 !== n.enabled && ("touch" === e.pointerType ? function (e) {
          switch (X(e), s) {
            case r.TOUCH_ROTATE:
              if (!1 === n.enableRotate) return;
              F(e), n.update();
              break;

            case r.TOUCH_PAN:
              if (!1 === n.enablePan) return;
              N(e), n.update();
              break;

            case r.TOUCH_DOLLY_PAN:
              if (!1 === n.enableZoom && !1 === n.enablePan) return;
              !function (e) {
                n.enableZoom && U(e), n.enablePan && N(e);
              }(e), n.update();
              break;

            case r.TOUCH_DOLLY_ROTATE:
              if (!1 === n.enableZoom && !1 === n.enableRotate) return;
              !function (e) {
                n.enableZoom && U(e), n.enableRotate && F(e);
              }(e), n.update();
              break;

            default:
              s = r.NONE;
          }
        }(e) : function (e) {
          switch (s) {
            case r.ROTATE:
              if (!1 === n.enableRotate) return;
              !function (e) {
                d.set(e.clientX, e.clientY), f.subVectors(d, h).multiplyScalar(n.rotateSpeed);
                const t = n.domElement;
                M(2 * Math.PI * f.x / t.clientHeight), T(2 * Math.PI * f.y / t.clientHeight), h.copy(d), n.update();
              }(e);
              break;

            case r.DOLLY:
              if (!1 === n.enableZoom) return;
              !function (e) {
                b.set(e.clientX, e.clientY), x.subVectors(b, v), x.y > 0 ? R(S()) : x.y < 0 && k(S()), v.copy(b), n.update();
              }(e);
              break;

            case r.PAN:
              if (!1 === n.enablePan) return;
              !function (e) {
                m.set(e.clientX, e.clientY), g.subVectors(m, _).multiplyScalar(n.panSpeed), C(g.x, g.y), _.copy(m), n.update();
              }(e);
          }
        }(e));
      }

      function z(e) {
        K(e), 0 === y.length && (n.domElement.releasePointerCapture(e.pointerId), n.domElement.removeEventListener("pointermove", j), n.domElement.removeEventListener("pointerup", z)), n.dispatchEvent(ke), s = r.NONE;
      }

      function V(e) {
        K(e);
      }

      function G(e) {
        !1 !== n.enabled && !1 !== n.enableZoom && s === r.NONE && (e.preventDefault(), n.dispatchEvent(Re), function (e) {
          let t = 0;

          switch (e.deltaMode) {
            case 2:
              t += 1 * e.deltaY;
              break;

            case 1:
              t += .4 * e.deltaY;
              break;

            default:
              t += .01 * e.deltaY;
          }

          e.deltaY < 0 ? k(S(), t * n.zoomSpeed) : e.deltaY > 0 && R(S(), -t * n.zoomSpeed), n.update();
        }(e), n.dispatchEvent(ke));
      }

      function H(e) {
        !1 !== n.enabled && !1 !== n.enablePan && function (e) {
          let t = !1;

          switch (e.code) {
            case n.keys.UP:
              C(0, n.keyPanSpeed), t = !0;
              break;

            case n.keys.BOTTOM:
              C(0, -n.keyPanSpeed), t = !0;
              break;

            case n.keys.LEFT:
              C(n.keyPanSpeed, 0), t = !0;
              break;

            case n.keys.RIGHT:
              C(-n.keyPanSpeed, 0), t = !0;
          }

          t && (e.preventDefault(), n.update());
        }(e);
      }

      function W(e) {
        !1 !== n.enabled && e.preventDefault();
      }

      function K(e) {
        delete w[e.pointerId];

        for (let t = 0; t < y.length; t++) if (y[t].pointerId == e.pointerId) return void y.splice(t, 1);
      }

      function X(e) {
        let t = w[e.pointerId];
        void 0 === t && (t = new i.FM8(), w[e.pointerId] = t), t.set(e.pageX, e.pageY);
      }

      function q(e) {
        const t = e.pointerId === y[0].pointerId ? y[1] : y[0];
        return w[t.pointerId];
      }

      this.zoomIn = function (e) {
        R(S(), e * n.zoomSpeed);
      }, this.zoomOut = function (e) {
        k(S(), e * n.zoomSpeed);
      }, n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", B), n.domElement.addEventListener("pointercancel", V), n.domElement.addEventListener("wheel", G, {
        passive: !1
      }), this.update();
    }

  }

  var De,
      Oe = new Uint8Array(16);

  function Le() {
    if (!De && !(De = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return De(Oe);
  }

  for (var Ie = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Fe = function (e) {
    return "string" == typeof e && Ie.test(e);
  }, Ne = [], Ue = 0; Ue < 256; ++Ue) Ne.push((Ue + 256).toString(16).substr(1));

  var Be = function (e, t, n) {
    var r = (e = e || {}).random || (e.rng || Le)();

    if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
      n = n || 0;

      for (var i = 0; i < 16; ++i) t[n + i] = r[i];

      return t;
    }

    return function (e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          n = (Ne[e[t + 0]] + Ne[e[t + 1]] + Ne[e[t + 2]] + Ne[e[t + 3]] + "-" + Ne[e[t + 4]] + Ne[e[t + 5]] + "-" + Ne[e[t + 6]] + Ne[e[t + 7]] + "-" + Ne[e[t + 8]] + Ne[e[t + 9]] + "-" + Ne[e[t + 10]] + Ne[e[t + 11]] + Ne[e[t + 12]] + Ne[e[t + 13]] + Ne[e[t + 14]] + Ne[e[t + 15]]).toLowerCase();
      if (!Fe(n)) throw TypeError("Stringified UUID is invalid");
      return n;
    }(r);
  };

  const je = new Map();

  function ze(e, t) {
    return (n, r) => {
      const i = n.constructor;
      if (i === Object) throw new Error("All properties in an object are serialized by default");
      je.has(i) || je.set(i, []);
      const s = je.get(i);
      if (!(s.findIndex(e => e.propKey === r) < 0)) throw new Error(`Property ${r} already has a uiConfig decorator`);
      s.push({
        params: t || {},
        propKey: r,
        uiType: e
      });
    };
  }

  function Ve(e, t) {
    return ze("checkbox", {
      label: e,
      params: t
    });
  }

  function Ge(e, t) {
    return ze("monitor", {
      label: e,
      params: t
    });
  }

  function He(e, t, n, r) {
    return ze("slider", {
      label: e,
      bounds: t,
      stepSize: n,
      params: r
    });
  }

  function We(e, t, n, r) {
    return ze("vec", {
      label: e,
      bounds: t,
      stepSize: n,
      params: r
    });
  }

  function Ke(e, t, n) {
    return ze("dropdown", {
      label: e,
      children: t,
      params: n
    });
  }

  function Xe(e, t) {
    return ze("button", {
      label: e,
      params: t
    });
  }

  function qe(e, t) {
    return ze("input", {
      label: e,
      params: t
    });
  }

  function Ye(e, t) {
    return ze("color", {
      label: e,
      params: t
    });
  }

  function Ze(e, t) {
    return ze("image", {
      label: e,
      params: t
    });
  }

  function Je(e) {
    let t = null == e ? void 0 : e.constructor;
    if (!e || !t) return [];
    const n = [],
          r = [];

    for (; t && t !== Object;) r.push(t), t = Object.getPrototypeOf(t);

    return r.reverse().forEach(t => {
      var r;
      null === (r = je.get(t)) || void 0 === r || r.forEach(({
        params: t,
        propKey: r,
        uiType: i
      }) => {
        var s;
        let o;

        if (i || (o = null === (s = e[r]) || void 0 === s ? void 0 : s.uiConfig), o || (o = {
          property: [e, r],
          type: i || "input"
        }), t) {
          const n = "function" == typeof t.params ? t.params(e) : t.params || {};
          delete t.params, Object.assign(o, { ...t,
            ...n
          });
        }

        n.push(o);
      });
    }), n;
  }

  function $e(e, t, n = {}) {
    return {
      type: "folder",
      label: e,
      children: Je(t),
      uuid: Be(),
      ...n
    };
  }

  function Qe(e, t) {
    return n => class extends n {
      constructor() {
        super(...arguments), this.uiConfig = $e(e, this, t || {});
      }

    };
  }

  var et = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let tt = class extends Pe {
    constructor() {
      super(...arguments), this.type = "OrbitControls", this.enableDamping = !0, this.dampingFactor = .08, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableZoom = !0, this.zoomSpeed = .15, this.maxZoomSpeed = .2, this.enableRotate = !0, this.rotateSpeed = 2, this.enablePan = !0, this.panSpeed = 1, this.minDistance = .01, this.maxDistance = 1e3, this.minZoom = .01, this.maxZoom = 1e3, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1e4, this.maxAzimuthAngle = 1e4, this.screenSpacePanning = !0, this.keyPanSpeed = 7;
    }

    zoomIn(e) {
      super.zoomIn(e);
    }

    zoomOut(e) {
      super.zoomOut(e);
    }

  };
  et([xe()], tt.prototype, "type", void 0), et([Ve(), xe()], tt.prototype, "enableDamping", void 0), et([qe(), xe()], tt.prototype, "dampingFactor", void 0), et([Ve(), xe()], tt.prototype, "autoRotate", void 0), et([qe(), xe()], tt.prototype, "autoRotateSpeed", void 0), et([Ve(), xe()], tt.prototype, "enableZoom", void 0), et([qe(), xe()], tt.prototype, "zoomSpeed", void 0), et([qe(), xe()], tt.prototype, "maxZoomSpeed", void 0), et([Ve(), xe()], tt.prototype, "enableRotate", void 0), et([qe(), xe()], tt.prototype, "rotateSpeed", void 0), et([Ve(), xe()], tt.prototype, "enablePan", void 0), et([qe(), xe()], tt.prototype, "panSpeed", void 0), et([qe(), xe()], tt.prototype, "minDistance", void 0), et([qe(), xe()], tt.prototype, "maxDistance", void 0), et([qe(), xe()], tt.prototype, "minZoom", void 0), et([qe(), xe()], tt.prototype, "maxZoom", void 0), et([qe(), xe()], tt.prototype, "minPolarAngle", void 0), et([qe(), xe()], tt.prototype, "maxPolarAngle", void 0), et([qe(), xe()], tt.prototype, "minAzimuthAngle", void 0), et([qe(), xe()], tt.prototype, "maxAzimuthAngle", void 0), et([xe()], tt.prototype, "screenSpacePanning", void 0), et([xe()], tt.prototype, "keyPanSpeed", void 0), tt = et([Qe("Orbit Controls")], tt);

  class nt extends r {
    constructor(e, t, n) {
      super(), this._controlsMode = "", this._isActiveCamera = !1, this._interactionsEnabled = !0, this.autoLookAtTarget = !0, this.near = .01, this.far = 50, this._options = {
        type: "PerspectiveCamera",
        aspect: "auto",
        focus: 10,
        fov: 25,
        zoom: 1,
        frustumSize: 1,
        top: 1,
        bottom: -1,
        left: -1,
        right: 1,
        controlsMode: "orbit",
        controlsEnabled: !0
      }, this._position = new i.Pa4(0, 0, 10), this._target = new i.Pa4(0, 0, 0), this.uiConfig = {
        type: "folder",
        label: "Camera",
        limitedUi: !0,
        children: [{
          type: "input",
          property: [this._options, "fov"],
          onChange: () => {
            this.refreshCameraOptions();
          },
          limitedUi: !0
        }, {
          type: "button",
          label: "Zoom in",
          value: () => {
            var e;
            null === (e = this._controls) || void 0 === e || e.zoomIn(1);
          }
        }, {
          type: "button",
          label: "Zoom out",
          value: () => {
            var e;
            null === (e = this._controls) || void 0 === e || e.zoomOut(1);
          }
        }, () => {
          var e;
          return null === (e = this._controls) || void 0 === e ? void 0 : e.uiConfig;
        }]
      }, this.assetType = "model", this.setDirty = this.setDirty.bind(this), this.targetUpdated = this.targetUpdated.bind(this), this._refreshCameraOptions = this._refreshCameraOptions.bind(this), this._container = null != n ? n : document.body, this._camera = null != e ? e : "OrthographicCamera" === (null == t ? void 0 : t.type) ? new i.iKG(-1, 1, 1, -1) : new i.cPb(), this._camera.userData.iCamera = this;
      const r = null != t ? t : this._options,
            s = e;
      e && (s.isPerspectiveCamera ? (r.fov = s.fov, r.focus = s.focus, r.aspect = s.aspect <= 0 || s.userData.autoAspect ? "auto" : s.aspect, r.zoom = s.zoom) : s.isOrthographicCamera && (r.left = s.left, r.right = s.right, r.top = s.top, r.bottom = s.bottom, r.zoom = s.zoom), r.near = s.near, r.far = s.far, this._position.copy(e.position), this.refreshTarget()), this.positionUpdated(!1), e || this.targetUpdated(!1), this.setCameraOptions(r), n && (n.style.touchAction = "none");
    }

    get controls() {
      return this._controls;
    }

    get target() {
      return this._target;
    }

    set target(e) {
      const t = this._target.sub(e).length() > .01;
      this._target.copy(e), t && this.targetUpdated();
    }

    get position() {
      return this._position;
    }

    set position(e) {
      const t = this._position.sub(e).length() > .01;
      this._position.copy(e), t && this.positionUpdated();
    }

    getCameraOptions() {
      return { ...this._options
      };
    }

    setCameraOptions(e, t = !0) {
      const n = { ...e
      };
      Object.keys(n).forEach(e => "frustumSize" !== e && void 0 === n[e] && delete n[e]), Object.assign(this._options, n), this._refreshCameraOptions(!1), this.refreshCameraControls(!1), t && this.setDirty();
    }

    _refreshCameraOptions(e = !0) {
      let t = this._camera,
          n = this._options.aspect;

      if ("auto" === n && (n = this._container.clientWidth / this._container.clientHeight), "PerspectiveCamera" === this._options.type && (t.fov = this._options.fov, t.focus = this._options.focus, t.aspect = n), "OrthographicCamera" === this._options.type) {
        const e = this._options.frustumSize;
        void 0 !== e ? (t.top = e / 2, t.bottom = -e / 2, t.left = n * e / 2, t.right = -n * e / 2) : (t.top = this._options.top, t.bottom = this._options.bottom, t.left = this._options.left, t.right = this._options.right);
      }

      t.zoom = this._options.zoom, this._nearFarChanged(), e && this.setDirty();
    }

    get interactionsEnabled() {
      return this._interactionsEnabled && this._isActiveCamera && this._options.controlsEnabled;
    }

    set interactionsEnabled(e) {
      this._interactionsEnabled !== e && (this._interactionsEnabled = e, this.refreshCameraControls(!0));
    }

    _nearFarChanged() {
      this._camera && (this._camera.near = this.near, this._camera.far = this.far, this._camera.updateProjectionMatrix());
    }

    refreshAspect(e = !0) {
      "auto" === this._options.aspect && this._refreshCameraOptions(e);
    }

    refreshTarget() {
      var e;
      (null === (e = this._controls) || void 0 === e ? void 0 : e.enabled) ? this._target.copy(this._controls.target) : this._target.set(0, 0, -1).applyQuaternion(this._camera.getWorldQuaternion(new i._fP()));
    }

    _initCameraControls() {
      const e = this._options.controlsMode;
      "orbit" === e && (this._controls = new tt(this._camera, this._container), this._controls.screenSpacePanning = !0, this._controls.addEventListener("change", this.setDirty)), this._controlsMode = e;
    }

    _disposeCameraControls() {
      var e;
      "orbit" === this._controlsMode && (null === (e = this._controls) || void 0 === e || e.dispose()), this._controlsMode = "", this._controls = void 0;
    }

    refreshCameraControls(e = !0) {
      if (this._options.controlsEnabled) {
        const e = this._options.controlsMode;
        this._controls ? this._controlsMode !== e && (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controlsMode = e;
      }

      if (this._controls) {
        const e = this.interactionsEnabled;
        this._controls.enabled = e, e && this._camera.up.copy(i.Tme.DefaultUp);
      }

      e && this.setDirty();
    }

    setDirty() {
      this._position.copy(this._camera.position), this._controls && this._controls.enabled && this._target.copy(this._controls.target), this.dispatchEvent({
        type: "update"
      });
    }

    activateMain() {
      this._isActiveCamera || (this._isActiveCamera = !0, this.cameraObject.userData.__lastScale = this.cameraObject.scale.clone(), this.cameraObject.scale.divide(this.cameraObject.getWorldScale(new i.Pa4())), this.refreshCameraControls(!0), this.refreshAspect());
    }

    deactivateMain() {
      this._isActiveCamera && (this._isActiveCamera = !1, this.cameraObject.userData.__lastScale && (this.cameraObject.scale.copy(this.cameraObject.userData.__lastScale), delete this.cameraObject.userData.__lastScale), this.refreshCameraControls(!0));
    }

    get cameraObject() {
      return this._camera;
    }

    get modelObject() {
      return this._camera;
    }

    dispose() {}

    targetUpdated(e = !0) {
      var t;
      const n = this.target;
      null === (t = this._controls) || void 0 === t || t.target.set(n.x, n.y, n.z), this._controls && this._controls.enabled ? (this._controls.update(), e && this.setDirty()) : this._camera && (this.autoLookAtTarget && this._camera.lookAt(n), e && this.setDirty());
    }

    positionUpdated(e = !0) {
      const t = this.position;
      this._camera.position.set(t.x, t.y, t.z), e && this.setDirty();
    }

    updateShaderProperties(e) {
      var t;
      return (null === (t = e.uniforms.cameraPositionWorld) || void 0 === t ? void 0 : t.value) && this._camera.getWorldPosition(e.uniforms.cameraPositionWorld.value), e.uniforms.cameraNearFar ? e.uniforms.cameraNearFar.value.set(this._camera.near, this._camera.far) : console.warn("BaseRenderer: no uniform: cameraNearFar"), e.uniforms.projection && (e.uniforms.projection.value = this._camera.projectionMatrix), e.defines.PERSPECTIVE_CAMERA = "PerspectiveCamera" === this._camera.type ? "1" : "0", e.defines.ORTHOGRAPHIC_CAMERA = "OrthographicCamera" === this._camera.type ? "1" : "0", this;
    }

    toJSON(e) {
      return Object.assign({}, Me(this, !0, e));
    }

    fromJSON(e, t) {
      return Te(e, this, !0, t), this.positionUpdated(!1), this.targetUpdated(!1), this.refreshCameraOptions(), this;
    }

    refreshCameraOptions(e = !0) {
      this.setCameraOptions(this._options, e);
    }

  }

  et([xe("camControls")], nt.prototype, "_controls", void 0), et([C(nt.prototype._nearFarChanged)], nt.prototype, "near", void 0), et([C(nt.prototype._nearFarChanged)], nt.prototype, "far", void 0), et([xe("camOptions")], nt.prototype, "_options", void 0), et([xe("position")], nt.prototype, "_position", void 0), et([xe("target")], nt.prototype, "_target", void 0);

  class rt {
    constructor() {
      this._processors = new Map();
    }

    add(e, t) {
      var n;
      this._processors.has(e) || this._processors.set(e, []), null === (n = this._processors.get(e)) || void 0 === n || n.push(t);
    }

    remove(e, t) {
      const n = this._processors.get(e),
            r = (null == n ? void 0 : n.indexOf(t)) || (null == n ? void 0 : n.findIndex(e => e.process && e.process === t.process || e.processAsync && e.processAsync === t.processAsync));

      !n || !r || r < 0 || n.splice(r, 1);
    }

    get(e) {
      var t;
      return null !== (t = this._processors.get(e)) && void 0 !== t ? t : [];
    }

    async process(e, t, n) {
      var r, i, s, o;
      const a = this.get(e),
            l = t.assetType;

      for (const e of a) e.forAssetType === l && (t = null !== (i = null === (r = e.process) || void 0 === r ? void 0 : r.call(e, t, n)) && void 0 !== i ? i : t, t = null !== (o = await (null === (s = e.processAsync) || void 0 === s ? void 0 : s.call(e, t, n))) && void 0 !== o ? o : t);

      return t;
    }

    dispose() {
      this._processors.clear();
    }

  }

  function it(e, t) {
    if (e.uiConfig) return e.uiConfig;
    const n = {
      type: "folder",
      label: e.name || "unnamed",
      expanded: !0,
      limitedUi: !0,
      children: [{
        type: "checkbox",
        label: "Visible",
        property: [e, "visible"],
        limitedUi: !0
      }, {
        type: "button",
        label: "Pick/Focus",
        value: () => {
          e.dispatchEvent({
            type: "select",
            ui: !0,
            value: e
          });
        }
      }, {
        type: "button",
        label: "Pick Parent",
        hidden: () => !e.parent,
        value: () => {
          const t = e.parent;
          t && t.dispatchEvent({
            type: "select",
            ui: !0,
            value: t
          });
        }
      }, {
        type: "input",
        label: "Name",
        property: [e, "name"]
      }, {
        type: "checkbox",
        label: "Casts Shadow",
        hidden: () => !e.isMesh,
        property: [e, "castShadow"]
      }, {
        type: "checkbox",
        label: "Receive Shadow",
        hidden: () => !e.isMesh,
        property: [e, "receiveShadow"]
      }, {
        type: "vec3",
        label: "Position",
        property: [e, "position"],
        limitedUi: !0
      }, {
        type: "vec3",
        label: "Rotation",
        property: [e, "rotation"],
        limitedUi: !0
      }, {
        type: "vec3",
        label: "Scale",
        property: [e, "scale"]
      }, {
        type: "button",
        label: "Auto Scale",
        value: () => {
          const t = parseFloat(prompt("Auto Scale Radius", e.userData.autoScaleRadius || "2") || "0");
          Math.abs(t) > 1e-4 && X(e, t);
        }
      }, void 0 !== e.userData.license ? {
        type: "input",
        label: "License/Credits",
        property: [e.userData, "license"],
        limitedUi: !0
      } : {}]
    },
          r = e;

    if ((null == r ? void 0 : r.isMesh) && !1 !== t) {
      const e = [() => {
        var e;
        return null === (e = r.geometry) || void 0 === e ? void 0 : e.uiConfig;
      }, () => {
        var e;
        return Array.isArray(r.material) ? r.material.length < 1 ? void 0 : {
          label: "Materials",
          type: "folder",
          children: r.material.map(e => null == e ? void 0 : e.uiConfig).filter(e => e)
        } : null === (e = r.material) || void 0 === e ? void 0 : e.uiConfig;
      }];
      n.children.push(...e);
    }

    return e.uiConfig = n, n;
  }

  class st {
    constructor(e, {
      pseudoCenter: t = !1,
      autoScale: n = !1,
      autoScaleRadius: r = 2,
      license: s = "",
      ...o
    } = {}) {
      if (this.assetType = "model", this._modelObject = at(new i.Tme()), this.setDirty = this.setDirty.bind(this), this.updateBounds = this.updateBounds.bind(this), n ? e && !e.userData.autoScaled && X(e, e.userData.autoScaleRadius || r) : e.userData.autoScaled = !0, e && t && !e.userData.pseudoCentered) {
        const t = new P().expandByObject(e, !0, !0).getCenter(new i.Pa4());
        this._modelObject.position.copy(t).negate(), this._modelObject.updateMatrix(), this._modelObject.add(e), this._modelObject.name = e.name + "-centered", this._modelObject.userData.pseudoCentered = !0;
      } else t || (e.userData.pseudoCentered = !0), this._modelObject = e;

      this._modelObject.userData.iModel = this, this._modelObject.userData.setDirty = this.setDirty, this._modelObject.userData.updateBounds = this.updateBounds, this._modelObject.addEventListener("added", this.updateBounds), this._modelObject.addEventListener("removed", this.updateBounds), this.license = s, this.updateBounds();
    }

    get modelObject() {
      return this._modelObject;
    }

    get license() {
      return this._modelObject.userData.license;
    }

    set license(e) {
      this._modelObject.userData.license = e;
    }

    addEventListener(e, t) {
      this._modelObject.addEventListener(e, t);
    }

    dispatchEvent(e) {
      this._modelObject.dispatchEvent(e);
    }

    hasEventListener(e, t) {
      return this._modelObject.hasEventListener(e, t);
    }

    removeEventListener(e, t) {
      this._modelObject.removeEventListener(e, t);
    }

    dispose() {
      const e = this._modelObject.userData.dispose;
      e && "function" == typeof e ? e() : this._modelObject.removeFromParent();
    }

    setDirty(e) {
      var t, n;
      this.dispatchEvent({ ...e,
        type: "objectUpdate"
      }), null === (n = null === (t = this._uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    updateBounds() {
      this.setDirty();
    }

    get uiConfig() {
      return this._uiConfig || (this._uiConfig = it(this._modelObject, !1)), this._uiConfig;
    }

    clone() {
      return new st(this._modelObject.clone(), {
        pseudoCenter: !1,
        autoScale: !1
      });
    }

  }

  function ot(e, t) {
    const n = e.modelObject;
    return n.traverse(r => {
      at(r, r !== n ? e : void 0, t);
    }), e;
  }

  function at(e, t, n) {
    var r;
    if (!e) return void console.warn("setupIModel: object is undefined");
    if (e.userData || (e.userData = {}), e.userData.__iModelSetup && e.modelObject) return e;
    e.userData.__iModelSetup = !0;
    const i = [];

    if (i.push(() => {
      e.parent && e.removeFromParent();
    }), e.isLight && !e.assetType ? (e.assetType = "light", e.lightObject = e) : e.isCamera ? (e.assetType = "camera", e.cameraObject = e) : e.assetType || (e.assetType = "model"), e.modelObject || (e.modelObject = e), !e.userData.setDirty) {
      e.userData.setDirty = t => {
        var n, r;
        e.dispatchEvent({ ...t,
          type: "objectUpdate"
        }), null === (r = null === (n = e.uiConfig) || void 0 === n ? void 0 : n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !0);
      };

      const t = t => {
        var n, r, i, s;
        const o = null !== (r = null === (n = e.parent) || void 0 === n ? void 0 : n.userData.parentRoot) && void 0 !== r ? r : e.parent;
        o !== e.userData.parentRoot && e.traverse(e => {
          e.userData.parentRoot = o;
        }), null === (s = (i = e.userData).setDirty) || void 0 === s || s.call(i);
      },
            n = () => {
        var t, n;
        void 0 !== e.userData.parentRoot && e.traverse(e => {
          e.userData.parentRoot = void 0;
        }), null === (n = (t = e.userData).setDirty) || void 0 === n || n.call(t);
      };

      e.addEventListener("added", t), e.addEventListener("removed", n), i.push(() => {
        e.removeEventListener("added", t), e.removeEventListener("removed", n);
      });
    }

    e.userData.dispose ? console.warn("onDispose already set, disposing might be buggy.") : e.userData.dispose = () => i.forEach(e => e());
    const s = e;
    s.isMesh && !s.userData.__meshSetup && (s.userData.setMaterial || (s.userData.setMaterial = e => pt(s, e)), s.userData.setGeometry || (s.userData.setGeometry = (e, t = !1) => ht(s, e, t), s.userData.setGeometry(s.geometry, !0)), e.userData.__keepShadowDef || (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0), i.push(() => {
      const e = s.userData.setMaterial(void 0),
            t = s.userData.setGeometry(void 0);

      for (const t of e);

      t && 0 === t.userData.appliedMeshes.size && !1 !== t.userData.disposeOnIdle && t.dispose();
    }), s.userData.__meshSetup = !0), e.uiConfig || "model" !== e.assetType || (it(e), i.push(() => {
      e.uiConfig = void 0;
    })), t && (e.userData.parentRoot = t), i.push(() => {
      delete e.userData.parentRoot;
    });

    const o = t => {
      var n;
      const r = null !== (n = e.userData.parentRoot) && void 0 !== n ? n : e.parent;
      (null == r ? void 0 : r.modelObject) && r.dispatchEvent(t);
    };

    e.addEventListener("objectUpdate", o), e.addEventListener("materialUpdate", o), e.addEventListener("select", o), i.push(() => {
      e.removeEventListener("objectUpdate", o), e.removeEventListener("materialUpdate", o), e.removeEventListener("select", o);
    });
    const a = e.clone;
    e.clone = (...t) => {
      const r = e.userData,
            i = {};
      Object.entries(r).forEach(([e, t]) => {
        (!t || "function" == typeof t || t.isObject3D || t.isTexture || t.isMaterial || null != t.assetType || e.startsWith("__") || ct.includes(e)) && (i[e] = t, delete r[e]);
      });
      let s = a.call(e, ...t);
      Object.entries(i).forEach(([e, t]) => {
        r[e] = t, delete i[e];
      });
      const o = e.userData.parentRoot;
      return o && "model" !== o.assetType && console.warn("Cloning an object with a parent that is not an IModel is not supported"), s = at(s, o, n), s.userData.cloneParent = e.uuid, s;
    }, i.push(() => {
      e.clone = a;
    });
    const l = e.add;
    return e.add = (...t) => (t.forEach(t => at(t, e.userData.parentRoot || e, n)), l.call(e, ...t)), i.push(() => {
      e.add = l;
    }), e = null !== (r = null == n ? void 0 : n(e)) && void 0 !== r ? r : e, i.push(() => {
      e.modelObject = void 0, e.userData = {};
    }), e;
  }

  const lt = ["appliedMeshes"],
        ct = ["parentRoot", "iCamera"];

  function ut(e, t) {
    if (t) for (const n of Object.keys(t)) ct.includes(n) || n.startsWith("__") || "function" != typeof e[n] && "function" != typeof t[n] && (e[n] = t[n]);
    return e;
  }

  function pt(e, t) {
    var n, r, i, s;
    const o = (Array.isArray(t) ? t : [t]).map(e => null == e ? void 0 : e.materialObject).filter(e => e);
    if (e.material == o || 1 === o.length && e.material === o[0]) return [];
    e.userData.__materialUpdater || (e.userData.__materialUpdater = () => {
      e.dispatchEvent({
        type: "materialUpdate"
      });
    });
    const a = Array.isArray(e.material) ? [...e.material] : [e.material];

    for (const t of a) t && (t.removeEventListener("materialUpdate", e.userData.__materialUpdater), null === (r = null === (n = t.userData) || void 0 === n ? void 0 : n.appliedMeshes) || void 0 === r || r.delete(e));

    const l = [];

    for (const t of o) t.userData.appliedMeshes || (t.userData.appliedMeshes = new Set()), l.push(t), t && (t.addEventListener("materialUpdate", e.userData.__materialUpdater), t.userData.appliedMeshes.add(e));

    return e.material = 1 !== l.length ? l : l[0], e.traverseAncestors(t => {
      t.isRootScene && t.refreshEnvMapIntensity(e);
    }), e.dispatchEvent({
      type: "materialChanged",
      material: t
    }), null === (s = null === (i = e.uiConfig) || void 0 === i ? void 0 : i.uiRefresh) || void 0 === s || s.call(i, "postFrame", !0), a;
  }

  function ht(e, t, n = !1) {
    var r, i, s, o, a, l;
    e.userData.__objectUpdater || (e.userData.__objectUpdater = t => {
      e.dispatchEvent({ ...t,
        type: "objectUpdate"
      });
    });
    let c = e.geometry;
    const u = c;
    return (c !== t || n) && (c && (c.removeEventListener("geometryUpdate", e.userData.__objectUpdater), null === (i = null === (r = c.userData) || void 0 === r ? void 0 : r.appliedMeshes) || void 0 === i || i.delete(e)), c = t, c && !c.userData.appliedMeshes && (c.userData.appliedMeshes = new Set()), e.geometry = c, c && (c.addEventListener("geometryUpdate", e.userData.__objectUpdater), null === (o = null === (s = c.userData) || void 0 === s ? void 0 : s.appliedMeshes) || void 0 === o || o.add(e))), t.uiConfig || (t.uiConfig = function (e) {
      return {
        label: "Geometry",
        type: "folder",
        children: [{
          type: "input",
          property: [e, "uuid"],
          disabled: !0
        }, {
          type: "button",
          label: "Create uv2 from uv",
          value: () => {
            e.hasAttribute("uv2") && !confirm("uv2 already exists, replace with uv data?") || e.setAttribute("uv2", e.getAttribute("uv"));
          }
        }, {
          type: "input",
          label: "Mesh count",

          get value() {
            var t, n, r;
            return null !== (r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.appliedMeshes) || void 0 === n ? void 0 : n.size) && void 0 !== r ? r : 0;
          },

          set value(e) {},

          disabled: !0
        }]
      };
    }(e.geometry)), e.dispatchEvent({
      type: "geometryChanged",
      geometry: t
    }), null === (l = null === (a = e.uiConfig) || void 0 === a ? void 0 : a.uiRefresh) || void 0 === l || l.call(a, "postFrame", !0), u === c ? void 0 : u;
  }

  var dt = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class ft extends i.xsS {
    constructor(e) {
      super(), this.isRootScene = !0, this.assetType = "model", this._sceneBounds = new P(), this._sceneBoundingRadius = 0, this._processors = new rt(), this._cameras = [], this._activeCamera = -1, this.envMapIntensity = 1, this._dummyCam = new nt(new i.cPb(), {
        controlsMode: "",
        controlsEnabled: !1
      }), this.environment = null, this.background = null, this.minNearDistance = .2, this.setDirty = this.setDirty.bind(this), this.refreshActiveCameraNearFar = this.refreshActiveCameraNearFar.bind(this), this._activeCameraUpdate = this._activeCameraUpdate.bind(this), this._onSceneMaterialUpdate = this._onSceneMaterialUpdate.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this.addEventListener("materialUpdate", this._onSceneMaterialUpdate), this.addEventListener("objectUpdate", this._onSceneUpdate), this.defaultCamera = e, this.modelRoot = at(new i.ZAu(), void 0), this.modelRoot.userData.rootSceneModelRoot = !0, this.modelRoot.name = "Scene", this.modelRoot.addEventListener("update", this.setDirty), this.addSceneObject(this.modelRoot, {
        addToRoot: !0,
        autoScale: !1
      }), this.addSceneObject(this.defaultCamera, {
        addToRoot: !0
      }), this.activeCamera = this.defaultCamera, this.boxHelper = new i.GQ(this.getBounds());
    }

    refreshEnvMapIntensity(e) {
      return (null == e ? void 0 : e.isObject3D) || (e = this), (null != e ? e : this).traverse(e => {
        const t = e.material;
        t && void 0 !== t.envMapIntensity && !t.userData.separateEnvMapIntensity && (t.envMapIntensity = this.envMapIntensity, t.needsUpdate = !0);
      }), this.setDirty(), this;
    }

    get activeCamera() {
      return this._activeCamera >= 0 ? this._cameras[this._activeCamera] : this._dummyCam;
    }

    set activeCamera(e) {
      const t = this.activeCamera;

      if (e || (e = this.defaultCamera), t !== e) {
        if (t && (t.deactivateMain(), t.removeEventListener("update", this._activeCameraUpdate)), e) {
          e.activateMain(), e.addEventListener("update", this._activeCameraUpdate);

          let t = this._cameras.indexOf(e);

          t < 0 && (this._cameras.push(e), t = this._cameras.length - 1), this._activeCamera = t;
        } else this._activeCamera = -1;

        this.dispatchEvent({
          type: "activeCameraChange"
        }), this.setDirty();
      }
    }

    get modelObject() {
      return this;
    }

    addModel(e, t = {}) {
      return "model" !== e.assetType && console.error("Invalid asset type for ", e, ", adding anyway"), this.addSceneObject(e, t);
    }

    addWidget(e, t = {}) {
      "widget" !== e.assetType && console.warn("Invalid asset type for ", e, ", adding anyway"), this.add(e.modelObject);
    }

    _addModel(e, t = {}) {
      return this._addObject3D(null == e ? void 0 : e.modelObject, t);
    }

    addSceneObject(e, t) {
      if (!e) return e;
      const n = e.assetType;
      let r = !1;

      switch (n) {
        case "model":
          r = e.modelObject.isCamera, r && (t = { ...t,
            autoScale: !1
          }), this._addModel(e, t);
          break;

        case "material":
          break;

        case "texture":
          this.dispatchEvent({
            type: "textureAdded",
            texture: e
          });
          break;

        case "light":
          this._addLight(e, t);

          break;

        default:
          console.warn("Unknown asset imported", e, n);
      }

      return this.dispatchEvent({
        type: "addSceneObject",
        object: e
      }), e;
    }

    _addObject3D(e, {
      autoScale: t = !0,
      autoScaleRadius: n = 2,
      addToRoot: r = !1
    } = {}) {
      const i = e;
      i ? (t && !i.userData.autoScaled && X(i, i.userData.autoScaleRadius || n), i.traverse(e => {
        e.isMesh && !e.userData.__keepShadowDef && (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0);
      }), this.refreshEnvMapIntensity(i), r ? this.modelObject.add(i) : this.modelRoot.add(i), this.setDirty()) : console.error("Invalid Model, cannot add.");
    }

    removeSceneModels() {
      this.modelRoot.clear(), this.setDirty({
        sceneUpdate: !0
      });
    }

    disposeSceneModels() {
      this.modelRoot.children.forEach(e => {
        var t, n, r, i, s;
        (null !== (i = null !== (t = e.dispose) && void 0 !== t ? t : null === (r = null === (n = e.modelObject) || void 0 === n ? void 0 : n.userData) || void 0 === r ? void 0 : r.dispose) && void 0 !== i ? i : null === (s = e.modelObject) || void 0 === s ? void 0 : s.removeFromParent)();
      }), this.setDirty({
        sceneUpdate: !0
      });
    }

    _onEnvironmentChange() {
      this.dispatchEvent({
        type: "environmentChanged",
        environment: this.getEnvironment()
      }), this._onSceneUpdate();
    }

    add(...e) {
      return super.add(...e), this._onSceneUpdate(), this;
    }

    async setEnvironment(e) {
      if (!e) return this.environment = null, this.dispatchEvent({
        type: "environmentChanged"
      }), void this._onSceneUpdate();
      if ("texture" !== (null == e ? void 0 : e.assetType)) return void console.error("Unknown Environment type", e);
      e.mapping === i.xfE && (e.mapping = i.dSO, e.needsUpdate = !0);
      const t = (e = await this.processors.process("environment", e, {})).textureObject || e;
      this.environment = t, this._onEnvironmentChange();
    }

    getEnvironment() {
      return this.environment;
    }

    async setBackground(e) {
      var t;
      let n;
      if (!e || "texture" === e.assetType || e.isColor || e.isVector4) n = "texture" === (null === (t = e) || void 0 === t ? void 0 : t.assetType) && (e = await this.processors.process("background", e, {})).textureObject || e;else {
        if ("string" != typeof e && "number" != typeof e) return void console.error("Unknown Background type", e);
        n = new i.Ilk(e);
      }
      this.background = n, this._onSceneUpdate({
        geometryChanged: !1
      });
    }

    getBackground() {
      return this.background;
    }

    get processors() {
      return this._processors;
    }

    setDirty(e) {
      return (null == e ? void 0 : e.sceneUpdate) ? this._onSceneUpdate(e) : this.dispatchEvent({
        type: "update"
      }), this;
    }

    _activeCameraUpdate() {
      this.setDirty(), this.refreshActiveCameraNearFar(), this.dispatchEvent({
        type: "activeCameraUpdate"
      });
    }

    _onSceneUpdate(e = {}) {
      var t, n, r;
      this.refreshActiveCameraNearFar(), this._sceneBounds = this.getBounds(!1, !0), null === (r = null === (n = null === (t = this.boxHelper) || void 0 === t ? void 0 : t.box) || void 0 === n ? void 0 : n.copy) || void 0 === r || r.call(n, this._sceneBounds), this._sceneBoundingRadius = this._sceneBounds.getSize(new i.Pa4()).length() / 2, this.dispatchEvent({ ...e,
        type: "sceneUpdate"
      });
    }

    _onSceneMaterialUpdate() {
      this.dispatchEvent({
        type: "sceneMaterialUpdate"
      });
    }

    dispose() {
      this.clear();
    }

    findObjectsByName(e, t) {
      const n = [];
      return (null != t ? t : this.modelObject).traverse(t => {
        t.name === e && n.push(t);
      }), n;
    }

    addLight(e, t = {}) {
      this.addSceneObject(e, t);
    }

    _addLight(e, {
      setDefaultLayer: t = !0,
      addToRoot: n = !1,
      ...r
    } = {}) {
      var i;
      const s = e.lightObject;
      s && (null === (i = s.children) || void 0 === i || i.length, n ? this.add(s) : this.modelRoot.add(s));
    }

    getBounds(e = !1, t = !0) {
      return new P().expandByObject(this.modelObject, e, t);
    }

    refreshActiveCameraNearFar() {
      const e = this.activeCamera;
      if (!e) return;
      const t = this.getBounds(!1),
            n = e.cameraObject.getWorldPosition(new i.Pa4()).sub(t.getCenter(new i.Pa4())),
            r = 1.5 * t.getSize(new i.Pa4()).length() / 2,
            s = n.length(),
            o = Math.max(this.minNearDistance, s - r),
            a = Math.max(o + 1, s + r);
      e.near = o, e.far = a;
    }

    updateShaderProperties(e) {
      return e.uniforms.sceneBoundingRadius ? e.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }

    toJSON(e) {
      return Me(this, !0, e);
    }

    fromJSON(e, t) {
      const n = e.environment;
      return void 0 !== n && (this.setEnvironment(Te(n, this.getEnvironment(), !1, t)), delete e.environment), Te(e, this, !0, t), e.environment = n, this;
    }

  }

  function _t() {
    const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    return e.style.display = "block", e;
  }

  function mt(e, t) {
    const n = t || "/";
    return new RegExp(n + "{1,}", "g"), e.join(n);
  }

  function gt(e, t) {
    const n = window.URL.createObjectURL(e),
          r = document.createElement("a");
    r.style.display = "none", r.href = n, r.download = t, document.body.appendChild(r), r.click(), setTimeout(() => {
      document.body.removeChild(r), window.URL.revokeObjectURL(n);
    }, 1e3);
  }

  async function vt(e) {
    return new Promise((t, n) => {
      const r = new FileReader();
      r.onload = e => t(r.result), r.onerror = e => n(r.error), r.onabort = e => n(new Error("Read aborted")), r.readAsDataURL(e);
    });
  }

  function bt(e, t) {
    return gt(e, null != t ? t : e.name);
  }

  async function xt(e = !1, t = !1, n) {
    const r = document.createElement("input");
    r.type = "file", r.multiple = e, r.accept = n || "*", r.webkitdirectory = t, r.style.display = "none", document.body.appendChild(r), r.click();
    const i = await new Promise(e => {
      r.onchange = t => {
        e(Array.from(r.files || []));
      };
    });
    return document.body.removeChild(r), i;
  }

  function yt({
    innerHTML: e = "",
    id: t,
    classList: n,
    addToBody: r = !0,
    elementTag: i = "div"
  }) {
    const s = document.createElement(i);
    return t && (s.id = t), s.innerHTML = e, n && s.classList.add(...n), r && document.body.appendChild(s), s;
  }

  async function wt(e) {
    return new Promise((t, n) => {
      const r = new Image();
      r.onload = () => t(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "sync", r.src = e;
    });
  }

  function St(e) {
    const t = document.createElement("style");
    return t.type = "text/css", t.innerText = e, document.head.appendChild(t), t;
  }

  async function Mt(e) {
    return new Promise((t, n) => {
      const r = document.createElement("script");
      r.setAttribute("src", e), r.addEventListener("load", t), r.addEventListener("error", n), document.body.appendChild(r);
    });
  }

  function Tt(e, t = 8192) {
    var n;
    if (!e.width || !e.height) return "";
    const r = document.createElement("canvas");
    r.width = Math.min(t, e.width), r.height = Math.floor(1 + r.width * e.height / e.width);
    const i = e instanceof ImageBitmap && Math.abs(r.width - e.width) < .5 ? r.getContext("bitmaprenderer") : void 0;
    i ? i.transferFromImageBitmap(e) : null === (n = r.getContext("2d")) || void 0 === n || n.drawImage(e, 0, 0, r.width, r.height);
    const s = r.toDataURL("image/png");
    return r.remove(), s;
  }

  async function Et(e) {
    return new Promise((t, n) => {
      const r = new Image();
      r.addEventListener("load", () => {
        const e = document.createElement("canvas");
        e.width = r.width, e.height = r.height;
        const i = e.getContext("2d");
        if (!i) return void n(new Error("Could not get 2d context"));
        i.drawImage(r, 0, 0, e.width, e.height);
        const s = i.getImageData(0, 0, e.width, e.height);
        t(s), e.remove(), r.remove();
      }, !1), r.addEventListener("error", e => {
        r.remove(), n(e);
      }, !1), r.src = e;
    });
  }

  function At() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }

  function Ct() {
    let e = !1;
    return function (t) {
      (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0);
    }(navigator.userAgent || navigator.vendor || window.opera), e;
  }

  function Rt(e) {
    return new URL(window.location.href).searchParams.get(e);
  }

  function kt(e, t, n = !1) {
    const r = new URLSearchParams(location.search);
    null == t ? r.has(e) && r.delete(e) : r.set(e, t), n ? window.location.search = r.toString() : window.history.replaceState({}, "", "?" + r.toString());
  }

  function Pt(e) {
    return e.replace(/\w\S*/g, function (e) {
      return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase();
    });
  }

  function Dt(e, {
    backgroundColor: t = "",
    displayPixelRatio: n = 1,
    width: r = 512,
    height: i = 512
  }) {
    const s = document.createElement("canvas"),
          o = s.getContext("2d"),
          a = n,
          l = r,
          c = i;
    return s.width = l * a, s.height = c * a, s.style.width = `${l}`, s.style.height = `${c}`, (null == t ? void 0 : t.length) > 0 && (o.fillStyle = t, o.fillRect(0, 0, s.width, s.height)), o.drawImage(e, 0, 0, s.width, s.height), s;
  }

  dt([xe()], ft.prototype, "defaultCamera", void 0), dt([C(ft.prototype.refreshEnvMapIntensity), xe()], ft.prototype, "envMapIntensity", void 0), dt([xe()], ft.prototype, "environment", void 0), ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function (e, t) {
    const n = new Uint8Array(this);
    null == t && (t = n.length);
    const r = new ArrayBuffer(t - e),
          i = new Uint8Array(r);

    for (let t = 0; t < i.length; t++) i[t] = n[t + e];

    return r;
  });

  class Ot extends i.jyz {
    constructor(e, t) {
      super(e), this.typeSlug = "shaderMat", this.assetType = "material", this.materialObject = this, this.textures = [], this.setTextureIds(t);
    }

    setTextureIds(e) {
      this.textures.map(e => e.id).join(";") !== e.join(";") && (this.textures = e.map(e => ({
        id: e,
        encoding: i.rnI
      })), this.needsUpdate = !0);
    }

    _setUniformTexSize(e, t) {
      var n, r, i, s;
      if (!t || !e) return;
      const o = null !== (r = null === (n = t.image) || void 0 === n ? void 0 : n.width) && void 0 !== r ? r : 512,
            a = null !== (s = null === (i = t.image) || void 0 === i ? void 0 : i.height) && void 0 !== s ? s : 512,
            l = e.value;
      l.isVector2 || console.warn("uniform is not a Vector2"), l && Math.abs(l.x - o) + Math.abs(l.y - a) > .1 && (l.x = o, l.y = a, this.uniformsNeedUpdate = !0);
    }

    onBeforeRender(e, t, n, r, i) {
      var s, o;

      this._setUniformTexSize(this.uniforms.screenSize, null === (s = e.getRenderTarget()) || void 0 === s ? void 0 : s.texture);

      for (const e of this.textures) {
        const t = e.id,
              n = null === (o = this.uniforms[t]) || void 0 === o ? void 0 : o.value;
        n && (this._setUniformTexSize(this.uniforms[t + "Size"], n), n.encoding !== e.encoding && (e.encoding = n.encoding, this.needsUpdate = !0));
      }

      super.onBeforeRender(e, t, n, r, i);
    }

    onBeforeCompile(e, t) {
      e.fragmentShader = this.textures.map(e => {
        var t, n;
        return `uniform sampler2D ${e.id}; \n` + B(null !== (t = e.id) && void 0 !== t ? t : "input", null !== (n = e.encoding) && void 0 !== n ? n : i.rnI);
      }).join("\n") + e.fragmentShader, super.onBeforeCompile(e, t);
    }

    customProgramCacheKey() {
      return super.customProgramCacheKey() + this.textures.map(e => e.id + e.encoding).join(";");
    }

    toJSON(e) {
      throw new Error("Method not supported for this material.");
    }

    fromJSON(e, t) {
      throw new Error("Method not supported for this material.");
    }

    copyProps(e) {
      throw new Error("Method not supported for this material.");
    }

  }

  function Lt(e, ...t) {
    const n = e.fragmentShader;
    return new Ot({
      defines: Object.assign({}, e.defines),
      uniforms: e.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: n
    }, t);
  }

  class It extends u {
    constructor(e, ...t) {
      super(Lt(e, ...t), t.length < 1 ? It.DEFAULT_TEX_ID : t[0]), this.onDirty = [], this.enabled = !0, this.setDirty = this.setDirty.bind(this);
    }

    dispose() {
      var e, t, n, r;
      null === (t = null === (e = this.material) || void 0 === e ? void 0 : e.dispose) || void 0 === t || t.call(e), null === (r = null === (n = this.fsQuad) || void 0 === n ? void 0 : n.dispose) || void 0 === r || r.call(n), this.onDirty = [];
    }

    setDirty() {
      this.onDirty.forEach(e => e());
    }

    updateShaderProperties(e) {
      e && (Array.isArray(e) || (e = [e]), e.forEach(e => null == e ? void 0 : e.updateShaderProperties(this.material)));
    }

    render(e, t, n, r, i) {
      this.enabled && super.render(e, t, n, r, i);
    }

  }

  It.DEFAULT_TEX_ID = "tDiffuse", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([Ve("Enabled"), xe()], It.prototype, "enabled", void 0);

  class Ft extends o {
    constructor(e, t, n, r, s) {
      super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== s ? s : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new i.Ilk();
    }

    render(e, t, n, r, i, s) {
      const o = e.autoClear;
      let a, l;

      if (e.autoClear = !1, void 0 !== this.overrideMaterial && (l = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), a = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), s) {
        const t = e.getContext();
        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, s);
      }

      if (this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), s) {
        const t = e.getContext();
        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, null);
      }

      this.clearColor && e.setClearColor(this._oldClearColor, a), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = l), e.autoClear = o;
    }

  }

  class Nt extends It {
    constructor(e, t = "c = a + b;", n = "", r) {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: M`
                varying vec2 vUv;
                
                ${n}
                
                void blend(in vec4 a, in vec4 b, inout vec4 c){
                
                ${t}
                
                }
                void main() {
                    vec4 texel = vec4(0);
                    blend(tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ), tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), texel);
                    texel = clamp(texel, vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tDiffuse2: {
            value: r
          },
          ...e
        }
      }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
    }

  }

  class Ut extends i.jyz {
    constructor(e = !0) {
      super({
        vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#endif\n#include <uv_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nout vec3 vViewPosition;void main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;}",
        fragmentShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#include <packing>\nuniform float alphaTest;\n#endif\n#ifndef gl_FragColor \nlayout(location=0)out vec4 gDepthNormal;layout(location=1)out vec4 gFlags;\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <alphamap_pars_fragment>\nuniform vec2 cameraNearFar;uniform vec4 flags;in vec3 vViewPosition;vec2 pack16(float value){float sMax=65535.;int v=int(clamp(value,0.,1.)*sMax+0.5);int digit0=v/256;int digit1=v-digit0*256;return vec2(float(digit0)/255.,float(digit1)/255.);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.+8.);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}void main(){\n#ifdef USE_ALPHAMAP\n#ifdef ALPHA_I_RGBA_PACKING\nif(1.-unpackRGBAToDepth(texture2D(alphaMap,vUv))<alphaTest)discard;\n#else\nif(texture2D(alphaMap,vUv).g<alphaTest)discard;\n#endif\n#endif\n#include <normal_fragment_begin>\nfloat linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);vec2 packedZ=pack16(pow(linearZ,0.5));vec2 packedNormal=packNormal(normal);\n#ifndef gl_FragColor \ngDepthNormal=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);gFlags=flags;\n#else\ngl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);\n#endif\n}",
        uniforms: {
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: null
          },
          flags: {
            value: new i.Ltg(1, 1, 1, 1)
          }
        },
        glslVersion: e ? i.LSk : i.v9Y
      });
    }

    onBeforeRender(e, t, n, r, s) {
      var o, a;
      let l = s.material;
      Array.isArray(l) && (l = l[0]), this.uniforms.alphaMap.value = null !== (o = null == l ? void 0 : l.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !l || !l.alphaTest || l.alphaTest < 1e-7 ? .001 : l.alphaTest, this.uniforms.flags.value.x = !1 === (null == l ? void 0 : l.userData.postTonemap) ? 0 : 1;
      let c = this.uniforms.alphaMap.value ? 1 : void 0;
      c !== this.defines.USE_ALPHAMAP && (this.defines.USE_ALPHAMAP = c, this.needsUpdate = !0), c = l.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, c !== this.defines.ALPHA_I_RGBA_PACKING && (this.defines.ALPHA_I_RGBA_PACKING = c, this.needsUpdate = !0), this.side = null !== (a = l.side) && void 0 !== a ? a : i.ehD;
    }

  }

  var Bt = "#ifndef UNPACK_GBUFFER_SNIPPET\n#define UNPACK_GBUFFER_SNIPPET\nuniform sampler2D tNormalDepth;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}float getDepth(vec2 uv){vec4 uncodedDepth=texture2D(tNormalDepth,uv);return unpackDepth(uncodedDepth.xy);}void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nuniform sampler2D tGBufferFlags;\n#endif\nvec4 getGBufferFlags(const in vec2 uv){\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nreturn texture2D(tGBufferFlags,uv);\n#else\nreturn vec4(1.);\n#endif\n}\n#endif\n";

  class jt {
    static ApplyMaterialExtensions(e, t, n, r) {
      for (const i of n) this.ApplyMaterialExtension(e, t, i, r);
    }

    static ApplyMaterialExtension(e, t, n, r) {
      var i, s;
      let o = null !== (i = x(n.parsFragmentSnippet, r, e)) && void 0 !== i ? i : "";
      o.length && (t.fragmentShader = t.fragmentShader.replace(this.FragVoidMain, `\n${o}\n${this.FragVoidMain}`)), o = null !== (s = x(n.parsVertexSnippet, r, e)) && void 0 !== s ? s : "", o.length && (t.vertexShader = t.vertexShader.replace(this.VertVoidMain, `\n${o}\n${this.VertVoidMain}`)), n.extraUniforms && (t.uniforms = Object.assign(t.uniforms, n.extraUniforms)), n.shaderExtender && n.shaderExtender(t, e, r), e.lastShader = t;
    }

    static CacheKeyForExtensions(e, t) {
      let n = "";

      for (const r of t) n += this.CacheKeyForExtension(e, r);

      return n;
    }

    static CacheKeyForExtension(e, t) {
      let n = "";
      return t.customCacheKey && (n += t.customCacheKey), t.computeCacheKey && (n += t.computeCacheKey(e)), n;
    }

    static RegisterExtensions(e, t) {
      const n = [];
      if (t) for (const r of t) r.isCompatible && r.isCompatible(e) && (n.push(r), r.uuid || (r.uuid = Be()), r.setDirty || (r.setDirty = () => {
        r.updateVersion || (r.updateVersion = 0), r.updateVersion++;
      }));
      return e.materialExtensions = n, e.__ext_beforeRenderListen || (e.__ext_beforeRenderListen = !0, e.addEventListener("beforeRender", t => function (e, {
        object: t,
        renderer: n
      }) {
        var r;
        null === (r = e.materialExtensions) || void 0 === r || r.forEach(r => {
          var i, s;
          null === (i = r.onObjectRender) || void 0 === i || i.call(r, t, e, n), e.lastShader && (null === (s = x(r.updaters)) || void 0 === s || s.forEach(t => null == t ? void 0 : t.updateShaderProperties(e.lastShader))), r.updateVersion !== e.materialObject.userData["_" + r.uuid + "_version"] && (e.materialObject.userData["_" + r.uuid + "_version"] = r.updateVersion, e.materialObject.needsUpdate = !0);
        });
      }(e, t))), n;
    }

  }

  jt.FragVoidMain = "void main() {", jt.VertVoidMain = "void main() {";
  const zt = {
    name: "",
    fog: !0,
    blending: i.bdR,
    side: i.Wl3,
    vertexColors: !1,
    opacity: 1,
    transparent: !1,
    blendSrc: i.k74,
    blendDst: i.LgZ,
    blendEquation: i.bGH,
    blendSrcAlpha: null,
    blendDstAlpha: null,
    blendEquationAlpha: null,
    depthFunc: i.vCF,
    depthTest: !0,
    depthWrite: !0,
    stencilWriteMask: 255,
    stencilFunc: i.cum,
    stencilRef: 0,
    stencilFuncMask: 255,
    stencilFail: i.x5V,
    stencilZFail: i.x5V,
    stencilZPass: i.x5V,
    stencilWrite: !1,
    clippingPlanes: null,
    clipIntersection: !1,
    clipShadows: !1,
    shadowSide: null,
    colorWrite: !0,
    precision: null,
    polygonOffset: !1,
    polygonOffsetFactor: 0,
    polygonOffsetUnits: 0,
    dithering: !1,
    alphaTest: 0,
    alphaToCoverage: !1,
    premultipliedAlpha: !1,
    visible: !0,
    toneMapped: !0,
    userData: {},
    wireframeLinecap: "round",
    wireframeLinejoin: "round"
  },
        Vt = { ...zt,
    color: "#000000",
    roughness: 0,
    metalness: 0,
    map: null,
    lightMap: null,
    lightMapIntensity: 0,
    aoMap: null,
    aoMapIntensity: 0,
    emissive: "#000000",
    emissiveIntensity: 0,
    emissiveMap: null,
    bumpMap: null,
    bumpScale: 0,
    normalMap: null,
    normalMapType: i.IOt,
    normalScale: new i.FM8(1, 1),
    displacementMap: null,
    displacementScale: 0,
    displacementBias: 0,
    roughnessMap: null,
    metalnessMap: null,
    alphaMap: null,
    envMap: null,
    envMapIntensity: 0,
    refractionRatio: 0,
    wireframe: !1,
    wireframeLinewidth: 0,
    skinning: !1,
    morphTargets: !1,
    morphNormals: !1,
    flatShading: !1,
    glossiness: 0,
    glossinessMap: null,
    specularColor: new ve(0),
    specularColorMap: null
  },
        Gt = { ...Vt,
    clearcoat: 0,
    clearcoatMap: null,
    clearcoatRoughness: 0,
    clearcoatRoughnessMap: null,
    clearcoatNormalScale: new i.FM8(1, 1),
    clearcoatNormalMap: null,
    reflectivity: .5,
    sheen: 0,
    sheenColor: new ve(0),
    sheenColorMap: null,
    sheenRoughness: 1,
    sheenRoughnessMap: null,
    specularIntensity: 1,
    specularIntensityMap: null,
    specularColor: new ve(1, 1, 1),
    specularColorMap: null,
    transmission: 0,
    transmissionMap: null,
    thickness: 0,
    thicknessMap: null,
    attenuationDistance: 0,
    attenuationColor: new ve(1, 1, 1)
  };

  class Ht extends i.EJi {
    constructor(e) {
      var t;
      super(e), this.typeSlug = Ht.TypeSlug, this.isMeshStandardMaterial2 = !0, this.extraUniformsToUpload = {}, this.assetType = "material", this.materialObject = this, this.fog = !1, this.userData.setDirty = () => {
        var e, t;
        this.needsUpdate = !0, this.dispatchEvent({
          type: "materialUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.materialExtensions = jt.RegisterExtensions(this, null !== (t = null == e ? void 0 : e.customMaterialExtensions) && void 0 !== t ? t : []);
    }

    registerMaterialExtensions(e) {
      this.materialExtensions = [...this.materialExtensions, ...jt.RegisterExtensions(this, e)];
    }

    unregisterMaterialExtensions(e) {}

    _makeSamplerUi(e = "map") {
      const t = "map" === e;
      return {
        type: "folder",
        label: e + " Sampler",
        hidden: () => !this[e],
        children: [() => {
          var n;
          return {
            type: "vec2",
            label: "Repeat",
            hidden: () => !t && this.map,
            bounds: [0, 100],
            stepSize: .001,
            property: [this[e], "repeat"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var n;
          return {
            type: "vec2",
            label: "Offset",
            hidden: () => !t && this.map,
            bounds: [0, 2],
            property: [this[e], "offset"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var n;
          return {
            type: "vec2",
            label: "Center",
            hidden: () => !t && this.map,
            bounds: [-2, 2],
            property: [this[e], "center"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var n;
          return {
            type: "input",
            label: "Rotation",
            hidden: () => !t && this.map,
            bounds: [-Math.PI, Math.PI],
            property: [this[e], "rotation"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Encoding",
            property: [this[e], "encoding"],
            children: [["Linear", i.rnI], ["sRGB", i.knz]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              const t = this[e];
              t && (t.needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => ({
          type: "checkbox",
          label: "Flip Y",
          getValue: () => {
            var t, n;
            return null !== (n = null === (t = this[e]) || void 0 === t ? void 0 : t.flipY) && void 0 !== n && n;
          },
          setValue: t => {
            var n, r;
            const i = this[e];
            if (i && i.flipY !== t) if (i.image && ImageBitmap && i.image instanceof ImageBitmap) {
              const e = i,
                    n = i.source.data;
              createImageBitmap(n, {
                imageOrientation: "flipY"
              }).then(r => {
                var i, s;
                n.close && n.close(), e.flipY = t, e.source.data = r, e.source.needsUpdate = !0, e.needsUpdate = !0, null === (s = null === (i = this.userData) || void 0 === i ? void 0 : i.setDirty) || void 0 === s || s.call(i);
              });
            } else i.flipY = t, i.needsUpdate = !0, null === (r = null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty) || void 0 === r || r.call(n);
          }
        }), () => {
          var t;
          return {
            type: "dropdown",
            label: "Wrap S",
            property: [this[e], "wrapS"],
            children: [["ClampToEdge", i.uWy], ["MirroredRepeat", i.OoA], ["Repeat", i.rpg]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Wrap T",
            property: [this[e], "wrapT"],
            children: [["ClampToEdge", i.uWy], ["MirroredRepeat", i.OoA], ["Repeat", i.rpg]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "input",
            label: "Anisotropy",
            bounds: [1, 6],
            stepSize: 1,
            property: [this[e], "anisotropy"],
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0), this.needsUpdate = !0;
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Min Filter",
            property: [this[e], "minFilter"],
            children: [["Linear", se], ["Nearest", i.TyD]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Mag Filter",
            property: [this[e], "magFilter"],
            children: [["Linear", se], ["Nearest", i.TyD]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }]
      };
    }

    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{
        type: "input",
        property: [this, "name"]
      }, {
        type: "checkbox",
        property: [this, "wireframe"]
      }, {
        type: "color",
        property: [this, "color"],
        limitedUi: !0
      }, {
        type: "image",
        property: [this, "map"]
      }, this._makeSamplerUi("map"), {
        type: "folder",
        label: "Rough/Metal",
        limitedUi: !0,
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "roughness"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "metalness"],
          limitedUi: !0
        }, {
          type: "image",
          property: [this, "roughnessMap"]
        }, this._makeSamplerUi("roughnessMap"), {
          type: "image",
          property: [this, "metalnessMap"]
        }, this._makeSamplerUi("metalnessMap")]
      }, {
        type: "folder",
        label: "Bump/Normal",
        limitedUi: !0,
        children: [{
          type: "slider",
          bounds: [0, .2],
          stepSize: .001,
          property: [this, "bumpScale"],
          hidden: () => !this.bumpMap
        }, {
          type: "image",
          property: [this, "bumpMap"]
        }, this._makeSamplerUi("bumpMap"), {
          type: "image",
          property: [this, "normalMap"]
        }, {
          type: "vec2",
          property: [this, "normalScale"],
          hidden: () => !this.normalMap
        }, {
          type: "dropdown",
          hidden: () => !this.normalMap,
          property: [this, "normalMapType"],
          children: [["TangentSpace", i.IOt], ["ObjectSpace", i.PA7]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, this._makeSamplerUi("normalMap"), {
          type: "slider",
          bounds: [0, 10],
          stepSize: .001,
          property: [this, "displacementScale"],
          hidden: () => !this.displacementMap
        }, {
          type: "image",
          property: [this, "displacementMap"]
        }, this._makeSamplerUi("displacementMap")]
      }, {
        type: "folder",
        label: "Sheen",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "sheen"]
        }, {
          type: "color",
          hidden: () => this.sheen < .001,
          property: [this, "sheenColor"]
        }, {
          type: "image",
          property: [this, "sheenColorMap"]
        }, this._makeSamplerUi("sheenColorMap"), {
          type: "slider",
          bounds: [0, 1],
          property: [this, "sheenRoughness"]
        }, {
          type: "image",
          property: [this, "sheenRoughnessMap"]
        }, this._makeSamplerUi("sheenRoughnessMap")]
      }, {
        type: "folder",
        label: "Clearcoat",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "clearcoat"]
        }, {
          type: "slider",
          bounds: [0, 1],
          hidden: () => this.clearcoat < .001,
          property: [this, "clearcoatRoughness"]
        }, {
          type: "image",
          property: [this, "clearcoatMap"]
        }, this._makeSamplerUi("clearcoatMap"), {
          type: "slider",
          bounds: [0, 1],
          property: [this, "clearcoatRoughness"]
        }, {
          type: "image",
          property: [this, "clearcoatRoughnessMap"]
        }, this._makeSamplerUi("clearcoatRoughnessMap"), {
          type: "image",
          property: [this, "clearcoatNormalMap"]
        }, {
          type: "vec2",
          property: [this, "clearcoatNormalScale"],
          hidden: () => !this.clearcoatNormalMap
        }, this._makeSamplerUi("clearcoatNormalMap")]
      }, {
        type: "folder",
        label: "Emission",
        children: [{
          type: "color",
          property: [this, "emissive"]
        }, {
          type: "slider",
          bounds: [0, 10],
          property: [this, "emissiveIntensity"]
        }, {
          type: "image",
          property: [this, "emissiveMap"]
        }, this._makeSamplerUi("emissiveMap")]
      }, {
        type: "folder",
        label: "Refraction",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "reflectivity"]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "transmission"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 1],
          stepSize: .001,
          property: [this, "thickness"]
        }, {
          type: "image",
          property: [this, "transmissionMap"]
        }, this._makeSamplerUi("transmissionMap"), {
          type: "image",
          property: [this, "thicknessMap"]
        }, this._makeSamplerUi("thicknessMap")]
      }, {
        type: "folder",
        label: "Blending",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "opacity"]
        }, {
          type: "checkbox",
          property: [this, "transparent"],
          onChange: () => {
            var e, t;
            null === (t = (e = this.userData).setDirty) || void 0 === t || t.call(e);
          }
        }, {
          type: "checkbox",
          property: [this, "depthWrite"],
          onChange: () => {
            var e, t;
            null === (t = (e = this.userData).setDirty) || void 0 === t || t.call(e);
          }
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "alphaTest"]
        }, {
          type: "checkbox",
          property: [this, "dithering"]
        }, {
          type: "dropdown",
          label: "Blending",
          property: [this, "blending"],
          children: [["None", te], ["Normal", ne], ["Additive", i.WMw], ["Subtractive", re], ["Multiply", ie]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "image",
          property: [this, "alphaMap"]
        }, this._makeSamplerUi("alphaMap"), {
          type: "checkbox",
          label: "Render to Depth",
          hidden: () => !this.transparent && this.transmission < .001,
          getValue: () => !0 === this.userData.renderToDepth,
          setValue: e => {
            var t, n;
            this.userData.renderToDepth = e || void 0, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t);
          }
        }, {
          type: "checkbox",
          label: "Inverse AlphaMap",
          hidden: () => !this.transparent,
          getValue: () => !0 === this.userData.inverseAlphaMap,
          setValue: e => {
            var t, n;
            this.userData.inverseAlphaMap = e || void 0, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t);
          }
        }]
      }, {
        type: "folder",
        label: "AO/Lightmap",
        children: [{
          type: "slider",
          bounds: [0, 2],
          property: [this, "aoMapIntensity"]
        }, {
          type: "image",
          property: [this, "aoMap"]
        }, this._makeSamplerUi("aoMap"), {
          type: "slider",
          bounds: [0, 2],
          property: [this, "lightMapIntensity"]
        }, {
          type: "image",
          property: [this, "lightMap"]
        }, this._makeSamplerUi("lightMap")]
      }, {
        type: "dropdown",
        label: "Side",
        property: [this, "side"],
        children: [["Front", i.Wl3], ["Back", i._Li], ["Double", i.ehD]].map(e => ({
          label: e[0],
          value: e[1]
        }))
      }, {
        type: "checkbox",
        property: [this, "flatShading"]
      }, {
        type: "input",
        label: "Mesh count",
        getValue: () => {
          var e, t, n;
          return null !== (n = null === (t = null === (e = this.userData) || void 0 === e ? void 0 : e.appliedMeshes) || void 0 === t ? void 0 : t.size) && void 0 !== n ? n : 0;
        },
        setValue: e => {},
        disabled: !0
      }, {
        type: "button",
        label: `Download ${this.typeSlug}`,
        value: () => {
          gt(new Blob([JSON.stringify(this.toJSON(), null, 2)], {
            type: "application/json"
          }), `standard-material.${this.typeSlug}`);
        }
      }]), this._uiConfig || (this._uiConfig = {
        type: "folder",
        label: "Physical Material",
        expanded: !0,
        children: this._uiConfigChildren,
        uuid: "MSM2_" + this.uuid,
        limitedUi: !0
      }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map(e => {
        var t;
        return null === (t = e.getUiConfig) || void 0 === t ? void 0 : t.call(e, this);
      })].filter(e => e), this._uiConfig;
    }

    onBeforeCompile(e, t) {
      const n = [["vec3 totalDiffuse = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["#include <lights_physical_fragment>", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]],
            r = [["#include <uv_vertex>", "mainStart"]];

      for (const t of r) e.vertexShader = e.vertexShader.replace(t[0], "#glMarker " + t[1] + "\n" + t[0]);

      for (const t of n) e.fragmentShader = e.fragmentShader.replace(t[0], "#glMarker " + t[1] + "\n" + t[0]);

      jt.ApplyMaterialExtensions(this, e, this.materialExtensions, t), e.fragmentShader = e.fragmentShader.replaceAll("#glMarker", "// "), e.vertexShader = e.vertexShader.replaceAll("#glMarker", "// "), e.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0, super.onBeforeCompile(e, t);
    }

    customProgramCacheKey() {
      return super.customProgramCacheKey() + jt.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }

    onBeforeRender(e, t, n, r, i) {
      super.onBeforeRender(e, t, n, r, i), this.dispatchEvent({
        type: "beforeRender",
        renderer: e,
        scene: t,
        camera: n,
        geometry: r,
        object: i
      });
      const s = this.userData.inverseAlphaMap ? 1 : 0;
      s !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = s, this.needsUpdate = !0);
    }

    copyProps(e, t = !1) {
      var n, r;
      if (!t && !["MeshStandardMaterial", Ht.TYPE, "MeshPhysicalMaterial"].includes(e.type)) return console.warn("Material type is not supported:", e.type), this;
      const i = {};
      y(e, i, Array.from(Object.keys(Gt)));
      const s = i.userData;
      delete i.userData;

      for (const e of Object.keys(i)) void 0 === i[e] && delete i[e];

      return this.setValues(i), s && Kt(this.userData, s), null === (r = (n = this.userData).setDirty) || void 0 === r || r.call(n), this;
    }

    toJSON(e) {
      const t = this.userData;
      this.userData = {};
      const n = super.toJSON(e);
      this.userData = t, n.userData = {}, Kt(n.userData, t), n.userData.uuid = this.userData.uuid, n.type = Ht.TYPE;

      for (const e of Object.keys(n)) void 0 === n[e] && delete n[e];

      return n;
    }

    fromJSON(e, t, n = !1) {
      return Array.isArray(e.normalScale) && (e.normalScale = new i.FM8().fromArray(e.normalScale)), Array.isArray(e.clearcoatNormalScale) && (e.clearcoatNormalScale = new i.FM8().fromArray(e.clearcoatNormalScale)), this.copyProps(e, n);
    }

    clone() {
      return super.clone();
    }

  }

  Ht.TypeSlug = "pmat", Ht.TYPE = "MeshStandardMaterial2";
  const Wt = ["appliedMeshes", "imageLoadAwaiter", "inverseModelMatrix", "uvTransform", "uuid"];

  function Kt(e, t) {
    if (t) for (const n of Object.keys(t)) Wt.includes(n) || n.startsWith("__") || "function" != typeof e[n] && "function" != typeof t[n] && (e[n] = t[n]);
    return e;
  }

  const Xt = {
    materialType: Ht.TYPE,
    name: "standard",
    color: "#ffffff"
  };

  class qt extends r {
    constructor() {
      super(), this._templates = [Xt], this._materials = [], this._materialExtensions = [], this.processModel = this.processModel.bind(this), this.processMaterial = this.processMaterial.bind(this);
    }

    findOrCreate(e, t) {
      let n = this.findMaterial(e);
      return n || (n = this.generateFromTemplate(e, t)), n;
    }

    generateFromTemplate(e, t) {
      const n = this.findTemplate(e);
      if (n) return this._generateFromTemplate(n, null != t ? t : {});
    }

    generateFromTemplateType(e, t) {
      const n = this._templates.find(t => t.materialType === e);

      if (n) return this._generateFromTemplate(n, null != t ? t : {});
    }

    findTemplate(e) {
      return this._templates.find(t => t.name === e);
    }

    registerMaterial(e) {
      if (this._materials.includes(e)) return;
      const t = this.findMaterial(e.uuid);
      t ? console.warn("Material UUID already exists", e, t) : this._materials.push(e);
    }

    registerMaterialObject(e) {
      const t = e.materialObject ? e : Object.assign(e, {
        assetType: "material",
        materialObject: e
      });
      return this.registerMaterial(t), t;
    }

    unregisterMaterial(e) {
      this._materials = this._materials.filter(t => t.uuid !== e.uuid);
    }

    registerMaterialTemplate(e) {
      e.templateUUID || (e.templateUUID = Be());

      const t = this._templates.find(t => t.templateUUID === e.templateUUID);

      t ? console.warn("MaterialTemplate already exists", e, t) : this._templates.push(e);
    }

    unregisterMaterialTemplate(e) {
      this._templates = this._templates.filter(t => t.templateUUID !== e.templateUUID);
    }

    dispose() {}

    findMaterial(e) {
      return e ? this._materials.find(t => t.uuid === e) : void 0;
    }

    findMaterialsByName(e) {
      return this._materials.filter(t => t.name === e);
    }

    getMaterialsOfType(e) {
      return e ? this._materials.filter(t => t.typeSlug === e) : [];
    }

    getAllMaterials() {
      return [...this._materials];
    }

    processModel(e, t) {
      return g(e, "modelObject", this._processModel(e.modelObject, t)), e;
    }

    _processMaterial(e, t) {
      var n, r, i;
      if (!e) return;
      if (null === (n = e.materialObject) || void 0 === n ? void 0 : n.isMaterial) return e;
      let s = e.mmMaterial;

      if (!s) {
        const n = (null === (r = e.userData) || void 0 === r ? void 0 : r.uuid) || e.uuid;
        s = this.findMaterial(n), s ? s.copyProps(e) : s = this.generateFromTemplate(null !== (i = t.materialTemplate) && void 0 !== i ? i : "standard", !1 !== t.useSourceMaterial && e.isMaterial ? e : {}), e.mmMaterial = s;
      }

      return s;
    }

    processMaterial(e, t) {
      return !1 !== t.register && this.registerMaterial(e), e.materialObject || (e = this._processMaterial(e, { ...t,
        register: !1
      })), e;
    }

    registerMaterialExtension(e) {
      this._materialExtensions.includes(e) || this._materialExtensions.push(e);
    }

    unregisterMaterialExtension(e) {
      const t = this._materialExtensions.indexOf(e);

      t >= 0 && this._materialExtensions.splice(t, 1);
    }

    exportMaterial(e, t, n = !0, r = !1) {
      const i = Me(e, !1),
            s = JSON.stringify(i, null, n ? 0 : 2),
            o = (t || e.name || "physical_material") + "." + e.typeSlug,
            a = new File([s], o, {
        type: "application/json"
      });
      return r && bt(a), a;
    }

  }

  class Yt extends qt {
    _generateFromTemplate(e, t) {
      var n, r, s, o, a;
      let l;
      const c = { ...e
      };
      c.customMaterialExtensions = [...(null !== (n = c.customMaterialExtensions) && void 0 !== n ? n : []), ...this._materialExtensions];
      let u = {};

      switch (e.materialType) {
        case "MeshStandardMaterial2":
        case "standard":
          t && y(t, c, Array.from(Object.keys(Gt))), u = c.userData, delete c.userData, l = new Ht({
            customMaterialExtensions: c.customMaterialExtensions
          }).fromJSON(c, void 0, !0), u && (Kt(l.userData, u), u.uuid && (l.uuid = u.uuid), c.userData = u, u = {}), l.userData.uuid = l.uuid, null === (s = (r = l.userData).setDirty) || void 0 === s || s.call(r);
          break;

        case "basic":
          l = new i.vBJ(c);
          break;

        case "shadow":
          l = new i.Tn7(c);
          break;

        default:
          u = null, t && t.userData && (u = t.userData, delete t.userData), l = (null === (o = e.generator) || void 0 === o ? void 0 : o.call(e, c, t)) || void 0, t && u && (t.userData = u), u && l && (Kt(l.userData, u), (null == u ? void 0 : u.uuid) && (l.uuid = u.uuid), u = null), l && (l.userData.uuid = l.uuid);
      }

      if (l) {
        t.runtimeMaterial && (l.userData.__runtimeMaterial = !0);
        const n = l;
        return l.clone = () => {
          n.userData.cloneId || (n.userData.cloneId = "0", n.userData.cloneCount = 0), n.userData.cloneCount += 1;
          const t = this.generateFromTemplate(e.name);
          return t && (t.copyProps(n), t.userData.cloneId = t.userData.cloneId + "_" + n.userData.cloneCount, t.userData.cloneCount = 0, t.name = t.name + "_" + t.userData.cloneId), null == t ? void 0 : t.materialObject;
        }, t && (this.findMaterial(null == t ? void 0 : t.uuid) && this.unregisterMaterial(t), this.findMaterial(null === (a = null == t ? void 0 : t.materialObject) || void 0 === a ? void 0 : a.uuid) && this.unregisterMaterial(t.materialObject)), this.registerMaterialObject(n);
      }
    }

    _processModel(e, t) {
      var n;
      let r = e.material;

      if (r) {
        let i = !0;
        Array.isArray(r) || (r = [r], i = !1);
        const s = [];

        for (const e of r) {
          const n = this._processMaterial(e, t);

          s.push(null == n ? void 0 : n.materialObject);
        }

        const o = null !== (n = e.userData.setMaterial) && void 0 !== n ? n : t => {
          e.material = t;
        };
        e.material = null, o(i ? s : s[0]);
      }

      if (!1 !== t.recursive) for (let n = 0; n < e.children.length; n++) e.children[n] = this._processModel(e.children[n], t);
      return e;
    }

  }

  class Zt {
    constructor(e, t, n, r) {
      this.cls = e, this.ext = t, this.root = n, this.onCtor = r;
    }

    ctor(e) {
      const t = this.cls && new this.cls(e.loadingManager);
      return "function" == typeof this.onCtor ? this.onCtor(t, e) : t;
    }

  }

  function Jt(e) {
    var t;
    if (!e || "" === e || e.match(/__MACOSX\/.*\._/)) return "";
    const n = null !== (t = (e = e.replace(/\?.*$/, "")).split(/[\\/]/).pop()) && void 0 !== t ? t : "",
          r = n.lastIndexOf(".");
    return "" === n || r < 1 ? "" : n.slice(r + 1);
  }

  function $t(e) {
    return e.substring(e.lastIndexOf("/") + 1);
  }

  class Qt extends i.hH6 {
    load(e, t, n, r) {
      return super.load(e, e => {
        try {
          if ("string" != typeof e) throw new Error("Invalid JSON");
          null == t || t(JSON.parse(e));
        } catch (e) {
          null == r || r(e);
        }
      }, n, r);
    }

  }

  class en extends i.yxD {
    constructor(e) {
      super(e), this.type = i.cLu;
    }

    parse(e) {
      const t = function (e, t) {
        switch (e) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (t || ""));
            break;

          case 2:
            console.error("THREE.RGBELoader Write Error: " + (t || ""));
            break;

          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
            break;

          default:
            console.error("THREE.RGBELoader: Error: " + (t || ""));
        }

        return -1;
      },
            n = function (e, t, n) {
        t = t || 1024;
        let r = e.pos,
            i = -1,
            s = 0,
            o = "",
            a = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));

        for (; 0 > (i = a.indexOf("\n")) && s < t && r < e.byteLength;) o += a, s += a.length, r += 128, a += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));

        return -1 < i && (!1 !== n && (e.pos += s + i + 1), o + a.slice(0, i));
      },
            r = function (e, t, n, r) {
        const i = e[t + 3],
              s = Math.pow(2, i - 128) / 255;
        n[r + 0] = e[t + 0] * s, n[r + 1] = e[t + 1] * s, n[r + 2] = e[t + 2] * s, n[r + 3] = 1;
      },
            s = function (e, t, n, r) {
        const s = e[t + 3],
              o = Math.pow(2, s - 128) / 255;
        n[r + 0] = i.A5E.toHalfFloat(Math.min(e[t + 0] * o, 65504)), n[r + 1] = i.A5E.toHalfFloat(Math.min(e[t + 1] * o, 65504)), n[r + 2] = i.A5E.toHalfFloat(Math.min(e[t + 2] * o, 65504)), n[r + 3] = i.A5E.toHalfFloat(1);
      },
            o = new Uint8Array(e);

      o.pos = 0;

      const a = function (e) {
        const r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
              i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
              s = /^\s*FORMAT=(\S+)\s*$/,
              o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
              a = {
          valid: 0,
          string: "",
          comments: "",
          programtype: "RGBE",
          format: "",
          gamma: 1,
          exposure: 1,
          width: 0,
          height: 0
        };
        let l, c;
        if (e.pos >= e.byteLength || !(l = n(e))) return t(1, "no header found");
        if (!(c = l.match(/^#\?(\S+)/))) return t(3, "bad initial token");

        for (a.valid |= 1, a.programtype = c[1], a.string += l + "\n"; l = n(e), !1 !== l;) if (a.string += l + "\n", "#" !== l.charAt(0)) {
          if ((c = l.match(r)) && (a.gamma = parseFloat(c[1])), (c = l.match(i)) && (a.exposure = parseFloat(c[1])), (c = l.match(s)) && (a.valid |= 2, a.format = c[1]), (c = l.match(o)) && (a.valid |= 4, a.height = parseInt(c[1], 10), a.width = parseInt(c[2], 10)), 2 & a.valid && 4 & a.valid) break;
        } else a.comments += l + "\n";

        return 2 & a.valid ? 4 & a.valid ? a : t(3, "missing image size specifier") : t(3, "missing format specifier");
      }(o);

      if (-1 !== a) {
        const e = a.width,
              n = a.height,
              l = function (e, n, r) {
          const i = n;
          if (i < 8 || i > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
          if (i !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width");
          const s = new Uint8Array(4 * n * r);
          if (!s.length) return t(4, "unable to allocate buffer space");
          let o = 0,
              a = 0;
          const l = 4 * i,
                c = new Uint8Array(4),
                u = new Uint8Array(l);
          let p = r;

          for (; p > 0 && a < e.byteLength;) {
            if (a + 4 > e.byteLength) return t(1);
            if (c[0] = e[a++], c[1] = e[a++], c[2] = e[a++], c[3] = e[a++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != i) return t(3, "bad rgbe scanline format");
            let n,
                r = 0;

            for (; r < l && a < e.byteLength;) {
              n = e[a++];
              const i = n > 128;
              if (i && (n -= 128), 0 === n || r + n > l) return t(3, "bad scanline data");

              if (i) {
                const t = e[a++];

                for (let e = 0; e < n; e++) u[r++] = t;
              } else u.set(e.subarray(a, a + n), r), r += n, a += n;
            }

            const h = i;

            for (let e = 0; e < h; e++) {
              let t = 0;
              s[o] = u[e + t], t += i, s[o + 1] = u[e + t], t += i, s[o + 2] = u[e + t], t += i, s[o + 3] = u[e + t], o += 4;
            }

            p--;
          }

          return s;
        }(o.subarray(o.pos), e, n);

        if (-1 !== l) {
          let t, o, c;

          switch (this.type) {
            case i.VzW:
              c = l.length / 4;
              const e = new Float32Array(4 * c);

              for (let t = 0; t < c; t++) r(l, 4 * t, e, 4 * t);

              t = e, o = i.VzW;
              break;

            case i.cLu:
              c = l.length / 4;
              const n = new Uint16Array(4 * c);

              for (let e = 0; e < c; e++) s(l, 4 * e, n, 4 * e);

              t = n, o = i.cLu;
              break;

            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }

          return {
            width: e,
            height: n,
            data: t,
            header: a.string,
            gamma: a.gamma,
            exposure: a.exposure,
            type: o
          };
        }
      }

      return null;
    }

    setDataType(e) {
      return this.type = e, this;
    }

    load(e, t, n, r) {
      return super.load(e, function (e, n) {
        switch (e.type) {
          case i.VzW:
          case i.cLu:
            e.encoding = i.rnI, e.minFilter = i.wem, e.magFilter = i.wem, e.generateMipmaps = !1, e.flipY = !0;
        }

        t && t(e, n);
      }, n, r);
    }

  }

  function tn(e) {
    Fs.Importers.push(new Zt(class extends en {
      constructor(t) {
        super(t), this.setDataType(Ns(e));
      }

    }, ["hdr"], !1));
  }

  class nn extends i.aNw {
    constructor(e) {
      super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) {
        return new cn(e);
      }), this.register(function (e) {
        return new mn(e);
      }), this.register(function (e) {
        return new gn(e);
      }), this.register(function (e) {
        return new pn(e);
      }), this.register(function (e) {
        return new hn(e);
      }), this.register(function (e) {
        return new dn(e);
      }), this.register(function (e) {
        return new fn(e);
      }), this.register(function (e) {
        return new ln(e);
      }), this.register(function (e) {
        return new _n(e);
      }), this.register(function (e) {
        return new un(e);
      }), this.register(function (e) {
        return new on(e);
      }), this.register(function (e) {
        return new vn(e);
      });
    }

    load(e, t, n, r) {
      const s = this;
      let o;
      o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : i.Zp0.extractUrlBase(e), this.manager.itemStart(e);

      const a = function (t) {
        r ? r(t) : console.error(t), s.manager.itemError(e), s.manager.itemEnd(e);
      },
            l = new i.hH6(this.manager);

      l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (n) {
        try {
          s.parse(n, o, function (n) {
            t(n), s.manager.itemEnd(e);
          }, a);
        } catch (e) {
          a(e);
        }
      }, n, a);
    }

    setDRACOLoader(e) {
      return this.dracoLoader = e, this;
    }

    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }

    setKTX2Loader(e) {
      return this.ktx2Loader = e, this;
    }

    setMeshoptDecoder(e) {
      return this.meshoptDecoder = e, this;
    }

    register(e) {
      return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
    }

    unregister(e) {
      return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }

    parse(e, t, n, r) {
      let s;
      const o = {},
            a = {};
      if ("string" == typeof e) s = e;else if (i.Zp0.decodeText(new Uint8Array(e, 0, 4)) === bn) {
        try {
          o[sn.KHR_BINARY_GLTF] = new xn(e);
        } catch (e) {
          return void (r && r(e));
        }

        s = o[sn.KHR_BINARY_GLTF].content;
      } else s = i.Zp0.decodeText(new Uint8Array(e));
      const l = JSON.parse(s);
      if (void 0 === l.asset || l.asset.version[0] < 2) return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
      const c = new Vn(l, {
        path: t || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      c.fileLoader.setRequestHeader(this.requestHeader);

      for (let e = 0; e < this.pluginCallbacks.length; e++) {
        const t = this.pluginCallbacks[e](c);
        a[t.name] = t, o[t.name] = !0;
      }

      if (l.extensionsUsed) for (let e = 0; e < l.extensionsUsed.length; ++e) {
        const t = l.extensionsUsed[e],
              n = l.extensionsRequired || [];

        switch (t) {
          case sn.KHR_MATERIALS_UNLIT:
            o[t] = new an();
            break;

          case sn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            o[t] = new Mn();
            break;

          case sn.KHR_DRACO_MESH_COMPRESSION:
            o[t] = new yn(l, this.dracoLoader);
            break;

          case sn.KHR_TEXTURE_TRANSFORM:
            o[t] = new wn();
            break;

          case sn.KHR_MESH_QUANTIZATION:
            o[t] = new Tn();
            break;

          default:
            n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".');
        }
      }
      c.setExtensions(o), c.setPlugins(a), c.parse(n, r);
    }

    parseAsync(e, t) {
      const n = this;
      return new Promise(function (r, i) {
        n.parse(e, t, r, i);
      });
    }

  }

  function rn() {
    let e = {};
    return {
      get: function (t) {
        return e[t];
      },
      add: function (t, n) {
        e[t] = n;
      },
      remove: function (t) {
        delete e[t];
      },
      removeAll: function () {
        e = {};
      }
    };
  }

  const sn = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
  };

  class on {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_LIGHTS_PUNCTUAL, this.cache = {
        refs: {},
        uses: {}
      };
    }

    _markDefs() {
      const e = this.parser,
            t = this.parser.json.nodes || [];

      for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n];
        r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light);
      }
    }

    _loadLight(e) {
      const t = this.parser,
            n = "light:" + e;
      let r = t.cache.get(n);
      if (r) return r;
      const s = t.json,
            o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
      let a;
      const l = new i.Ilk(16777215);
      void 0 !== o.color && l.fromArray(o.color);
      const c = void 0 !== o.range ? o.range : 0;

      switch (o.type) {
        case "directional":
          a = new i.Ox3(l), a.target.position.set(0, 0, -1), a.add(a.target);
          break;

        case "point":
          a = new i.cek(l), a.distance = c;
          break;

        case "spot":
          a = new i.PMe(l), a.distance = c, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
          break;

        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type);
      }

      return a.position.set(0, 0, 0), a.decay = 2, void 0 !== o.intensity && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(a), t.cache.add(n, r), r;
    }

    createNodeAttachment(e) {
      const t = this,
            n = this.parser,
            r = n.json.nodes[e],
            i = (r.extensions && r.extensions[this.name] || {}).light;
      return void 0 === i ? null : this._loadLight(i).then(function (e) {
        return n._getNodeRef(t.cache, i, e);
      });
    }

  }

  class an {
    constructor() {
      this.name = sn.KHR_MATERIALS_UNLIT;
    }

    getMaterialType() {
      return i.vBJ;
    }

    extendParams(e, t, n) {
      const r = [];
      e.color = new i.Ilk(1, 1, 1), e.opacity = 1;
      const s = t.pbrMetallicRoughness;

      if (s) {
        if (Array.isArray(s.baseColorFactor)) {
          const t = s.baseColorFactor;
          e.color.fromArray(t), e.opacity = t[3];
        }

        void 0 !== s.baseColorTexture && r.push(n.assignTexture(e, "map", s.baseColorTexture, i.knz));
      }

      return Promise.all(r);
    }

  }

  class ln {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }

    extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name].emissiveStrength;
      return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve();
    }

  }

  class cn {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_CLEARCOAT;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [],
            o = r.extensions[this.name];

      if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && s.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (s.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
        const e = o.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new i.FM8(e, e);
      }

      return Promise.all(s);
    }

  }

  class un {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_IRIDESCENCE;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(i);
    }

  }

  class pn {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_SHEEN;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [];
      t.sheenColor = new i.Ilk(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
      const o = r.extensions[this.name];
      return void 0 !== o.sheenColorFactor && t.sheenColor.fromArray(o.sheenColorFactor), void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && s.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, i.knz)), void 0 !== o.sheenRoughnessTexture && s.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), r.extras && void 0 !== r.extras.sheenFactor && (t.sheen = r.extras.sheenFactor, delete r.extras.sheenFactor), Promise.all(s);
    }

  }

  class hn {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_TRANSMISSION;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(i);
    }

  }

  class dn {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_VOLUME;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [],
            o = r.extensions[this.name];
      t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 0;
      const a = o.attenuationColor || [1, 1, 1];
      return t.attenuationColor = new i.Ilk(a[0], a[1], a[2]), Promise.all(s);
    }

  }

  class fn {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_IOR;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve();
    }

  }

  class _n {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_MATERIALS_SPECULAR;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [],
            o = r.extensions[this.name];
      t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && s.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
      const a = o.specularColorFactor || [1, 1, 1];
      return t.specularColor = new i.Ilk(a[0], a[1], a[2]), void 0 !== o.specularColorTexture && s.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, i.knz)), Promise.all(s);
    }

  }

  class mn {
    constructor(e) {
      this.parser = e, this.name = sn.KHR_TEXTURE_BASISU;
    }

    loadTexture(e) {
      const t = this.parser,
            n = t.json,
            r = n.textures[e];
      if (!r.extensions || !r.extensions[this.name]) return null;
      const i = r.extensions[this.name],
            s = t.options.ktx2Loader;

      if (!s) {
        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }

      return t.loadTextureImage(e, i.source, s);
    }

  }

  class gn {
    constructor(e) {
      this.parser = e, this.name = sn.EXT_TEXTURE_WEBP, this.isSupported = null;
    }

    loadTexture(e) {
      const t = this.name,
            n = this.parser,
            r = n.json,
            i = r.textures[e];
      if (!i.extensions || !i.extensions[t]) return null;
      const s = i.extensions[t],
            o = r.images[s.source];
      let a = n.textureLoader;

      if (o.uri) {
        const e = n.options.manager.getHandler(o.uri);
        null !== e && (a = e);
      }

      return this.detectSupport().then(function (i) {
        if (i) return n.loadTextureImage(e, s.source, a);
        if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n.loadTexture(e);
      });
    }

    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function (e) {
        const t = new Image();
        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
          e(1 === t.height);
        };
      })), this.isSupported;
    }

  }

  class vn {
    constructor(e) {
      this.name = sn.EXT_MESHOPT_COMPRESSION, this.parser = e;
    }

    loadBufferView(e) {
      const t = this.parser.json,
            n = t.bufferViews[e];

      if (n.extensions && n.extensions[this.name]) {
        const e = n.extensions[this.name],
              r = this.parser.getDependency("buffer", e.buffer),
              i = this.parser.options.meshoptDecoder;

        if (!i || !i.supported) {
          if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }

        return Promise.all([r, i.ready]).then(function (t) {
          const n = e.byteOffset || 0,
                r = e.byteLength || 0,
                s = e.count,
                o = e.byteStride,
                a = new ArrayBuffer(s * o),
                l = new Uint8Array(t[0], n, r);
          return i.decodeGltfBuffer(new Uint8Array(a), s, o, l, e.mode, e.filter), a;
        });
      }

      return null;
    }

  }

  const bn = "glTF";

  class xn {
    constructor(e) {
      this.name = sn.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const t = new DataView(e, 0, 12);
      if (this.header = {
        magic: i.Zp0.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0)
      }, this.header.magic !== bn) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const n = this.header.length - 12,
            r = new DataView(e, 12);
      let s = 0;

      for (; s < n;) {
        const t = r.getUint32(s, !0);
        s += 4;
        const n = r.getUint32(s, !0);

        if (s += 4, 1313821514 === n) {
          const n = new Uint8Array(e, 12 + s, t);
          this.content = i.Zp0.decodeText(n);
        } else if (5130562 === n) {
          const n = 12 + s;
          this.body = e.slice(n, n + t);
        }

        s += t;
      }

      if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }

  }

  class yn {
    constructor(e, t) {
      if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = sn.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
    }

    decodePrimitive(e, t) {
      const n = this.json,
            r = this.dracoLoader,
            i = e.extensions[this.name].bufferView,
            s = e.extensions[this.name].attributes,
            o = {},
            a = {},
            l = {};

      for (const e in s) {
        const t = On[e] || e.toLowerCase();
        o[t] = s[e];
      }

      for (const t in e.attributes) {
        const r = On[t] || t.toLowerCase();

        if (void 0 !== s[t]) {
          const i = n.accessors[e.attributes[t]],
                s = Rn[i.componentType];
          l[r] = s, a[r] = !0 === i.normalized;
        }
      }

      return t.getDependency("bufferView", i).then(function (e) {
        return new Promise(function (t) {
          r.decodeDracoFile(e, function (e) {
            for (const t in e.attributes) {
              const n = e.attributes[t],
                    r = a[t];
              void 0 !== r && (n.normalized = r);
            }

            t(e);
          }, o, l);
        });
      });
    }

  }

  class wn {
    constructor() {
      this.name = sn.KHR_TEXTURE_TRANSFORM;
    }

    extendTexture(e, t) {
      return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
    }

  }

  class Sn extends i.Wid {
    constructor(e) {
      super(), this.isGLTFSpecularGlossinessMaterial = !0;
      const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
            n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
            r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
            s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
            o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
            a = {
        specular: {
          value: new i.Ilk().setHex(16777215)
        },
        glossiness: {
          value: 1
        },
        specularMap: {
          value: null
        },
        glossinessMap: {
          value: null
        }
      };
      this._extraUniforms = a, this.onBeforeCompile = function (e) {
        for (const t in a) e.uniforms[t] = a[t];

        e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o);
      }, Object.defineProperties(this, {
        specular: {
          get: function () {
            return a.specular.value;
          },
          set: function (e) {
            a.specular.value = e;
          }
        },
        specularMap: {
          get: function () {
            return a.specularMap.value;
          },
          set: function (e) {
            a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
          }
        },
        glossiness: {
          get: function () {
            return a.glossiness.value;
          },
          set: function (e) {
            a.glossiness.value = e;
          }
        },
        glossinessMap: {
          get: function () {
            return a.glossinessMap.value;
          },
          set: function (e) {
            a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
          }
        }
      }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e);
    }

    copy(e) {
      return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
    }

  }

  class Mn {
    constructor() {
      this.name = sn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"];
    }

    getMaterialType() {
      return Sn;
    }

    extendParams(e, t, n) {
      const r = t.extensions[this.name];
      e.color = new i.Ilk(1, 1, 1), e.opacity = 1;
      const s = [];

      if (Array.isArray(r.diffuseFactor)) {
        const t = r.diffuseFactor;
        e.color.fromArray(t), e.opacity = t[3];
      }

      if (void 0 !== r.diffuseTexture && s.push(n.assignTexture(e, "map", r.diffuseTexture, i.knz)), e.emissive = new i.Ilk(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new i.Ilk(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
        const t = r.specularGlossinessTexture;
        s.push(n.assignTexture(e, "glossinessMap", t)), s.push(n.assignTexture(e, "specularMap", t, i.knz));
      }

      return Promise.all(s);
    }

    createMaterial(e) {
      const t = new Sn(e);
      return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = i.IOt, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t;
    }

  }

  class Tn {
    constructor() {
      this.name = sn.KHR_MESH_QUANTIZATION;
    }

  }

  class En extends i._C8 {
    constructor(e, t, n, r) {
      super(e, t, n, r);
    }

    copySampleValue_(e) {
      const t = this.resultBuffer,
            n = this.sampleValues,
            r = this.valueSize,
            i = e * r * 3 + r;

      for (let e = 0; e !== r; e++) t[e] = n[i + e];

      return t;
    }

    interpolate_(e, t, n, r) {
      const i = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = 2 * o,
            l = 3 * o,
            c = r - t,
            u = (n - t) / c,
            p = u * u,
            h = p * u,
            d = e * l,
            f = d - l,
            _ = -2 * h + 3 * p,
            m = h - p,
            g = 1 - _,
            v = m - p + u;

      for (let e = 0; e !== o; e++) {
        const t = s[f + e + o],
              n = s[f + e + a] * c,
              r = s[d + e + o],
              l = s[d + e] * c;
        i[e] = g * t + v * n + _ * r + m * l;
      }

      return i;
    }

  }

  const An = new i._fP();

  class Cn extends En {
    interpolate_(e, t, n, r) {
      const i = super.interpolate_(e, t, n, r);
      return An.fromArray(i).normalize().toArray(i), i;
    }

  }

  const Rn = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  },
        kn = {
    9728: i.TyD,
    9729: i.wem,
    9984: i.YLQ,
    9985: i.qyh,
    9986: i.aH4,
    9987: i.D1R
  },
        Pn = {
    33071: i.uWy,
    33648: i.OoA,
    10497: i.rpg
  },
        Dn = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  },
        On = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  },
        Ln = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  },
        In = {
    CUBICSPLINE: void 0,
    LINEAR: i.NMF,
    STEP: i.Syv
  };

  function Fn(e, t, n) {
    for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r]);
  }

  function Nn(e, t) {
    void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
  }

  function Un(e, t) {
    if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];

    if (t.extras && Array.isArray(t.extras.targetNames)) {
      const n = t.extras.targetNames;

      if (e.morphTargetInfluences.length === n.length) {
        e.morphTargetDictionary = {};

        for (let t = 0, r = n.length; t < r; t++) e.morphTargetDictionary[n[t]] = t;
      } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }

  function Bn(e) {
    const t = e.extensions && e.extensions[sn.KHR_DRACO_MESH_COMPRESSION];
    let n;
    return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + jn(t.attributes) : e.indices + ":" + jn(e.attributes) + ":" + e.mode, n;
  }

  function jn(e) {
    let t = "";
    const n = Object.keys(e).sort();

    for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";

    return t;
  }

  function zn(e) {
    switch (e) {
      case Int8Array:
        return 1 / 127;

      case Uint8Array:
        return 1 / 255;

      case Int16Array:
        return 1 / 32767;

      case Uint16Array:
        return 1 / 65535;

      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }

  class Vn {
    constructor(e = {}, t = {}) {
      this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new rn(), this.associations = new Map(), this.primitiveCache = {}, this.meshCache = {
        refs: {},
        uses: {}
      }, this.cameraCache = {
        refs: {},
        uses: {}
      }, this.lightCache = {
        refs: {},
        uses: {}
      }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      const n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
            r = navigator.userAgent.indexOf("Firefox") > -1,
            s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
      "undefined" == typeof createImageBitmap || n || r && s < 98 ? this.textureLoader = new i.dpR(this.options.manager) : this.textureLoader = new i.QRU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new i.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
    }

    setExtensions(e) {
      this.extensions = e;
    }

    setPlugins(e) {
      this.plugins = e;
    }

    parse(e, t) {
      const n = this,
            r = this.json,
            i = this.extensions;
      this.cache.removeAll(), this._invokeAll(function (e) {
        return e._markDefs && e._markDefs();
      }), Promise.all(this._invokeAll(function (e) {
        return e.beforeRoot && e.beforeRoot();
      })).then(function () {
        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]);
      }).then(function (t) {
        const s = {
          scene: t[0][r.scene || 0],
          scenes: t[0],
          animations: t[1],
          cameras: t[2],
          asset: r.asset,
          parser: n,
          userData: {}
        };
        Fn(i, s, r), Nn(s, r), Promise.all(n._invokeAll(function (e) {
          return e.afterRoot && e.afterRoot(s);
        })).then(function () {
          e(s);
        });
      }).catch(t);
    }

    _markDefs() {
      const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];

      for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n].joints;

        for (let t = 0, n = r.length; t < n; t++) e[r[t]].isBone = !0;
      }

      for (let t = 0, r = e.length; t < r; t++) {
        const r = e[t];
        void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera);
      }
    }

    _addNodeRef(e, t) {
      void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
    }

    _getNodeRef(e, t, n) {
      if (e.refs[t] <= 1) return n;

      const r = n.clone(),
            i = (e, t) => {
        const n = this.associations.get(e);
        null != n && this.associations.set(t, n);

        for (const [n, r] of e.children.entries()) i(r, t.children[n]);
      };

      return i(n, r), r.name += "_instance_" + e.uses[t]++, r;
    }

    _invokeOne(e) {
      const t = Object.values(this.plugins);
      t.push(this);

      for (let n = 0; n < t.length; n++) {
        const r = e(t[n]);
        if (r) return r;
      }

      return null;
    }

    _invokeAll(e) {
      const t = Object.values(this.plugins);
      t.unshift(this);
      const n = [];

      for (let r = 0; r < t.length; r++) {
        const i = e(t[r]);
        i && n.push(i);
      }

      return n;
    }

    getDependency(e, t) {
      const n = e + ":" + t;
      let r = this.cache.get(n);

      if (!r) {
        switch (e) {
          case "scene":
            r = this.loadScene(t);
            break;

          case "node":
            r = this.loadNode(t);
            break;

          case "mesh":
            r = this._invokeOne(function (e) {
              return e.loadMesh && e.loadMesh(t);
            });
            break;

          case "accessor":
            r = this.loadAccessor(t);
            break;

          case "bufferView":
            r = this._invokeOne(function (e) {
              return e.loadBufferView && e.loadBufferView(t);
            });
            break;

          case "buffer":
            r = this.loadBuffer(t);
            break;

          case "material":
            r = this._invokeOne(function (e) {
              return e.loadMaterial && e.loadMaterial(t);
            });
            break;

          case "texture":
            r = this._invokeOne(function (e) {
              return e.loadTexture && e.loadTexture(t);
            });
            break;

          case "skin":
            r = this.loadSkin(t);
            break;

          case "animation":
            r = this._invokeOne(function (e) {
              return e.loadAnimation && e.loadAnimation(t);
            });
            break;

          case "camera":
            r = this.loadCamera(t);
            break;

          default:
            throw new Error("Unknown type: " + e);
        }

        this.cache.add(n, r);
      }

      return r;
    }

    getDependencies(e) {
      let t = this.cache.get(e);

      if (!t) {
        const n = this,
              r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
        t = Promise.all(r.map(function (t, r) {
          return n.getDependency(e, r);
        })), this.cache.add(e, t);
      }

      return t;
    }

    loadBuffer(e) {
      const t = this.json.buffers[e],
            n = this.fileLoader;
      if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
      if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[sn.KHR_BINARY_GLTF].body);
      const r = this.options;
      return new Promise(function (e, s) {
        n.load(i.Zp0.resolveURL(t.uri, r.path), e, void 0, function () {
          s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
        });
      });
    }

    loadBufferView(e) {
      const t = this.json.bufferViews[e];
      return this.getDependency("buffer", t.buffer).then(function (e) {
        const n = t.byteLength || 0,
              r = t.byteOffset || 0;
        return e.slice(r, r + n);
      });
    }

    loadAccessor(e) {
      const t = this,
            n = this.json,
            r = this.json.accessors[e];
      if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null);
      const s = [];
      return void 0 !== r.bufferView ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), void 0 !== r.sparse && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function (e) {
        const s = e[0],
              o = Dn[r.type],
              a = Rn[r.componentType],
              l = a.BYTES_PER_ELEMENT,
              c = l * o,
              u = r.byteOffset || 0,
              p = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
              h = !0 === r.normalized;
        let d, f;

        if (p && p !== c) {
          const e = Math.floor(u / p),
                n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
          let c = t.cache.get(n);
          c || (d = new a(s, e * p, r.count * p / l), c = new i.vpT(d, p / l), t.cache.add(n, c)), f = new i.kB5(c, o, u % p / l, h);
        } else d = null === s ? new a(r.count * o) : new a(s, u, r.count * o), f = new i.TlE(d, o, h);

        if (void 0 !== r.sparse) {
          const t = Dn.SCALAR,
                n = Rn[r.sparse.indices.componentType],
                l = r.sparse.indices.byteOffset || 0,
                c = r.sparse.values.byteOffset || 0,
                u = new n(e[1], l, r.sparse.count * t),
                p = new a(e[2], c, r.sparse.count * o);
          null !== s && (f = new i.TlE(f.array.slice(), f.itemSize, f.normalized));

          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e];
            if (f.setX(t, p[e * o]), o >= 2 && f.setY(t, p[e * o + 1]), o >= 3 && f.setZ(t, p[e * o + 2]), o >= 4 && f.setW(t, p[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }

        return f;
      });
    }

    loadTexture(e) {
      const t = this.json,
            n = this.options,
            r = t.textures[e].source,
            i = t.images[r];
      let s = this.textureLoader;

      if (i.uri) {
        const e = n.manager.getHandler(i.uri);
        null !== e && (s = e);
      }

      return this.loadTextureImage(e, r, s);
    }

    loadTextureImage(e, t, n) {
      const r = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[t],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
      if (this.textureCache[l]) return this.textureCache[l];
      const c = this.loadImageSource(t, n).then(function (t) {
        o.name && (t.name = o.name);
        const n = (s.samplers || {})[o.sampler] || {};
        return t.magFilter = kn[n.magFilter] || i.wem, t.minFilter = kn[n.minFilter] || i.D1R, t.wrapS = Pn[n.wrapS] || i.rpg, t.wrapT = Pn[n.wrapT] || i.rpg, r.associations.set(t, {
          textures: e
        }), t;
      }).catch(function () {
        return null;
      });
      return this.textureCache[l] = c, c;
    }

    loadImageSource(e, t) {
      const n = this.json,
            r = this.options;
      if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then(e => e.clone());
      const s = n.images[e],
            o = self.URL || self.webkitURL;
      let a = s.uri || "",
          l = !1;
      if (void 0 !== s.bufferView) a = this.getDependency("bufferView", s.bufferView).then(function (e) {
        l = !0;
        const t = new Blob([e], {
          type: s.mimeType
        });
        return a = o.createObjectURL(t), a;
      });else if (void 0 === s.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
      const c = Promise.resolve(a).then(function (e) {
        return new Promise(function (n, s) {
          let o = n;
          !0 === t.isImageBitmapLoader && (o = function (e) {
            const t = new i.xEZ(e);
            t.needsUpdate = !0, n(t);
          }), t.load(i.Zp0.resolveURL(e, r.path), o, void 0, s);
        });
      }).then(function (e) {
        var n;

        if (!0 === l && o.revokeObjectURL(a), e.userData.mimeType = s.mimeType || ((n = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === n.search(/^data\:image\/jpeg/) ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || 0 === n.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e.flipY = !1, s.extras) {
          if (void 0 !== s.extras.flipY) {
            if (!0 === t.isImageBitmapLoader && void 0 !== typeof createImageBitmap) {
              const t = e,
                    n = s.extras.flipY && !t.flipY;
              createImageBitmap(t.source.data, {
                imageOrientation: n ? "flipY" : "none"
              }).then(function (e) {
                t.source.data.close && t.source.data.close(), t.source.data = e, t.source.needsUpdate = !0, t.needsUpdate = !0;
              });
            }

            e.flipY = s.extras.flipY, e.needsUpdate = !0, delete s.extras.flipY;
          }

          void 0 !== s.extras.uuid && (e.uuid = s.extras.uuid, delete s.extras.uuid);
        }

        return s.uri && "string" == typeof s.uri && (e.userData.rootPath = s.uri), e;
      }).catch(function (e) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e;
      });
      return this.sourceCache[e] = c, c;
    }

    assignTexture(e, t, n, r) {
      const i = this;
      return this.getDependency("texture", n.index).then(function (s) {
        if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[sn.KHR_TEXTURE_TRANSFORM]) {
          const e = void 0 !== n.extensions ? n.extensions[sn.KHR_TEXTURE_TRANSFORM] : void 0;

          if (e) {
            const t = i.associations.get(s);
            s = i.extensions[sn.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), i.associations.set(s, t);
          }
        }

        return void 0 !== r && (s.encoding = r), e[t] = s, s;
      });
    }

    assignFinalMaterial(e) {
      const t = e.geometry;
      let n = e.material;
      const r = void 0 === t.attributes.tangent,
            s = void 0 !== t.attributes.color,
            o = void 0 === t.attributes.normal;

      if (e.isPoints) {
        const e = "PointsMaterial:" + n.uuid;
        let t = this.cache.get(e);
        t || (t = new i.UY4(), i.F5T.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t;
      } else if (e.isLine) {
        const e = "LineBasicMaterial:" + n.uuid;
        let t = this.cache.get(e);
        t || (t = new i.nls(), i.F5T.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t;
      }

      if (r || s || o) {
        let e = "ClonedMaterial:" + n.uuid + ":";
        n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), r && (e += "derivative-tangents:"), s && (e += "vertex-colors:"), o && (e += "flat-shading:");
        let t = this.cache.get(e);
        t || (t = n.clone(), s && (t.vertexColors = !0), o && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t;
      }

      n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n;
    }

    getMaterialType() {
      return i.Wid;
    }

    loadMaterial(e) {
      const t = this,
            n = this.json,
            r = this.extensions,
            s = n.materials[e];
      let o;
      const a = {},
            l = s.extensions || {},
            c = [];

      if (l[sn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const e = r[sn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        o = e.getMaterialType(), c.push(e.extendParams(a, s, t));
      } else if (l[sn.KHR_MATERIALS_UNLIT]) {
        const e = r[sn.KHR_MATERIALS_UNLIT];
        o = e.getMaterialType(), c.push(e.extendParams(a, s, t));
      } else {
        const n = s.pbrMetallicRoughness || {};

        if (a.color = new i.Ilk(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
          const e = n.baseColorFactor;
          a.color.fromArray(e), a.opacity = e[3];
        }

        void 0 !== n.baseColorTexture && c.push(t.assignTexture(a, "map", n.baseColorTexture, i.knz)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (c.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne(function (t) {
          return t.getMaterialType && t.getMaterialType(e);
        }), c.push(Promise.all(this._invokeAll(function (t) {
          return t.extendMaterialParams && t.extendMaterialParams(e, a);
        })));
      }

      !0 === s.doubleSided && (a.side = i.ehD);
      const u = s.alphaMode || "OPAQUE";

      if ("BLEND" === u ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, "MASK" === u && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && o !== i.vBJ && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new i.FM8(1, 1), void 0 !== s.normalTexture.scale)) {
        const e = s.normalTexture.scale;
        a.normalScale.set(e, e);
      }

      return void 0 !== s.occlusionTexture && o !== i.vBJ && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && o !== i.vBJ && (a.emissive = new i.Ilk().fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && o !== i.vBJ && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, i.knz)), Promise.all(c).then(function () {
        let n;
        return n = o === Sn ? r[sn.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new o(a), s.name && (n.name = s.name), Nn(n, s), t.associations.set(n, {
          materials: e
        }), s.extensions && Fn(r, n, s), n;
      });
    }

    createUniqueName(e) {
      const t = i.iUV.sanitizeNodeName(e || "");
      let n = t;

      for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;

      return this.nodeNamesUsed[n] = !0, n;
    }

    loadGeometries(e) {
      const t = this,
            n = this.extensions,
            r = this.primitiveCache;

      function s(e) {
        return n[sn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (n) {
          return Hn(n, e, t);
        });
      }

      const o = [];

      for (let n = 0, a = e.length; n < a; n++) {
        const a = e[n],
              l = Bn(a),
              c = r[l];
        if (c) o.push(c.promise);else {
          let e;
          e = a.extensions && a.extensions[sn.KHR_DRACO_MESH_COMPRESSION] ? s(a) : Hn(new i.u9r(), a, t), r[l] = {
            primitive: a,
            promise: e
          }, o.push(e);
        }
      }

      return Promise.all(o);
    }

    loadMesh(e) {
      const t = this,
            n = this.json,
            r = this.extensions,
            s = n.meshes[e],
            o = s.primitives,
            a = [];

      for (let e = 0, t = o.length; e < t; e++) {
        const t = void 0 === o[e].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new i.Wid({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: !1,
          depthTest: !0,
          side: i.Wl3
        })), l.DefaultMaterial) : this.getDependency("material", o[e].material);
        a.push(t);
      }

      var l;
      return a.push(t.loadGeometries(o)), Promise.all(a).then(function (n) {
        const a = n.slice(0, n.length - 1),
              l = n[n.length - 1],
              c = [];

        for (let n = 0, u = l.length; n < u; n++) {
          const u = l[n],
                p = o[n];
          let h;
          const d = a[n];
          if (4 === p.mode || 5 === p.mode || 6 === p.mode || void 0 === p.mode) h = !0 === s.isSkinnedMesh ? new i.TUv(u, d) : new i.Kj0(u, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), 5 === p.mode ? h.geometry = Wn(h.geometry, i.UlW) : 6 === p.mode && (h.geometry = Wn(h.geometry, i.z$h));else if (1 === p.mode) h = new i.ejS(u, d);else if (3 === p.mode) h = new i.x12(u, d);else if (2 === p.mode) h = new i.blk(u, d);else {
            if (0 !== p.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
            h = new i.woe(u, d);
          }
          Object.keys(h.geometry.morphAttributes).length > 0 && Un(h, s), h.name = t.createUniqueName(s.name || "mesh_" + e), Nn(h, s), p.extensions && Fn(r, h, p), t.assignFinalMaterial(h), c.push(h);
        }

        s.extensions && c.forEach(e => Fn(r, e, s));

        for (let n = 0, r = c.length; n < r; n++) t.associations.set(c[n], {
          meshes: e,
          primitives: n
        });

        if (1 === c.length) return c[0];
        const u = new i.ZAu();
        t.associations.set(u, {
          meshes: e
        });

        for (let e = 0, t = c.length; e < t; e++) u.add(c[e]);

        return u;
      });
    }

    loadCamera(e) {
      let t;
      const n = this.json.cameras[e],
            r = n[n.type];
      if (r) return "perspective" === n.type ? t = new i.cPb(i.M8C.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new i.iKG(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Nn(t, n), Promise.resolve(t);
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }

    loadSkin(e) {
      const t = this.json.skins[e],
            n = {
        joints: t.joints
      };
      return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) {
        return n.inverseBindMatrices = e, n;
      });
    }

    loadAnimation(e) {
      const t = this.json.animations[e],
            n = [],
            r = [],
            s = [],
            o = [],
            a = [];

      for (let e = 0, i = t.channels.length; e < i; e++) {
        const i = t.channels[e],
              l = t.samplers[i.sampler],
              c = i.target,
              u = void 0 !== c.node ? c.node : c.id,
              p = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
              h = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
        n.push(this.getDependency("node", u)), r.push(this.getDependency("accessor", p)), s.push(this.getDependency("accessor", h)), o.push(l), a.push(c);
      }

      return Promise.all([Promise.all(n), Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a)]).then(function (n) {
        const r = n[0],
              s = n[1],
              o = n[2],
              a = n[3],
              l = n[4],
              c = [];

        for (let e = 0, t = r.length; e < t; e++) {
          const t = r[e],
                n = s[e],
                u = o[e],
                p = a[e],
                h = l[e];
          if (void 0 === t) continue;
          let d;

          switch (t.updateMatrix(), Ln[h.path]) {
            case Ln.weights:
              d = i.dUE;
              break;

            case Ln.rotation:
              d = i.iLg;
              break;

            default:
              d = i.yC1;
          }

          const f = t.name ? t.name : t.uuid,
                _ = void 0 !== p.interpolation ? In[p.interpolation] : i.NMF,
                m = [];

          Ln[h.path] === Ln.weights ? t.traverse(function (e) {
            e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid);
          }) : m.push(f);
          let g = u.array;

          if (u.normalized) {
            const e = zn(g.constructor),
                  t = new Float32Array(g.length);

            for (let n = 0, r = g.length; n < r; n++) t[n] = g[n] * e;

            g = t;
          }

          for (let e = 0, t = m.length; e < t; e++) {
            const t = new d(m[e] + "." + Ln[h.path], n.array, g, _);
            "CUBICSPLINE" === p.interpolation && (t.createInterpolant = function (e) {
              return new (this instanceof i.iLg ? Cn : En)(this.times, this.values, this.getValueSize() / 3, e);
            }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(t);
          }
        }

        const u = t.name ? t.name : "animation_" + e;
        return new i.m7l(u, void 0, c);
      });
    }

    createNodeMesh(e) {
      const t = this.json,
            n = this,
            r = t.nodes[e];
      return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then(function (e) {
        const t = n._getNodeRef(n.meshCache, r.mesh, e);

        return void 0 !== r.weights && t.traverse(function (e) {
          if (e.isMesh) for (let t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t];
        }), t;
      });
    }

    loadNode(e) {
      const t = this.json,
            n = this.extensions,
            r = this,
            s = t.nodes[e],
            o = s.name ? r.createUniqueName(s.name) : "";
      return function () {
        const t = [],
              n = r._invokeOne(function (t) {
          return t.createNodeMesh && t.createNodeMesh(e);
        });

        return n && t.push(n), void 0 !== s.camera && t.push(r.getDependency("camera", s.camera).then(function (e) {
          return r._getNodeRef(r.cameraCache, s.camera, e);
        })), r._invokeAll(function (t) {
          return t.createNodeAttachment && t.createNodeAttachment(e);
        }).forEach(function (e) {
          t.push(e);
        }), Promise.all(t);
      }().then(function (t) {
        let a;
        if (a = !0 === s.isBone ? new i.N$j() : t.length > 1 ? new i.ZAu() : 1 === t.length ? t[0] : new i.Tme(), a !== t[0]) for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);

        if (s.name && (a.userData.name = s.name, a.name = o), Nn(a, s), s.extensions && Fn(n, a, s), void 0 !== s.matrix) {
          const e = new i.yGw();
          e.fromArray(s.matrix), a.applyMatrix4(e);
        } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);

        return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = e, a;
      });
    }

    loadScene(e) {
      const t = this.json,
            n = this.extensions,
            r = this.json.scenes[e],
            s = this,
            o = new i.ZAu();
      r.name && (o.name = s.createUniqueName(r.name)), Nn(o, r), r.extensions && Fn(n, o, r);
      const a = r.nodes || [],
            l = [];

      for (let e = 0, n = a.length; e < n; e++) l.push(Gn(a[e], o, t, s));

      return Promise.all(l).then(function () {
        return s.associations = (e => {
          const t = new Map();

          for (const [e, n] of s.associations) (e instanceof i.F5T || e instanceof i.xEZ) && t.set(e, n);

          return e.traverse(e => {
            const n = s.associations.get(e);
            null != n && t.set(e, n);
          }), t;
        })(o), o;
      });
    }

  }

  function Gn(e, t, n, r) {
    const s = n.nodes[e];
    return r.getDependency("node", e).then(function (e) {
      if (void 0 === s.skin) return e;
      let t;
      return r.getDependency("skin", s.skin).then(function (e) {
        t = e;
        const n = [];

        for (let e = 0, i = t.joints.length; e < i; e++) n.push(r.getDependency("node", t.joints[e]));

        return Promise.all(n);
      }).then(function (n) {
        return e.traverse(function (e) {
          if (!e.isMesh) return;
          const r = [],
                s = [];

          for (let e = 0, o = n.length; e < o; e++) {
            const o = n[e];

            if (o) {
              r.push(o);
              const n = new i.yGw();
              void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), s.push(n);
            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]);
          }

          e.bind(new i.OdW(r, s), e.matrixWorld);
        }), e;
      });
    }).then(function (e) {
      t.add(e);
      const i = [];

      if (s.children) {
        const t = s.children;

        for (let s = 0, o = t.length; s < o; s++) {
          const o = t[s];
          i.push(Gn(o, e, n, r));
        }
      }

      return Promise.all(i);
    });
  }

  function Hn(e, t, n) {
    const r = t.attributes,
          s = [];

    function o(t, r) {
      return n.getDependency("accessor", t).then(function (t) {
        e.setAttribute(r, t);
      });
    }

    for (const t in r) {
      const n = On[t] || t.toLowerCase();
      n in e.attributes || s.push(o(r[t], n));
    }

    if (void 0 !== t.indices && !e.index) {
      const r = n.getDependency("accessor", t.indices).then(function (t) {
        e.setIndex(t);
      });
      s.push(r);
    }

    return Nn(e, t), function (e, t, n) {
      const r = t.attributes,
            s = new i.ZzF();
      if (void 0 === r.POSITION) return;
      {
        const e = n.json.accessors[r.POSITION],
              t = e.min,
              o = e.max;
        if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");

        if (s.set(new i.Pa4(t[0], t[1], t[2]), new i.Pa4(o[0], o[1], o[2])), e.normalized) {
          const t = zn(Rn[e.componentType]);
          s.min.multiplyScalar(t), s.max.multiplyScalar(t);
        }
      }
      const o = t.targets;

      if (void 0 !== o) {
        const e = new i.Pa4(),
              t = new i.Pa4();

        for (let r = 0, i = o.length; r < i; r++) {
          const i = o[r];

          if (void 0 !== i.POSITION) {
            const r = n.json.accessors[i.POSITION],
                  s = r.min,
                  o = r.max;

            if (void 0 !== s && void 0 !== o) {
              if (t.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), r.normalized) {
                const e = zn(Rn[r.componentType]);
                t.multiplyScalar(e);
              }

              e.max(t);
            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }

        s.expandByVector(e);
      }

      e.boundingBox = s;
      const a = new i.aLr();
      s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = a;
    }(e, t, n), Promise.all(s).then(function () {
      return void 0 !== t.targets ? function (e, t, n) {
        let r = !1,
            i = !1,
            s = !1;

        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), void 0 !== n.COLOR_0 && (s = !0), r && i && s) break;
        }

        if (!r && !i && !s) return Promise.resolve(e);
        const o = [],
              a = [],
              l = [];

        for (let c = 0, u = t.length; c < u; c++) {
          const u = t[c];

          if (r) {
            const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
            o.push(t);
          }

          if (i) {
            const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
            a.push(t);
          }

          if (s) {
            const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
            l.push(t);
          }
        }

        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (t) {
          const n = t[0],
                o = t[1],
                a = t[2];
          return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = o), s && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e;
        });
      }(e, t.targets, n) : e;
    });
  }

  function Wn(e, t) {
    let n = e.getIndex();

    if (null === n) {
      const t = [],
            r = e.getAttribute("position");
      if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;

      for (let e = 0; e < r.count; e++) t.push(e);

      e.setIndex(t), n = e.getIndex();
    }

    const r = n.count - 2,
          s = [];
    if (t === i.z$h) for (let e = 1; e <= r; e++) s.push(n.getX(0)), s.push(n.getX(e)), s.push(n.getX(e + 1));else for (let e = 0; e < r; e++) e % 2 == 0 ? (s.push(n.getX(e)), s.push(n.getX(e + 1)), s.push(n.getX(e + 2))) : (s.push(n.getX(e + 2)), s.push(n.getX(e + 1)), s.push(n.getX(e)));
    s.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const o = e.clone();
    return o.setIndex(s), o;
  }

  class Kn extends nn {
    constructor(e) {
      super(e), this.isGLTFLoader2 = !0;
    }

    async loadAsync(e, t) {
      const n = await super.loadAsync(e, t),
            r = n ? n.scene || n.scenes && n.scenes.length > 0 && n.scenes[0] : void 0;
      return r && n.animations.length > 0 && (r.animations = n.animations), r.traverse(e => {
        e.userData.gltfUUID && (e.uuid = e.userData.gltfUUID, delete e.userData.gltfUUID);
      }), r;
    }

    register(e) {
      return super.register(e);
    }

  }

  class Xn extends i.hH6 {
    constructor(e) {
      super(e), this.type = i.cLu;
    }

    async loadAsync(e, t) {
      const n = await this.parseAsync(e, t, !1),
            r = new i.IEO(n.data, n.width, n.height, i.wk1, this.type);
      return r.needsUpdate = !0, r.flipY = !0, r.encoding = i.rnI, r.minFilter = i.wem, r.magFilter = i.wem, r.source.data.complete = !0, r;
    }

    async parseAsync(e, t, n = !1) {
      if (!e.startsWith("data:")) {
        this.responseType = "blob";
        const n = await super.loadAsync(e, t);
        e = (e = await vt(n)).replace("application/octet-stream", "image/png");
      }

      const r = await Et(e);
      let s = Uint8Array;
      this.type === i.cLu ? s = Uint16Array : this.type === i.VzW && (s = Uint32Array);

      const o = function (e, t = 3, n = Uint16Array, r = !1) {
        let s;
        const o = e.byteLength >> 2,
              a = new n(o * t);

        for (let n = 0; n < o; n++) s = Math.pow(2, e[4 * n + 3] - 136), r ? (a[n * t] = Math.min(e[4 * n] * s, 65504), a[n * t + 1] = Math.min(e[4 * n + 1] * s, 65504), a[n * t + 2] = Math.min(e[4 * n + 2] * s, 65504)) : (a[n * t] = i.A5E.toHalfFloat(Math.min(e[4 * n] * s, 65504)), a[n * t + 1] = i.A5E.toHalfFloat(Math.min(e[4 * n + 1] * s, 65504)), a[n * t + 2] = i.A5E.toHalfFloat(Math.min(e[4 * n + 2] * s, 65504))), 4 === t && (a[n * t + 3] = i.A5E.toHalfFloat(1));

        return a;
      }(r.data, 4, s, n);

      return {
        data: o,
        width: r.width,
        height: r.height
      };
    }

    setDataType(e) {
      return this.type = e, this;
    }

  }

  class qn extends i.Gql {
    constructor(e) {
      super(e), this._imageLoader = new i.S3k(e);
    }

    parseTextures2(e, t, n) {
      var r;

      for (const s of e) {
        const e = null === (r = null == s ? void 0 : s.userData) || void 0 === r ? void 0 : r.rootPath;

        if (e && (!s.image || !t[s.image])) {
          const r = new i.Hw6(this._imageLoader.load(e, n));
          if (!r) continue;
          s.image && (r.uuid = s.image), t[r.uuid] = r, s.image = r.uuid;
        }
      }

      return super.parseTextures(e, t);
    }

    parseMaterials2(e, t, n) {
      const r = {};
      return e.forEach(e => {
        if (!e) return;
        const i = { ...e
        },
              s = Object.keys(i);

        for (const e of s) if ("map" === e || e.endsWith("Map")) {
          const n = i[e];
          "string" == typeof n && (t[n] ? i[e] = t[n] : (console.warn(`Texture ${n} not found`), delete i[e]));
        }

        const o = n.generateFromTemplateType(i.type, i);
        o && (r[e.uuid] = o);
      }), r;
    }

  }

  const Yn = "WEBGI_viewer";

  function Zn(e) {
    Fs.Importers.push(new Zt(Kn, ["gltf", "glb", "data:model/gltf"], !0, (t, n) => {
      if (!t) return t;
      const r = t,
            i = new qn(n.loadingManager);
      return r.register(tr(i, e)), r.register(er(i)), r.register(nr(i)), r.register(e => new ar(e)), r.register(e => new lr(e)), r.register(e => new cr(e)), r.register(t => {
        var s, o, a, l, c, u, p, h, d;

        const f = Be() + ".drc",
              _ = Be() + ".ktx2",
              m = null === (a = null === (o = null === (s = t.json) || void 0 === s ? void 0 : s.extensionsRequired) || void 0 === o ? void 0 : o.includes) || void 0 === a ? void 0 : a.call(o, "KHR_draco_mesh_compression");

        if (m) {
          const e = n.registerFile(f);
          e && r.setDRACOLoader(e);
        }

        (null === (u = null === (c = null === (l = t.json) || void 0 === l ? void 0 : l.extensionsUsed) || void 0 === c ? void 0 : c.includes) || void 0 === u ? void 0 : u.call(c, "EXT_meshopt_compression")) && (window.MeshoptDecoder ? (r.setMeshoptDecoder(window.MeshoptDecoder), t.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptPlugin to viewer to enable EXT_meshopt_compression decode"));
        const g = null === (d = null === (h = null === (p = t.json) || void 0 === p ? void 0 : p.extensionsUsed) || void 0 === h ? void 0 : h.includes) || void 0 === d ? void 0 : d.call(h, "KHR_texture_basisu");

        if (g) {
          const e = n.registerFile(_);
          e && (r.setKTX2Loader(e), t.options.ktx2Loader = e);
        }

        return {
          name: "GLTF2_HELPER_PLUGIN",
          afterRoot: async r => {
            m && n.unregisterFile(f), g && n.unregisterFile(_);
            const s = await rr(t, e, i);
            r.scene.__importedViewerConfig = s;
          }
        };
      }), r;
    }));
  }

  const Jn = "WEBGI_light_extras",
        $n = "WEBGI_object3d_extras",
        Qn = "WEBGI_material_extras",
        er = e => e => ({
    name: "__" + $n,
    afterRoot: async e => {
      (e.scenes || (e.scene ? [e.scene] : [])).forEach(e => {
        e.traverse(e => {
          var t, n;
          if (!e.isObject3D) return;
          const r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === n ? void 0 : n[$n];
          if (!r) return void (e.isLight && !e.isAmbientLight && (e.castShadow = !0));
          const i = void 0 !== r.castShadow || void 0 !== r.receiveShadow;
          void 0 !== r.castShadow && (e.castShadow = r.castShadow), void 0 !== r.receiveShadow && (e.receiveShadow = r.receiveShadow), void 0 !== r.visible && (e.visible = r.visible), void 0 !== r.frustumCulled && (e.frustumCulled = r.frustumCulled), void 0 !== r.renderOrder && (e.renderOrder = r.renderOrder), void 0 !== r.layers && (e.layers.mask = r.layers), i && (e.userData.__keepShadowDef = !0), delete e.userData.gltfExtensions[$n];
        });
      });
    }
  }),
        tr = (e, t) => e => ({
    name: "__" + Qn,
    afterRoot: async e => {
      var n, r, i;
      const s = e.scenes || (e.scene ? [e.scene] : []);

      for (const e of s) {
        const s = null === (r = null === (n = e.userData) || void 0 === n ? void 0 : n.gltfExtensions) || void 0 === r ? void 0 : r[Qn],
              o = s && (await (null === (i = t.getPlugin(js)) || void 0 === i ? void 0 : i.importConfigResources(s.resources || {}))) || {};
        e.traverse(e => {
          var t, n;
          const r = null == e ? void 0 : e.material;
          if (!(null == r ? void 0 : r.isMaterial)) return;
          const i = null === (n = null === (t = r.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === n ? void 0 : n[Qn];
          i && (void 0 !== i.emissiveIntensity && (r.emissiveIntensity = i.emissiveIntensity), void 0 !== i.fog && (r.fog = i.fog), void 0 !== i.flatShading && (r.flatShading = i.flatShading), void 0 !== i.blending && (r.blending = i.blending), void 0 !== i.shadowSide && (r.shadowSide = i.shadowSide), void 0 !== i.depthTest && (r.depthTest = i.depthTest), void 0 !== i.depthWrite && (r.depthWrite = i.depthWrite), void 0 !== i.colorWrite && (r.colorWrite = i.colorWrite), void 0 !== i.wireframe && (r.wireframe = i.wireframe), void 0 !== i.wireframeLinewidth && (r.wireframeLinewidth = i.wireframeLinewidth), void 0 !== i.wireframeLinecap && (r.wireframeLinecap = i.wireframeLinecap), void 0 !== i.wireframeLinejoin && (r.wireframeLinejoin = i.wireframeLinejoin), void 0 !== i.rotation && (r.rotation = i.rotation), void 0 !== i.dithering && (r.dithering = i.dithering), void 0 !== i.alphaToCoverage && (r.alphaToCoverage = i.alphaToCoverage), void 0 !== i.premultipliedAlpha && (r.premultipliedAlpha = i.premultipliedAlpha), void 0 !== i.toneMapped && (r.toneMapped = i.toneMapped), void 0 !== i.reflectivity && (r.reflectivity = i.reflectivity), Object.entries(i).forEach(([e, t]) => {
            e.startsWith("_") || t && t.resource && "string" == typeof t.resource && (r[e] = Te(t, r[e], !1, o));
          }), delete r.userData.gltfExtensions[Qn]);
        }), s && delete e.userData.gltfExtensions[Qn];
      }
    }
  }),
        nr = e => t => ({
    name: "__" + Jn,
    afterRoot: async t => {
      (t.scenes || (t.scene ? [t.scene] : [])).forEach(t => {
        t.traverse(t => {
          var n, r;
          if (!t.isLight) return;
          const i = null === (r = null === (n = t.userData) || void 0 === n ? void 0 : n.gltfExtensions) || void 0 === r ? void 0 : r[Jn];
          i && (!t.shadow && i.shadow && console.error("Light has no shadow, cannot import", t, i), i.shadow && t.shadow && (void 0 !== i.shadow.bias && (t.shadow.bias = i.shadow.bias), void 0 !== i.shadow.normalBias && (t.shadow.normalBias = i.shadow.normalBias), void 0 !== i.shadow.radius && (t.shadow.radius = i.shadow.radius), void 0 !== i.shadow.mapSize && t.shadow.mapSize.fromArray(i.shadow.mapSize), void 0 !== i.shadow.camera && (t.shadow.camera = e.parseObject(i.shadow.camera))), delete t.userData.gltfExtensions[Jn]);
        });
      });
    }
  });

  async function rr(e, t, n, r) {
    var i;

    if (!r) {
      const n = e.json.scenes || [];

      if (1 !== n.length) {
        for (const r of n) await rr(e, t, r);

        return;
      }

      r = n[0];
    }

    const s = null === (i = r.extensions) || void 0 === i ? void 0 : i[Yn];
    if (!s) return;
    const o = [];
    Object.values(s.resources).forEach(e => {
      Object.values(e).forEach(e => {
        e.url && ("Uint16Array" === e.url.type && e.url.data && o.push(e.url), "Uint8Array" === e.url.type && e.url.data && o.push(e.url));
      });
    });

    for (const t of o) {
      const n = t.data.image,
            r = e.json.images[n],
            i = await e.getDependency("bufferView", r.bufferView);

      if (r.mimeType.startsWith("image/") && "Uint16Array" === t.type && "rgbe" === t.encoding) {
        const e = new Blob([i], {
          type: r.mimeType
        }),
              n = "data:image/png;base64," + btoa(await e.text());
        t.data = (await new Xn().parseAsync(n, void 0, !0)).data, delete t.encoding;
      } else t.data = i;
    }

    return s.resources = await t.getPlugin(js).importConfigResources(s.resources || {}, n), s;
  }

  const ir = "WEBGI_materials_bumpmap",
        sr = "WEBGI_materials_alphamap",
        or = "WEBGI_materials_lightmap";

  class ar {
    constructor(e) {
      this.parser = e, this.name = ir;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.bumpScale && (t.bumpScale = s.bumpScale), void 0 !== s.bumpTexture && i.push(n.assignTexture(t, "bumpMap", s.bumpTexture)), Promise.all(i);
    }

  }

  class lr {
    constructor(e) {
      this.parser = e, this.name = or;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.lightMapIntensity && (t.lightMapIntensity = s.lightMapIntensity), void 0 !== s.lightMapTexture && i.push(n.assignTexture(t, "lightMap", s.lightMapTexture)), Promise.all(i);
    }

  }

  class cr {
    constructor(e) {
      this.parser = e, this.name = sr;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.alphaTexture && i.push(n.assignTexture(t, "alphaMap", s.alphaTexture)), Promise.all(i);
    }

  }

  var ur = __webpackgi_require__(23);

  function pr() {
    Fs.Importers.push(new Zt(ur.Q, ["drc"], !0));
  }

  var hr = {},
      dr = Uint8Array,
      fr = Uint16Array,
      _r = Uint32Array,
      mr = new dr([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
      gr = new dr([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
      vr = new dr([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
      br = function (e, t) {
    for (var n = new fr(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];

    var i = new _r(n[30]);

    for (r = 1; r < 30; ++r) for (var s = n[r]; s < n[r + 1]; ++s) i[s] = s - n[r] << 5 | r;

    return [n, i];
  },
      xr = br(mr, 2),
      yr = xr[0],
      wr = xr[1];

  yr[28] = 258, wr[258] = 28;

  for (var Sr = br(gr, 0), Mr = Sr[0], Tr = Sr[1], Er = new fr(32768), Ar = 0; Ar < 32768; ++Ar) {
    var Cr = (43690 & Ar) >>> 1 | (21845 & Ar) << 1;
    Cr = (61680 & (Cr = (52428 & Cr) >>> 2 | (13107 & Cr) << 2)) >>> 4 | (3855 & Cr) << 4, Er[Ar] = ((65280 & Cr) >>> 8 | (255 & Cr) << 8) >>> 1;
  }

  var Rr = function (e, t, n) {
    for (var r = e.length, i = 0, s = new fr(t); i < r; ++i) ++s[e[i] - 1];

    var o,
        a = new fr(t);

    for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;

    if (n) {
      o = new fr(1 << t);
      var l = 15 - t;

      for (i = 0; i < r; ++i) if (e[i]) for (var c = i << 4 | e[i], u = t - e[i], p = a[e[i] - 1]++ << u, h = p | (1 << u) - 1; p <= h; ++p) o[Er[p] >>> l] = c;
    } else for (o = new fr(r), i = 0; i < r; ++i) e[i] && (o[i] = Er[a[e[i] - 1]++] >>> 15 - e[i]);

    return o;
  },
      kr = new dr(288);

  for (Ar = 0; Ar < 144; ++Ar) kr[Ar] = 8;

  for (Ar = 144; Ar < 256; ++Ar) kr[Ar] = 9;

  for (Ar = 256; Ar < 280; ++Ar) kr[Ar] = 7;

  for (Ar = 280; Ar < 288; ++Ar) kr[Ar] = 8;

  var Pr = new dr(32);

  for (Ar = 0; Ar < 32; ++Ar) Pr[Ar] = 5;

  var Dr = Rr(kr, 9, 0),
      Or = Rr(kr, 9, 1),
      Lr = Rr(Pr, 5, 0),
      Ir = Rr(Pr, 5, 1),
      Fr = function (e) {
    for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);

    return t;
  },
      Nr = function (e, t, n) {
    var r = t / 8 | 0;
    return (e[r] | e[r + 1] << 8) >> (7 & t) & n;
  },
      Ur = function (e, t) {
    var n = t / 8 | 0;
    return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t);
  },
      Br = function (e) {
    return (e / 8 | 0) + (7 & e && 1);
  },
      jr = function (e, t, n) {
    (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
    var r = new (e instanceof fr ? fr : e instanceof _r ? _r : dr)(n - t);
    return r.set(e.subarray(t, n)), r;
  },
      zr = function (e, t, n) {
    var r = e.length;
    if (!r || n && !n.l && r < 5) return t || new dr(0);
    var i = !t || n,
        s = !n || n.i;
    n || (n = {}), t || (t = new dr(3 * r));

    var o = function (e) {
      var n = t.length;

      if (e > n) {
        var r = new dr(Math.max(2 * n, e));
        r.set(t), t = r;
      }
    },
        a = n.f || 0,
        l = n.p || 0,
        c = n.b || 0,
        u = n.l,
        p = n.d,
        h = n.m,
        d = n.n,
        f = 8 * r;

    do {
      if (!u) {
        n.f = a = Nr(e, l, 1);

        var _ = Nr(e, l + 1, 3);

        if (l += 3, !_) {
          var m = e[(A = Br(l) + 4) - 4] | e[A - 3] << 8,
              g = A + m;

          if (g > r) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + m), t.set(e.subarray(A, g), c), n.b = c += m, n.p = l = 8 * g;
          continue;
        }

        if (1 == _) u = Or, p = Ir, h = 9, d = 5;else {
          if (2 != _) throw "invalid block type";
          var v = Nr(e, l, 31) + 257,
              b = Nr(e, l + 10, 15) + 4,
              x = v + Nr(e, l + 5, 31) + 1;
          l += 14;

          for (var y = new dr(x), w = new dr(19), S = 0; S < b; ++S) w[vr[S]] = Nr(e, l + 3 * S, 7);

          l += 3 * b;
          var M = Fr(w),
              T = (1 << M) - 1,
              E = Rr(w, M, 1);

          for (S = 0; S < x;) {
            var A,
                C = E[Nr(e, l, T)];
            if (l += 15 & C, (A = C >>> 4) < 16) y[S++] = A;else {
              var R = 0,
                  k = 0;

              for (16 == A ? (k = 3 + Nr(e, l, 3), l += 2, R = y[S - 1]) : 17 == A ? (k = 3 + Nr(e, l, 7), l += 3) : 18 == A && (k = 11 + Nr(e, l, 127), l += 7); k--;) y[S++] = R;
            }
          }

          var P = y.subarray(0, v),
              D = y.subarray(v);
          h = Fr(P), d = Fr(D), u = Rr(P, h, 1), p = Rr(D, d, 1);
        }

        if (l > f) {
          if (s) throw "unexpected EOF";
          break;
        }
      }

      i && o(c + 131072);

      for (var O = (1 << h) - 1, L = (1 << d) - 1, I = l;; I = l) {
        var F = (R = u[Ur(e, l) & O]) >>> 4;

        if ((l += 15 & R) > f) {
          if (s) throw "unexpected EOF";
          break;
        }

        if (!R) throw "invalid length/literal";
        if (F < 256) t[c++] = F;else {
          if (256 == F) {
            I = l, u = null;
            break;
          }

          var N = F - 254;

          if (F > 264) {
            var U = mr[S = F - 257];
            N = Nr(e, l, (1 << U) - 1) + yr[S], l += U;
          }

          var B = p[Ur(e, l) & L],
              j = B >>> 4;
          if (!B) throw "invalid distance";

          if (l += 15 & B, D = Mr[j], j > 3 && (U = gr[j], D += Ur(e, l) & (1 << U) - 1, l += U), l > f) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + 131072);

          for (var z = c + N; c < z; c += 4) t[c] = t[c - D], t[c + 1] = t[c + 1 - D], t[c + 2] = t[c + 2 - D], t[c + 3] = t[c + 3 - D];

          c = z;
        }
      }

      n.l = u, n.p = I, n.b = c, u && (a = 1, n.m = h, n.d = p, n.n = d);
    } while (!a);

    return c == t.length ? t : jr(t, 0, c);
  },
      Vr = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8;
  },
      Gr = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8, e[r + 2] |= n >>> 16;
  },
      Hr = function (e, t) {
    for (var n = [], r = 0; r < e.length; ++r) e[r] && n.push({
      s: r,
      f: e[r]
    });

    var i = n.length,
        s = n.slice();
    if (!i) return [Jr, 0];

    if (1 == i) {
      var o = new dr(n[0].s + 1);
      return o[n[0].s] = 1, [o, 1];
    }

    n.sort(function (e, t) {
      return e.f - t.f;
    }), n.push({
      s: -1,
      f: 25001
    });
    var a = n[0],
        l = n[1],
        c = 0,
        u = 1,
        p = 2;

    for (n[0] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    }; u != i - 1;) a = n[n[c].f < n[p].f ? c++ : p++], l = n[c != u && n[c].f < n[p].f ? c++ : p++], n[u++] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    };

    var h = s[0].s;

    for (r = 1; r < i; ++r) s[r].s > h && (h = s[r].s);

    var d = new fr(h + 1),
        f = Wr(n[u - 1], d, 0);

    if (f > t) {
      r = 0;
      var _ = 0,
          m = f - t,
          g = 1 << m;

      for (s.sort(function (e, t) {
        return d[t.s] - d[e.s] || e.f - t.f;
      }); r < i; ++r) {
        var v = s[r].s;
        if (!(d[v] > t)) break;
        _ += g - (1 << f - d[v]), d[v] = t;
      }

      for (_ >>>= m; _ > 0;) {
        var b = s[r].s;
        d[b] < t ? _ -= 1 << t - d[b]++ - 1 : ++r;
      }

      for (; r >= 0 && _; --r) {
        var x = s[r].s;
        d[x] == t && (--d[x], ++_);
      }

      f = t;
    }

    return [new dr(d), f];
  },
      Wr = function (e, t, n) {
    return -1 == e.s ? Math.max(Wr(e.l, t, n + 1), Wr(e.r, t, n + 1)) : t[e.s] = n;
  },
      Kr = function (e) {
    for (var t = e.length; t && !e[--t];);

    for (var n = new fr(++t), r = 0, i = e[0], s = 1, o = function (e) {
      n[r++] = e;
    }, a = 1; a <= t; ++a) if (e[a] == i && a != t) ++s;else {
      if (!i && s > 2) {
        for (; s > 138; s -= 138) o(32754);

        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(i), --s; s > 6; s -= 6) o(8304);

        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }

      for (; s--;) o(i);

      s = 1, i = e[a];
    }

    return [n.subarray(0, r), t];
  },
      Xr = function (e, t) {
    for (var n = 0, r = 0; r < t.length; ++r) n += e[r] * t[r];

    return n;
  },
      qr = function (e, t, n) {
    var r = n.length,
        i = Br(t + 2);
    e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];

    for (var s = 0; s < r; ++s) e[i + s + 4] = n[s];

    return 8 * (i + 4 + r);
  },
      Yr = function (e, t, n, r, i, s, o, a, l, c, u) {
    Vr(t, u++, n), ++i[256];

    for (var p = Hr(i, 15), h = p[0], d = p[1], f = Hr(s, 15), _ = f[0], m = f[1], g = Kr(h), v = g[0], b = g[1], x = Kr(_), y = x[0], w = x[1], S = new fr(19), M = 0; M < v.length; ++M) S[31 & v[M]]++;

    for (M = 0; M < y.length; ++M) S[31 & y[M]]++;

    for (var T = Hr(S, 7), E = T[0], A = T[1], C = 19; C > 4 && !E[vr[C - 1]]; --C);

    var R,
        k,
        P,
        D,
        O = c + 5 << 3,
        L = Xr(i, kr) + Xr(s, Pr) + o,
        I = Xr(i, h) + Xr(s, _) + o + 14 + 3 * C + Xr(S, E) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
    if (O <= L && O <= I) return qr(t, u, e.subarray(l, l + c));

    if (Vr(t, u, 1 + (I < L)), u += 2, I < L) {
      R = Rr(h, d, 0), k = h, P = Rr(_, m, 0), D = _;
      var F = Rr(E, A, 0);

      for (Vr(t, u, b - 257), Vr(t, u + 5, w - 1), Vr(t, u + 10, C - 4), u += 14, M = 0; M < C; ++M) Vr(t, u + 3 * M, E[vr[M]]);

      u += 3 * C;

      for (var N = [v, y], U = 0; U < 2; ++U) {
        var B = N[U];

        for (M = 0; M < B.length; ++M) {
          var j = 31 & B[M];
          Vr(t, u, F[j]), u += E[j], j > 15 && (Vr(t, u, B[M] >>> 5 & 127), u += B[M] >>> 12);
        }
      }
    } else R = Dr, k = kr, P = Lr, D = Pr;

    for (M = 0; M < a; ++M) if (r[M] > 255) {
      j = r[M] >>> 18 & 31, Gr(t, u, R[j + 257]), u += k[j + 257], j > 7 && (Vr(t, u, r[M] >>> 23 & 31), u += mr[j]);
      var z = 31 & r[M];
      Gr(t, u, P[z]), u += D[z], z > 3 && (Gr(t, u, r[M] >>> 5 & 8191), u += gr[z]);
    } else Gr(t, u, R[r[M]]), u += k[r[M]];

    return Gr(t, u, R[256]), u + k[256];
  },
      Zr = new _r([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
      Jr = new dr(0),
      $r = function (e, t, n, r, i, s) {
    var o = e.length,
        a = new dr(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
        l = a.subarray(r, a.length - i),
        c = 0;
    if (!t || o < 8) for (var u = 0; u <= o; u += 65535) {
      var p = u + 65535;
      p < o ? c = qr(l, c, e.subarray(u, p)) : (l[u] = s, c = qr(l, c, e.subarray(u, o)));
    } else {
      for (var h = Zr[t - 1], d = h >>> 13, f = 8191 & h, _ = (1 << n) - 1, m = new fr(32768), g = new fr(_ + 1), v = Math.ceil(n / 3), b = 2 * v, x = function (t) {
        return (e[t] ^ e[t + 1] << v ^ e[t + 2] << b) & _;
      }, y = new _r(25e3), w = new fr(288), S = new fr(32), M = 0, T = 0, E = (u = 0, 0), A = 0, C = 0; u < o; ++u) {
        var R = x(u),
            k = 32767 & u,
            P = g[R];

        if (m[k] = P, g[R] = k, A <= u) {
          var D = o - u;

          if ((M > 7e3 || E > 24576) && D > 423) {
            c = Yr(e, l, 0, y, w, S, T, E, C, u - C, c), E = M = T = 0, C = u;

            for (var O = 0; O < 286; ++O) w[O] = 0;

            for (O = 0; O < 30; ++O) S[O] = 0;
          }

          var L = 2,
              I = 0,
              F = f,
              N = k - P & 32767;
          if (D > 2 && R == x(u - N)) for (var U = Math.min(d, D) - 1, B = Math.min(32767, u), j = Math.min(258, D); N <= B && --F && k != P;) {
            if (e[u + L] == e[u + L - N]) {
              for (var z = 0; z < j && e[u + z] == e[u + z - N]; ++z);

              if (z > L) {
                if (L = z, I = N, z > U) break;
                var V = Math.min(N, z - 2),
                    G = 0;

                for (O = 0; O < V; ++O) {
                  var H = u - N + O + 32768 & 32767,
                      W = H - m[H] + 32768 & 32767;
                  W > G && (G = W, P = H);
                }
              }
            }

            N += (k = P) - (P = m[k]) + 32768 & 32767;
          }

          if (I) {
            y[E++] = 268435456 | wr[L] << 18 | Tr[I];
            var K = 31 & wr[L],
                X = 31 & Tr[I];
            T += mr[K] + gr[X], ++w[257 + K], ++S[X], A = u + L, ++M;
          } else y[E++] = e[u], ++w[e[u]];
        }
      }

      c = Yr(e, l, s, y, w, S, T, E, C, u - C, c), !s && 7 & c && (c = qr(l, c + 1, Jr));
    }
    return jr(a, 0, r + Br(c) + i);
  },
      Qr = function () {
    for (var e = new Int32Array(256), t = 0; t < 256; ++t) {
      for (var n = t, r = 9; --r;) n = (1 & n && -306674912) ^ n >>> 1;

      e[t] = n;
    }

    return e;
  }(),
      ei = function () {
    var e = -1;
    return {
      p: function (t) {
        for (var n = e, r = 0; r < t.length; ++r) n = Qr[255 & n ^ t[r]] ^ n >>> 8;

        e = n;
      },
      d: function () {
        return ~e;
      }
    };
  },
      ti = function () {
    var e = 1,
        t = 0;
    return {
      p: function (n) {
        for (var r = e, i = t, s = n.length, o = 0; o != s;) {
          for (var a = Math.min(o + 2655, s); o < a; ++o) i += r += n[o];

          r = (65535 & r) + 15 * (r >> 16), i = (65535 & i) + 15 * (i >> 16);
        }

        e = r, t = i;
      },
      d: function () {
        return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8;
      }
    };
  },
      ni = function (e, t, n, r, i) {
    return $r(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, r, !i);
  },
      ri = function (e, t) {
    var n = {};

    for (var r in e) n[r] = e[r];

    for (var r in t) n[r] = t[r];

    return n;
  },
      ii = function (e, t, n) {
    for (var r = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) {
      var a = r[o],
          l = s[o];

      if ("function" == typeof a) {
        t += ";" + l + "=";
        var c = a.toString();
        if (a.prototype) {
          if (-1 != c.indexOf("[native code]")) {
            var u = c.indexOf(" ", 8) + 1;
            t += c.slice(u, c.indexOf("(", u));
          } else for (var p in t += c, a.prototype) t += ";" + l + ".prototype." + p + "=" + a.prototype[p].toString();
        } else t += c;
      } else n[l] = a;
    }

    return [t, n];
  },
      si = [],
      oi = function (e, t, n, r) {
    var i;

    if (!si[n]) {
      for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = ii(e[l], s, o))[0], o = i[1];

      si[n] = ii(e[a], s, o);
    }

    var c = ri({}, si[n][1]);
    return function (e, t, n, r, i) {
      var s = new Worker(hr[t] || (hr[t] = URL.createObjectURL(new Blob([e], {
        type: "text/javascript"
      }))));
      return s.onerror = function (e) {
        return i(e.error, null);
      }, s.onmessage = function (e) {
        return i(null, e.data);
      }, s.postMessage(n, r), s;
    }(si[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, c, function (e) {
      var t = [];

      for (var n in e) (e[n] instanceof dr || e[n] instanceof fr || e[n] instanceof _r) && t.push((e[n] = new e[n].constructor(e[n])).buffer);

      return t;
    }(c), r);
  },
      ai = function () {
    return [dr, fr, _r, mr, gr, vr, yr, Mr, Or, Ir, Er, Rr, Fr, Nr, Ur, Br, jr, zr, Fi, di, fi];
  },
      li = function () {
    return [dr, fr, _r, mr, gr, vr, wr, Tr, Dr, kr, Lr, Pr, Er, Zr, Jr, Rr, Vr, Gr, Hr, Wr, Kr, Xr, qr, Yr, Br, jr, $r, ni, Di, di];
  },
      ci = function () {
    return [wi, Ti, yi, ei, Qr];
  },
      ui = function () {
    return [Si, Mi];
  },
      pi = function () {
    return [Ei, yi, ti];
  },
      hi = function () {
    return [Ai];
  },
      di = function (e) {
    return postMessage(e, [e.buffer]);
  },
      fi = function (e) {
    return e && e.size && new dr(e.size);
  },
      _i = function (e, t, n, r, i, s) {
    var o = oi(n, r, i, function (e, t) {
      o.terminate(), s(e, t);
    });
    return o.postMessage([e, t], t.consume ? [e.buffer] : []), function () {
      o.terminate();
    };
  },
      mi = function (e) {
    return e.ondata = function (e, t) {
      return postMessage([e, t], [e.buffer]);
    }, function (t) {
      return e.push(t.data[0], t.data[1]);
    };
  },
      gi = function (e, t, n, r, i) {
    var s,
        o = oi(e, r, i, function (e, n) {
      e ? (o.terminate(), t.ondata.call(t, e)) : (n[1] && o.terminate(), t.ondata.call(t, e, n[0], n[1]));
    });
    o.postMessage(n), t.push = function (e, n) {
      if (s) throw "stream finished";
      if (!t.ondata) throw "no stream handler";
      o.postMessage([e, s = n], [e.buffer]);
    }, t.terminate = function () {
      o.terminate();
    };
  },
      vi = function (e, t) {
    return e[t] | e[t + 1] << 8;
  },
      bi = function (e, t) {
    return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;
  },
      xi = function (e, t) {
    return bi(e, t) + 4294967296 * bi(e, t + 4);
  },
      yi = function (e, t, n) {
    for (; n; ++t) e[t] = n, n >>>= 8;
  },
      wi = function (e, t) {
    var n = t.filename;

    if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && yi(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), n) {
      e[3] = 8;

      for (var r = 0; r <= n.length; ++r) e[r + 10] = n.charCodeAt(r);
    }
  },
      Si = function (e) {
    if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
    var t = e[3],
        n = 10;
    4 & t && (n += e[10] | 2 + (e[11] << 8));

    for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[n++]);

    return n + (2 & t);
  },
      Mi = function (e) {
    var t = e.length;
    return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
  },
      Ti = function (e) {
    return 10 + (e.filename && e.filename.length + 1 || 0);
  },
      Ei = function (e, t) {
    var n = t.level,
        r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
    e[0] = 120, e[1] = r << 6 | (r ? 32 - 2 * r : 1);
  },
      Ai = function (e) {
    if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
    if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported";
  };

  function Ci(e, t) {
    return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e;
  }

  var Ri = function () {
    function e(e, t) {
      t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {};
    }

    return e.prototype.p = function (e, t) {
      this.ondata(ni(e, this.o, 0, 0, !t), t);
    }, e.prototype.push = function (e, t) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      this.d = t, this.p(e, t || !1);
    }, e;
  }(),
      ki = function () {
    return function (e, t) {
      gi([li, function () {
        return [mi, Ri];
      }], this, Ci.call(this, e, t), function (e) {
        var t = new Ri(e.data);
        onmessage = mi(t);
      }, 6);
    };
  }();

  function Pi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return _i(e, t, [li], function (e) {
      return di(Di(e.data[0], e.data[1]));
    }, 0, n);
  }

  function Di(e, t) {
    return ni(e, t || {}, 0, 0);
  }

  var Oi = function () {
    function e(e) {
      this.s = {}, this.p = new dr(0), this.ondata = e;
    }

    return e.prototype.e = function (e) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      var t = this.p.length,
          n = new dr(t + e.length);
      n.set(this.p), n.set(e, t), this.p = n;
    }, e.prototype.c = function (e) {
      this.d = this.s.i = e || !1;
      var t = this.s.b,
          n = zr(this.p, this.o, this.s);
      this.ondata(jr(n, t, this.s.b), this.d), this.o = jr(n, this.s.b - 32768), this.s.b = this.o.length, this.p = jr(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, e.prototype.push = function (e, t) {
      this.e(e), this.c(t);
    }, e;
  }(),
      Li = function () {
    return function (e) {
      this.ondata = e, gi([ai, function () {
        return [mi, Oi];
      }], this, 0, function () {
        var e = new Oi();
        onmessage = mi(e);
      }, 7);
    };
  }();

  function Ii(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return _i(e, t, [ai], function (e) {
      return di(Fi(e.data[0], fi(e.data[1])));
    }, 1, n);
  }

  function Fi(e, t) {
    return zr(e, t);
  }

  var Ni = function () {
    function e(e, t) {
      this.c = ei(), this.l = 0, this.v = 1, Ri.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      Ri.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e), this.l += e.length;
      var n = ni(e, this.o, this.v && Ti(this.o), t && 8, !t);
      this.v && (wi(n, this.o), this.v = 0), t && (yi(n, n.length - 8, this.c.d()), yi(n, n.length - 4, this.l)), this.ondata(n, t);
    }, e;
  }(),
      Ui = function () {
    return function (e, t) {
      gi([li, ci, function () {
        return [mi, Ri, Ni];
      }], this, Ci.call(this, e, t), function (e) {
        var t = new Ni(e.data);
        onmessage = mi(t);
      }, 8);
    };
  }();

  function Bi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return _i(e, t, [li, ci, function () {
      return [ji];
    }], function (e) {
      return di(ji(e.data[0], e.data[1]));
    }, 2, n);
  }

  function ji(e, t) {
    t || (t = {});
    var n = ei(),
        r = e.length;
    n.p(e);
    var i = ni(e, t, Ti(t), 8),
        s = i.length;
    return wi(i, t), yi(i, s - 8, n.d()), yi(i, s - 4, r), i;
  }

  var zi = function () {
    function e(e) {
      this.v = 1, Oi.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (Oi.prototype.e.call(this, e), this.v) {
        var n = this.p.length > 3 ? Si(this.p) : 4;
        if (n >= this.p.length && !t) return;
        this.p = this.p.subarray(n), this.v = 0;
      }

      if (t) {
        if (this.p.length < 8) throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }

      Oi.prototype.c.call(this, t);
    }, e;
  }(),
      Vi = function () {
    return function (e) {
      this.ondata = e, gi([ai, ui, function () {
        return [mi, Oi, zi];
      }], this, 0, function () {
        var e = new zi();
        onmessage = mi(e);
      }, 9);
    };
  }();

  function Gi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return _i(e, t, [ai, ui, function () {
      return [Hi];
    }], function (e) {
      return di(Hi(e.data[0]));
    }, 3, n);
  }

  function Hi(e, t) {
    return zr(e.subarray(Si(e), -8), t || new dr(Mi(e)));
  }

  var Wi = function () {
    function e(e, t) {
      this.c = ti(), this.v = 1, Ri.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      Ri.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e);
      var n = ni(e, this.o, this.v && 2, t && 4, !t);
      this.v && (Ei(n, this.o), this.v = 0), t && yi(n, n.length - 4, this.c.d()), this.ondata(n, t);
    }, e;
  }(),
      Ki = function () {
    return function (e, t) {
      gi([li, pi, function () {
        return [mi, Ri, Wi];
      }], this, Ci.call(this, e, t), function (e) {
        var t = new Wi(e.data);
        onmessage = mi(t);
      }, 10);
    };
  }();

  function Xi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return _i(e, t, [li, pi, function () {
      return [qi];
    }], function (e) {
      return di(qi(e.data[0], e.data[1]));
    }, 4, n);
  }

  function qi(e, t) {
    t || (t = {});
    var n = ti();
    n.p(e);
    var r = ni(e, t, 2, 4);
    return Ei(r, t), yi(r, r.length - 4, n.d()), r;
  }

  var Yi = function () {
    function e(e) {
      this.v = 1, Oi.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (Oi.prototype.e.call(this, e), this.v) {
        if (this.p.length < 2 && !t) return;
        this.p = this.p.subarray(2), this.v = 0;
      }

      if (t) {
        if (this.p.length < 4) throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }

      Oi.prototype.c.call(this, t);
    }, e;
  }(),
      Zi = function () {
    return function (e) {
      this.ondata = e, gi([ai, hi, function () {
        return [mi, Oi, Yi];
      }], this, 0, function () {
        var e = new Yi();
        onmessage = mi(e);
      }, 11);
    };
  }();

  function Ji(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return _i(e, t, [ai, hi, function () {
      return [$i];
    }], function (e) {
      return di($i(e.data[0], fi(e.data[1])));
    }, 5, n);
  }

  function $i(e, t) {
    return zr((Ai(e), e.subarray(2, -4)), t);
  }

  var Qi = function () {
    function e(e) {
      this.G = zi, this.I = Oi, this.Z = Yi, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no stream handler";
      if (this.s) this.s.push(e, t);else {
        if (this.p && this.p.length) {
          var n = new dr(this.p.length + e.length);
          n.set(this.p), n.set(e, this.p.length);
        } else this.p = e;

        if (this.p.length > 2) {
          var r = this,
              i = function () {
            r.ondata.apply(r, arguments);
          };

          this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null;
        }
      }
    }, e;
  }(),
      es = function () {
    function e(e) {
      this.G = Vi, this.I = Li, this.Z = Zi, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      Qi.prototype.push.call(this, e, t);
    }, e;
  }();

  function ts(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Gi(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Ii(e, t, n) : Ji(e, t, n);
  }

  function ns(e, t) {
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Hi(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Fi(e, t) : $i(e, t);
  }

  var rs = function (e, t, n, r) {
    for (var i in e) {
      var s = e[i],
          o = t + i;
      s instanceof dr ? n[o] = [s, r] : Array.isArray(s) ? n[o] = [s[0], ri(r, s[1])] : rs(s, o + "/", n, r);
    }
  },
      is = "undefined" != typeof TextEncoder && new TextEncoder(),
      ss = "undefined" != typeof TextDecoder && new TextDecoder(),
      os = 0;

  try {
    ss.decode(Jr, {
      stream: !0
    }), os = 1;
  } catch (Lc) {}

  var as = function (e) {
    for (var t = "", n = 0;;) {
      var r = e[n++],
          i = (r > 127) + (r > 223) + (r > 239);
      if (n + i > e.length) return [t, jr(e, n - 1)];
      i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[n++]) : String.fromCharCode((15 & r) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(r);
    }
  },
      ls = function () {
    function e(e) {
      this.ondata = e, os ? this.t = new TextDecoder() : this.p = Jr;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";

      if (t = !!t, this.t) {
        if (this.ondata(this.t.decode(e, {
          stream: !0
        }), t), t) {
          if (this.t.decode().length) throw "invalid utf-8 data";
          this.t = null;
        }
      } else {
        if (!this.p) throw "stream finished";
        var n = new dr(this.p.length + e.length);
        n.set(this.p), n.set(e, this.p.length);
        var r = as(n),
            i = r[0],
            s = r[1];

        if (t) {
          if (s.length) throw "invalid utf-8 data";
          this.p = null;
        } else this.p = s;

        this.ondata(i, t);
      }
    }, e;
  }(),
      cs = function () {
    function e(e) {
      this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";
      if (this.d) throw "stream finished";
      this.ondata(us(e), this.d = t || !1);
    }, e;
  }();

  function us(e, t) {
    if (t) {
      for (var n = new dr(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);

      return n;
    }

    if (is) return is.encode(e);

    var i = e.length,
        s = new dr(e.length + (e.length >> 1)),
        o = 0,
        a = function (e) {
      s[o++] = e;
    };

    for (r = 0; r < i; ++r) {
      if (o + 5 > s.length) {
        var l = new dr(o + 8 + (i - r << 1));
        l.set(s), s = l;
      }

      var c = e.charCodeAt(r);
      c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++r)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c));
    }

    return jr(s, 0, o);
  }

  function ps(e, t) {
    if (t) {
      for (var n = "", r = 0; r < e.length; r += 16384) n += String.fromCharCode.apply(null, e.subarray(r, r + 16384));

      return n;
    }

    if (ss) return ss.decode(e);
    var i = as(e),
        s = i[0];
    if (i[1].length) throw "invalid utf-8 data";
    return s;
  }

  var hs = function (e) {
    return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0;
  },
      ds = function (e, t) {
    return t + 30 + vi(e, t + 26) + vi(e, t + 28);
  },
      fs = function (e, t, n) {
    var r = vi(e, t + 28),
        i = ps(e.subarray(t + 46, t + 46 + r), !(2048 & vi(e, t + 8))),
        s = t + 46 + r,
        o = bi(e, t + 20),
        a = n && 4294967295 == o ? _s(e, s) : [o, bi(e, t + 24), bi(e, t + 42)],
        l = a[0],
        c = a[1],
        u = a[2];
    return [vi(e, t + 10), l, c, i, s + vi(e, t + 30) + vi(e, t + 32), u];
  },
      _s = function (e, t) {
    for (; 1 != vi(e, t); t += 4 + vi(e, t + 2));

    return [xi(e, t + 12), xi(e, t + 4), xi(e, t + 20)];
  },
      ms = function (e) {
    var t = 0;
    if (e) for (var n in e) {
      var r = e[n].length;
      if (r > 65535) throw "extra field too long";
      t += r + 4;
    }
    return t;
  },
      gs = function (e, t, n, r, i, s, o, a) {
    var l = r.length,
        c = n.extra,
        u = a && a.length,
        p = ms(c);
    yi(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
    var h = new Date(null == n.mtime ? Date.now() : n.mtime),
        d = h.getFullYear() - 1980;
    if (d < 0 || d > 119) throw "date not in range 1980-2099";
    if (yi(e, t, d << 25 | h.getMonth() + 1 << 21 | h.getDate() << 16 | h.getHours() << 11 | h.getMinutes() << 5 | h.getSeconds() >>> 1), t += 4, null != s && (yi(e, t, n.crc), yi(e, t + 4, s), yi(e, t + 8, n.size)), yi(e, t + 12, l), yi(e, t + 14, p), t += 16, null != o && (yi(e, t, u), yi(e, t + 6, n.attrs), yi(e, t + 10, o), t += 14), e.set(r, t), t += l, p) for (var f in c) {
      var _ = c[f],
          m = _.length;
      yi(e, t, +f), yi(e, t + 2, m), e.set(_, t + 4), t += 4 + m;
    }
    return u && (e.set(a, t), t += u), t;
  },
      vs = function (e, t, n, r, i) {
    yi(e, t, 101010256), yi(e, t + 8, n), yi(e, t + 10, n), yi(e, t + 12, r), yi(e, t + 16, i);
  },
      bs = function () {
    function e(e) {
      this.filename = e, this.c = ei(), this.size = 0, this.compression = 0;
    }

    return e.prototype.process = function (e, t) {
      this.ondata(null, e, t);
    }, e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
      this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1);
    }, e;
  }(),
      xs = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), bs.call(this, e), this.d = new Ri(t, function (e, t) {
        n.ondata(null, e, t);
      }), this.compression = 8, this.flag = hs(t.level);
    }

    return e.prototype.process = function (e, t) {
      try {
        this.d.push(e, t);
      } catch (e) {
        this.ondata(e, null, t);
      }
    }, e.prototype.push = function (e, t) {
      bs.prototype.push.call(this, e, t);
    }, e;
  }(),
      ys = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), bs.call(this, e), this.d = new ki(t, function (e, t, r) {
        n.ondata(e, t, r);
      }), this.compression = 8, this.flag = hs(t.level), this.terminate = this.d.terminate;
    }

    return e.prototype.process = function (e, t) {
      this.d.push(e, t);
    }, e.prototype.push = function (e, t) {
      bs.prototype.push.call(this, e, t);
    }, e;
  }(),
      ws = function () {
    function e(e) {
      this.ondata = e, this.u = [], this.d = 1;
    }

    return e.prototype.add = function (e) {
      var t = this;
      if (2 & this.d) throw "stream finished";
      var n = us(e.filename),
          r = n.length,
          i = e.comment,
          s = i && us(i),
          o = r != e.filename.length || s && i.length != s.length,
          a = r + ms(e.extra) + 30;
      if (r > 65535) throw "filename too long";
      var l = new dr(a);
      gs(l, 0, e, n, o);

      var c = [l],
          u = function () {
        for (var e = 0, n = c; e < n.length; e++) {
          var r = n[e];
          t.ondata(null, r, !1);
        }

        c = [];
      },
          p = this.d;

      this.d = 0;
      var h = this.u.length,
          d = ri(e, {
        f: n,
        u: o,
        o: s,
        t: function () {
          e.terminate && e.terminate();
        },
        r: function () {
          if (u(), p) {
            var e = t.u[h + 1];
            e ? e.r() : t.d = 1;
          }

          p = 1;
        }
      }),
          f = 0;
      e.ondata = function (n, r, i) {
        if (n) t.ondata(n, r, i), t.terminate();else if (f += r.length, c.push(r), i) {
          var s = new dr(16);
          yi(s, 0, 134695760), yi(s, 4, e.crc), yi(s, 8, f), yi(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, p && d.r(), p = 1;
        } else p && u();
      }, this.u.push(d);
    }, e.prototype.end = function () {
      var e = this;

      if (2 & this.d) {
        if (1 & this.d) throw "stream finishing";
        throw "stream finished";
      }

      this.d ? this.e() : this.u.push({
        r: function () {
          1 & e.d && (e.u.splice(-1, 1), e.e());
        },
        t: function () {}
      }), this.d = 3;
    }, e.prototype.e = function () {
      for (var e = 0, t = 0, n = 0, r = 0, i = this.u; r < i.length; r++) n += 46 + (l = i[r]).f.length + ms(l.extra) + (l.o ? l.o.length : 0);

      for (var s = new dr(n + 22), o = 0, a = this.u; o < a.length; o++) {
        var l = a[o];
        gs(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + ms(l.extra) + (l.o ? l.o.length : 0), t += l.b;
      }

      vs(s, e, this.u.length, n, t), this.ondata(null, s, !0), this.d = 2;
    }, e.prototype.terminate = function () {
      for (var e = 0, t = this.u; e < t.length; e++) t[e].t();

      this.d = 2;
    }, e;
  }();

  function Ss(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    var r = {};
    rs(e, "", r, t);

    var i = Object.keys(r),
        s = i.length,
        o = 0,
        a = 0,
        l = s,
        c = new Array(s),
        u = [],
        p = function () {
      for (var e = 0; e < u.length; ++e) u[e]();
    },
        h = function () {
      var e = new dr(a + 22),
          t = o,
          r = a - o;
      a = 0;

      for (var i = 0; i < l; ++i) {
        var s = c[i];

        try {
          var u = s.c.length;
          gs(e, a, s, s.f, s.u, u);
          var p = 30 + s.f.length + ms(s.extra),
              h = a + p;
          e.set(s.c, h), gs(e, o, s, s.f, s.u, u, a, s.m), o += 16 + p + (s.m ? s.m.length : 0), a = h + u;
        } catch (e) {
          return n(e, null);
        }
      }

      vs(e, o, c.length, r, t), n(null, e);
    };

    s || h();

    for (var d = function (e) {
      var t = i[e],
          l = r[t],
          d = l[0],
          f = l[1],
          _ = ei(),
          m = d.length;

      _.p(d);

      var g = us(t),
          v = g.length,
          b = f.comment,
          x = b && us(b),
          y = x && x.length,
          w = ms(f.extra),
          S = 0 == f.level ? 0 : 8,
          M = function (r, i) {
        if (r) p(), n(r, null);else {
          var l = i.length;
          c[e] = ri(f, {
            size: m,
            crc: _.d(),
            c: i,
            f: g,
            m: x,
            u: v != t.length || x && b.length != y,
            compression: S
          }), o += 30 + v + w + l, a += 76 + 2 * (v + w) + (y || 0) + l, --s || h();
        }
      };

      if (v > 65535 && M("filename too long", null), S) {
        if (m < 16e4) try {
          M(null, Di(d, f));
        } catch (e) {
          M(e, null);
        } else u.push(Pi(d, f, M));
      } else M(null, d);
    }, f = 0; f < l; ++f) d(f);

    return p;
  }

  function Ms(e, t) {
    t || (t = {});
    var n = {},
        r = [];
    rs(e, "", n, t);
    var i = 0,
        s = 0;

    for (var o in n) {
      var a = n[o],
          l = a[0],
          c = a[1],
          u = 0 == c.level ? 0 : 8,
          p = (S = us(o)).length,
          h = c.comment,
          d = h && us(h),
          f = d && d.length,
          _ = ms(c.extra);

      if (p > 65535) throw "filename too long";
      var m = u ? Di(l, c) : l,
          g = m.length,
          v = ei();
      v.p(l), r.push(ri(c, {
        size: l.length,
        crc: v.d(),
        c: m,
        f: S,
        m: d,
        u: p != o.length || d && h.length != f,
        o: i,
        compression: u
      })), i += 30 + p + _ + g, s += 76 + 2 * (p + _) + (f || 0) + g;
    }

    for (var b = new dr(s + 22), x = i, y = s - i, w = 0; w < r.length; ++w) {
      var S = r[w];
      gs(b, S.o, S, S.f, S.u, S.c.length);
      var M = 30 + S.f.length + ms(S.extra);
      b.set(S.c, S.o + M), gs(b, i, S, S.f, S.u, S.c.length, S.o, S.m), i += 16 + M + (S.m ? S.m.length : 0);
    }

    return vs(b, i, r.length, y, x), b;
  }

  var Ts = function () {
    function e() {}

    return e.prototype.push = function (e, t) {
      this.ondata(null, e, t);
    }, e.compression = 0, e;
  }(),
      Es = function () {
    function e() {
      var e = this;
      this.i = new Oi(function (t, n) {
        e.ondata(null, t, n);
      });
    }

    return e.prototype.push = function (e, t) {
      try {
        this.i.push(e, t);
      } catch (n) {
        this.ondata(n, e, t);
      }
    }, e.compression = 8, e;
  }(),
      As = function () {
    function e(e, t) {
      var n = this;
      t < 32e4 ? this.i = new Oi(function (e, t) {
        n.ondata(null, e, t);
      }) : (this.i = new Li(function (e, t, r) {
        n.ondata(e, t, r);
      }), this.terminate = this.i.terminate);
    }

    return e.prototype.push = function (e, t) {
      this.i.terminate && (e = jr(e, 0)), this.i.push(e, t);
    }, e.compression = 8, e;
  }(),
      Cs = function () {
    function e(e) {
      this.onfile = e, this.k = [], this.o = {
        0: Ts
      }, this.p = Jr;
    }

    return e.prototype.push = function (e, t) {
      var n = this;
      if (!this.onfile) throw "no callback";
      if (!this.p) throw "stream finished";

      if (this.c > 0) {
        var r = Math.min(this.c, e.length),
            i = e.subarray(0, r);
        if (this.c -= r, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(r)).length) return this.push(e, t);
      } else {
        var s = 0,
            o = 0,
            a = void 0,
            l = void 0;
        this.p.length ? e.length ? ((l = new dr(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;

        for (var c = l.length, u = this.c, p = u && this.d, h = function () {
          var e,
              t = bi(l, o);

          if (67324752 == t) {
            s = 1, a = o, d.d = null, d.c = 0;

            var r = vi(l, o + 6),
                i = vi(l, o + 8),
                p = 2048 & r,
                h = 8 & r,
                f = vi(l, o + 26),
                _ = vi(l, o + 28);

            if (c > o + 30 + f + _) {
              var m = [];
              d.k.unshift(m), s = 2;
              var g,
                  v = bi(l, o + 18),
                  b = bi(l, o + 22),
                  x = ps(l.subarray(o + 30, o += 30 + f), !p);
              4294967295 == v ? (e = h ? [-2] : _s(l, o), v = e[0], b = e[1]) : h && (v = -1), o += _, d.c = v;
              var y = {
                name: x,
                compression: i,
                start: function () {
                  if (!y.ondata) throw "no callback";

                  if (v) {
                    var e = n.o[i];
                    if (!e) throw "unknown compression type " + i;

                    (g = v < 0 ? new e(x) : new e(x, v, b)).ondata = function (e, t, n) {
                      y.ondata(e, t, n);
                    };

                    for (var t = 0, r = m; t < r.length; t++) {
                      var s = r[t];
                      g.push(s, !1);
                    }

                    n.k[0] == m && n.c ? n.d = g : g.push(Jr, !0);
                  } else y.ondata(null, Jr, !0);
                },
                terminate: function () {
                  g && g.terminate && g.terminate();
                }
              };
              v >= 0 && (y.size = v, y.originalSize = b), d.onfile(y);
            }

            return "break";
          }

          if (u) {
            if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
            if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break";
          }
        }, d = this; o < c - 4 && "break" !== h(); ++o);

        if (this.p = Jr, u < 0) {
          var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == bi(l, a - 16) && 4)) : l.subarray(0, o);
          p ? p.push(f, !!s) : this.k[+(2 == s)].push(f);
        }

        if (2 & s) return this.push(l.subarray(o), t);
        this.p = l.subarray(o);
      }

      if (t) {
        if (this.c) throw "invalid zip file";
        this.p = null;
      }
    }, e.prototype.register = function (e) {
      this.o[e.compression] = e;
    }, e;
  }();

  function Rs(e, t) {
    if ("function" != typeof t) throw "no callback";

    for (var n = [], r = function () {
      for (var e = 0; e < n.length; ++e) n[e]();
    }, i = {}, s = e.length - 22; 101010256 != bi(e, s); --s) if (!s || e.length - s > 65558) return void t("invalid zip file", null);

    var o = vi(e, s + 8);
    o || t(null, {});
    var a = o,
        l = bi(e, s + 16),
        c = 4294967295 == l;

    if (c) {
      if (s = bi(e, s - 12), 101075792 != bi(e, s)) return void t("invalid zip file", null);
      a = o = bi(e, s + 32), l = bi(e, s + 48);
    }

    for (var u = function (s) {
      var a = fs(e, l, c),
          u = a[0],
          p = a[1],
          h = a[2],
          d = a[3],
          f = a[4],
          _ = a[5],
          m = ds(e, _);
      l = f;

      var g = function (e, n) {
        e ? (r(), t(e, null)) : (i[d] = n, --o || t(null, i));
      };

      if (u) {
        if (8 == u) {
          var v = e.subarray(m, m + p);
          if (p < 32e4) try {
            g(null, Fi(v, new dr(h)));
          } catch (e) {
            g(e, null);
          } else n.push(Ii(v, {
            size: h
          }, g));
        } else g("unknown compression type " + u, null);
      } else g(null, jr(e, m, m + p));
    }, p = 0; p < a; ++p) u();

    return r;
  }

  function ks(e) {
    for (var t = {}, n = e.length - 22; 101010256 != bi(e, n); --n) if (!n || e.length - n > 65558) throw "invalid zip file";

    var r = vi(e, n + 8);
    if (!r) return {};
    var i = bi(e, n + 16),
        s = 4294967295 == i;

    if (s) {
      if (n = bi(e, n - 12), 101075792 != bi(e, n)) throw "invalid zip file";
      r = bi(e, n + 32), i = bi(e, n + 48);
    }

    for (var o = 0; o < r; ++o) {
      var a = fs(e, i, s),
          l = a[0],
          c = a[1],
          u = a[2],
          p = a[3],
          h = a[4],
          d = a[5],
          f = ds(e, d);

      if (i = h, l) {
        if (8 != l) throw "unknown compression type " + l;
        t[p] = Fi(e.subarray(f, f + c), new dr(u));
      } else t[p] = jr(e, f, f + c);
    }

    return t;
  }

  class Ps extends i.hH6 {
    load(e, t, n, r) {
      return this.setResponseType("arraybuffer"), super.load(e, e => {
        const n = ks(new Uint8Array(e)),
              r = new Map(Object.entries(n).map(([e, t]) => [e, new File([t], e)]));
        null == t || t(r);
      }, n, r);
    }

  }

  function Ds() {
    Fs.Importers.push(new Zt(Ps, ["zip"], !0));
  }

  class Os extends i.Ox3 {
    constructor(e, t) {
      super(), this.assetType = "light", this.isDirectionalLight2 = !0, this.color = new i.Ilk(e), this.intensity = t || 1, this.userData.setDirty = () => {
        var e, t;
        this.dispatchEvent({
          type: "objectUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.target.position.set(0, 0, -1), this.add(this.target);
    }

    get lightObject() {
      return this;
    }

    get modelObject() {
      return this;
    }

    copy(e, t) {
      const n = this.target,
            r = e.userData;
      return e.userData = {}, super.copy(e, t), ut(this.userData, r), n.position.copy(this.target.position), n.updateMatrixWorld(), this.target = n, this;
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Directional Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 20],
          property: [this, "intensity"]
        }, {
          type: "vec3",
          label: "Rotation",
          property: [this, "rotation"]
        }, {
          type: "vec3",
          label: "Position",
          property: [this, "position"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [this, "castShadow"]
        }, {
          type: "vec2",
          label: "Shadow Map Size",
          property: [null == this ? void 0 : this.shadow, "mapSize"],
          onChange: () => {
            var e, t;
            null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
          }
        }, {
          type: "slider",
          bounds: [-.001, .001],
          stepSize: 2e-5,
          label: "Shadow Bias",
          property: [null == this ? void 0 : this.shadow, "bias"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [-.1, .1],
          stepSize: .005,
          label: "Shadow Normal Bias",
          property: [null == this ? void 0 : this.shadow, "normalBias"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [0, 5],
          label: "Shadow radius",
          property: [null == this ? void 0 : this.shadow, "radius"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [.1, 50],
          label: "Shadow frustum",
          getValue: () => 2 * this.shadow.camera.right,
          setValue: e => {
            this.shadow.camera.left = -e / 2, this.shadow.camera.right = e / 2, this.shadow.camera.top = e / 2, this.shadow.camera.bottom = -e / 2;
          },
          onChange: this.userData.setDirty
        }]
      };
    }

    toJSON(e) {
      const t = super.toJSON(e);
      return t.type = "DirectionalLight2", t.target = this.target.position.toArray(), Object.assign(t, Me(this, !0, e));
    }

    fromJSON(e, t) {
      if ("DirectionalLight2" !== e.type) return null;
      const n = e.target,
            r = e.object;
      return e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld(), delete e.target), e.object && delete e.object, Te(e, this, !0, t), n && (e.target = n), r && (void 0 !== r.color && this.color.set(r.color), void 0 !== r.intensity && (this.intensity = r.intensity), e.object = r), this;
    }

  }

  class Ls extends i.PMe {
    constructor(e, t, n, r, i, s) {
      super(e, t, n, r, i, s), this.assetType = "light", this.userData.setDirty = () => {
        var e, t;
        this.dispatchEvent({
          type: "objectUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.target.position.set(0, 0, -1), this.add(this.target);
    }

    get lightObject() {
      return this;
    }

    get modelObject() {
      return this;
    }

    copy(e, t) {
      const n = this.target,
            r = e.userData;
      return e.userData = {}, super.copy(e, t), ut(this.userData, r), n.position.copy(this.target.position), n.updateMatrixWorld(), this.target = n, this;
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Spot Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 30],
          property: [this, "intensity"]
        }, {
          type: "slider",
          bounds: [0, 2],
          property: [this, "angle"]
        }, {
          type: "slider",
          bounds: [0, .9999],
          property: [this, "penumbra"]
        }, {
          type: "vec3",
          label: "Rotation",
          property: [this, "rotation"]
        }, {
          type: "vec3",
          label: "Position",
          property: [this, "position"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [this, "castShadow"]
        }, {
          type: "vec2",
          label: "Shadow Map Size",
          property: [null == this ? void 0 : this.shadow, "mapSize"],
          onChange: () => {
            var e, t;
            null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
          }
        }, {
          type: "slider",
          bounds: [-.001, .001],
          stepSize: 2e-5,
          label: "Shadow Bias",
          property: [null == this ? void 0 : this.shadow, "bias"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [0, 5],
          label: "Shadow radius",
          property: [null == this ? void 0 : this.shadow, "radius"],
          onChange: this.userData.setDirty
        }]
      };
    }

    toJSON(e) {
      const t = super.toJSON(e);
      return t.type = "SpotLight2", t.target = this.target.position.toArray(), Object.assign(t, Me(this, !0, e));
    }

    fromJSON(e, t) {
      return "SpotLight2" !== e.type ? null : (e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld()), e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), void 0 !== e.object.distance && (this.distance = e.object.distance), void 0 !== e.object.angle && (this.angle = e.object.angle), void 0 !== e.object.decay && (this.decay = e.object.decay), void 0 !== e.object.penumbra && (this.penumbra = e.object.penumbra), Te(e, this, !0, t), this) : this);
    }

  }

  class Is extends i.Mig {
    constructor(e, t) {
      super(e, t), this.assetType = "light", this.userData.setDirty = () => {
        var e, t;
        this.dispatchEvent({
          type: "objectUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      };
    }

    get lightObject() {
      return this;
    }

    get modelObject() {
      return this;
    }

    copy(e, t) {
      const n = e.userData;
      return e.userData = {}, super.copy(e, t), ut(this.userData, n), this;
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Ambient Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 20],
          property: [this, "intensity"]
        }]
      };
    }

    toJSON(e) {
      const t = super.toJSON(e);
      return t.type = "AmbientLight2", Object.assign(t, Me(this, !0, e));
    }

    fromJSON(e, t) {
      return "AmbientLight2" !== e.type ? null : e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), Te(e, this, !0, t), this) : this;
    }

  }

  class Fs extends r {
    constructor(e, t = !1) {
      super(), this._processors = new rt(), this._logger = console.log, this._loaderCache = [], this._fileDatabase = new Map(), this._cachedAssets = [], t || (this._logger = () => {}), this._viewer = e, this._onLoad = this._onLoad.bind(this), this._onProgress = this._onProgress.bind(this), this._onError = this._onError.bind(this), this._onStart = this._onStart.bind(this), this._urlModifier = this._urlModifier.bind(this), this._loadingManager = new i.lLk(this._onLoad, this._onProgress, this._onError), this._loadingManager.onStart = this._onStart, this._loadingManager.setURLModifier(this._urlModifier), Ds(), tn(e.renderer.rendererObject), Zn(e), pr();
    }

    get processors() {
      return this._processors;
    }

    get loadingManager() {
      return this._loadingManager;
    }

    _onLoad() {
      this.dispatchEvent({
        type: "onLoad"
      });
    }

    _onProgress(e, t, n) {
      this.dispatchEvent({
        type: "onProgress",
        url: e,
        loaded: t,
        total: n
      });
    }

    _onError(e) {
      this.dispatchEvent({
        type: "onError",
        url: e
      });
    }

    _onStart(e, t, n) {
      this.dispatchEvent({
        type: "onStart",
        url: e,
        loaded: t,
        total: n
      });
    }

    _urlModifier(e) {
      var t;
      let n = decodeURI(e);
      const r = null === (t = this._rootContext) || void 0 === t ? void 0 : t.rootUrl;
      n.includes("://") || !r || n.startsWith(r) || (n = r + n), n = n.replace("./", ""), n = n.replace(/^(\/\/)/, "/"), n = n.replace(/\?.*$/, "");

      const i = this._fileDatabase.get(n);

      return i ? i.ext ? (i.objectUrl || (i.objectUrl = URL.createObjectURL(i) + "#" + n), i.objectUrl) : (console.error("Unable to determine file extension", i), e) : e;
    }

    _createLoader(e) {
      const t = this._getImporter(e),
            n = null == t ? void 0 : t.ctor(this);

      return n && (null == t || t.ext.forEach(e => {
        const t = new RegExp(e.startsWith("data:") ? "^" + e + "\\/" : "\\." + e + "$", "i");

        this._loadingManager.addHandler(t, n);
      })), n && (this._loaderCache.push({
        loader: n,
        files: []
      }), this.dispatchEvent({
        type: "loaderCreate",
        loader: n
      })), n;
    }

    async importFiles(e, t, n = {}) {
      const r = new Map();
      let {
        allowedExtensions: i
      } = n;
      if (i && i.length < 1 && (i = void 0), 0 === e.size) return r;
      this.dispatchEvent({
        type: "importFiles",
        files: Object.keys(e),
        state: "start"
      });
      const s = [],
            o = [];
      if (e.forEach((e, t) => {
        var n;
        this.registerFile(t, e);
        const r = e.ext;
        r && (null === (n = null == i ? void 0 : i.includes(r.toLowerCase())) || void 0 === n || n) && (this._isRootFileExtension(r) ? s.push(t) : o.push(t));
      }), s.length > 0) for (const e of s) {
        const t = await this._importFile(e, void 0, n);
        r.set(e, t);
      } else for (const e of o) {
        const t = await this._importFile(e, void 0, n);
        r.set(e, t);
      }
      return this.dispatchEvent({
        type: "importFiles",
        files: Object.keys(e),
        state: "end"
      }), e.forEach((e, t) => {
        this.unregisterFile(t);
      }), r;
    }

    registerFile(e, t) {
      var n, r, i;
      e = e.replace(/\?.*$/, "");
      const s = null !== (n = null == t ? void 0 : t.ext) && void 0 !== n ? n : null === (i = Jt(null !== (r = null == t ? void 0 : t.name) && void 0 !== r ? r : e)) || void 0 === i ? void 0 : i.toLowerCase();
      t && (t.ext || (t.ext = s), this._fileDatabase.set(e, t));

      let o = this._getLoader(e);

      if (o || (o = this._createLoader(null != t ? t : {
        name: e,
        ext: s
      })), o) for (const t of this._loaderCache) if (t.loader === o) {
        t.files.push(e);
        break;
      }
      return o;
    }

    unregisterFile(e) {
      e = e.replace(/\?.*$/, "");

      const t = this._fileDatabase.get(e);

      (null == t ? void 0 : t.objectUrl) && (URL.revokeObjectURL(t.objectUrl), t.objectUrl = void 0), t && this._fileDatabase.delete(e);
    }

    _isRootFileExtension(e) {
      return null != Fs.Importers.find(t => t.root && t.ext.includes(e.toLowerCase()));
    }

    resolveURL(e) {
      return this._loadingManager.resolveURL(e);
    }

    async _importFile(e, t, n = {}) {
      var r, s;
      if (null === (r = t) || void 0 === r ? void 0 : r.__imported) return t.__imported;
      let o;
      this.dispatchEvent({
        type: "importFile",
        path: e,
        state: "downloading"
      });

      try {
        this.registerFile(e, t), n.rootPath = e;
        const r = this.resolveURL(e),
              a = e.replace(/\?.*$/, ""),
              l = null !== (s = n.fileHandler) && void 0 !== s ? s : (await this._loadingManager.getHandler(a)) || (t ? await this._loadingManager.getHandler(t.name || t.ext || "") : void 0);
        if (!l) throw new Error("AssetImporter: Unable to find loader for " + e);
        this._rootContext = {
          path: e,
          url: r,
          rootUrl: i.Zp0.extractUrlBase(e),
          baseUrl: i.Zp0.extractUrlBase(r)
        }, o = await l.loadAsync(e + (n.queryString ? (e.includes("?") ? "&" : "?") + n.queryString : "")), this._rootContext = void 0, this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "adding"
        }), o && (o = !1 !== n.processImported ? await this.processImported(o, n) : [o]), t ? this._logger("AssetImporter: loaded", e) : this._logger("AssetImporter: downloaded", e), t && this.unregisterFile(e);
      } catch (n) {
        return console.error("AssetImporter: Unable to import file", e, t), console.error(n), this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "error",
          error: n
        }), [];
      }

      return this.dispatchEvent({
        type: "importFile",
        path: e,
        state: "done"
      }), t && (t.__imported = o), o;
    }

    _getImporter(e, t = !1) {
      return Fs.Importers.find(n => {
        if (t && !n.root) return !1;
        const r = n.ext.find(t => {
          var n, r, i;
          return e.ext && t === e.ext.toLowerCase() || (null === (r = null === (n = e.name) || void 0 === n ? void 0 : n.toLowerCase()) || void 0 === r ? void 0 : r.endsWith("." + t.toLowerCase())) || (null == t ? void 0 : t.startsWith("data:")) && (null === (i = e.name) || void 0 === i ? void 0 : i.startsWith(t));
        });
        return !!r && (e.ext = r, !0);
      });
    }

    _getLoader(e) {
      var t;
      return null !== (t = this._loadingManager.getHandler(e)) && void 0 !== t ? t : void 0;
    }

    async importAsset(e, t = {}) {
      var n;
      if (!e) return [];

      if (!this._cachedAssets.includes(e)) {
        if (1 === Object.entries(e).length && e.path) {
          const t = this._cachedAssets.find(t => t.path === e.path);

          t && Object.assign(e, t);
        }

        const t = this._cachedAssets.findIndex(t => t.path === e.path);

        t >= 0 && this._cachedAssets.splice(t, 1), this._cachedAssets.push(e);
      }

      return (null == e ? void 0 : e.preImported) || (e.preImported = this._importFile(t.pathOverride || e.path, "function" == typeof (null === (n = e.file) || void 0 === n ? void 0 : n.arrayBuffer) ? e.file : void 0, t)), await e.preImported;
    }

    async importSingle(e, t = {}) {
      var n;
      return null === (n = await this.importAsset(e, t)) || void 0 === n ? void 0 : n[0];
    }

    async importSinglePath(e, t) {
      var n;
      return null === (n = await this.importPath(e, t)) || void 0 === n ? void 0 : n[0];
    }

    async importPath(e, t = {}) {
      const n = t.pathOverride;
      void 0 !== n && delete t.pathOverride;
      const r = JSON.stringify(t);
      void 0 !== n && (t.pathOverride = n);

      const i = this._cachedAssets.find(t => t.path === e && t._options === r);

      let s;
      return s = i || {
        path: e
      }, s._options = r, await this.importAsset(s, t);
    }

    async processImportedSingle(e, t = {}) {
      return (await this.processImported(e, t))[0];
    }

    async processImported(e, t = {}) {
      var n, r, s;

      if (Array.isArray(e)) {
        const n = [];

        for (const r of e) n.push(...(await this.processImported(r, t)));

        return n;
      }

      if (null === (n = null == e ? void 0 : e.userData) || void 0 === n ? void 0 : n.rootSceneModelRoot) return t.rootSceneImported = !0, e.animations && e.children[0] && (e.children[0].animations || (e.children[0].animations = []), e.children[0].animations.push(...e.animations)), e.__importedViewerConfig && e.children[0] && (e.children[0].__importedViewerConfig = e.__importedViewerConfig), this.processImported([...e.children], t);
      if ((null === (r = null == e ? void 0 : e.userData) || void 0 === r ? void 0 : r.iModel) && (e = e.userData.iModel), e.assetImporterProcessed && !t.forceImporterReprocess) return [e];

      if (!e.assetType) {
        if (e.isBufferGeometry && (e = new i.Kj0(e, new i.Wid())), e.isObject3D) {
          e = e.isLight ? Us(e) : new st(e, t);
          const n = [];
          e.modelObject.traverse(t => {
            t !== e.modelObject && n.push([t, Us(t)]);
          });

          for (const e of n) {
            const t = e[0].parent;
            t && (t.remove(e[0]), t.add(e[1]));
          }

          !t.rootPath || e.modelObject.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.modelObject.userData.rootPath = t.rootPath);
        }

        e.isTexture && (e.assetType = "texture", void 0 !== t.generageMipmaps && (e.generateMipmaps = t.generageMipmaps), e.generateMipmaps || e.isRenderTargetTexture || (e.minFilter = e.minFilter === i.D1R ? i.wem : e.minFilter, e.magFilter = e.magFilter === i.D1R ? i.wem : e.magFilter), !t.rootPath || e.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.userData.rootPath = t.rootPath)), e.isMaterial && (e.assetType = "material", !t.rootPath || e.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.userData.rootPath = t.rootPath));
      }

      if (null != e.assetType) return (e = await this._processors.process(e.assetType, e, {})).assetImporterProcessed = !0, [e];
      if (e instanceof Map) return [...(await this.importFiles(e, void 0, t)).values()].flat();

      if (e.type) {
        const t = this._viewer.getPluginByType(e.type);

        if (t) {
          let n = e._importedResources || {};
          return e.resources && (n = await (null === (s = this._viewer.getManager()) || void 0 === s ? void 0 : s.importConfigResources(e.resources)), delete e.resources, e._importedResources = n), "function" == typeof t.fromJSON && (await Promise.resolve(t.fromJSON(e, n)), e.assetImporterProcessed = !1), [];
        }
      } else if (e.plugins) return await this._viewer.getManager().importViewerConfig(e), e.assetImporterProcessed = !1, [];

      return console.warn("unknown asset type: ", e), [e];
    }

    dispose() {
      var e;
      null === (e = this._processors) || void 0 === e || e.dispose();
    }

  }

  function Ns(e) {
    if (!e) return i.ywz;
    const t = e.extensions.has("EXT_color_buffer_half_float") || e.capabilities.isWebGL2 && e.extensions.has("EXT_color_buffer_float"),
          n = e.capabilities.isWebGL2 || e.extensions.has("OES_texture_float") || e.extensions.has("WEBGL_color_buffer_float");
    return t ? i.cLu : n ? i.VzW : i.ywz;
  }

  function Us(e) {
    var t, n, r;
    if (!e.isLight) return e;
    if ("light" === e.assetType) return e;
    if (e.uiConfig) return console.warn("ui config already exists, not supported", e), e;
    let i;

    if (e.children.length, e.isDirectionalLight && (i = new Os()), e.isAmbientLight && (i = new Is()), e.isSpotLight && (i = new Ls()), i) {
      null === (n = (t = i.lightObject).copy) || void 0 === n || n.call(t, e);
      const s = e.parent;
      "model" === (null === (r = s) || void 0 === r ? void 0 : r.assetType) && (s.remove(e), e.dispose(), s.add(i.lightObject)), at(i.lightObject, s);
    }

    return i;
  }

  Fs.Importers = [new Zt(Qt, ["json"], !1), new Zt(i.hH6, ["txt"], !1), new Zt(Xn, ["rgbe.png", "hdr.png", "hdrpng"], !1), new Zt(i.dpR, ["webp", "png", "jpeg", "jpg", "svg", "data:image"], !1)];

  class Bs extends i.u7G {
    constructor(e) {
      super(e);
    }

    async loadAsync(e, t) {
      var n;
      const r = new i.hH6(this.manager);
      r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
      const s = await r.loadAsync(e, t);

      try {
        const e = JSON.parse(s);

        if (e.images && this.importer) {
          const t = {};

          for (const r of e.images) {
            if (!r.url || !r.uuid) continue;
            const e = null === (n = await this.importer.importPath(r.url, {
              processImported: !1
            })) || void 0 === n ? void 0 : n[0],
                  s = null == e ? void 0 : e.source;
            if (!e || !s) continue;
            const o = new i.Hw6(s.data);
            o.uuid = r.uuid, t[o.uuid] = o, e.dispose();
          }

          return this.parse(e, t);
        }

        return this.parse(e);
      } catch (t) {
        throw console.error(t), this.manager.itemError(e), t;
      }
    }

    parse(e, t) {
      var n, r;
      let s;
      const o = {
        p: new Promise(e => {
          s = e;
        })
      };

      if (e.images || e.textures) {
        const n = new qn(this.manager);
        let r = {};

        const i = e => {
          s(), o.p = void 0, Object.values(r).forEach(e => {
            var t;
            e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0);
          });
        },
              a = t || n.parseImages(e.images, i);

        r = n.parseTextures2(e.textures, a, i), this.setTextures(r);
      }

      this.materials || console.warn("A Material Manager is not set to import three materials, trying standard materials");
      const a = { ...e
      };

      if (Object.entries(a).forEach(([e, t]) => {
        t && "string" == typeof t && this.textures[t] && (a[e] = this.textures[t]);
      }), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors), void 0 !== e.normalScale) {
        let t = e.normalScale;
        !1 === Array.isArray(t) && (t = [t, t]), a.normalScale = new i.FM8().fromArray(t);
      }

      let l = e.type;
      "MeshPhysicalMaterial" !== l && "MeshStandardMaterial" !== l || (l = Ht.TYPE);
      const c = null !== (r = null === (n = this.materials) || void 0 === n ? void 0 : n.generateFromTemplateType(l, a)) && void 0 !== r ? r : super.parse(e);
      return this.setTextures({}), c.userData.imageLoadAwaiter = o, c;
    }

  }

  class js extends r {
    constructor(e, t, {
      simpleCache: n = !1,
      storage: r
    } = {}) {
      if (super(), this._sceneUpdated = this._sceneUpdated.bind(this), this.addAsset = this.addAsset.bind(this), this.addProcessedAssets = this.addProcessedAssets.bind(this), this.addImported = this.addImported.bind(this), (n || r) && (n && (i.CtF.enabled = !0), r && window.Cache && "function" == typeof window.Cache && r instanceof window.Cache)) {
        const e = { ...i.CtF
        };
        i.CtF.get = (t, n, i) => n ? t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") ? Promise.resolve(void 0) : r.match(t).then(e => {
          if (e) switch (n) {
            case "arraybuffer":
              return e.arrayBuffer();

            case "blob":
              return e.blob();

            case "document":
              return e.text().then(e => new DOMParser().parseFromString(e, null != i ? i : "text/html"));

            case "json":
              return e.json();

            default:
              if (void 0 === i) return e.text();
              {
                const t = /charset="?([^;"\s]*)"?/i.exec(i),
                      n = t && t[1] ? t[1].toLowerCase() : void 0,
                      r = new TextDecoder(n);
                return e.arrayBuffer().then(e => r.decode(e));
              }
          }
        }) : e.get(t), i.CtF.add = (t, n, i) => {
          i || e.add(t, n), t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") || r.put(t, new Response(n, {
            status: 200
          }));
        }, i.CtF.remove = (t, n) => {
          n || e.remove(t), r.delete(t);
        };
      }

      this._importer = e, this._materials = t;
    }

    async addAsset(e, t = {}) {
      if (!this._importer || !this._viewer) return [];
      const n = await this._importer.importAsset(e, t);
      return n ? (this.addProcessedAssets(n, t), n) : (console.warn("Unable to import", e, n), []);
    }

    async addFromPath(e, t = {}) {
      if (!this._importer || !this._viewer) return [];
      const n = await this._importer.importPath(e, t);
      return n ? (this.addProcessedAssets(n, t), n) : (console.warn("Unable to import", e, n), []);
    }

    addProcessedAssets(e, t) {
      return e.map(e => {
        var n;
        return null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.addSceneObject(e, t);
      });
    }

    async addAssetSingle(e, t = {}) {
      var n;
      return e ? null === (n = await ("string" == typeof e ? this.addFromPath : this.addAsset)(e, t)) || void 0 === n ? void 0 : n[0] : void 0;
    }

    async addImported(e, t = {}) {
      var n;
      return null === (n = this._importer) || void 0 === n ? void 0 : n.processImported(e, t).then(e => (this.addProcessedAssets(e, t), e));
    }

    async addImportedSingle(e, t = {}) {
      return this.addImported(e, t).then(e => null == e ? void 0 : e[0]);
    }

    _sceneUpdated(e) {
      var t;

      if ("addSceneObject" === e.type) {
        const n = e.object;
        "material" === n.assetType && (null === (t = this._materials) || void 0 === t || t.processMaterial(n, {}));
      } else console.error("Unexpected");
    }

    async onAdded(e) {
      this._viewer = e, this._materials || (this._materials = new Yt(), this._viewer.scene.addEventListener("addSceneObject", this._sceneUpdated)), this._importer || (this._importer = new Fs(e, !!e.getPluginByType("debug")), this._importer.processors.add("model", {
        forAssetType: "model",
        process: (e, t) => (ot(e, e => {
          var t;
          return null === (t = this._materials) || void 0 === t ? void 0 : t.processModel(e, {
            recursive: !1
          });
        }), e)
      }), this._importer.processors.add("model", {
        forAssetType: "model",
        process: this._materials.processModel
      }), this._importer.processors.add("material", {
        forAssetType: "material",
        process: (e, t) => {
          var n;
          return (null === (n = this.materials) || void 0 === n ? void 0 : n.findMaterial(e.uuid)) && (console.warn("imported material uuid already exists, creating new uuid"), e.uuid = $(), e.userData.uuid && (e.userData.uuid = e.uuid)), this._materials.processMaterial(e, t);
        }
      })), Fs.Importers.push(new Zt(Bs, [Ht.TypeSlug], !1, e => (e && (e.materials = this._materials), e && (e.importer = this._importer), e)));
      const t = this.importViewerConfig.bind(this);
      Fs.Importers.push(new Zt(class extends Qt {
        async loadAsync(e, n) {
          return t(await super.loadAsync(e, n));
        }

      }, [js.ViewerTypeSlug], !0));
    }

    async onDispose(e) {}

    async onRemove(e) {
      var t, n;
      e === this._viewer && (null === (t = this._importer) || void 0 === t || t.dispose(), this._importer = void 0, this._viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated), null === (n = this._materials) || void 0 === n || n.dispose(), this._materials = void 0);
    }

    get importer() {
      return this._importer;
    }

    get exporter() {
      var e, t;
      return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("AssetExporterPlugin")) || void 0 === t ? void 0 : t.exporter;
    }

    get materials() {
      return this._materials;
    }

    exportViewerConfig(e) {
      if (!this._viewer) return {};

      const t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        ...e
      },
            n = this._viewer.toJSON(t);

      return n.resources = t, n;
    }

    exportPluginPresets(e) {
      var t;
      const n = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      return {
        plugins: null === (t = this._viewer) || void 0 === t ? void 0 : t.serializePlugins(n, e),
        resources: n
      };
    }

    exportPluginPreset(e) {
      if (!e.toJSON) return;
      const t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      },
            n = e.toJSON(t);
      return n.resources = t, n;
    }

    async importPluginPreset(e, t) {
      var n;
      const r = e.type;
      if (!(t = t || (null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType(r)))) return void console.warn(`No plugin found for type ${r} to import preset`);
      if (!t.fromJSON) return void console.warn(`Plugin ${r} does not support importing presets`);
      const i = e.resources || {};
      return e.resources && delete e.resources, await t.fromJSON(e, i), i && (e.resources = i), t;
    }

    async importViewerConfig(e, t) {
      var n;
      if (!this._viewer || !this._importer) return void console.warn("No viewer or importer");
      const r = await this.importConfigResources(e.resources || {}, t);
      await this._viewer.fromJSON(e, r);

      for (const e of Object.values(r.materials)) e.__useCount ? delete e.__useCount : null === (n = this._materials) || void 0 === n || n.unregisterMaterial(e);

      for (const e of Object.values(r.textures)) e.__useCount && delete e.__useCount;
    }

    async importConfigResources(e, t) {
      var n, r, s;
      if (!this._importer) throw "Importer not initialized yet.";
      if (e.__isLoadedResources) return e;
      const o = {};
      t = null != t ? t : new qn(this._importer.loadingManager), o.animations = e.animations ? t.parseAnimations(e.animations) : {}, o.shapes = e.shapes ? t.parseShapes(e.shapes) : {}, o.geometries = e.geometries ? t.parseGeometries(e.geometries, o.shapes) : {}, o.images = e.images ? await t.parseImagesAsync(Object.values(e.images)) : {};

      for (const t of Object.values(e.textures)) {
        const e = null === (n = null == t ? void 0 : t.userData) || void 0 === n ? void 0 : n.rootPath;

        if (e && (!t.image || !o.images[t.image])) {
          const n = null === (r = await this._importer.importPath(e, {
            processImported: !1
          })) || void 0 === r ? void 0 : r[0],
                s = null == n ? void 0 : n.source;
          if (!n || !s) continue;
          const a = new i.Hw6(s.data);
          t.image && (a.uuid = t.image), o.images[a.uuid] = a, t.image = a.uuid, n.dispose();
        }
      }

      o.textures = e.textures ? t.parseTextures2(Object.values(e.textures), o.images, () => {
        Object.values(o.textures).forEach(e => {
          var t;
          e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0);
        });
      }) : {};

      for (const e of Object.entries(o.textures)) e[1] = null === (s = await this._importer.processImported(e[1], {})) || void 0 === s ? void 0 : s[0], e[1] ? o.textures[e[0]] = e[1] : delete o.textures[e[0]];

      const a = e.materials ? Object.values(e.materials) : [];

      for (const e of a) Object.entries(e).forEach(([t, n]) => {
        n && n.resource && n.uuid && "textures" === n.resource && (e[t] = n.uuid);
      });

      return o.materials = t.parseMaterials2(a, o.textures, this._materials), e.object && (o.object = t.parseObject(e.object, o.geometries, o.materials, o.textures, o.animations), e.skeletons && (o.skeletons = t.parseSkeletons(e.skeletons, o.object), t.bindSkeletons(o.object, o.skeletons))), o.__isLoadedResources = !0, o;
    }

  }

  js.PluginType = "AssetManager", js.ViewerTypeSlug = "vjson";

  class zs extends r {
    constructor() {
      super(...arguments), this._dirty = !1;
    }

    get dirty() {
      return this._dirty;
    }

    set dirty(e) {
      this._dirty = e;
    }

    async onAdded(e) {
      this._viewer = e;
    }

    async onDispose(e) {}

    async onRemove(e) {
      this._viewer !== e && console.error("Wrong viewer"), this._viewer = void 0;
    }

    toJSON(e) {
      const t = Me(this, !0, e);
      return t.type = this.constructor.PluginType, this.dispatchEvent({
        type: "serialize",
        data: t
      }), t;
    }

    fromJSON(e, t) {
      return e.type !== this.constructor.PluginType ? null : (Te(e, this, !0, t), this.dispatchEvent({
        type: "deserialize",
        data: e
      }), this);
    }

  }

  function Vs(e, t, n) {
    return { ...t,

      get dirty() {
        return t.dirty || !1;
      },

      set dirty(e) {
        g(t, "dirty", e, !0);
      },

      update() {
        var e, r, i;
        this.passObject.enabled && (null === (r = (e = this.passObject).updateShaderProperties) || void 0 === r || r.call(e, x(n)), null === (i = t.update) || void 0 === i || i.call(this));
      },

      onRegister(n) {
        var r, i, s;
        this.passObject.materialExtension && (null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.materials) || void 0 === i || i.registerMaterialExtension(this.passObject.materialExtension)), null === (s = t.onRegister) || void 0 === s || s.call(this, n);
      },

      onUnregister(n) {
        var r, i, s;
        this.passObject.materialExtension && (null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.materials) || void 0 === i || i.unregisterMaterialExtension(this.passObject.materialExtension)), null === (s = t.onUnregister) || void 0 === s || s.call(this, n);
      },

      dispose() {
        var e, n, r;
        null === (n = (e = this.passObject).dispose) || void 0 === n || n.call(e), null === (r = t.dispose) || void 0 === r || r.call(this);
      }

    };
  }

  class Gs extends zs {
    constructor() {
      super(), this._enabledTemp = !0;
    }

    _update(e) {
      var t;
      return (null === (t = this._pass) || void 0 === t ? void 0 : t.enabled) && this.enabled || !1;
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || this._enabledTemp;
    }

    set enabled(e) {
      var t;
      (null === (t = this._pass) || void 0 === t ? void 0 : t.passObject) && (this._pass.passObject.enabled = e), this._enabledTemp = e;
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = {
        enabled: !0,
        passId: this.passId,
        passObject: this.passCtor(e),
        after: this._afterFilters,
        before: this._beforeFilters,
        required: this._requiredFilters,

        set dirty(t) {
          t && e.setDirty();
        },

        get dirty() {
          return !1;
        },

        dispose() {
          var e, t;
          null === (t = null === (e = this.passObject) || void 0 === e ? void 0 : e.dispose) || void 0 === t || t.call(e);
        },

        update: () => this._update(e)
      };
      this._pass = t, void 0 !== t.passObject.onDirty && t.passObject.onDirty.push(() => t.dirty = !0), e.renderer.registerPass(this._pass), this.enabled = this._enabledTemp;
    }

    async onRemove(e) {
      var t, n;
      this._pass && e.renderer.unregisterPass(this._pass), null === (n = null === (t = this._pass) || void 0 === t ? void 0 : t.dispose) || void 0 === n || n.call(t), this._pass = void 0, await super.onRemove(e);
    }

    get pass() {
      return this._pass;
    }

    toJSON(e) {
      var t, n;
      const r = super.toJSON(e);
      if (!r.type) return r;
      const i = this.pass;
      return i && (r.pass = Me(null !== (n = null === (t = i) || void 0 === t ? void 0 : t.passObject) && void 0 !== n ? n : i, !1, e)), r;
    }

    fromJSON(e, t) {
      var n, r;
      if (!super.fromJSON(e, t)) return null;

      if (e.pass) {
        const i = this.pass;
        i && Te(e.pass, null !== (r = null === (n = i) || void 0 === n ? void 0 : n.passObject) && void 0 !== r ? r : i, !1, t);
      }

      return this;
    }

  }

  !function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe()], Gs.prototype, "enabled", null);
  const Hs = new Set(),
        Ws = new Set();

  class Ks extends Ft {
    constructor(e, t, n, r) {
      super(void 0, void 0, t, null != n ? n : new ve(1, 1, 1), null != r ? r : 1), this.target = e;
    }

    render(e, t, n, r, i) {
      const s = e.getRenderTarget(),
            o = e.getActiveCubeFace(),
            a = e.getActiveMipmapLevel();
      this.scene.traverse(({
        material: e
      }) => {
        e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (Hs.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (Ws.add([e, e.transmission]), e.transmission = 0));
      }), K(e, {
        shadowMapRender: !1,
        backgroundRender: !1,
        opaqueRender: !0,
        transparentRender: !1,
        transmissionRender: !1,
        mainRenderPass: !1
      }, () => super.render(e, t, this.target, r, i)), Hs.forEach(e => e.transparent = !e.transparent), Hs.clear(), Ws.forEach(([e, t]) => e.transmission = t), Ws.clear(), e.setRenderTarget(s, o, a);
    }

  }

  class Xs extends Gs {
    constructor(e = !0) {
      super(), this.renderFlagsBuffer = e, this.passId = "gbuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._gbufferTextures = [];
    }

    passCtor(e) {
      var t, n;
      const r = (null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.isWebGL2) && this.renderFlagsBuffer,
            s = e.renderer.createTarget({
        depthBuffer: !0,
        type: i.ywz,
        textureCount: r ? 2 : 1
      });
      Array.isArray(s.texture) ? (s.texture[0].name = "gbufferDepthNormal", s.texture[1].name = "gbufferFlags", this._gbufferTextures = s.texture) : (s.texture.name = "gbufferDepthNormal", this._gbufferTextures.push(s.texture)), this._gbufferTarget = s;
      const o = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("debug");
      return o && (o.addTexture("gbuffer depth normal", () => this.getDepthNormal(), [40, 510, 200, 100]), this._gbufferTextures.length > 1 && o.addTexture("gbuffer flags", () => this.getFlagsTexture(), [40, 310, 200, 100])), new Ks(s, new Ut(r));
    }

    _update(e) {
      if (!super._update(e)) return !1;
      const t = this.pass.passObject;
      return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0;
    }

    getDepthNormal() {
      return this._gbufferTextures.length > 0 ? this._gbufferTextures[0] : void 0;
    }

    getFlagsTexture() {
      return this._gbufferTextures.length > 1 ? this._gbufferTextures[1] : void 0;
    }

    async onDispose(e) {}

    async onRemove(e) {
      return this._gbufferTarget && (e.renderer.disposeTarget(this._gbufferTarget), this._gbufferTarget = void 0), super.onRemove(e);
    }

    getTarget() {
      return this._gbufferTarget;
    }

    getUnpackSnippet() {
      return Bt;
    }

    updateShaderProperties(e) {
      var t, n;

      if (e.uniforms.tNormalDepth ? e.uniforms.tNormalDepth.value = null !== (t = this.getDepthNormal()) && void 0 !== t ? t : void 0 : console.warn("BaseRenderer: no uniform: tNormalDepth"), e.uniforms.tGBufferFlags) {
        e.uniforms.tGBufferFlags.value = null !== (n = this.getFlagsTexture()) && void 0 !== n ? n : void 0;
        const t = e.uniforms.tGBufferFlags.value ? 1 : 0;
        t !== e.defines.GBUFFER_HAS_FLAGS && (e.defines.GBUFFER_HAS_FLAGS = t, e.needsUpdate = !0);
      }

      return this;
    }

  }

  Xs.PluginType = "GBuffer";

  class qs extends Ft {
    constructor(e, t = !0) {
      super(), this._viewer = e, this._doTransmissionFix = t, this.clear = !0, this.clearColor = new ve(0, 0, 0), this.clearAlpha = 0, this.clearDepth = !1, this._blendPass = new Nt({}, "c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);");
    }

    get transparentTarget() {
      return this._transparentTarget || (this._transparentTarget = this._viewer.renderer.getTempTarget({
        sizeMultiplier: 1,
        isAntialiased: !1,
        encoding: i.rnI,
        type: i.cLu,
        format: i.wk1,
        minFilter: i.wem,
        magFilter: i.wem,
        depthBuffer: !1
      })), this._transparentTarget;
    }

    _releaseTransparentTarget() {
      this._transparentTarget && this._viewer.renderer.releaseTempTarget(this._transparentTarget), this._transparentTarget = void 0;
    }

    render(e, t, n, r, i) {
      var s;
      let o = !1;
      if (e.userData.mainRenderPass = !0, !this._doTransmissionFix) return super.render(e, t, n, r, i), this.needsSwap = o, void (e.userData.mainRenderPass = void 0);
      const a = e.userData;
      a || console.error("threejs is not patched?");
      const l = this._viewer.useGBufferDepth;
      let c;

      if (l) {
        const t = null === (s = this._viewer.getPlugin(Xs)) || void 0 === s ? void 0 : s.getTarget();

        if (t) {
          const n = e.properties.get(t);
          c = n.__webglDepthRenderbuffer || n.__webglDepthbuffer;
        } else console.warn("No Gbuffer present for depth prepass.");
      }

      let u = () => {
        super.render(e, void 0, n, r, i, c);
      };

      if (this._viewer.useRgbm) {
        if (this._viewer.useRgbm) {
          if (o = !1, !e.info.autoReset) throw "renderer.info.autoReset must be true";
          {
            const t = e.autoClearDepth;
            e.autoClearDepth = !l, K(e, {
              shadowMapRender: !0,
              backgroundRender: !0,
              opaqueRender: !0,
              transparentRender: !1,
              transmissionRender: !1
            }, u), e.autoClearDepth = t;
          }

          if (!l) {
            const t = e.properties.get(n);
            c = t.__webglDepthRenderbuffer || t.__webglDepthbuffer;
          }

          u = () => {
            super.render(e, void 0, this.transparentTarget, r, i, c);
          };

          {
            const t = this.clear,
                  n = e.autoClearDepth;
            e.autoClearDepth = !1, this.clear = !0, K(e, {
              shadowMapRender: !1,
              backgroundRender: !1,
              opaqueRender: !1,
              transparentRender: !0,
              transmissionRender: !1
            }, u), this.clear = t, e.autoClearDepth = n;
          }
          e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, n, r, i), o = !0);
          {
            const r = this.clear;
            this.clear = !1, a.transmissionRenderTarget = o ? t : n, K(e, {
              shadowMapRender: !1,
              backgroundRender: !1,
              opaqueRender: !1,
              transparentRender: !1,
              transmissionRender: !0
            }, u), a.transmissionRenderTarget = void 0, this.clear = r;
          }
          e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, n, r, i), o = !0);
        }
      } else {
        {
          const t = this.clear,
                n = e.autoClearDepth;
          e.autoClearDepth = !l, this.clear = !0, K(e, {
            shadowMapRender: !0,
            backgroundRender: !0,
            opaqueRender: !0,
            transparentRender: !0,
            transmissionRender: !1
          }, u), this.clear = t, e.autoClearDepth = n;
        }
        {
          this._viewer.renderer.blit(n.texture, t, {
            clear: !0
          });

          const r = this.clear;
          this.clear = !1, a.transmissionRenderTarget = t, K(e, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !1,
            transparentRender: !1,
            transmissionRender: !0
          }, u), a.transmissionRenderTarget = void 0, this.clear = r;
        }
        o = !1;
      }

      this._releaseTransparentTarget(), this.needsSwap = o, e.userData.mainRenderPass = void 0;
    }

  }

  function Ys(e, t) {
    return e.multiplyScalar(e.w * t), e.w = 1, e;
  }

  function Zs(e, t) {
    return Ys(e, t), new ve(e.x, e.y, e.z);
  }

  function Js(e, t) {
    const n = Math.max(e.x, Math.max(e.y, e.z));
    let r = Math.max(Math.min(n / t, 1), 0);
    return r = Math.ceil(255 * r) / 255, e.divideScalar(r * t), e.w = r, e;
  }

  function $s(e, t) {
    return Js(new i.Ltg(e.r, e.g, e.b, 1), t);
  }

  var Qs = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  function eo(e) {
    return Object.getPrototypeOf(e).constructor.PluginType;
  }

  i.Vj0.background.fragmentShader = i.Vj0.background.fragmentShader.replace("uniform sampler2D t2D;", "uniform sampler2D t2D;\nuniform float intensity;"), i.Vj0.background.fragmentShader = i.Vj0.background.fragmentShader.replace("texture2D( t2D, vUv )", "texture2D( t2D, vUv )*intensity");

  class to extends r {
    constructor({
      isAntialiased: e = !1,
      useRgbm: n = !0,
      useGBufferDepth: r = !1,
      ...o
    }) {
      var a, l;
      super(), this.console = console, this._state = t.None, this.plugins = {}, this._needsResize = !1, this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver(e => this.resize()) : void 0, this._lastSize = new i.FM8(), this._onContextRestore = e => {
        this.enabled = !0, this._canvas.width = this._lastSize.width, this._canvas.height = this._lastSize.height, this.resize(), this.scene.setDirty({
          sceneUpdate: !0,
          frameFade: !1
        });
      }, this._onContextLost = e => {
        this._lastSize.set(this._canvas.width, this._canvas.height), this._canvas.width = 2, this._canvas.height = 2, this.resize(), this.enabled = !1;
      }, this.resize = () => {
        this._needsResize = !0, this.setDirty();
      }, this._needsReset = !0, this.enabled = !0, this.renderEnabled = !0, this._isRenderingFrame = !1, this.maxFramePerLoop = 1, this._rawBackground = null, this.backgroundIntensity = 1, this._sceneEnvironmentChanged = async () => {
        this._rawBackground === no && (await this.scene.setBackground(this.scene.getEnvironment()));
      }, this._addSceneObject = async e => {
        var t;
        if (!e || !e.object) return;
        const n = e.object.__importedViewerConfig || (null === (t = e.object.modelObject) || void 0 === t ? void 0 : t.__importedViewerConfig);
        if (!n) return;
        const r = this.getManager();
        r ? await r.importViewerConfig(n) : await this.fromJSON(n, n.resources);
      }, this._useRgbm = n, this._useGBufferDepth = r, this._canvas = o.canvas || _t();
      let c = o.container;
      if (c && !o.canvas && c.appendChild(this._canvas), c || (c = null !== (a = this._canvas.parentElement) && void 0 !== a ? a : void 0), !c) throw new Error("No container.");
      this._container = c, this._animationLoop = this._animationLoop.bind(this), this.setDirty = this.setDirty.bind(this), window.webGiViewers || (window.webGiViewers = []), window.webGiViewers.push(this), async function () {
        try {
          const e = window.location.href;
          if (e.startsWith("http://localhost:8062") || e.startsWith("https://localhost:8062")) return !0;
          const t = "https://europe-west1-pixotronics-320918.cloudfunctions.net/viewer-hit-test";
          await fetch(t + "/?u=" + encodeURIComponent(e), {
            mode: "no-cors",
            method: "POST",
            credentials: "omit",
            cache: "no-store",
            keepalive: !1,
            referrer: "about:client",
            referrerPolicy: "unsafe-url"
          });
        } catch (e) {
          return !1;
        }
      }(), async function () {
        var e;
        const t = window.location.href,
              n = "https://dev-sandbox.pixotronics.com/webgi/";
        if (!t.startsWith(n)) return !0;
        if (null !== Rt("noUpdate")) return !0;
        const r = null === (e = t.match(/\/webgi\/([0-9.a-zA-Z]+)/)) || void 0 === e ? void 0 : e[1],
              i = (await (await fetch(n + "version.txt")).text()).split("\n")[0];

        if (r && r !== i) {
          if (confirm(`New version ${i} is available, do you want to open?`)) {
            const e = window.location.href.replace(r, i);
            return window.location.href = e, !1;
          }

          window.location.href.includes("noUpdate") || (window.location.href += (window.location.href.includes("?") ? "&" : "?") + "noUpdate");
        }
      }();
      const u = new nt(void 0, void 0, this._canvas);
      this.addEventListener("postFrame", () => {
        var e, t;
        const n = h.scene.activeCamera;

        if (n && n.interactionsEnabled) {
          if (0 === (null === (e = this.getPluginByType("Progressive")) || void 0 === e ? void 0 : e.postFrameConvergedRecordingDelta())) return;
          null === (t = n.controls) || void 0 === t || t.update();
        }
      }), this.scene = new ft(u), this.scene.addEventListener("environmentChanged", this._sceneEnvironmentChanged), this.scene.addEventListener("addSceneObject", this._addSceneObject), this._renderer = new Y({
        canvas: this._canvas,
        animationLoop: this._animationLoop,
        targetOptions: {
          isAntialiased: false,
          encoding: n ? 3005 : i.rnI,
          type: n ? i.ywz : i.cLu,
          depthBuffer: !r
        }
      }), this._isAntialiased = false;
      let p = !0;
      this._renderer.rendererObject.userData || (p = !1, this._renderer.rendererObject.userData = {}), this._renderer.rendererObject.userData.renderTransmissionPass = !p;
      const h = this;
      this.renderFilter = {
        passId: "render",
        passObject: new qs(this, p),

        update() {
          const e = this.passObject;
          e.scene = h.scene.modelObject, e.camera = h.scene.activeCamera.cameraObject;
        }

      }, [this.renderFilter, {
        passId: "screen",
        after: ["render"],
        required: ["render"],
        passObject: new It({ ...s,
          fragmentShader: "\n                       varying vec2 vUv;\n                       " + (null !== (l = o.screenFragmentShader) && void 0 !== l ? l : M`
                        void main() {

                            vec4 texel = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                            gl_FragColor = LinearTosRGB(texel);// Gamma Correction

                        }
                    `),
          uniforms: {
            tDiffuse: {
              value: null
            }
          }
        }, "tDiffuse")
      }].forEach(e => this._renderer.registerPass(e)), this._renderer.pipeline = ["render", "screen"], this.scene.addEventListener("sceneMaterialUpdate", e => this.setDirty(this.scene, e)), this.scene.addEventListener("sceneUpdate", e => {
        this.setDirty(this.scene, e), !1 !== e.geometryChanged && this.renderer.resetShadows();
      }), this.scene.addEventListener("update", e => this.setDirty(this.scene, e)), this._renderer.addEventListener("update", e => this.setDirty(this._renderer, e)), this.resizeObserver && this.resizeObserver.observe(this._canvas), window && window.addEventListener("resize", this.resize), this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.addEventListener("webglcontextlost", this._onContextLost, !1), this.renderer.addEventListener("resize", () => {
        this.scene.activeCamera.refreshAspect();
      }), this.setBackground("#ffffff"), this.console.log("WebGi Viewer instance initialized, version: ", to.VERSION);
    }

    get useRgbm() {
      return this._useRgbm;
    }

    get useGBufferDepth() {
      return this._useGBufferDepth;
    }

    get isAntialiased() {
      return this._isAntialiased;
    }

    setDirty(e, t) {
      this._needsReset = !0, e = null != e ? e : this, this.dispatchEvent({ ...(null != t ? t : {}),
        type: "update",
        source: e
      });
    }

    get renderer() {
      return this._renderer;
    }

    dispose() {
      var e;
      this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.removeEventListener("webglcontextlost", this._onContextLost, !1), null === (e = window.webGiViewers) || void 0 === e || e.splice(window.webGiViewers.indexOf(this), 1), this.resizeObserver ? this.resizeObserver.unobserve(this._canvas) : window.removeEventListener("resize", this.resize), this.dispatchEvent({
        type: "dispose"
      });
    }

    _animationLoop({
      time: e,
      deltaTime: t,
      xrFrame: n
    }) {
      var r, i;
      if (this.enabled && this.renderEnabled) if (this._isRenderingFrame) this.console.warn("animation loop: frame skip");else {
        this._isRenderingFrame = !0;

        for (let s = 0; s < this.maxFramePerLoop; s++) {
          if (this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._needsResize) {
            const e = [this._canvas.clientWidth, this._canvas.clientHeight];

            if (n) {
              const t = null === (i = null === (r = this._renderer.rendererObject.xr.getCamera()) || void 0 === r ? void 0 : r.cameras[0]) || void 0 === i ? void 0 : i.viewport;
              t ? (0 === t.x && 0 === t.y || this.console.warn("x and y must be 0?"), e[0] = t.width, e[1] = t.height, this.console.log("resize for xr", e)) : this._needsResize = !1;
            }

            this._needsResize && (this._renderer.setSize(...e), this._needsResize = !1);
          }

          this.dispatchEvent({
            type: "preFrame",
            target: this,
            time: e,
            deltaTime: t,
            xrFrame: n
          });
          const s = Object.values(this.plugins).filter(e => e.dirty);
          s.length > 0 && this.setDirty(s), this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._renderer.updateDirty();
          const o = this._renderer.dirty;

          if (o) {
            this.dispatchEvent({
              type: "preRender",
              target: this
            });

            try {
              this._renderer.render();
            } catch (e) {
              this.console.error(e), this.enabled = !1;
            }

            this.dispatchEvent({
              type: "postRender",
              target: this
            });
          }

          if (this.dispatchEvent({
            type: "postFrame",
            target: this
          }), !o) break;
        }

        this._isRenderingFrame = !1;
      }
    }

    get state() {
      return this._state;
    }

    get container() {
      return this._container;
    }

    get canvas() {
      return this._canvas;
    }

    getPlugin(e) {
      return this.plugins[e.PluginType];
    }

    getPluginByType(e) {
      return this.plugins[e];
    }

    async addPlugin(e, ...t) {
      var n;
      let r;
      r = e.prototype ? new e(...t) : e;
      const i = eo(r);
      return i ? (null === (n = r.dependencies) || void 0 === n || n.forEach(e => {
        this.getPlugin(e) || (this.console.log("Adding plugin dependency", e.name, "for", i), this.addPlugin(e));
      }), this.plugins[i] && this.console.error(`Plugin of type ${i} already exists`, this.plugins[i], r), this.plugins[i] = r, await r.onAdded(this), this.dispatchEvent({
        type: "addPlugin",
        target: this,
        plugin: r
      }), this.setDirty(r), r) : (this.console.error("PluginType is not defined for", r), r);
    }

    async removePlugin(e, t = !0) {
      const n = eo(e);
      this.plugins[n] && (await e.onRemove(this), delete this.plugins[n], t && (await e.onDispose(this)), this.setDirty(e));
    }

    createCamera(e) {
      var t;
      const n = null !== (t = e.userData.iCamera) && void 0 !== t ? t : new nt(e, {
        controlsMode: "",
        controlsEnabled: !1
      }, this.container);
      return n.autoLookAtTarget = !1, n;
    }

    _backgroundIntensityChanged() {
      var e, t, n, r;
      const s = null !== (r = null === (n = null === (t = null === (e = this._renderer) || void 0 === e ? void 0 : e.rendererObject) || void 0 === t ? void 0 : t.background.getPlaneMesh()) || void 0 === n ? void 0 : n.material.uniforms) && void 0 !== r ? r : i.Vj0.background.uniforms;
      s.intensity || (s.intensity = {
        value: 1
      }), s.intensity.value = this.backgroundIntensity, this.setDirty();
    }

    async setBackgroundColor(e) {
      const t = new ve().set(e).convertSRGBToLinear();
      return this.setBackground(t);
    }

    async setBackground(e) {
      if (this._rawBackground = e, null != e && ("string" == typeof e || "number" == typeof e || e.isVector4 || e.isColor)) {
        if (e === no) return this._sceneEnvironmentChanged();
        const t = e.isVector4 ? W(e) : H(e.isColor ? e : new ve(e));
        return t.assetType = "texture", this.scene.setBackground(t);
      }

      return !e && this.useRgbm && this.console.error("Transparent background not supported with HDR RGBM rendering mode"), this.scene.setBackground(e);
    }

    getBackground(e = !1) {
      var t, n, r;
      if (e) return this._rawBackground;
      let i = null !== (t = this._rawBackground) && void 0 !== t ? t : this.scene.getBackground();
      return i ? ((null === (n = i) || void 0 === n ? void 0 : n.isVector4) && (i = Zs(i, 7).getHexString()), (null === (r = i) || void 0 === r ? void 0 : r.isColor) ? i.getHexString() : this._rawBackground === no ? this.scene.getEnvironment() : i) : null;
    }

    getManager() {
      return this.getPluginByType("AssetManager");
    }

    resetCamera({
      rootObject: e,
      centerOffset: t = new i.Pa4(1, 1, 1),
      targetOffset: n = new i.Pa4(0, 0, 0),
      ...r
    } = {}) {
      if (this.scene.activeCamera) {
        this.scene.matrixWorldNeedsUpdate = !0, this.scene.updateMatrixWorld(!0);
        const r = e ? new P().expandByObject(e, !0, !0) : this.scene.getBounds(!0),
              s = r.getCenter(new i.Pa4()),
              o = .5 * r.getSize(new i.Pa4()).length();
        s.add(n.clone().multiplyScalar(o)), this.scene.activeCamera.position = new i.Pa4(s.x + t.x * o, s.y + t.y * o, s.z + t.z * o), this.scene.activeCamera.target = s, this.setDirty();
      }
    }

    async createObject3D(e) {
      var t;
      return null === (t = this.getManager()) || void 0 === t ? void 0 : t.addImportedSingle(e || new i.Tme(), {
        autoScale: !1,
        pseudoCenter: !1
      });
    }

    createPhysicalMaterial(e) {
      var t, n, r, i, s;

      if (null === (t = e) || void 0 === t ? void 0 : t.isMaterial) {
        const t = null === (r = null === (n = this.getManager()) || void 0 === n ? void 0 : n.materials) || void 0 === r ? void 0 : r.findMaterial(e.uuid);
        if (t) return t;
      }

      return null === (s = null === (i = this.getManager()) || void 0 === i ? void 0 : i.materials) || void 0 === s ? void 0 : s.generateFromTemplate("standard", e);
    }

    serializePlugins(e, t) {
      return Object.entries(this.plugins).map(n => {
        var r, i;
        if (!t || t.includes(n[1].constructor.PluginType)) return null === (i = (r = n[1]).toJSON) || void 0 === i ? void 0 : i.call(r, e);
      }).filter(e => !!e);
    }

    deserializePlugins(e, t) {
      return e.forEach(e => {
        var n;
        if (!e.type) return void this.console.warn("Invalid plugin to import ", e);
        const r = this.getPluginByType(e.type);
        r && (null === (n = r.fromJSON) || void 0 === n || n.call(r, e, t));
      }), this;
    }

    toJSON(e, t) {
      return Object.assign({
        version: to.VERSION,
        plugins: this.serializePlugins(e, t)
      }, Me(this, !0, e));
    }

    async fromJSON(e, t) {
      return Te(e, this, !0, t), Array.isArray(e.plugins) && this.deserializePlugins(e.plugins, t), await this.setBackground(this._rawBackground), this;
    }

  }

  to.VERSION = "0.4.7", Qs([xe()], to.prototype, "scene", void 0), Qs([xe("background")], to.prototype, "_rawBackground", void 0), Qs([xe(), C(to.prototype._backgroundIntensityChanged)], to.prototype, "backgroundIntensity", void 0);
  const no = "envMapBackground";

  var ro = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let io = class extends zs {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = !0, this._lastSize = ["100%", "100%"], this._lastFsElement = null, this._fsChangeHandler = e => {
        var t;
        if (this.isFullScreen()) this.dispatchEvent({
          type: "enter"
        });else {
          const e = this._lastFsElement || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
          e && (e.style.width = this._lastSize[0], e.style.height = this._lastSize[1]), document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("fullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, !1), this.dispatchEvent({
            type: "exit"
          });
        }
      }, this.enter = this.enter.bind(this), this.exit = this.exit.bind(this);
    }

    async enter(e) {
      var t;
      if (this.isFullScreen()) return;
      const n = e || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
      return n ? (this._lastFsElement = n, document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("fullscreenchange", this._fsChangeHandler, !1), document.addEventListener("MSFullscreenChange", this._fsChangeHandler, !1)), this._lastSize = [n.style.width, n.style.height], n.style.width = "100%", n.style.height = "100%", n.requestFullscreen ? n.requestFullscreen() : n.mozRequestFullScreen ? n.mozRequestFullScreen() : n.webkitRequestFullscreen ? n.webkitRequestFullscreen() : n.msRequestFullscreen ? n.msRequestFullscreen() : void 0) : void 0;
    }

    async exit() {
      return document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : void 0;
    }

    async toggle(e) {
      return this.isFullScreen() ? this.exit() : this.enter(e);
    }

    isFullScreen() {
      return document.webkitIsFullScreen || document.mozFullScreen || void 0 !== document.msFullscreenElement;
    }

  };
  io.PluginType = "FullScreenPlugin", ro([Xe("Enter FullScreen")], io.prototype, "enter", null), ro([Xe("Exit FullScreen")], io.prototype, "exit", null), ro([Xe("Toggle FullScreen")], io.prototype, "toggle", null), io = ro([Qe("Full Screen")], io);

  class so {
    constructor(e, t, n) {
      this._el = e, this._inputEl = t, this._listeners = {
        drop: [],
        dropstart: [],
        droperror: []
      }, this._onDragover = this._onDragover.bind(this), this._onDrop = this._onDrop.bind(this), this._onSelect = this._onSelect.bind(this), null == e || e.addEventListener("dragover", this._onDragover, !1), null == e || e.addEventListener("drop", this._onDrop, !1), null == t || t.addEventListener("change", this._onSelect), n && Object.entries(n).forEach(([e, t]) => t && this.on(e, t));
    }

    get inputEl() {
      return this._inputEl;
    }

    get el() {
      return this._el;
    }

    on(e, t) {
      return this._listeners[e].push(t), this;
    }

    _emit(e, t) {
      return this._listeners[e].forEach(e => e(t)), this;
    }

    destroy() {
      const e = this._el,
            t = this._inputEl;
      null == e || e.removeEventListener("dragover", this._onDragover), null == e || e.removeEventListener("drop", this._onDrop), null == t || t.removeEventListener("change", this._onSelect);
    }

    _onDrop(e) {
      var t, n;
      e.stopPropagation(), e.preventDefault(), this._emit("dropstart");
      const r = Array.from((null === (t = e.dataTransfer) || void 0 === t ? void 0 : t.files) || []),
            i = Array.from((null === (n = e.dataTransfer) || void 0 === n ? void 0 : n.items) || []);
      if (0 !== r.length || 0 !== i.length) {
        if (i.length > 0) {
          const e = i.map(e => e.webkitGetAsEntry());

          this._loadNextEntry(new Map(), e);
        } else this._emit("drop", {
          files: new Map(r.map(e => (e.filePath = e.name, [e.filePath, e])))
        });
      } else this._fail("Required drag-and-drop APIs are not supported in this browser.");
    }

    _onDragover(e) {
      e.stopPropagation(), e.preventDefault(), e.dataTransfer && (e.dataTransfer.dropEffect = "copy");
    }

    _onSelect(e) {
      var t;
      if (!this._inputEl) return void console.warn("Invalid Dropzone event ", e);

      this._emit("dropstart");

      const n = [].slice.call(null !== (t = this._inputEl.files) && void 0 !== t ? t : new FileList()),
            r = new Map();
      n.forEach(e => {
        e.filePath = e.webkitRelativePath || e.name, r.set(e.filePath, e);
      }), this._emit("drop", {
        files: r
      });
    }

    _loadNextEntry(e, t) {
      const n = t.pop();
      if (n) {
        if (n.isFile) n.file(r => {
          r.filePath = n.fullPath, e.set(n.fullPath, r), this._loadNextEntry(e, t);
        }, () => console.error("Could not load file: %s", n.fullPath));else if (n.isDirectory) {
          const r = n.createReader(),
                i = n => {
            n.length ? (t = t.concat(n), r.readEntries(i)) : this._loadNextEntry(e, t);
          };

          r.readEntries(i);
        } else console.warn("Unknown asset type: " + n.fullPath), this._loadNextEntry(e, t);
      } else this._emit("drop", {
        files: e
      });
    }

    _fail(e) {
      this._emit("droperror", {
        message: e
      });
    }

  }

  class oo extends r {
    constructor(e) {
      super(), this._domElement = e, this._allowedExtensions = void 0, this.importerParams = {
        autoScale: !0,
        autoScaleRadius: 2,
        pseudoCenter: !0,
        autoImport: !0,
        autoAdd: !0,
        centerOffset: new i.Pa4(.5, .5, 3)
      }, this.dependencies = [js], this.uiConfig = {
        type: "folder",
        label: "Drop Options",
        children: [{
          label: "Auto Center",
          type: "checkbox",
          property: [this.importerParams, "pseudoCenter"],
          limitedUi: !0
        }, {
          label: "Auto Scale",
          type: "checkbox",
          property: [this.importerParams, "autoScale"],
          limitedUi: !0
        }, {
          label: "Auto scale radius",
          type: "slider",
          bounds: [.5, 100],
          property: [this.importerParams, "autoScaleRadius"]
        }]
      };
    }

    async onAdded(e) {
      this._inputEl = document.createElement("input"), this._viewer = e, this._inputEl.type = "file", this._dropzone = new so(this._domElement || e.canvas, this._inputEl, {
        drop: this._onFileDrop.bind(this)
      });
    }

    async _onFileDrop({
      files: e
    }) {
      var t, n, r, i, s, o;
      if (!e) return;
      const a = this._viewer;
      if (!a) return;
      if (void 0 !== this._allowedExtensions) for (const r of e.keys()) this._allowedExtensions.includes(null !== (n = null === (t = r.split(".").pop()) || void 0 === t ? void 0 : t.toLowerCase()) && void 0 !== n ? n : "") || e.delete(r);
      if (e.size < 1) return;
      const l = a.getPlugin(js),
            c = {
        type: "drop",
        files: e
      };

      if (this.importerParams.autoImport) {
        const t = {
          allowedExtensions: this.allowedExtensions,
          ...this.importerParams
        };

        if (c.imported = await (null === (r = l.importer) || void 0 === r ? void 0 : r.importFiles(e, void 0, t)), this.importerParams.autoAdd) {
          const e = null !== (o = [...(null !== (s = null === (i = c.imported) || void 0 === i ? void 0 : i.values()) && void 0 !== s ? s : [])].flat(2).filter(e => !!e)) && void 0 !== o ? o : [];
          c.assets = l.addProcessedAssets(e, { ...this.importerParams
          }), t.rootSceneImported || a.resetCamera(this.importerParams);
        }
      }

      this.dispatchEvent(c);
    }

    promptForFile() {
      var e;
      null === (e = this._inputEl) || void 0 === e || e.click();
    }

    async onDispose(e) {}

    async onRemove(e) {
      var t;
      null === (t = this._dropzone) || void 0 === t || t.destroy(), this._dropzone = void 0, this._viewer = void 0;
    }

    get allowedExtensions() {
      return this._allowedExtensions;
    }

    set allowedExtensions(e) {
      this._allowedExtensions = e, this._inputEl && (this._inputEl.accept = e ? e.map(e => "." + e).join(", ") : "");
    }

  }

  oo.PluginType = "Dropzone";

  class ao extends It {
    constructor(e) {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: M`
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tDiffuse2: {
            value: e
          },
          weight: {
            value: new i.Ltg(1, 1, 1, 1)
          },
          weight2: {
            value: new i.Ltg(1, 1, 1, 1)
          }
        }
      }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
    }

    set weights2(e) {
      this.uniforms.weight2.value.copy(e);
    }

    get weights2() {
      return this.uniforms.weight2.value;
    }

    set weights1(e) {
      this.uniforms.weight.value.copy(e);
    }

    get weights1() {
      return this.uniforms.weight.value;
    }

    set blendTexture(e) {
      this.uniforms.tDiffuse2.value = e;
    }

  }

  class lo extends zs {
    constructor() {
      super(), this._pipeline = [];
    }

    get passes() {
      if (!this._passes) throw "Plugin not yet added to the viewer";
      return this._passes;
    }

    get pipeline() {
      return this._pipeline;
    }

    set pipeline(e) {
      this._pipeline = e;
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = this.createPasses(e);
      this._passes = Object.fromEntries(t.map(t => (t.passId || (console.warn("no id found for pass", t), t.passId = Be()), e.renderer.registerPass(t, !0), [t.passId, t])));
    }

    async onRemove(e) {
      var t;

      if (this._passes) {
        for (const n of [...Object.values(this._passes)]) {
          const r = n;
          e.renderer.unregisterPass(r), null === (t = null == r ? void 0 : r.dispose) || void 0 === t || t.call(r);
        }

        this._passes = void 0;
      }

      await super.onRemove(e);
    }

    toJSON(e) {
      var t, n;
      const r = super.toJSON(e);
      if (!r.type) return r;
      const i = Object.entries(this.passes);
      r.passes = {};

      for (const [s, o] of i) r.passes[s] = Me(null !== (n = null === (t = o) || void 0 === t ? void 0 : t.passObject) && void 0 !== n ? n : o, !1, e);

      return r;
    }

    fromJSON(e, t) {
      var n, r;
      if (!super.fromJSON(e, t)) return null;

      if (e.passes) {
        const i = Object.entries(this.passes);

        for (const [s, o] of i) Te(e.passes[s], null !== (r = null === (n = o) || void 0 === n ? void 0 : n.passObject) && void 0 !== r ? r : o, !1, t);
      }

      return this;
    }

  }

  var co = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const uo = [{
    x: 0,
    y: 0
  }, {
    x: -.5,
    y: 0
  }, {
    x: -.375,
    y: -.25
  }, {
    x: -.1875,
    y: -.125
  }, {
    x: -.125,
    y: -.375
  }, {
    x: .0625,
    y: -.0625
  }, {
    x: .125,
    y: -.3125
  }, {
    x: .375,
    y: -.4375
  }, {
    x: .3125,
    y: -.1875
  }, {
    x: .25,
    y: .0625
  }, {
    x: .4375,
    y: .25
  }, {
    x: .1875,
    y: .3125
  }, {
    x: 0,
    y: .4375
  }, {
    x: -.0625,
    y: .1875
  }, {
    x: -.25,
    y: .375
  }, {
    x: -.4375,
    y: .5
  }, {
    x: -.3125,
    y: .125
  }];

  class po extends lo {
    constructor(e = 2 * uo.length) {
      super(), this.enabled = !0, this.jitter = !0, this._hasSetOffset = !1, this.trackedJitterCameras = new Set(), this._addSceneObject = e => {
        const t = e.object;
        (t.modelObject || t.lightObject) && (t.modelObject || t.lightObject).traverse(e => {
          var t;
          (null === (t = null == e ? void 0 : e.shadow) || void 0 === t ? void 0 : t.camera) && e.shadow.mapSize && this.trackedJitterCameras.add([e.shadow.camera, e.shadow.mapSize]);
        });
      }, this._jitterCamera = e => {
        var t;
        const n = e.target;

        if (this.jitter && n.renderer.frameCount > 2) {
          const e = (e, t) => {
            const r = { ...uo[n.renderer.frameCount % uo.length]
            };
            e.setViewOffset(t.width, t.height, r.x, r.y, t.width, t.height);
          },
                r = n.scene.activeCamera.cameraObject;

          e(r, {
            width: n.canvas.clientWidth * n.renderer.displayCanvasScaling,
            height: n.canvas.clientHeight * n.renderer.displayCanvasScaling
          }), this.trackedJitterCameras.forEach(t => e(...t)), this._hasSetOffset = !0, null === (t = this._viewer) || void 0 === t || t.renderer.resetShadows();
        }
      }, this._resetCameraJitter = e => {
        const t = e.target;
        this._hasSetOffset && (t.scene.activeCamera.cameraObject.clearViewOffset(), this._hasSetOffset = !1);
      }, this.uiConfig = $e("Progressive", this), this.maxFrameCount = e;
    }

    async onAdded(e) {
      return this._lastFrame = e.renderer.composerTarget.clone(!0), await super.onAdded(e);
    }

    async onRemove(e) {
      e.removeEventListener("preRender", this._jitterCamera), e.removeEventListener("postRender", this._resetCameraJitter), e.scene.removeEventListener("addSceneObject", this._addSceneObject), this._lastFrame && e.renderer.disposeTarget(this._lastFrame), this._lastFrame = void 0, await super.onRemove(e);
    }

    get lastFrame() {
      return this._lastFrame;
    }

    createPasses(e) {
      e.addEventListener("preRender", this._jitterCamera), e.addEventListener("postRender", this._resetCameraJitter), e.scene.addEventListener("addSceneObject", this._addSceneObject);
      const t = this,
            n = Vs(e, {
        passId: "progressive",

        get dirty() {
          var e;
          return t.jitter && ((null === (e = t._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) || 0) < t.maxFrameCount;
        },

        after: ["render"],
        before: ["tonemap", "screen"],
        required: ["render"],
        passObject: new class extends ao {
          render(n, r, i, s, o) {
            if (e.renderer.frameCount < 1) return this.needsSwap = !1, void ((null == i ? void 0 : i.texture) && e.renderer.blit(i.texture, t.lastFrame, {}));
            this.needsSwap = !0, super.render(n, r, i, s, o), e.renderer.blit(r.texture, t.lastFrame, {});
          }

        }(),

        update() {
          if (!t.lastFrame) return void console.error("lastFrame render target undefined");
          let n = 1 / (Math.max(e.renderer.frameCount, 0) + 1);
          this.passObject.weights1.set(n, n, n, n), n = 1 - n, this.passObject.weights2.set(n, n, n, n), this.passObject.blendTexture = t.lastFrame.texture, this.passObject.material.uniformsNeedUpdate = !0;
        }

      });
      return [n];
    }

    isConverged(e = !1) {
      var t;
      return ((null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.frameCount) || 0) >= this.maxFrameCount - 1 + (e ? 1 : 0);
    }

    updateShaderProperties(e) {
      var t, n;
      return e.uniforms.tLastFrame && (e.uniforms.tLastFrame.value = null !== (n = null === (t = this.lastFrame) || void 0 === t ? void 0 : t.texture) && void 0 !== n ? n : void 0), this;
    }

    postFrameConvergedRecordingDelta(e = "CanvasRecorder") {
      const t = this._viewer.getPluginByType(e);

      return t && t.isRecording() && t.convergeMode ? this.isConverged(!0) ? 1 / t.videoFrameRate : 0 : -1;
    }

  }

  po.PluginType = "Progressive", co([xe(), qe("Frame count")], po.prototype, "maxFrameCount", void 0), co([xe(), Ve("Jitter")], po.prototype, "jitter", void 0);

  var ho = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const fo = i.dZ3;

  let _o = class extends It {
    constructor(e = !1, t = "", n = "") {
      super({
        vertexShader: s.vertexShader,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tGBufferFlags: {
            value: null
          },
          opacity: {
            value: 1
          }
        },
        defines: {
          TONEMAP_BACKGROUND: 0,
          TRANSPARENT_BACKGROUND: 0,
          GBUFFER_HAS_FLAGS: 0
        },
        fragmentShader: `\n${e ? Bt : ""}\n#define USE_DEPTH_TONEMAP ${e ? "1" : "0"}\n${n}\n${"uniform float opacity;varying vec2 vUv;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));gl_FragColor=opacity*texel;\n#if USE_DEPTH_TONEMAP > 0\nbool doTonemap=getGBufferFlags(vUv).x>0.5;\n#if TONEMAP_BACKGROUND < 1 || TRANSPARENT_BACKGROUND > 0\nif(getDepth(vUv)>0.999)doTonemap=false;\n#endif\nif(doTonemap){\n#endif\n#include <tonemapping_fragment>\n#if USE_DEPTH_TONEMAP > 0\n}else{\n#if TRANSPARENT_BACKGROUND > 0\ngl_FragColor.a=0.;\n#endif\n}\n#endif\n#pragma screen_shader\n#include <encodings_fragment>\n}".replace("#pragma screen_shader", t)}\n                `
      }, "tDiffuse"), this.uiConfig = void 0, this.toneMapping = i.LY2, this.tonemapBackground = !0, this.clipBackground = !1, this.exposure = 1;
    }

    render(e, t, n, r, s) {
      const {
        toneMapping: o,
        toneMappingExposure: a,
        outputEncoding: l
      } = e;
      let c = this.tonemapBackground ? "1" : "0";
      this.material.defines.TONEMAP_BACKGROUND !== c && (this.material.defines.TONEMAP_BACKGROUND = c, this.material.needsUpdate = !0), c = this.clipBackground ? "1" : "0", this.material.defines.TRANSPARENT_BACKGROUND !== c && (this.material.defines.TRANSPARENT_BACKGROUND = c, this.material.needsUpdate = !0), e.toneMapping = this.toneMapping, e.toneMappingExposure = this.exposure, e.outputEncoding = i.knz, this.material.toneMapped = !0, this.material.needsUpdate = !0, super.render(e, t, n, r, s), e.toneMapping = o, e.toneMappingExposure = a, e.outputEncoding = l, this.needsSwap = !0;
    }

  };

  ho([Ke("Mode", [["Linear", i.EoG], ["Reinhard", i.CdI], ["Cineon", i.YGz], ["ACESFilmic", i.LY2], ["Uncharted2", fo]].map(e => ({
    label: e[0],
    value: e[1]
  })), {
    limitedUi: !0
  }), xe()], _o.prototype, "toneMapping", void 0), ho([Ve("Tonemap Background", {
    limitedUi: !0
  }), xe()], _o.prototype, "tonemapBackground", void 0), ho([Ve("Clip Background"), xe()], _o.prototype, "clipBackground", void 0), ho([He("Exposure", [0, 2 * Math.PI], .01, {
    limitedUi: !0
  }), xe()], _o.prototype, "exposure", void 0), _o = ho([Qe("Tonemapping")], _o), i.WdD.tonemapping_pars_fragment = i.WdD.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( 1.0 ) ) );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\n\n");

  class mo extends Gs {
    constructor(e = !1, t = !0, n = ["", ""]) {
      super(), this.depthTonemap = e, this.renderToScreen = t, this.screenShader = n, this.passId = "tonemap", this.dependencies = [Xs], this._beforeFilters = [], this._afterFilters = ["render"], this._requiredFilters = ["render"], this._setDirty = this._setDirty.bind(this);
    }

    async onAdded(e) {
      return this.renderToScreen && g(e.renderer.passes.find(e => "screen" === e.passId), "enabled", !1, !0, !0), super.onAdded(e);
    }

    passCtor(e) {
      var t, n;
      const r = new _o(this.depthTonemap, this.screenShader[1], this.screenShader[0]);
      return g(null === (n = null === (t = r.uiConfig) || void 0 === t ? void 0 : t.children) || void 0 === n ? void 0 : n.find(e => {
        var t;
        return "Enabled" === (null === (t = e) || void 0 === t ? void 0 : t.label);
      }), "hidden", !0, !0), r;
    }

    _update(e) {
      var t;
      return !!super._update(e) && (this._pass.passObject.updateShaderProperties(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Xs)), !0);
    }

    get exposure() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.exposure) && void 0 !== t ? t : 1;
    }

    set exposure(e) {
      var t;
      const n = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
      n && (n.exposure = e, this._setDirty());
    }

    get toneMapping() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.toneMapping) && void 0 !== t ? t : i.EoG;
    }

    set toneMapping(e) {
      var t;
      const n = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
      n && (n.toneMapping = e, this._setDirty());
    }

    _setDirty() {
      this.pass && (this.pass.dirty = !0);
    }

    get uiConfig() {
      var e, t, n, r, i;
      const s = null !== (n = null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
      return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map(e => x(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this._setDirty)), s;
    }

  }

  mo.PluginType = "Tonemap";

  var go = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}",
      vo = "#ifndef BASIC_CAMERA_HELPERS\n#define BASIC_CAMERA_HELPERS\nuniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;uniform mat4 projection;\n#ifndef THREE_PACKING_INCLUDED\n#define THREE_PACKING_INCLUDED\n#include <packing>\n#endif\nfloat linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.:-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}\n#endif\n",
      bo = "#ifndef BASIC_HELPERS\n#define BASIC_HELPERS\nfloat saturate2(float v,float mx){return max(0.,min(mx,v));}vec3 saturate2(vec3 v){return max(vec3(0.),min(vec3(1.),v));}\n#endif\n",
      xo = "#ifndef BASIC_RANDOM_HELPERS\n#define BASIC_RANDOM_HELPERS\nuniform float frameCount;float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}\n#endif\n",
      yo = "#define PI 3.141592653589793\nmat3 GetTangentBasis(vec3 TangentZ){vec3 up=vec3(0.,0.,1.);vec3 TangentX=normalize(cross(dot(TangentZ,up)<0.8?up:vec3(1.,0.,0.),TangentZ));vec3 TangentY=cross(TangentZ,TangentX);return mat3(TangentX,TangentY,TangentZ);}vec4 CosineSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=sqrt(E.y);float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=CosTheta*(1./PI);return vec4(H,PDF);}vec4 UniformSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=E.y;float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=1./(2.*PI);return vec4(H,PDF);}vec2 UniformSampleDiskConcentric(vec2 E){vec2 p=2.*E-1.;float Radius;float Phi;if(abs(p.x)>abs(p.y)){Radius=p.x;Phi=(PI/4.)*(p.y/p.x);}else{Radius=p.y;Phi=(PI/2.)-(PI/4.)*(p.x/p.y);}return vec2(Radius*cos(Phi),Radius*sin(Phi));}vec2 UniformSampleDiskConcentricApprox(vec2 E){vec2 sf=E*sqrt(2.)-sqrt(0.5);vec2 sq=sf*sf;float root=sqrt(2.*max(sq.x,sq.y)-min(sq.x,sq.y));if(sq.x>sq.y){sf.x=sf.x>0.?root:-root;}else{sf.y=sf.y>0.?root:-root;}return sf;}",
      wo = "#ifndef SSRT_PARS_SNIP\n#define SSRT_PARS_SNIP\n#define pow2(a) a*a\nfloat getDepth2(const in vec2 uv,const in float lod){float viewDepth=getDepth(uv);return depthToViewZ(viewDepth);}\n#define LOD_DEPTH 1.0\n#define LOD_COLOR 5.0\nvoid _traceRay(in vec4 ray_origin,in vec4 ray_dir,in float tolerance,inout vec3 state,in int loopMax,in float iStepCount){vec4 sample_uv;float d,hit;float dLod=0.;\n#pragma unroll_loop_start\nfor(int i=0;i<8;i++){if(UNROLLED_LOOP_INDEX<loopMax){sample_uv=ray_origin+ray_dir*state.y;d=getDepth2(sample_uv.xy,dLod);d=sample_uv.z/sample_uv.w-d;if(abs(d+tolerance)<tolerance){hit=clamp(state.x/(state.x-d),0.,1.)-1.;hit=(state.y+hit*iStepCount);state.z=min(state.z,hit);}state.x=d;state.y+=1.*iStepCount;}}\n#pragma unroll_loop_end\n}vec3 traceRay(in vec3 ray_origin_view,in vec3 ray_dir_view,in float tolerance,inout vec3 state,in int _STEP_COUNT){vec4 sample_uv;vec4 ray_origin=viewToScreen3(ray_origin_view);vec3 ray_end_view=ray_origin_view+ray_dir_view;vec4 ray_dir=viewToScreen3(ray_end_view);vec2 clamp_end=clamp(ray_dir.xy,vec2(0.),vec2(1.));vec2 correction=abs(ray_dir.xy-clamp_end);correction=(step(0.01,correction)*correction/(abs(clamp_end-ray_origin.xy)+0.01))+1.;correction.x=1./min(max(correction.y,correction.x),10.);ray_dir=ray_dir-ray_origin;ray_dir.xyw*=correction.x;float iStepCount=1./float(_STEP_COUNT);tolerance*=0.125;_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT,iStepCount);if(_STEP_COUNT>8&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-8,iStepCount);if(_STEP_COUNT>15&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);if(_STEP_COUNT>23&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);sample_uv=ray_origin+ray_dir*state.z;sample_uv.z/=sample_uv.w;state.z=state.z<0.999?state.z:9999999.;return sample_uv.xyz;}\n#endif\n",
      So = "uniform float objectRadius;uniform float radius;uniform float tolerance;uniform bool autoRadius;\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius\nuniform float sceneBoundingRadius;\n#endif\nvec3 ComputeReflectionL(vec3 N,vec2 E,vec3 V,float rough){float rough4=rough*rough*rough*rough;float phi=2.*PI*E.x;float cos_theta=pow(max(E.y,0.000001),rough4/(2.-rough4));float sin_theta=sqrt(max(0.,1.-cos_theta*cos_theta));vec3 half_vec=vec3(sin_theta*cos(phi),sin_theta*sin(phi),cos_theta);vec3 tangentX=normalize(cross(abs(N.z)<0.999?vec3(0.,0.,1.):vec3(1.,0.,0.),N));vec3 tangentY=cross(N,tangentX);half_vec=half_vec.x*tangentX+half_vec.y*tangentY+half_vec.z*N;vec3 ray_dir=(2.*dot(V,half_vec))*half_vec-V;return ray_dir;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=interleavedGradientNoise(gl_FragCoord.xy,frameCount*117.);rand_e.y=fract(rand_e.x*38.65435);rand_e.y=mix(rand_e.y,1.,0.7);return rand_e;}vec4 calculateSSR(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor,in float roughness){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeReflectionL(normal,E,-normalize(viewPos),roughness);L=normalize(L);float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?mix((cameraDist+objectRadius*sceneBoundingRadius)+viewPos.z,-viewPos.z-max(0.,cameraDist-objectRadius*sceneBoundingRadius),L.z*0.5+0.5):objectRadius*sceneBoundingRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount+seed);rayLen=max(rayLen,0.001);int steps=SSR_STEP_COUNT/(frameCount<float(SSR_LOW_QUALITY_FRAMES)?2:1);vec3 state=vec3(0.,(r+0.5)/float(steps),2.);viewPos+=normal*max(-0.0001*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,steps);if(state.z<0.99){vec3 hitColor=(tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy))).rgb;float ssrWeight=1.;return vec4(hitColor*ssrWeight,1.);}return vec4(0.);}",
      Mo = "#ifndef SIMPLE_CAMERA_HELPERS\n#define SIMPLE_CAMERA_HELPERS\n#ifndef USE_TRANSMISSION\nuniform mat4 projectionMatrix;\n#endif\nvec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}\n#endif\n",
      To = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Eo = class extends It {
    constructor(e, t, n, r = !0) {
      super({
        vertexShader: go,
        fragmentShader: `\n\nvarying vec2 vUv;\n\n${bo}\n${vo}\n${xo}\n${yo}\n${n}\n\n${wo}\n\n${So}\n\nuniform sampler2D tLastThis;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 lastAO=tLastThisTexelToLinear(texture2D(tLastThis,vUv));float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>=0.999){discard;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec3 viewPos=screenToView(screenPos.xy,screenPos.z);viewPos.z=viewZ/viewPos.z;vec4 ao=vec4(0.);ao+=calculateSSR(8.,screenPos,normal,1.,0.1);ao.rgb=min(vec3(3.),ao.rgb);ao.rgb=max(vec3(0.),ao.rgb);if(frameCount<1.){gl_FragColor=ao;return;}if(ao.a<0.01){gl_FragColor.rgb=lastAO.rgb;gl_FragColor.a=(((lastAO.a)*frameCount)/(frameCount+1.));}else{gl_FragColor=((ao+(lastAO)*frameCount)/(frameCount+1.));}\n#include <encodings_fragment>\n}\n\n\n            `,
        uniforms: {
          tLastThis: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tLastFrame: {
            value: null
          },
          opacity: {
            value: 1
          },
          intensity: {
            value: 0
          },
          boost: {
            value: new i.Pa4(0, 0, 0)
          },
          objectRadius: {
            value: 0
          },
          autoRadius: {
            value: !1
          },
          power: {
            value: 0
          },
          maskFrontFactor: {
            value: -.1
          },
          tolerance: {
            value: 0
          },
          frameCount: {
            value: 0
          },
          projection: {
            value: new i.yGw()
          },
          cameraPositionWorld: {
            value: new i.Pa4()
          },
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          sceneBoundingRadius: {
            value: 0
          }
        },
        defines: {
          PERSPECTIVE_CAMERA: 1,
          SSR_STEP_COUNT: 16,
          SSR_LOW_QUALITY_FRAMES: 2,
          SSR_MASK_FRONT_RAYS: !0,
          SSR_INLINE: r ? "1" : "0",
          SSR_NON_PHYSICAL: "0"
        }
      }, "tDiffuse", "tLastThis", "tLastFrame"), this.uiConfig = void 0, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          if (!e.defines.SSR_ENABLED) return;
          const r = "#glMarker beforeModulation";
          e.fragmentShader = e.fragmentShader.replace(r, `\n\n            \n            #if defined(SSR_ENABLED) && SSR_ENABLED > 0\nvec3 screenPos=viewToScreen(geometry.position);vec4 ssrColor=vec4(0,0,0,0);float alphaModifier=1.-clamp(material.roughness*.3,0.,1.);alphaModifier*=ssrIntensity;\n#if defined(SSR_MASK_FRONT_RAYS) && SSR_MASK_FRONT_RAYS > 0\nalphaModifier*=clamp(-4.*dot(geometry.viewDir,normal)+(4.+ssrMaskFrontFactor),0.,1.);\n#endif\n#ifdef USE_TRANSMISSION\nalphaModifier*=1.-transmission;\n#endif\nfloat vignette=1.;if(true){float fadeStrength=0.1;float dist=min(min(1.-screenPos.x,1.-screenPos.y),min(screenPos.x,screenPos.y));float fade=dist*dist/(fadeStrength+0.001);fade=clamp(fade,0.,1.);fade=pow(fade,0.3);vignette=fade;}alphaModifier*=vignette;vec3 specularColor=EnvironmentBRDF(geometry.normal,geometry.viewDir,material.specularColor.rgb,material.specularF90,material.roughness);if(length(specularColor.rgb)*alphaModifier>0.01&&roughnessFactor<0.9){\n#if defined(SSR_INLINE) && SSR_INLINE > 0\nssrColor=calculateSSR(8.,vec3(screenPos.xy,geometry.position.z),geometry.normal,1.,material.roughness);\n#else\nssrColor=tSSRMapTexelToLinear(texture2D(tSSRMap,screenPos.xy));\n#endif \n}ssrColor.rgb*=ssrBoost;ssrColor.a*=alphaModifier;ssrColor.a=min(ssrColor.a,1.);\n#if defined(SSR_NON_PHYSICAL) && SSR_NON_PHYSICAL > 0\ndiffuseColor.a=max(ssrColor.a,diffuseColor.a*diffuseColor.a);reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(diffuseColor.rgb*ssrColor.rgb),1.);reflectedLight.indirectDiffuse=vec3(0.);reflectedLight.directDiffuse=vec3(0.);reflectedLight.directSpecular=vec3(0.);\n#else\nreflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(specularColor.rgb*ssrColor.rgb),ssrColor.a);\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${r}`);
        },
        onObjectRender: (e, t, n) => {
          var r, i, s, o;
          let a = this.enabled && !1 !== n.userData.screenSpaceRendering && !(null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r.ssreflDisabled) ? 1 : 0;
          t.materialObject.defines.SSR_ENABLED !== a && (t.materialObject.defines.SSR_ENABLED = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_STEP_COUNT, t.materialObject.defines.SSR_STEP_COUNT !== a && (t.materialObject.defines.SSR_STEP_COUNT = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_LOW_QUALITY_FRAMES, t.materialObject.defines.SSR_LOW_QUALITY_FRAMES !== a && (t.materialObject.defines.SSR_LOW_QUALITY_FRAMES = a, t.materialObject.needsUpdate = !0), a = this.material.defines.PERSPECTIVE_CAMERA, t.materialObject.defines.PERSPECTIVE_CAMERA !== a && (t.materialObject.defines.PERSPECTIVE_CAMERA = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_INLINE, t.materialObject.defines.SSR_INLINE !== a && (t.materialObject.defines.SSR_INLINE = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_MASK_FRONT_RAYS ? 1 : 0, t.materialObject.defines.SSR_MASK_FRONT_RAYS !== a && (t.materialObject.defines.SSR_MASK_FRONT_RAYS = a, t.materialObject.needsUpdate = !0), a = (null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssreflNonPhysical) ? "1" : "0", t.materialObject.defines.SSR_NON_PHYSICAL !== a && (t.materialObject.defines.SSR_NON_PHYSICAL = a, t.materialObject.needsUpdate = !0), a = null !== (o = null === (s = this._target) || void 0 === s ? void 0 : s.texture) && void 0 !== o ? o : null, this.materialExtension.extraUniforms.tSSRMap.value !== a && (this.materialExtension.extraUniforms.tSSRMap.value = a, t.materialObject.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return "\nuniform float ssrPower;\nuniform float ssrIntensity;\nuniform float ssrMaskFrontFactor;\nuniform vec3 ssrBoost;\nuniform sampler2D tSSRMap;\nuniform sampler2D tLastFrame;\n" + U("tSSRMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2) + U("tLastFrame", this.materialExtension.extraUniforms.tLastFrame.value, e.capabilities.isWebGL2) + (this._inline ? `\n#if 1\n// #if SSR_INLINE\n    ${bo}\n    \n    #define THREE_PACKING_INCLUDED\n    ${vo}\n    \n    ${xo}\n    ${yo}\n    ${Bt}\n    \n    ${wo}\n    \n    ${So}\n// #endif // SSR_INLINE\n#endif\n` : "") + `\n\n${Mo}\n\n        `;
        },
        extraUniforms: {
          tSSRMap: {
            value: null
          },
          ssrPower: this.material.uniforms.power,
          ssrIntensity: this.material.uniforms.intensity,
          ssrMaskFrontFactor: this.material.uniforms.maskFrontFactor,
          ssrBoost: this.material.uniforms.boost,
          tNormalDepth: this.material.uniforms.tNormalDepth,
          tLastFrame: this.material.uniforms.tLastFrame,
          objectRadius: this.material.uniforms.objectRadius,
          autoRadius: this.material.uniforms.autoRadius,
          tolerance: this.material.uniforms.tolerance,
          frameCount: this.material.uniforms.frameCount,
          projection: this.material.uniforms.projection,
          cameraPositionWorld: this.material.uniforms.cameraPositionWorld,
          cameraNearFar: this.material.uniforms.cameraNearFar,
          sceneBoundingRadius: this.material.uniforms.sceneBoundingRadius
        },
        computeCacheKey: e => {
          var t, n;
          return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssreflDisabled) && e.isMeshStandardMaterial2;
        }
      }, this.intensity = 1, this.boost = new i.Pa4(1, 1, 1), this.objectRadius = 1, this.autoRadius = !0, this.power = 1.1, this.tolerance = .5, this.stepCount = 16, this.lowQualityFrames = 0, this.maskFrontRays = !0, this.maskFrontFactor = -.2, this._renderer = e, this._target = t, this.needsSwap = !1, this._inline = r;
    }

    render(e, t, n, r, i) {
      if (this._inline) this.needsSwap = !1;else {
        if (!this._target) throw "Target must be set when inline = false";
        this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this.needsSwap = !1;
      }
    }

  };
  To([He("Intensity", [0, 4]), xe(), V()], Eo.prototype, "intensity", void 0), To([We("Boost"), xe(), V()], Eo.prototype, "boost", void 0), To([He("Object Radius", [.01, 2]), xe(), V()], Eo.prototype, "objectRadius", void 0), To([Ve("Auto radius"), xe(), V()], Eo.prototype, "autoRadius", void 0), To([He("Power", [0, 3]), xe(), V()], Eo.prototype, "power", void 0), To([He("Tolerance", [.1, 5]), xe(), V()], Eo.prototype, "tolerance", void 0), To([He("Step count", [1, 32], 1), xe(), G("SSR_STEP_COUNT")], Eo.prototype, "stepCount", void 0), To([He("Low Quality Frames", [0, 4], 1), xe(), G("SSR_LOW_QUALITY_FRAMES")], Eo.prototype, "lowQualityFrames", void 0), To([Ve("Ignore front rays"), xe(), G("SSR_MASK_FRONT_RAYS")], Eo.prototype, "maskFrontRays", void 0), To([He("Mask front rays factor", [-1, 1], .01, e => ({
    hidden: () => !e.maskFrontRays
  })), xe(), V()], Eo.prototype, "maskFrontFactor", void 0), Eo = To([Qe("Screen Space Reflections")], Eo);

  class Ao extends lo {
    constructor() {
      super(), this.dependencies = [js, Xs, po], this.inlineSSR = !0, this.setDirty = this.setDirty.bind(this);
    }

    get ssrTarget() {
      return this._ssrTarget;
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }

    set enabled(e) {
      var t;
      (null === (t = this.passes.ssr) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssr.passObject.enabled = e);
    }

    async onAdded(e) {
      var t, n;
      e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSRPlugin"), await super.onAdded(e), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    createPasses(e) {
      var t, n;
      return this._ssrTarget = this.inlineSSR ? void 0 : e.renderer.createTarget({
        sizeMultiplier: 1
      }), [Vs(e, {
        passId: "ssr",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer", "progressive"],
        passObject: new Eo(e.renderer, this._ssrTarget, null !== (n = null === (t = e.getPlugin(Xs)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== n ? n : "", this.inlineSSR)
      }, () => [e.getPlugin(Xs), e.getPlugin(po), e.scene.activeCamera, e.renderer, e.scene])];
    }

    async onRemove(e) {
      return this._ssrTarget && e.renderer.disposeTarget(this._ssrTarget), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get uiConfig() {
      var e, t, n, r, i;
      const s = null !== (n = null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
      return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map(e => x(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this.setDirty)), s;
    }

  }

  Ao.PluginType = "SSReflection";

  var Co = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Ro extends It {
    constructor(e, t, n = "rgba") {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: t + "uniform vec2 tDiffuseSize;uniform vec2 bilDirection;varying vec2 vUv;uniform bool smoothEnabled;uniform float edgeSharpness;vec4 bilaterialAO(){vec4 color=clamp((texture2D(tDiffuse,vUv.xy)).B_SRC_ACCESSOR,0.,5.);if(!smoothEnabled)return color;float depth;vec3 normal;getDepthNormal(vUv.xy,depth,normal);float gaussianWeights[4];gaussianWeights[0]=0.153170;gaussianWeights[1]=0.144893;gaussianWeights[2]=0.122649;gaussianWeights[3]=0.092902;float Z=gaussianWeights[0]+0.03;vec4 final_colour=Z*color;vec2 nuv;vec4 cc;float dp;vec3 nor;vec2 direction=bilDirection/tDiffuseSize.xy;\n#pragma unroll_loop_start\nfor(int i=0;i<6;i++){direction*=-1.;nuv=vUv+2.*direction*float(UNROLLED_LOOP_INDEX/2+1);getDepthNormal(nuv,dp,nor);if(dp<0.999){float normalCloseness=dot(normal,nor);normalCloseness*=normalCloseness;float normalError=(1.-normalCloseness)*8.;float normalWeight=max((1.-normalError*edgeSharpness),0.00);float depthWeight=max(0.,1.-edgeSharpness*4000.*abs(depth-dp));float kernelWeight=gaussianWeights[UNROLLED_LOOP_INDEX/2]+0.03;float bilateralWeight=kernelWeight*depthWeight*normalWeight;Z+=bilateralWeight;cc=clamp((texture2D(tDiffuse,nuv)).B_SRC_ACCESSOR,0.,5.);final_colour+=bilateralWeight*cc;}}\n#pragma unroll_loop_end\nfinal_colour/=Z;return final_colour;}void main(){vec4 ao=clamp(bilaterialAO(),vec4(0.),vec4(1.));gl_FragColor=ao;}",
        uniforms: {
          bilDirection: {
            value: new i.FM8(1, 0)
          },
          tNormalDepth: {
            value: null
          },
          tDiffuse: {
            value: e.texture
          },
          tDiffuseSize: {
            value: new i.FM8()
          }
        },
        defines: {
          B_SRC_ACCESSOR: n
        }
      }, "tDiffuse", "tDiffuse2"), this.smoothEnabled = !0, this.edgeSharpness = .1, this._target = e, this.clear = !1, this.needsSwap = !1;
    }

    render(e, t, n, r, i) {
      var s, o, a, l;
      this.enabled && (this.uniforms.bilDirection.value.set(1, 0), this.uniforms.tDiffuse.value = this._target.texture, this.uniforms.tDiffuseSize.value.set((null === (s = this.uniforms.tDiffuse.value) || void 0 === s ? void 0 : s.image.width) || 0, (null === (o = this.uniforms.tDiffuse.value) || void 0 === o ? void 0 : o.image.height) || 0), super.render(e, t, this._target, r, i), this.uniforms.bilDirection.value.set(0, 1), this.uniforms.tDiffuse.value = t.texture, this.uniforms.tDiffuseSize.value.set((null === (a = this.uniforms.tDiffuse.value) || void 0 === a ? void 0 : a.image.width) || 0, (null === (l = this.uniforms.tDiffuse.value) || void 0 === l ? void 0 : l.image.height) || 0), super.render(e, this._target, t, r, i));
    }

  }

  Co([xe(), V()], Ro.prototype, "smoothEnabled", void 0), Co([xe(), V()], Ro.prototype, "edgeSharpness", void 0);

  var ko = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Po extends It {
    constructor(e, t, n) {
      super({
        defines: {
          LINEAR_DEPTH: 1,
          NUM_SAMPLES: 11,
          NUM_SPIRAL_TURNS: 3,
          DEPTH_NORMAL_TEXTURE: 1,
          DEPTH_PACKING_MODE: 2,
          PERSPECTIVE_CAMERA: 1
        },
        uniforms: {
          tLastThis: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          screenSize: {
            value: new i.FM8(512, 512)
          },
          saoData: {
            value: new i.Ltg()
          },
          frameCount: {
            value: 0
          },
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          projection: {
            value: new i.yGw()
          },
          saoBiasEpsilon: {
            value: new i.Pa4(1, 1, 1)
          }
        },
        vertexShader: go,
        fragmentShader: `\n\n${xo}\n\n${n}\n\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cameraNearFar;uniform mat4 projection;uniform sampler2D tLastThis;uniform vec4 saoData;uniform vec3 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1./float(NUM_SAMPLES);float getViewZFromNDCZ(const in float depth){\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.,255.,65025.);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1./256.);return pack;}vec3 getViewPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return vec3(xe,ye,viewDepth);}float decodeDepth(const in vec2 uv){vec4 uncodedDepth;\n#if DEPTH_PACKING_MODE == 2\nuncodedDepth=texture2D(tNormalDepth,uv);\n#else\nuncodedDepth=texture2D(tDepth,uv);\n#endif\n#if DEPTH_PACKING_MODE == 0\nreturn uncodedDepth.x;\n#elif DEPTH_PACKING_MODE == 1\n#if LINEAR_DEPTH == 1\nreturn pow2(unpackRGBAToDepth(uncodedDepth));\n#else\nreturn unpackRGBAToDepth(uncodedDepth);\n#endif\n#else\nreturn pow2(unpack16(uncodedDepth.xy));\n#endif\n}vec3 getPositionFromOffset(const in vec2 uv,const in vec2 offset,const in float screenSpaceRadius){vec2 uvOffset=uv+floor(screenSpaceRadius*offset)/screenSize;float d=decodeDepth(uvOffset);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(d);return getViewPositionFromViewZ(uvOffset,centerViewZ);\n#else\nd=mix(-cameraNearFar.x,-cameraNearFar.y,d);return getViewPositionFromViewZ(uvOffset,d);\n#endif\n}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 offset=vec2(cos(angle),sin(angle));vec3 samplePosition=getPositionFromOffset(uv,offset,screenSpaceRadius);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction);float ao=max((dot(centerNormal,direction)+centerPosition.z*saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.);return ao;}void main(){float centerDepth;vec3 centerNormal;getDepthNormal(vUv,centerDepth,centerNormal);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(centerDepth);\n#else\nfloat centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);\n#endif\nvec3 centerPosition=getViewPositionFromViewZ(vUv,centerViewZ);float occlusionSphereScreenRadius=200.*saoData.z/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#if NUM_SAMPLES > 1\nsum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 2\nsum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 3\nsum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 4\nsum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 5\nsum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 6\nsum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 7\nsum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 8\nsum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 9\nsum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 10\nsum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\nfloat aoValue=sum*saoData.y*INV_NUM_SAMPLES;aoValue=clamp(1.-max(aoValue,0.),0.,1.);gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=(vec4(aoValue)).r;}\n\n            `
      }, "tDiffuse"), this.parameters = {
        intensity: .25,
        occlusionWorldRadius: 1,
        bias: .001,
        falloff: 1,
        edgeSharpness: .3,
        blurEnabled: !0
      }, this._smoothEnabled = !0, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          e.defines.SSAO_ENABLED && (e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", "#ifndef USE_TRANSMISSION\n#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0\nfloat ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif\n#endif\n"));
        },
        onObjectRender: (e, t, n) => {
          var r, i;
          this.materialExtension.extraUniforms.tSSAOMap.value = null === (r = this._target) || void 0 === r ? void 0 : r.texture;
          const s = t.materialObject,
                o = !s.transparent && s.transmission < .001;
          let a = this.enabled && o && !1 !== n.userData.screenSpaceRendering && !(null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssaoDisabled) ? 1 : 0;
          s.defines.SSAO_ENABLED !== a && (s.defines.SSAO_ENABLED = a, s.needsUpdate = !0), a = this._target.texture, this.materialExtension.extraUniforms.tSSAOMap.value !== a && (this.materialExtension.extraUniforms.tSSAOMap.value = a, s.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return M`
             uniform sampler2D tSSAOMap;
             ${U("tSSAOMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2)}
            ${Mo}
        `;
        },
        extraUniforms: {
          tSSAOMap: {
            value: null
          }
        },
        computeCacheKey: e => {
          var t, n;
          return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2;
        }
      }, this._renderer = e, this._target = t, this.needsSwap = !1, this.clear = !0, this.bilateralPass = new Ro(this._target, n, "rrrr");
    }

    get smoothEnabled() {
      return this._smoothEnabled;
    }

    set smoothEnabled(e) {
      this._smoothEnabled = e, this.bilateralPass.enabled = e, this.bilateralPass.uniforms.smoothEnabled.value = e;
    }

    render(e, t, n, r, i) {
      this.enabled && (this._updateParameters(), this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this._smoothEnabled && this.bilateralPass.render(e, t, n, r, i));
    }

    _updateParameters() {
      const e = this.material.uniforms.saoData.value;
      e.y = this.parameters.intensity, e.z = this.parameters.occlusionWorldRadius;
      const t = this.material.uniforms.saoBiasEpsilon.value;
      t.x = this.parameters.bias, t.y = .001, t.z = this.parameters.falloff;
    }

  }

  ko([xe()], Po.prototype, "bilateralPass", void 0), ko([xe()], Po.prototype, "parameters", void 0);

  class Do extends lo {
    constructor() {
      super(), this.dependencies = [js, Xs], this.setDirty = this.setDirty.bind(this);
    }

    get aoTarget() {
      return this._aoTarget;
    }

    async onAdded(e) {
      return e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSAOPlugin"), super.onAdded(e);
    }

    createPasses(e) {
      var t, n;
      return this._aoTarget = e.renderer.createTarget({
        sizeMultiplier: 1
      }), [Vs(e, {
        passId: "ssao",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer"],
        passObject: new Po(e.renderer, this._aoTarget, null !== (n = null === (t = e.getPlugin(Xs)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== n ? n : ""),

        update() {
          this.passObject.bilateralPass.updateShaderProperties([e.getPlugin(Xs)]);
        }

      }, () => [e.getPlugin(Xs), e.scene.activeCamera, e.renderer])];
    }

    async onRemove(e) {
      return e.renderer.disposeTarget(this._aoTarget), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssao) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }

    set enabled(e) {
      var t;
      (null === (t = this.passes.ssao) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssao.passObject.enabled = e);
    }

    get uiConfig() {
      var e;
      if (this._uiConfig) return this._uiConfig;
      const t = this,
            n = t.passes.ssao.passObject;
      return this._uiConfig = {
        type: "folder",
        label: "SS Ambient Occlusion",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [n, "enabled"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 4],
          property: [n.parameters, "intensity"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Radius",
          bounds: [.1, 8],
          property: [n.parameters, "occlusionWorldRadius"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Bias",
          bounds: [1e-5, .01],
          property: [n.parameters, "bias"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Falloff",
          bounds: [.01, 3],
          property: [n.parameters, "falloff"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Num samples",
          stepSize: 1,
          bounds: [1, 11],
          property: [null === (e = n.material) || void 0 === e ? void 0 : e.defines, "NUM_SAMPLES"],
          onChange: [() => n.material.needsUpdate = !0, t.setDirty]
        }, {
          type: "checkbox",
          property: [n.bilateralPass, "smoothEnabled"],
          onChange: t.setDirty
        }, {
          type: "vec4",
          property: [n.bilateralPass, "edgeSharpness"],
          onChange: t.setDirty
        }]
      };
    }

  }

  Do.PluginType = "SSAO";

  class Oo {
    constructor(e) {
      this._normalsCache = {}, this._renderer = e, this._scene = new i.xsS(), this._mesh = new i.Kj0(), this._mesh.frustumCulled = !1, this._scene.add(this._mesh), this._mesh.position.set(0, 0, 0), this._mesh.material = new Lo();
    }

    dispose() {
      this._mesh.material.dispose();
    }

    captureNormalMap(e, t, n = 512) {
      if (!e) throw "No geometry";
      if (e.userData._normalsCaptureMap) return !1;
      const r = null == t ? void 0 : t.split(";").find(e => this._normalsCache[e]);

      if (r) {
        const i = this._normalsCache[r];
        return null == t || t.split(";").forEach(e => e !== r && (this._normalsCache[e] = i)), i.width !== n && console.warn("last cacheKey normalMapRes mismatch, check model", n), e.userData._normalsCaptureMap = i, !1;
      }

      const s = this._renderer.createTargetCustom({
        width: n,
        height: n
      }, {
        minFilter: i.TyD,
        magFilter: i.TyD,
        generateMipmaps: !1,
        type: i.cLu
      }, i.oAp);

      if (!s) throw "Unable to create render target";
      null == t || t.split(";").forEach(e => this._normalsCache[e] = s), s.addEventListener("dispose", () => delete this._normalsCache[t]);
      const o = new i._am(1e-4, 100, s);

      this._scene.add(o);

      const a = e.userData._normalsCaptureOffsets;
      return void 0 !== a.center && this._mesh.material.uniforms.offsetCenter.value.copy(a.center), void 0 !== a.offsetMatrixInv && this._mesh.material.uniforms.offsetMatrixInv.value.copy(a.offsetMatrixInv), void 0 !== a.radius && (this._mesh.material.uniforms.radius.value = a.radius), this._mesh.geometry = e, o.update(this._renderer.rendererObject, this._scene), this._scene.remove(o), this._mesh.geometry = void 0, e.userData._normalsCaptureMap = s, !0;
    }

  }

  class Lo extends i.jyz {
    constructor() {
      super({
        vertexShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform mat4 offsetMatrixInv;uniform vec3 offsetCenter;void main(){vNormal=normalize((offsetMatrixInv*vec4(normal,0.)).xyz);vecPosition=(modelMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.)).xyz;gl_Position=projectionMatrix*modelViewMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.);}",
        fragmentShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform float radius;void main(){vec3 color=normalize(vNormal);color=color*0.5+0.5;gl_FragColor=vec4(color.x,color.y,color.z,length(vecPosition)/radius);}",
        side: i.ehD,
        clipping: !1,
        uniforms: {
          radius: {
            value: 1
          },
          offsetMatrixInv: {
            value: new i.yGw().identity()
          },
          offsetCenter: {
            value: new i.Pa4()
          }
        }
      });
    }

  }

  function Io(e) {
    const t = new i.Pa4(0, 0, 0),
          n = new i.Pa4(0, 0, 0),
          r = new i.Pa4(0, 0, 0),
          s = new i.Pa4(0, 0, 0),
          o = e.getAttribute("position"),
          a = e.index;
    if (a) for (let i = Math.max(0, e.drawRange.start), l = Math.min(a.count, e.drawRange.start + e.drawRange.count) - 1; i < l / 3; i += 3) {
      const e = a.getX(i),
            l = a.getX(i + 1),
            c = a.getX(i + 2);
      n.set(o.getX(e), o.getY(e), o.getZ(e)), r.set(o.getX(l), o.getY(l), o.getZ(l)), s.set(o.getX(c), o.getY(c), o.getZ(c)), r.sub(n), s.sub(n), s.cross(r), s.normalize(), t.add(s);
    } else {
      const e = o.array;

      for (let i = 0; i < e.length / 3; i += 9) n.set(e[i], e[i + 1], e[i + 2]), r.set(e[i + 3], e[i + 4], e[i + 5]), s.set(e[i + 6], e[i + 7], e[i + 8]), r.sub(n), s.sub(n), s.cross(r), s.normalize(), t.add(s);
    }
    t.normalize();
    let l = !1,
        c = 0;

    for (; !l;) {
      const e = c / 3,
            i = a ? a.getX(e) : e,
            s = a ? a.getX(e + 1) : e + 1;
      n.set(o.getX(i), o.getY(i), o.getZ(i)), r.set(o.getX(s), o.getY(s), o.getZ(s)), n.sub(r), n.normalize();
      const u = t.dot(n);
      Math.abs(u - 1) > .001 && n.length() > .5 && (l = !0), c += 3;
    }

    r.crossVectors(n, t), r.normalize(), n.crossVectors(t, r), n.normalize();
    const u = new i.yGw();
    u.elements[0] = n.x, u.elements[1] = n.y, u.elements[2] = n.z, u.elements[3] = 0, u.elements[4] = t.x, u.elements[5] = t.y, u.elements[6] = t.z, u.elements[7] = 0, u.elements[8] = r.x, u.elements[9] = r.y, u.elements[10] = r.z, u.elements[11] = 0, u.elements[12] = 0, u.elements[13] = 0, u.elements[14] = 0, u.elements[15] = 1, e.computeBoundingSphere();
    const p = e.boundingSphere.radius,
          h = new i.yGw().makeScale(p, p, p);
    return u.multiply(h), u;
  }

  const Fo = { ...zt,
    color: new ve(1, 1, 1),
    envMapIntensity: 1,
    envMapRotation: 0,
    dispersion: .012,
    squashFactor: .98,
    geometryFactor: .5,
    gammaFactor: 1,
    absorptionFactor: 1,
    reflectivity: .5,
    refractiveIndex: 2.4,
    boostFactors: new i.Pa4(.892, .892, .98595025),
    envMap: null,
    wireframe: !1,
    wireframeLinewidth: 0,
    skinning: !1,
    transmission: 0,
    morphTargets: !1,
    morphNormals: !1,
    rayBounces: 1,
    diamondOrientedEnvMap: 0
  };

  var No = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Uo extends i.jyz {
    constructor(e) {
      super({
        side: i.ehD,
        defines: {
          DIA_ORIENT_ENVMAP: 0,
          RAY_BOUNCES: 5,
          ENV_MAP_TYPE: 0,
          PI: 3.1428
        },
        vertexShader: "#ifndef USE_ENVMAP\n#define USE_ENVMAP \n#endif\nvarying vec3 vWorldPosition;varying vec3 vWorldNormal;void main(){vWorldNormal=(modelMatrix*vec4(normal,0.)).xyz;\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\nvWorldPosition=worldPosition.xyz;}",
        fragmentShader: "varying vec3 vWorldNormal;varying vec3 vWorldPosition;uniform samplerCube tCubeMapNormals;\n#if ENV_MAP_TYPE == 0\nuniform samplerCube envMap;\n#elif ENV_MAP_TYPE == 1\nuniform sampler2D envMap;\n#endif\nuniform float envMapIntensity;uniform mat4 modelMatrix;uniform mat4 inverseModelMatrix;uniform mat4 offsetMatrixInv;uniform mat4 offsetMatrix;uniform float transmission;uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform float refractiveIndex;uniform float radius;uniform float rIndexDelta;uniform float squashFactor;uniform float geometryFactor;uniform vec3 color;uniform vec3 colorCorrection;uniform vec3 boostFactors;uniform vec3 centerOffset;uniform float gammaFactor;uniform float absorptionFactor;uniform float envMapRotation;uniform float reflectivity;vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float roughness){float dotNV=abs(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)/(PI*2.)+0.5;uv.y=asin(n.y)/PI+0.5;return uv;}vec4 sampleEnvMap(vec3 direction){\n#if !defined(USE_ENVMAP)\nreturn vec4(direction,1);\n#else\nfloat cs=cos(envMapRotation);float sn=sin(envMapRotation);float temp=cs*direction.x+sn*direction.z;direction.z=-sn*direction.x+cs*direction.z;direction.x=temp;direction.x*=-1.;direction.z*=-1.;\n#if ENV_MAP_TYPE == 0\nreturn(textureCube(envMap,direction));\n#elif ENV_MAP_TYPE == 1\nreturn(texture2D(envMap,cartesianToPolar(direction)));\n#endif\nreturn vec4(1,0,1,1);\n#endif\n}vec4 SampleSpecularReflection(vec3 direction){return envMapIntensity*(sampleEnvMap(direction));}uniform mat4 projectionMatrix;vec4 SampleSpecularContribution(vec3 direction){direction=normalize(direction);direction.x*=-1.;direction.z*=-1.;return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContributionRef(vec3 origin,int i){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(origin,1.);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.;refractionCoords/=2.;return transmissionSamplerMapTexelToLinear(texture2D(transmissionSamplerMap,refractionCoords));}vec3 intersectSphere(vec3 origin,vec3 direction){origin-=centerOffset;direction.y/=squashFactor;float A=dot(direction,direction);float B=2.*dot(origin,direction);float C=dot(origin,origin)-radius*radius;float disc=B*B-4.*A*C;if(disc>0.){disc=sqrt(disc);float t1=(-B+disc)*geometryFactor/A;float t2=(-B-disc)*geometryFactor/A;float t=(t1>t2)?t1:t2;direction.y*=squashFactor;return vec3(origin+centerOffset+direction*t);}return vec3(0.);}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}vec4 getNormalDistance(vec3 d){return textureCube(tCubeMapNormals,d);}vec3 getSurfaceNormal(vec4 surfaceInfos){vec3 surfaceNormal=surfaceInfos.rgb;surfaceNormal=surfaceNormal*2.-1.;return-normalize(surfaceNormal);}vec3 intersect(vec3 rayOrigin,vec3 rayDirection){vec3 sphereHitPoint=intersectSphere(rayOrigin,rayDirection);vec3 direction1=normalize(sphereHitPoint-centerOffset);vec4 normalDistanceData1=getNormalDistance(direction1);float distance1=normalDistanceData1.a*radius;vec3 pointOnPlane1=centerOffset+direction1*distance1;vec3 planeNormal1=getSurfaceNormal(normalDistanceData1);vec3 hitPoint1=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane1,planeNormal1);vec3 direction2=normalize(hitPoint1-centerOffset);vec4 normalDistanceData2=getNormalDistance(direction2);float distance2=normalDistanceData2.a*radius;vec3 pointOnPlane2=centerOffset+direction2*distance2;vec3 hitPoint=hitPoint1;vec3 planeNormal2=getSurfaceNormal(normalDistanceData2);hitPoint=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane2,planeNormal2);return hitPoint;}vec3 debugBounces(int count){vec3 color=vec3(1.,1.,1.);if(count==1)color=vec3(0.,1.,0.);else if(count==2)color=vec3(0.,0.,1.);else if(count==3)color=vec3(1.,1.,0.);else if(count==4)color=vec3(0.,1.,1.);else color=vec3(0.,1.,0.);if(count==0)color=vec3(1.,0.,0.);return color;}vec3 traceRay(vec3 origin,vec3 direction,vec3 normal){vec3 outColor=vec3(0.);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 newDirection=refract(direction,normal,n1/refractiveIndex);vec3 reflectedDirection=reflect(direction,normal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(reflectedDirection,normal,vec3(f0),0.);vec3 brdfRefracted=BRDF_Specular_GGX_Environment(newDirection,-normal,vec3(f0),0.);attenuationFactor*=(vec3(1.)-brdfRefracted);outColor+=SampleSpecularReflection(reflectedDirection).rgb*brdfReflected*reflectivity*2.;int count=0;newDirection=(offsetMatrixInv*inverseModelMatrix*vec4(newDirection,0.)).xyz;newDirection=normalize(newDirection);origin=(offsetMatrixInv*inverseModelMatrix*vec4(origin,1.)).xyz;vec3 origin2=origin;origin2=(modelMatrix*offsetMatrix*vec4(origin2,1.)).xyz;for(int i=0;i<RAY_BOUNCES;i++){vec3 intersectedPos=intersect(origin,newDirection);vec3 dist=intersectedPos-origin;vec3 d=normalize(intersectedPos-centerOffset);vec3 mappedNormal=getNormalDistance(d).rgb;mappedNormal=2.*mappedNormal-1.;mappedNormal=-normalize(mappedNormal);float r=length(dist)/radius*absorptionFactor;attenuationFactor*=exp(-r*(1.-color));origin=intersectedPos;origin2=(modelMatrix*offsetMatrix*vec4(intersectedPos,1.)).xyz;vec3 oldDir=newDirection;newDirection=refract(newDirection,mappedNormal,refractiveIndex/n1);if(dot(newDirection,newDirection)<epsilon){newDirection=reflect(oldDir,mappedNormal);if(i==RAY_BOUNCES-1){vec3 brdfReflected=BRDF_Specular_GGX_Environment(-oldDir,mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(oldDir,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);outColor+=((transmission>0.&&cosT<transmission)?SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb:SampleSpecularContribution(DIA_ORIENT_ENVMAP<1?d1:newDirection).rgb)*attenuationFactor*colorCorrection*boostFactors*(vec3(1.)-brdfReflected);}}else{vec3 brdfRefracted=vec3(1.)-BRDF_Specular_GGX_Environment(newDirection,-mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(newDirection,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);if(transmission>0.&&cosT<transmission){outColor+=SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}else{vec3 dir0=newDirection;vec3 dir1=refract(oldDir,mappedNormal,(refractiveIndex+rIndexDelta)/n1);vec3 dir2=refract(oldDir,mappedNormal,(refractiveIndex-rIndexDelta)/n1);\n#if DIA_ORIENT_ENVMAP < 1\ndir0=d1;dir1=(modelMatrix*offsetMatrix*vec4(dir1,0.)).xyz;dir2=(modelMatrix*offsetMatrix*vec4(dir2,0.)).xyz;\n#endif\noutColor+=vec3(SampleSpecularContribution(dir1).r,SampleSpecularContribution(dir0).g,SampleSpecularContribution(dir2).b)*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}newDirection=reflect(oldDir,mappedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(newDirection,mappedNormal,vec3(f0),0.);attenuationFactor*=brdfReflected*boostFactors;count++;}}return outColor;}void main(){vec3 normalizedNormal=normalize(vWorldNormal);vec3 viewVector=normalize(vWorldPosition-cameraPosition);vec3 color=traceRay(vWorldPosition,viewVector,normalizedNormal);gl_FragColor=vec4(color.rgb,1.);\n#include <encodings_fragment>\n}",
        uniforms: {
          envMap: {
            value: e.envMap || null
          },
          envMapRotation: {
            value: 0
          },
          transmission: {
            value: 0
          },
          transmissionSamplerMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new i.FM8()
          },
          normalOffset: {
            value: 0
          },
          distanceOffset: {
            value: 0
          },
          colorCorrection: {
            value: new i.Pa4(1, 1, 1)
          }
        }
      }), this.typeSlug = Uo.TypeSlug, this.assetType = "material", this._envMap = null, this.isDiamondMaterial = !0, this.color = new ve(1, 1, 1), this.envMapIntensity = 1, this.dispersion = .012, this.absorptionFactor = 1, this.refractiveIndex = 2.4, this.squashFactor = .98, this.geometryFactor = .5, this.gammaFactor = 1, this.boostFactors = new i.Pa4(.892, .892, .98595025), this.transmission = 0, this.reflectivity = .5, this.rayBounces = 5, this.diamondOrientedEnvMap = 0, this.normalsCaptureMap = null, this.extraUniformsToUpload = {
        inverseModelMatrix: {
          value: new i.yGw().identity()
        },
        radius: {
          value: 1
        },
        centerOffset: {
          value: new i.Pa4(0, 0, 0)
        },
        offsetMatrix: {
          value: new i.yGw().identity()
        },
        offsetMatrixInv: {
          value: new i.yGw().identity()
        }
      }, this.userData.setDirty = () => {
        var e, t;
        this.needsUpdate = !0, this.dispatchEvent({
          type: "materialUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.userData.separateEnvMapIntensity = !0, this.setValues(e);
    }

    get mmMaterial() {
      return this;
    }

    get materialObject() {
      return this;
    }

    onBeforeRender(e, t, n, r, i) {
      var s, o;
      super.onBeforeRender(e, t, n, r, i), this.uniforms.envMapRotation.value = (null === (s = this.envMap) || void 0 === s ? void 0 : s.rotation) || 0, this.extraUniformsToUpload.inverseModelMatrix.value.copy(i.matrixWorld).invert();
      const a = r.userData._normalsCaptureOffsets;
      a && (this.extraUniformsToUpload.centerOffset.value.copy(a.centerOffset), this.extraUniformsToUpload.offsetMatrix.value.copy(a.offsetMatrix), this.extraUniformsToUpload.offsetMatrixInv.value.copy(a.offsetMatrixInv), this.extraUniformsToUpload.radius.value = a.radius);
      const l = null === (o = r.userData._normalsCaptureMap) || void 0 === o ? void 0 : o.texture;
      this.normalsCaptureMap !== l && (this.normalsCaptureMap = l);
    }

    set envMap(e) {
      var t;
      this._envMap = e, this.uniforms.envMap.value = this._envMap, (null === (t = this._envMap) || void 0 === t ? void 0 : t.isCubeTexture) ? (this.defines.ENV_MAP_TYPE = 0, this.needsUpdate = !0) : (this.defines.ENV_MAP_TYPE = 1, this.needsUpdate = !0);
    }

    get envMap() {
      return this._envMap;
    }

    clone() {
      return super.clone();
    }

    toJSON(e) {
      const t = {};
      return t.name = this.name, t.uuid = this.uuid, t.color = this.color.getHex(), t.envMapIntensity = this.envMapIntensity, t.dispersion = this.dispersion, t.squashFactor = this.squashFactor, t.geometryFactor = this.geometryFactor, t.gammaFactor = this.gammaFactor, t.absorptionFactor = this.absorptionFactor, t.reflectivity = this.reflectivity, t.refractiveIndex = this.refractiveIndex, t.rayBounces = this.rayBounces, t.diamondOrientedEnvMap = this.diamondOrientedEnvMap, t.boostFactors = {
        x: this.boostFactors.x,
        y: this.boostFactors.y,
        z: this.boostFactors.z,
        isVector3: !0
      }, t.transmission = this.transmission, t.isDiamondMaterialParameters = !0, t.type = Uo.TYPE, t.userData = {}, Kt(t.userData, this.userData), t.userData.uuid = this.userData.uuid, t;
    }

    get uiConfig() {
      const e = this;
      return this._uiConfigChildren || (this._uiConfigChildren = [{
        type: "input",
        property: [this, "name"]
      }, {
        type: "checkbox",
        property: [this, "wireframe"]
      }, ...Je(this), {
        type: "input",
        label: "Mesh count",

        get value() {
          var t, n, r;
          return null !== (r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.appliedMeshes) || void 0 === n ? void 0 : n.size) && void 0 !== r ? r : 0;
        },

        set value(e) {},

        disabled: !0
      }, {
        type: "input",
        label: "uuid",

        get value() {
          return e.uuid;
        },

        set value(e) {},

        disabled: !0
      }, {
        type: "checkbox",
        label: "Render to Depth",
        hidden: () => 0 === this.transmission,

        get value() {
          return !0 === e.userData.renderToDepth;
        },

        set value(t) {
          e.userData.renderToDepth = t || void 0;
        }

      }, {
        type: "button",
        label: "Download .dmat",
        value: () => {
          gt(new Blob([JSON.stringify(e.toJSON(), null, 2)], {
            type: "application/json"
          }), "diamond-material.dmat");
        }
      }]), this._uiConfig || (this._uiConfig = {
        type: "folder",
        label: "Diamond Material",
        expanded: !0,
        children: this._uiConfigChildren,
        limitedUi: !0
      }), this._uiConfig;
    }

    copyProps(e) {
      var t, n;
      if (!e.isDiamondMaterialParameters && !e.isDiamondMaterial && !e.isDiamond) return console.warn("Material type is not supported", e), this;
      const r = {};
      y(e, r, Array.from(Object.keys(Fo)));
      const i = r.userData;
      return delete r.userData, this.setValues(r), Kt(this.userData, i), null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t), this;
    }

    fromJSON(e, t) {
      return this.copyProps(e);
    }

  }

  Uo.TypeSlug = "dmat", Uo.TYPE = "DiamondMaterial", No([Ye("Color", {
    limitedUi: !0
  }), V()], Uo.prototype, "color", void 0), No([He("Env Intensity", [0, 5], .01, {
    limitedUi: !0
  }), V()], Uo.prototype, "envMapIntensity", void 0), No([He("Dispersion", [0, .1], 1e-4, {
    limitedUi: !0
  }), V({
    propKey: "rIndexDelta"
  })], Uo.prototype, "dispersion", void 0), No([He("Absorption", [0, 15], .01, {
    limitedUi: !0
  }), V()], Uo.prototype, "absorptionFactor", void 0), No([He("Refractive Index", [0, 4], .01, {
    limitedUi: !0
  }), V()], Uo.prototype, "refractiveIndex", void 0), No([V()], Uo.prototype, "squashFactor", void 0), No([V()], Uo.prototype, "geometryFactor", void 0), No([V()], Uo.prototype, "gammaFactor", void 0), No([We("RGB Boost", void 0, void 0, {
    limitedUi: !0
  }), V()], Uo.prototype, "boostFactors", void 0), No([He("Transmission", [0, 1], .01, {
    limitedUi: !0
  }), V()], Uo.prototype, "transmission", void 0), No([He("Reflectivity", [0, 2], .01, {
    limitedUi: !0
  }), V()], Uo.prototype, "reflectivity", void 0), No([G("RAY_BOUNCES", void 0, !0), He("Ray Bounces", [1, 16], 1)], Uo.prototype, "rayBounces", void 0), No([G("DIA_ORIENT_ENVMAP", void 0, !0), He("Diamond Oriented Lighting", [0, 1], 1)], Uo.prototype, "diamondOrientedEnvMap", void 0), No([V({
    propKey: "tCubeMapNormals"
  })], Uo.prototype, "normalsCaptureMap", void 0);

  class Bo extends r {
    constructor(e, t, n, r) {
      super(), this._scene = e, this._camera = null != n ? n : this._scene.activeCamera, this.domElement = t, this._time = this.time, this._mouseDownTime = 0, this._mouseUpTime = 1, this.selectionCondition = null != r ? r : e => !1 !== e.userData.userSelectable && !1 !== e.userData.bboxVisible && null != e.material && "ShadowMaterial" !== e.material.type, this.raycaster = new i.iMs(), this.mouse = new i.FM8(), this._selected = [], this._hovering = [], this.cursorStyles = {
        default: "grab",
        down: "grabbing"
      }, this._activeCameraChange = this._activeCameraChange.bind(this), this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.domElement.style.touchAction = "none", this.domElement.style.cursor = this.cursorStyles.default, this.domElement.addEventListener("pointermove", e => this.onPointerMove(e)), this.domElement.addEventListener("pointerleave", e => this.onPointerLeave(e)), this.domElement.addEventListener("pointerout", e => this.onPointerLeave(e)), this.domElement.addEventListener("pointercancel", e => this.onPointerCancel(e)), this.domElement.addEventListener("pointerenter", e => this.onPointerEnter(e)), this.domElement.addEventListener("pointerdown", e => this.onPointerDown(e)), this.domElement.addEventListener("pointerup", e => this.onPointerUp(e));
    }

    get scene() {
      return this._scene;
    }

    set scene(e) {
      var t;
      null === (t = this._scene) || void 0 === t || t.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene = e, this._scene.addEventListener("activeCameraChange", this._activeCameraChange);
    }

    _activeCameraChange() {
      this.camera = this._scene.activeCamera;
    }

    get camera() {
      return this._camera;
    }

    set camera(e) {
      this._camera = e;
    }

    get selectedObject() {
      return this._selected.length > 0 ? this._selected[0] : null;
    }

    set selectedObject(e) {
      1 === this._selected.length && this._selected[0] === e || (this._selected = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
        type: "selectedObjectChanged",
        object: this.selectedObject
      }));
    }

    get hoverObject() {
      return this._hovering.length > 0 ? this._hovering[0] : null;
    }

    set hoverObject(e) {
      this._hovering = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
        type: "hoverObjectChanged",
        object: this.hoverObject
      });
    }

    get time() {
      return this._time = At(), this._time;
    }

    get isMouseDown() {
      return this.mouseDownDeltaTime < 0;
    }

    get mouseDownDeltaTime() {
      return this._mouseUpTime - this._mouseDownTime;
    }

    onPointerMove(e) {
      !1 !== e.isPrimary && this.updateMouseFromEvent(e);
    }

    onPointerLeave(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this.hoverObject = null);
    }

    onPointerEnter(e) {}

    onPointerCancel(e) {}

    updateMouseFromEvent(e) {
      const t = this.domElement.getBoundingClientRect();
      this.mouse.x = (e.clientX - t.x) / t.width * 2 - 1, this.mouse.y = -(e.clientY - t.y) / t.height * 2 + 1;
    }

    onPointerDown(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.down, this._mouseDownTime = this.time);
    }

    onPointerUp(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this._mouseUpTime = this.time, this.mouseDownDeltaTime < 200 && this.onPointerClick(e));
    }

    onPointerClick(e) {
      if (!1 === e.isPrimary) return;
      this.updateMouseFromEvent(e);
      const t = this.checkIntersection();
      t && this.dispatchEvent({
        type: "hitObject",
        time: this._mouseUpTime,
        intersects: t
      }), this.selectedObject = (null == t ? void 0 : t.selectedObject) || null;
    }

    addPasses() {}

    checkIntersection() {
      var e;
      const t = null === (e = this._camera) || void 0 === e ? void 0 : e.cameraObject;
      if (!t) return null;
      this.raycaster.setFromCamera(this.mouse, t);
      const n = this.raycaster.intersectObject(this._scene.modelObject, !0),
            r = this.selectedObject;

      if (r) {
        const e = n.length - 1 - [...n].reverse().findIndex(e => {
          let t = e.object;

          for (; t;) {
            if (e.object === r) return !0;
            t = t.parent;
          }

          return !1;
        });
        e >= 0 && n.splice(0, e + 1);
      }

      if (n.length > 0) {
        for (const e of n) {
          let t = e.object;

          for (; !(null == t || t.visible && this.selectionCondition(t));) t = t.parent;

          if (t) return {
            selectedObject: t,
            intersect: e,
            intersects: n,
            mouse: this.mouse.toArray()
          };
        }

        return null;
      }

      return null;
    }

    refreshOutlinePass() {
      var e;
      null !== (e = this.hoverObject) && void 0 !== e || this.selectedObject;
    }

    isHovering() {
      return null != this.hoverObject;
    }

    isSelected() {
      return null != this.selectedObject;
    }

  }

  const jo = new i.iMs(),
        zo = new i.Pa4(),
        Vo = new i.Pa4(),
        Go = new i._fP(),
        Ho = {
    X: new i.Pa4(1, 0, 0),
    Y: new i.Pa4(0, 1, 0),
    Z: new i.Pa4(0, 0, 1)
  },
        Wo = {
    type: "change"
  },
        Ko = {
    type: "mouseDown"
  },
        Xo = {
    type: "mouseUp",
    mode: null
  },
        qo = {
    type: "objectChange"
  };

  class Yo extends i.Tme {
    constructor(e, t) {
      super(), void 0 === t && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
      const n = new ma();
      this._gizmo = n, this.add(n);
      const r = new ga();
      this._plane = r, this.add(r);
      const s = this;

      function o(e, t) {
        let i = t;
        Object.defineProperty(s, e, {
          get: function () {
            return void 0 !== i ? i : t;
          },
          set: function (t) {
            i !== t && (i = t, r[e] = t, n[e] = t, s.dispatchEvent({
              type: e + "-changed",
              value: t
            }), s.dispatchEvent(Wo));
          }
        }), s[e] = t, r[e] = t, n[e] = t;
      }

      o("camera", e), o("object", void 0), o("enabled", !0), o("axis", null), o("mode", "translate"), o("translationSnap", null), o("rotationSnap", null), o("scaleSnap", null), o("space", "world"), o("size", 1), o("dragging", !1), o("showX", !0), o("showY", !0), o("showZ", !0);

      const a = new i.Pa4(),
            l = new i.Pa4(),
            c = new i._fP(),
            u = new i._fP(),
            p = new i.Pa4(),
            h = new i._fP(),
            d = new i.Pa4(),
            f = new i.Pa4(),
            _ = new i.Pa4(),
            m = new i.Pa4();

      o("worldPosition", a), o("worldPositionStart", l), o("worldQuaternion", c), o("worldQuaternionStart", u), o("cameraPosition", p), o("cameraQuaternion", h), o("pointStart", d), o("pointEnd", f), o("rotationAxis", _), o("rotationAngle", 0), o("eye", m), this._offset = new i.Pa4(), this._startNorm = new i.Pa4(), this._endNorm = new i.Pa4(), this._cameraScale = new i.Pa4(), this._parentPosition = new i.Pa4(), this._parentQuaternion = new i._fP(), this._parentQuaternionInv = new i._fP(), this._parentScale = new i.Pa4(), this._worldScaleStart = new i.Pa4(), this._worldQuaternionInv = new i._fP(), this._worldScale = new i.Pa4(), this._positionStart = new i.Pa4(), this._quaternionStart = new i._fP(), this._scaleStart = new i.Pa4(), this._getPointer = Zo.bind(this), this._onPointerDown = $o.bind(this), this._onPointerHover = Jo.bind(this), this._onPointerMove = Qo.bind(this), this._onPointerUp = ea.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
    }

    updateMatrixWorld() {
      void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye) : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
    }

    pointerHover(e) {
      if (void 0 === this.object || !0 === this.dragging) return;
      jo.setFromCamera(e, this.camera);
      const t = ta(this._gizmo.picker[this.mode], jo);
      this.axis = t ? t.object.name : null;
    }

    pointerDown(e) {
      if (void 0 !== this.object && !0 !== this.dragging && 0 === e.button && null !== this.axis) {
        jo.setFromCamera(e, this.camera);
        const t = ta(this._plane, jo, !0);
        t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, Ko.mode = this.mode, this.dispatchEvent(Ko);
      }
    }

    pointerMove(e) {
      const t = this.axis,
            n = this.mode,
            r = this.object;
      let i = this.space;
      if ("scale" === n ? i = "local" : "E" !== t && "XYZE" !== t && "XYZ" !== t || (i = "world"), void 0 === r || null === t || !1 === this.dragging || -1 !== e.button) return;
      jo.setFromCamera(e, this.camera);
      const s = ta(this._plane, jo, !0);

      if (s) {
        if (this.pointEnd.copy(s.point).sub(this.worldPositionStart), "translate" === n) this._offset.copy(this.pointEnd).sub(this.pointStart), "local" === i && "XYZ" !== t && this._offset.applyQuaternion(this._worldQuaternionInv), -1 === t.indexOf("X") && (this._offset.x = 0), -1 === t.indexOf("Y") && (this._offset.y = 0), -1 === t.indexOf("Z") && (this._offset.z = 0), "local" === i && "XYZ" !== t ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && ("local" === i && (r.position.applyQuaternion(Go.copy(this._quaternionStart).invert()), -1 !== t.search("X") && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), "world" === i && (r.parent && r.position.add(zo.setFromMatrixPosition(r.parent.matrixWorld)), -1 !== t.search("X") && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(zo.setFromMatrixPosition(r.parent.matrixWorld))));else if ("scale" === n) {
          if (-1 !== t.search("XYZ")) {
            let e = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (e *= -1), Vo.set(e, e, e);
          } else zo.copy(this.pointStart), Vo.copy(this.pointEnd), zo.applyQuaternion(this._worldQuaternionInv), Vo.applyQuaternion(this._worldQuaternionInv), Vo.divide(zo), -1 === t.search("X") && (Vo.x = 1), -1 === t.search("Y") && (Vo.y = 1), -1 === t.search("Z") && (Vo.z = 1);

          r.scale.copy(this._scaleStart).multiply(Vo), this.scaleSnap && (-1 !== t.search("X") && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Y") && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Z") && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if ("rotate" === n) {
          this._offset.copy(this.pointEnd).sub(this.pointStart);

          const e = 20 / this.worldPosition.distanceTo(zo.setFromMatrixPosition(this.camera.matrixWorld));
          "E" === t ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === t ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(zo.copy(this.rotationAxis).cross(this.eye)) * e) : "X" !== t && "Y" !== t && "Z" !== t || (this.rotationAxis.copy(Ho[t]), zo.copy(Ho[t]), "local" === i && zo.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(zo.cross(this.eye).normalize()) * e), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === i && "E" !== t && "XYZE" !== t ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(Go.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(Go.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
        }
        this.dispatchEvent(Wo), this.dispatchEvent(qo);
      }
    }

    pointerUp(e) {
      0 === e.button && (this.dragging && null !== this.axis && (Xo.mode = this.mode, this.dispatchEvent(Xo)), this.dragging = !1, this.axis = null);
    }

    dispose() {
      this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function (e) {
        e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
      });
    }

    attach(e) {
      return this.object = e, this.visible = !0, this;
    }

    detach() {
      return this.object = void 0, this.visible = !1, this.axis = null, this;
    }

    reset() {
      this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Wo), this.dispatchEvent(qo), this.pointStart.copy(this.pointEnd));
    }

    getRaycaster() {
      return jo;
    }

    getMode() {
      return this.mode;
    }

    setMode(e) {
      this.mode = e;
    }

    setTranslationSnap(e) {
      this.translationSnap = e;
    }

    setRotationSnap(e) {
      this.rotationSnap = e;
    }

    setScaleSnap(e) {
      this.scaleSnap = e;
    }

    setSize(e) {
      this.size = e;
    }

    setSpace(e) {
      this.space = e;
    }

    update() {
      console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
    }

  }

  function Zo(e) {
    if (this.domElement.ownerDocument.pointerLockElement) return {
      x: 0,
      y: 0,
      button: e.button
    };
    {
      const t = this.domElement.getBoundingClientRect();
      return {
        x: (e.clientX - t.left) / t.width * 2 - 1,
        y: -(e.clientY - t.top) / t.height * 2 + 1,
        button: e.button
      };
    }
  }

  function Jo(e) {
    if (this.enabled) switch (e.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(e));
    }
  }

  function $o(e) {
    this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(e.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(e)), this.pointerDown(this._getPointer(e)));
  }

  function Qo(e) {
    this.enabled && this.pointerMove(this._getPointer(e));
  }

  function ea(e) {
    this.enabled && (this.domElement.releasePointerCapture(e.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(e)));
  }

  function ta(e, t, n) {
    const r = t.intersectObject(e, !0);

    for (let e = 0; e < r.length; e++) if (r[e].object.visible || n) return r[e];

    return !1;
  }

  const na = new i.USm(),
        ra = new i.Pa4(0, 1, 0),
        ia = new i.Pa4(0, 0, 0),
        sa = new i.yGw(),
        oa = new i._fP(),
        aa = new i._fP(),
        la = new i.Pa4(),
        ca = new i.yGw(),
        ua = new i.Pa4(1, 0, 0),
        pa = new i.Pa4(0, 1, 0),
        ha = new i.Pa4(0, 0, 1),
        da = new i.Pa4(),
        fa = new i.Pa4(),
        _a = new i.Pa4();

  class ma extends i.Tme {
    constructor() {
      super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
      const e = new i.vBJ({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0
      }),
            t = new i.nls({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0
      }),
            n = e.clone();
      n.opacity = .15;
      const r = t.clone();
      r.opacity = .5;
      const s = e.clone();
      s.color.setHex(16711680);
      const o = e.clone();
      o.color.setHex(65280);
      const a = e.clone();
      a.color.setHex(255);
      const l = e.clone();
      l.color.setHex(16711680), l.opacity = .5;
      const c = e.clone();
      c.color.setHex(65280), c.opacity = .5;
      const u = e.clone();
      u.color.setHex(255), u.opacity = .5;
      const p = e.clone();
      p.opacity = .25;
      const h = e.clone();
      h.color.setHex(16776960), h.opacity = .25, e.clone().color.setHex(16776960);
      const d = e.clone();
      d.color.setHex(7895160);
      const f = new i.fHI(0, .04, .1, 12);
      f.translate(0, .05, 0);

      const _ = new i.DvJ(.08, .08, .08);

      _.translate(0, .04, 0);

      const m = new i.u9r();
      m.setAttribute("position", new i.a$l([0, 0, 0, 1, 0, 0], 3));
      const g = new i.fHI(.0075, .0075, .5, 3);

      function v(e, t) {
        const n = new i.XvJ(e, .0075, 3, 64, t * Math.PI * 2);
        return n.rotateY(Math.PI / 2), n.rotateX(Math.PI / 2), n;
      }

      g.translate(0, .25, 0);
      const b = {
        X: [[new i.Kj0(f, s), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(f, s), [-.5, 0, 0], [0, 0, Math.PI / 2]], [new i.Kj0(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]]],
        Y: [[new i.Kj0(f, o), [0, .5, 0]], [new i.Kj0(f, o), [0, -.5, 0], [Math.PI, 0, 0]], [new i.Kj0(g, o)]],
        Z: [[new i.Kj0(f, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new i.Kj0(f, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]], [new i.Kj0(g, a), null, [Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.pQR(.1, 0), p.clone()), [0, 0, 0]]],
        XY: [[new i.Kj0(new i.DvJ(.15, .15, .01), u.clone()), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), l.clone()), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), c.clone()), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
      },
            x = {
        X: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
        Y: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, .3, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, -.3, 0], [0, 0, Math.PI]]],
        Z: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, .3], [Math.PI / 2, 0, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.pQR(.2, 0), n)]],
        XY: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
      },
            y = {
        START: [[new i.Kj0(new i.pQR(.01, 2), r), null, null, null, "helper"]],
        END: [[new i.Kj0(new i.pQR(.01, 2), r), null, null, null, "helper"]],
        DELTA: [[new i.x12(function () {
          const e = new i.u9r();
          return e.setAttribute("position", new i.a$l([0, 0, 0, 1, 1, 1], 3)), e;
        }(), r), null, null, null, "helper"]],
        X: [[new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [[new i.x12(m, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
        Z: [[new i.x12(m, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
      },
            w = {
        XYZE: [[new i.Kj0(v(.5, 1), d), null, [0, Math.PI / 2, 0]]],
        X: [[new i.Kj0(v(.5, .5), s)]],
        Y: [[new i.Kj0(v(.5, .5), o), null, [0, 0, -Math.PI / 2]]],
        Z: [[new i.Kj0(v(.5, .5), a), null, [0, Math.PI / 2, 0]]],
        E: [[new i.Kj0(v(.75, 1), h), null, [0, Math.PI / 2, 0]]]
      },
            S = {
        AXIS: [[new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
      },
            M = {
        XYZE: [[new i.Kj0(new i.xo$(.25, 10, 8), n)]],
        X: [[new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
        Y: [[new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
        Z: [[new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
        E: [[new i.Kj0(new i.XvJ(.75, .1, 2, 24), n)]]
      },
            T = {
        X: [[new i.Kj0(_, s), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(_, s), [-.5, 0, 0], [0, 0, Math.PI / 2]]],
        Y: [[new i.Kj0(_, o), [0, .5, 0]], [new i.Kj0(g, o)], [new i.Kj0(_, o), [0, -.5, 0], [0, 0, Math.PI]]],
        Z: [[new i.Kj0(_, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new i.Kj0(g, a), [0, 0, 0], [Math.PI / 2, 0, 0]], [new i.Kj0(_, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]]],
        XY: [[new i.Kj0(new i.DvJ(.15, .15, .01), u), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), l), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), c), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.DvJ(.1, .1, .1), p.clone())]]
      },
            E = {
        X: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
        Y: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, .3, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, -.3, 0], [0, 0, Math.PI]]],
        Z: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, .3], [Math.PI / 2, 0, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
        XY: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.DvJ(.2, .2, .2), n), [0, 0, 0]]]
      },
            A = {
        X: [[new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [[new i.x12(m, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
        Z: [[new i.x12(m, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
      };

      function C(e) {
        const t = new i.Tme();

        for (const n in e) for (let r = e[n].length; r--;) {
          const i = e[n][r][0].clone(),
                s = e[n][r][1],
                o = e[n][r][2],
                a = e[n][r][3],
                l = e[n][r][4];
          i.name = n, i.tag = l, s && i.position.set(s[0], s[1], s[2]), o && i.rotation.set(o[0], o[1], o[2]), a && i.scale.set(a[0], a[1], a[2]), i.updateMatrix();
          const c = i.geometry.clone();
          c.applyMatrix4(i.matrix), i.geometry = c, i.renderOrder = 1 / 0, i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), i.scale.set(1, 1, 1), t.add(i);
        }

        return t;
      }

      this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = C(b)), this.add(this.gizmo.rotate = C(w)), this.add(this.gizmo.scale = C(T)), this.add(this.picker.translate = C(x)), this.add(this.picker.rotate = C(M)), this.add(this.picker.scale = C(E)), this.add(this.helper.translate = C(y)), this.add(this.helper.rotate = C(S)), this.add(this.helper.scale = C(A)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
    }

    updateMatrixWorld(e) {
      const t = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : aa;
      this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
      let n = [];
      n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);

      for (let e = 0; e < n.length; e++) {
        const r = n[e];
        let i;

        if (r.visible = !0, r.rotation.set(0, 0, 0), r.position.copy(this.worldPosition), i = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r.scale.set(1, 1, 1).multiplyScalar(i * this.size / 4), "helper" !== r.tag) {
          if (r.quaternion.copy(t), "translate" === this.mode || "scale" === this.mode) {
            const e = .99,
                  n = .2;
            "X" === r.name && Math.abs(ra.copy(ua).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "Y" === r.name && Math.abs(ra.copy(pa).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "Z" === r.name && Math.abs(ra.copy(ha).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "XY" === r.name && Math.abs(ra.copy(ha).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "YZ" === r.name && Math.abs(ra.copy(ua).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "XZ" === r.name && Math.abs(ra.copy(pa).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1);
          } else "rotate" === this.mode && (oa.copy(t), ra.copy(this.eye).applyQuaternion(Go.copy(t).invert()), -1 !== r.name.search("E") && r.quaternion.setFromRotationMatrix(sa.lookAt(this.eye, ia, pa)), "X" === r.name && (Go.setFromAxisAngle(ua, Math.atan2(-ra.y, ra.z)), Go.multiplyQuaternions(oa, Go), r.quaternion.copy(Go)), "Y" === r.name && (Go.setFromAxisAngle(pa, Math.atan2(ra.x, ra.z)), Go.multiplyQuaternions(oa, Go), r.quaternion.copy(Go)), "Z" === r.name && (Go.setFromAxisAngle(ha, Math.atan2(ra.y, ra.x)), Go.multiplyQuaternions(oa, Go), r.quaternion.copy(Go)));

          r.visible = r.visible && (-1 === r.name.indexOf("X") || this.showX), r.visible = r.visible && (-1 === r.name.indexOf("Y") || this.showY), r.visible = r.visible && (-1 === r.name.indexOf("Z") || this.showZ), r.visible = r.visible && (-1 === r.name.indexOf("E") || this.showX && this.showY && this.showZ), r.material._color = r.material._color || r.material.color.clone(), r.material._opacity = r.material._opacity || r.material.opacity, r.material.color.copy(r.material._color), r.material.opacity = r.material._opacity, this.enabled && this.axis && (r.name === this.axis || this.axis.split("").some(function (e) {
            return r.name === e;
          })) && (r.material.color.setHex(16776960), r.material.opacity = 1);
        } else r.visible = !1, "AXIS" === r.name ? (r.position.copy(this.worldPositionStart), r.visible = !!this.axis, "X" === this.axis && (Go.setFromEuler(na.set(0, 0, 0)), r.quaternion.copy(t).multiply(Go), Math.abs(ra.copy(ua).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "Y" === this.axis && (Go.setFromEuler(na.set(0, 0, Math.PI / 2)), r.quaternion.copy(t).multiply(Go), Math.abs(ra.copy(pa).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "Z" === this.axis && (Go.setFromEuler(na.set(0, Math.PI / 2, 0)), r.quaternion.copy(t).multiply(Go), Math.abs(ra.copy(ha).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "XYZE" === this.axis && (Go.setFromEuler(na.set(0, Math.PI / 2, 0)), ra.copy(this.rotationAxis), r.quaternion.setFromRotationMatrix(sa.lookAt(ia, ra, pa)), r.quaternion.multiply(Go), r.visible = this.dragging), "E" === this.axis && (r.visible = !1)) : "START" === r.name ? (r.position.copy(this.worldPositionStart), r.visible = this.dragging) : "END" === r.name ? (r.position.copy(this.worldPosition), r.visible = this.dragging) : "DELTA" === r.name ? (r.position.copy(this.worldPositionStart), r.quaternion.copy(this.worldQuaternionStart), zo.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), zo.applyQuaternion(this.worldQuaternionStart.clone().invert()), r.scale.copy(zo), r.visible = this.dragging) : (r.quaternion.copy(t), this.dragging ? r.position.copy(this.worldPositionStart) : r.position.copy(this.worldPosition), this.axis && (r.visible = -1 !== this.axis.search(r.name)));
      }

      super.updateMatrixWorld(e);
    }

  }

  class ga extends i.Kj0 {
    constructor() {
      super(new i._12(1e5, 1e5, 2, 2), new i.vBJ({
        visible: !1,
        wireframe: !0,
        side: i.ehD,
        transparent: !0,
        opacity: .1,
        toneMapped: !1
      })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
    }

    updateMatrixWorld(e) {
      let t = this.space;

      switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t = "local"), da.copy(ua).applyQuaternion("local" === t ? this.worldQuaternion : aa), fa.copy(pa).applyQuaternion("local" === t ? this.worldQuaternion : aa), _a.copy(ha).applyQuaternion("local" === t ? this.worldQuaternion : aa), ra.copy(fa), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              ra.copy(this.eye).cross(da), la.copy(da).cross(ra);
              break;

            case "Y":
              ra.copy(this.eye).cross(fa), la.copy(fa).cross(ra);
              break;

            case "Z":
              ra.copy(this.eye).cross(_a), la.copy(_a).cross(ra);
              break;

            case "XY":
              la.copy(_a);
              break;

            case "YZ":
              la.copy(da);
              break;

            case "XZ":
              ra.copy(_a), la.copy(fa);
              break;

            case "XYZ":
            case "E":
              la.set(0, 0, 0);
          }

          break;

        default:
          la.set(0, 0, 0);
      }

      0 === la.length() ? this.quaternion.copy(this.cameraQuaternion) : (ca.lookAt(zo.set(0, 0, 0), la, ra), this.quaternion.setFromRotationMatrix(ca)), super.updateMatrixWorld(e);
    }

  }

  const va = new i.ZzF(),
        ba = new i.Pa4();

  class xa extends i.L5s {
    constructor() {
      super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new i.a$l([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new i.a$l([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
    }

    applyMatrix4(e) {
      const t = this.attributes.instanceStart,
            n = this.attributes.instanceEnd;
      return void 0 !== t && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }

    setPositions(e) {
      let t;
      e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
      const n = new i.$TI(t, 6, 1);
      return this.setAttribute("instanceStart", new i.kB5(n, 3, 0)), this.setAttribute("instanceEnd", new i.kB5(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
    }

    setColors(e) {
      let t;
      e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
      const n = new i.$TI(t, 6, 1);
      return this.setAttribute("instanceColorStart", new i.kB5(n, 3, 0)), this.setAttribute("instanceColorEnd", new i.kB5(n, 3, 3)), this;
    }

    fromWireframeGeometry(e) {
      return this.setPositions(e.attributes.position.array), this;
    }

    fromEdgesGeometry(e) {
      return this.setPositions(e.attributes.position.array), this;
    }

    fromMesh(e) {
      return this.fromWireframeGeometry(new i.Uk6(e.geometry)), this;
    }

    fromLineSegments(e) {
      const t = e.geometry;
      return this.setPositions(t.attributes.position.array), this;
    }

    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new i.ZzF());
      const e = this.attributes.instanceStart,
            t = this.attributes.instanceEnd;
      void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), va.setFromBufferAttribute(t), this.boundingBox.union(va));
    }

    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new i.aLr()), null === this.boundingBox && this.computeBoundingBox();
      const e = this.attributes.instanceStart,
            t = this.attributes.instanceEnd;

      if (void 0 !== e && void 0 !== t) {
        const n = this.boundingSphere.center;
        this.boundingBox.getCenter(n);
        let r = 0;

        for (let i = 0, s = e.count; i < s; i++) ba.fromBufferAttribute(e, i), r = Math.max(r, n.distanceToSquared(ba)), ba.fromBufferAttribute(t, i), r = Math.max(r, n.distanceToSquared(ba));

        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }

    toJSON() {}

    applyMatrix(e) {
      return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
    }

  }

  class ya extends xa {
    constructor(e) {
      super(), this.isWireframeGeometry2 = !0, this.type = "WireframeGeometry2", this.fromWireframeGeometry(new i.Uk6(e));
    }

  }

  i.rBU.line = {
    worldUnits: {
      value: 1
    },
    linewidth: {
      value: 1
    },
    resolution: {
      value: new i.FM8(1, 1)
    },
    dashOffset: {
      value: 0
    },
    dashScale: {
      value: 1
    },
    dashSize: {
      value: 1
    },
    gapSize: {
      value: 1
    }
  }, i.Vj0.line = {
    uniforms: i.rDY.merge([i.rBU.common, i.rBU.fog, i.rBU.line]),
    vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
    fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"
  };

  class wa extends i.jyz {
    constructor(e) {
      super({
        type: "LineMaterial",
        uniforms: i.rDY.clone(i.Vj0.line.uniforms),
        vertexShader: i.Vj0.line.vertexShader,
        fragmentShader: i.Vj0.line.fragmentShader,
        clipping: !0
      }), this.isLineMaterial = !0, Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value;
          },
          set: function (e) {
            this.uniforms.diffuse.value = e;
          }
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines;
          },
          set: function (e) {
            !0 === e ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
          }
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value;
          },
          set: function (e) {
            this.uniforms.linewidth.value = e;
          }
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return Boolean("USE_DASH" in this.defines);
          },

          set(e) {
            Boolean(e) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), !0 === e ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
          }

        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value;
          },
          set: function (e) {
            this.uniforms.dashScale.value = e;
          }
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value;
          },
          set: function (e) {
            this.uniforms.dashSize.value = e;
          }
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value;
          },
          set: function (e) {
            this.uniforms.dashOffset.value = e;
          }
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value;
          },
          set: function (e) {
            this.uniforms.gapSize.value = e;
          }
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value;
          },
          set: function (e) {
            this.uniforms.opacity.value = e;
          }
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value;
          },
          set: function (e) {
            this.uniforms.resolution.value.copy(e);
          }
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
          },
          set: function (e) {
            Boolean(e) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), !0 === e ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
          }
        }
      }), this.setValues(e);
    }

  }

  const Sa = new i.Pa4(),
        Ma = new i.Pa4();

  class Ta extends i.Kj0 {
    constructor(e = new xa(), t = new wa({
      color: 16777215 * Math.random()
    })) {
      super(e, t), this.isWireframe = !0, this.type = "Wireframe";
    }

    computeLineDistances() {
      const e = this.geometry,
            t = e.attributes.instanceStart,
            n = e.attributes.instanceEnd,
            r = new Float32Array(2 * t.count);

      for (let e = 0, i = 0, s = t.count; e < s; e++, i += 2) Sa.fromBufferAttribute(t, e), Ma.fromBufferAttribute(n, e), r[i] = 0 === i ? 0 : r[i - 1], r[i + 1] = r[i] + Sa.distanceTo(Ma);

      const s = new i.$TI(r, 2, 1);
      return e.setAttribute("instanceDistanceStart", new i.kB5(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new i.kB5(s, 1, 1)), this;
    }

  }

  class Ea extends i.ZAu {
    constructor(e) {
      super(), this.assetType = "widget", this.modelObject = this, this._object = null, this.boundingScaleMultiplier = 1, this.position.set(0, 0, 0), this.visible = !1, this.renderOrder = 1, this.userData.bboxVisible = !1, this.userData.setDirty = e, this._updater = this._updater.bind(this);
    }

    _updater() {
      const e = this._object;

      if (e) {
        const t = new P().expandByObject(e, !1);
        t.getCenter(this.position);
        const n = t.getBoundingSphere(new i.aLr()).radius;
        this.scale.setScalar(n * this.boundingScaleMultiplier), this.setVisible(!0);
      } else this.setVisible(!1);
    }

    _initGeometry(e) {
      if (this._geometry) return;
      const t = new ya(e);
      this._geometry = t;
      const n = new wa({
        color: "#ff2222",
        transparent: !0,
        opacity: .9,
        linewidth: 5,
        resolution: new i.FM8(1024, 1024),
        dashed: !1,
        toneMapped: !1
      }),
            r = new Ta(t, n);
      r.computeLineDistances(), r.scale.set(1, 1, 1), r.visible = !0, this.add(r);
    }

    setVisible(e) {
      var t, n;
      e !== this.visible && (this.visible = e, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t));
    }

    attach(e) {
      return this.detach(), e ? (this._object = e, this._object.addEventListener("objectUpdate", this._updater), this._updater(), this) : this;
    }

    detach() {
      var e;
      return this._object ? (null === (e = this._object) || void 0 === e || e.removeEventListener("objectUpdate", this._updater), this._object = null, this._updater(), this) : this;
    }

    get object() {
      return this._object;
    }

  }

  class Aa extends Ea {
    constructor(e) {
      super(e), this.boundingScaleMultiplier = 1 / 1.7, this._initGeometry(new i.nvb(2, 2, 2, 1, 1, 1));
    }

    _updater() {
      super._updater();

      const e = this.object;
      e && (new P().expandByObject(e, !1).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(.1, 100), this.setVisible(!0));
    }

  }

  var Ca = function () {
    return Ca = Object.assign || function (e) {
      for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);

      return e;
    }, Ca.apply(this, arguments);
  };

  function Ra(e, t) {
    var n = {};

    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);

    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
      var i = 0;

      for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
    }

    return n;
  }

  Object.create, Object.create;

  var ka = function (e, t, n) {
    return Math.min(Math.max(n, e), t);
  };

  function Pa(e, t) {
    return e * Math.sqrt(1 - t * t);
  }

  var Da = ["duration", "bounce"],
      Oa = ["stiffness", "damping", "mass"];

  function La(e, t) {
    return t.some(function (t) {
      return void 0 !== e[t];
    });
  }

  function Ia(e) {
    var t = e.from,
        n = void 0 === t ? 0 : t,
        r = e.to,
        i = void 0 === r ? 1 : r,
        s = e.restSpeed,
        o = void 0 === s ? 2 : s,
        a = e.restDelta,
        l = Ra(e, ["from", "to", "restSpeed", "restDelta"]),
        c = {
      done: !1,
      value: n
    },
        u = function (e) {
      var t = Ca({
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1
      }, e);

      if (!La(e, Oa) && La(e, Da)) {
        var n = function (e) {
          var t,
              n,
              r = e.duration,
              i = void 0 === r ? 800 : r,
              s = e.bounce,
              o = void 0 === s ? .25 : s,
              a = e.velocity,
              l = void 0 === a ? 0 : a,
              c = e.mass,
              u = void 0 === c ? 1 : c,
              p = 1 - o;
          p = ka(.05, 1, p), i = ka(.01, 10, i / 1e3), p < 1 ? (t = function (e) {
            var t = e * p,
                n = t * i;
            return .001 - (t - l) / Pa(e, p) * Math.exp(-n);
          }, n = function (e) {
            var n = e * p * i,
                r = n * l + l,
                s = Math.pow(p, 2) * Math.pow(e, 2) * i,
                o = Math.exp(-n),
                a = Pa(Math.pow(e, 2), p);
            return (.001 - t(e) > 0 ? -1 : 1) * ((r - s) * o) / a;
          }) : (t = function (e) {
            return Math.exp(-e * i) * ((e - l) * i + 1) - .001;
          }, n = function (e) {
            return Math.exp(-e * i) * (i * i * (l - e));
          });

          var h = function (e, t, n) {
            for (var r = n, i = 1; i < 12; i++) r -= e(r) / t(r);

            return r;
          }(t, n, 5 / i);

          if (i *= 1e3, isNaN(h)) return {
            stiffness: 100,
            damping: 10,
            duration: i
          };
          var d = Math.pow(h, 2) * u;
          return {
            stiffness: d,
            damping: 2 * p * Math.sqrt(u * d),
            duration: i
          };
        }(e);

        (t = Ca(Ca(Ca({}, t), n), {
          velocity: 0,
          mass: 1
        })).isResolvedFromDuration = !0;
      }

      return t;
    }(l),
        p = u.stiffness,
        h = u.damping,
        d = u.mass,
        f = u.velocity,
        _ = u.duration,
        m = u.isResolvedFromDuration,
        g = Fa,
        v = Fa;

    function b() {
      var e = f ? -f / 1e3 : 0,
          t = i - n,
          r = h / (2 * Math.sqrt(p * d)),
          s = Math.sqrt(p / d) / 1e3;

      if (null != a || (a = Math.abs(i - n) <= 1 ? .01 : .4), r < 1) {
        var o = Pa(s, r);
        g = function (n) {
          var a = Math.exp(-r * s * n);
          return i - a * ((e + r * s * t) / o * Math.sin(o * n) + t * Math.cos(o * n));
        }, v = function (n) {
          var i = Math.exp(-r * s * n);
          return r * s * i * (Math.sin(o * n) * (e + r * s * t) / o + t * Math.cos(o * n)) - i * (Math.cos(o * n) * (e + r * s * t) - o * t * Math.sin(o * n));
        };
      } else if (1 === r) g = function (n) {
        return i - Math.exp(-s * n) * (t + (e + s * t) * n);
      };else {
        var l = s * Math.sqrt(r * r - 1);

        g = function (n) {
          var o = Math.exp(-r * s * n),
              a = Math.min(l * n, 300);
          return i - o * ((e + r * s * t) * Math.sinh(a) + l * t * Math.cosh(a)) / l;
        };
      }
    }

    return b(), {
      next: function (e) {
        var t = g(e);
        if (m) c.done = e >= _;else {
          var n = 1e3 * v(e),
              r = Math.abs(n) <= o,
              s = Math.abs(i - t) <= a;
          c.done = r && s;
        }
        return c.value = c.done ? i : t, c;
      },
      flipTarget: function () {
        var e;
        f = -f, n = (e = [i, n])[0], i = e[1], b();
      }
    };
  }

  Ia.needsInterpolation = function (e, t) {
    return "string" == typeof e || "string" == typeof t;
  };

  var Fa = function (e) {
    return 0;
  },
      Na = function (e, t, n) {
    var r = t - e;
    return 0 === r ? 1 : (n - e) / r;
  },
      Ua = function (e, t, n) {
    return -n * e + n * t + e;
  },
      Ba = function (e, t) {
    return function (n) {
      return Math.max(Math.min(n, t), e);
    };
  },
      ja = function (e) {
    return e % 1 ? Number(e.toFixed(5)) : e;
  },
      za = /(-)?([\d]*\.?[\d])+/g,
      Va = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi,
      Ga = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;

  function Ha(e) {
    return "string" == typeof e;
  }

  var Wa = {
    test: function (e) {
      return "number" == typeof e;
    },
    parse: parseFloat,
    transform: function (e) {
      return e;
    }
  },
      Ka = Ca(Ca({}, Wa), {
    transform: Ba(0, 1)
  }),
      Xa = (Ca(Ca({}, Wa), {
    default: 1
  }), function (e, t) {
    return function (n) {
      return Boolean(Ha(n) && Ga.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t));
    };
  }),
      qa = function (e, t, n) {
    return function (r) {
      var i;
      if (!Ha(r)) return r;
      var s = r.match(za),
          o = s[0],
          a = s[1],
          l = s[2],
          c = s[3];
      return (i = {})[e] = parseFloat(o), i[t] = parseFloat(a), i[n] = parseFloat(l), i.alpha = void 0 !== c ? parseFloat(c) : 1, i;
    };
  },
      Ya = Ba(0, 255),
      Za = Ca(Ca({}, Wa), {
    transform: function (e) {
      return Math.round(Ya(e));
    }
  }),
      Ja = {
    test: Xa("rgb", "red"),
    parse: qa("red", "green", "blue"),
    transform: function (e) {
      var t = e.red,
          n = e.green,
          r = e.blue,
          i = e.alpha,
          s = void 0 === i ? 1 : i;
      return "rgba(" + Za.transform(t) + ", " + Za.transform(n) + ", " + Za.transform(r) + ", " + ja(Ka.transform(s)) + ")";
    }
  },
      $a = {
    test: Xa("#"),
    parse: function (e) {
      var t = "",
          n = "",
          r = "",
          i = "";
      return e.length > 5 ? (t = e.substr(1, 2), n = e.substr(3, 2), r = e.substr(5, 2), i = e.substr(7, 2)) : (t = e.substr(1, 1), n = e.substr(2, 1), r = e.substr(3, 1), i = e.substr(4, 1), t += t, n += n, r += r, i += i), {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(r, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
      };
    },
    transform: Ja.transform
  },
      Qa = function (e) {
    return {
      test: function (t) {
        return Ha(t) && t.endsWith(e) && 1 === t.split(" ").length;
      },
      parse: parseFloat,
      transform: function (t) {
        return "" + t + e;
      }
    };
  },
      el = (Qa("deg"), Qa("%")),
      tl = (Qa("px"), Qa("vh"), Qa("vw"), Ca(Ca({}, el), {
    parse: function (e) {
      return el.parse(e) / 100;
    },
    transform: function (e) {
      return el.transform(100 * e);
    }
  }), {
    test: Xa("hsl", "hue"),
    parse: qa("hue", "saturation", "lightness"),
    transform: function (e) {
      var t = e.hue,
          n = e.saturation,
          r = e.lightness,
          i = e.alpha,
          s = void 0 === i ? 1 : i;
      return "hsla(" + Math.round(t) + ", " + el.transform(ja(n)) + ", " + el.transform(ja(r)) + ", " + ja(Ka.transform(s)) + ")";
    }
  }),
      nl = function (e, t, n) {
    var r = e * e,
        i = t * t;
    return Math.sqrt(Math.max(0, n * (i - r) + r));
  },
      rl = [$a, Ja, tl],
      il = function (e) {
    return rl.find(function (t) {
      return t.test(e);
    });
  },
      sl = function (e) {
    return "'" + e + "' is not an animatable color. Use the equivalent color code instead.";
  },
      ol = function (e, t) {
    var n = il(e),
        r = il(t);
    sl(e), sl(t), n.transform, r.transform;
    var i = n.parse(e),
        s = r.parse(t),
        o = Ca({}, i),
        a = n === tl ? Ua : nl;
    return function (e) {
      for (var t in o) "alpha" !== t && (o[t] = a(i[t], s[t], e));

      return o.alpha = Ua(i.alpha, s.alpha, e), n.transform(o);
    };
  },
      al = function (e) {
    return Ja.test(e) || $a.test(e) || tl.test(e);
  },
      ll = function (e) {
    return Ja.test(e) ? Ja.parse(e) : tl.test(e) ? tl.parse(e) : $a.parse(e);
  },
      cl = function (e) {
    return Ha(e) ? e : e.hasOwnProperty("red") ? Ja.transform(e) : tl.transform(e);
  },
      ul = "${c}",
      pl = "${n}";

  function hl(e) {
    var t = [],
        n = 0,
        r = e.match(Va);
    r && (n = r.length, e = e.replace(Va, ul), t.push.apply(t, r.map(ll)));
    var i = e.match(za);
    return i && (e = e.replace(za, pl), t.push.apply(t, i.map(Wa.parse))), {
      values: t,
      numColors: n,
      tokenised: e
    };
  }

  function dl(e) {
    return hl(e).values;
  }

  function fl(e) {
    var t = hl(e),
        n = t.values,
        r = t.numColors,
        i = t.tokenised,
        s = n.length;
    return function (e) {
      for (var t = i, n = 0; n < s; n++) t = t.replace(n < r ? ul : pl, n < r ? cl(e[n]) : ja(e[n]));

      return t;
    };
  }

  var _l = function (e) {
    return "number" == typeof e ? 0 : e;
  },
      ml = {
    test: function (e) {
      var t, n, r, i;
      return isNaN(e) && Ha(e) && (null !== (n = null === (t = e.match(za)) || void 0 === t ? void 0 : t.length) && void 0 !== n ? n : 0) + (null !== (i = null === (r = e.match(Va)) || void 0 === r ? void 0 : r.length) && void 0 !== i ? i : 0) > 0;
    },
    parse: dl,
    createTransformer: fl,
    getAnimatableNone: function (e) {
      var t = dl(e);
      return fl(e)(t.map(_l));
    }
  },
      gl = function (e, t) {
    return function (n) {
      return t(e(n));
    };
  },
      vl = function () {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];

    return e.reduce(gl);
  };

  function bl(e, t) {
    return function (e) {
      return "number" == typeof e;
    }(e) ? function (n) {
      return Ua(e, t, n);
    } : al(e) ? ol(e, t) : Sl(e, t);
  }

  var xl = function (e, t) {
    var n = function (e, t) {
      for (var n = 0, r = t.length, i = e.length; n < r; n++, i++) e[i] = t[n];

      return e;
    }([], e),
        r = n.length,
        i = e.map(function (e, n) {
      return bl(e, t[n]);
    });

    return function (e) {
      for (var t = 0; t < r; t++) n[t] = i[t](e);

      return n;
    };
  },
      yl = function (e, t) {
    var n = Ca(Ca({}, e), t),
        r = {};

    for (var i in n) void 0 !== e[i] && void 0 !== t[i] && (r[i] = bl(e[i], t[i]));

    return function (e) {
      for (var t in r) n[t] = r[t](e);

      return n;
    };
  };

  function wl(e) {
    for (var t = ml.parse(e), n = t.length, r = 0, i = 0, s = 0, o = 0; o < n; o++) r || "number" == typeof t[o] ? r++ : void 0 !== t[o].hue ? s++ : i++;

    return {
      parsed: t,
      numNumbers: r,
      numRGB: i,
      numHSL: s
    };
  }

  var Sl = function (e, t) {
    var n = ml.createTransformer(t),
        r = wl(e),
        i = wl(t);
    return r.numHSL === i.numHSL && r.numRGB === i.numRGB && (r.numNumbers, i.numNumbers), vl(xl(r.parsed, i.parsed), n);
  },
      Ml = function (e, t) {
    return function (n) {
      return Ua(e, t, n);
    };
  };

  function Tl(e, t, n) {
    var r = void 0 === n ? {} : n,
        i = r.clamp,
        s = void 0 === i || i,
        o = r.ease,
        a = r.mixer,
        l = e.length;
    t.length, !o || !Array.isArray(o) || o.length, e[0] > e[l - 1] && (e = [].concat(e), t = [].concat(t), e.reverse(), t.reverse());

    var c = function (e, t, n) {
      for (var r = [], i = n || function (e) {
        return "number" == typeof e ? Ml : "string" == typeof e ? al(e) ? ol : Sl : Array.isArray(e) ? xl : "object" == typeof e ? yl : void 0;
      }(e[0]), s = e.length - 1, o = 0; o < s; o++) {
        var a = i(e[o], e[o + 1]);

        if (t) {
          var l = Array.isArray(t) ? t[o] : t;
          a = vl(l, a);
        }

        r.push(a);
      }

      return r;
    }(t, o, a),
        u = 2 === l ? function (e, t) {
      var n = e[0],
          r = e[1],
          i = t[0];
      return function (e) {
        return i(Na(n, r, e));
      };
    }(e, c) : function (e, t) {
      var n = e.length,
          r = n - 1;
      return function (i) {
        var s = 0,
            o = !1;

        if (i <= e[0] ? o = !0 : i >= e[r] && (s = r - 1, o = !0), !o) {
          for (var a = 1; a < n && !(e[a] > i || a === r); a++);

          s = a - 1;
        }

        var l = Na(e[s], e[s + 1], i);
        return t[s](l);
      };
    }(e, c);

    return s ? function (t) {
      return u(ka(e[0], e[l - 1], t));
    } : u;
  }

  var El,
      Al = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
      Cl = function (e) {
    return function (t) {
      return t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2;
    };
  },
      Rl = function (e) {
    return function (t) {
      return t * t * ((e + 1) * t - e);
    };
  },
      kl = (2, function (e) {
    return Math.pow(e, 2);
  }),
      Pl = Al(kl),
      Dl = Cl(kl),
      Ol = function (e) {
    return 1 - Math.sin(Math.acos(e));
  },
      Ll = Al(Ol),
      Il = Cl(Ll),
      Fl = Rl(1.525),
      Nl = Al(Fl),
      Ul = Cl(Fl),
      Bl = (El = Rl(1.525), function (e) {
    return (e *= 2) < 1 ? .5 * El(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)));
  }),
      jl = function (e) {
    if (1 === e || 0 === e) return e;
    var t = e * e;
    return e < .36363636363636365 ? 7.5625 * t : e < .7272727272727273 ? 9.075 * t - 9.9 * e + 3.4 : e < .9 ? 12.066481994459833 * t - 19.63545706371191 * e + 8.898060941828255 : 10.8 * e * e - 20.52 * e + 10.72;
  },
      zl = Al(jl);

  function Vl(e, t) {
    return e.map(function () {
      return t || Dl;
    }).splice(0, e.length - 1);
  }

  function Gl(e) {
    var t = e.from,
        n = void 0 === t ? 0 : t,
        r = e.to,
        i = void 0 === r ? 1 : r,
        s = e.ease,
        o = e.offset,
        a = e.duration,
        l = void 0 === a ? 300 : a,
        c = {
      done: !1,
      value: n
    },
        u = Array.isArray(i) ? i : [n, i],
        p = function (e, t) {
      return e.map(function (e) {
        return e * t;
      });
    }(o && o.length === u.length ? o : function (e) {
      var t = e.length;
      return e.map(function (e, n) {
        return 0 !== n ? n / (t - 1) : 0;
      });
    }(u), l);

    function h() {
      return Tl(p, u, {
        ease: Array.isArray(s) ? s : Vl(u, s)
      });
    }

    var d = h();
    return {
      next: function (e) {
        return c.value = d(e), c.done = e >= l, c;
      },
      flipTarget: function () {
        u.reverse(), d = h();
      }
    };
  }

  var Hl = {
    keyframes: Gl,
    spring: Ia,
    decay: function (e) {
      var t = e.velocity,
          n = void 0 === t ? 0 : t,
          r = e.from,
          i = void 0 === r ? 0 : r,
          s = e.power,
          o = void 0 === s ? .8 : s,
          a = e.timeConstant,
          l = void 0 === a ? 350 : a,
          c = e.restDelta,
          u = void 0 === c ? .5 : c,
          p = e.modifyTarget,
          h = {
        done: !1,
        value: i
      },
          d = o * n,
          f = i + d,
          _ = void 0 === p ? f : p(f);

      return _ !== f && (d = _ - i), {
        next: function (e) {
          var t = -d * Math.exp(-e / l);
          return h.done = !(t > u || t < -u), h.value = h.done ? _ : _ + t, h;
        },
        flipTarget: function () {}
      };
    }
  },
      Wl = 1 / 60 * 1e3,
      Kl = "undefined" != typeof performance ? function () {
    return performance.now();
  } : function () {
    return Date.now();
  },
      Xl = "undefined" != typeof window ? function (e) {
    return window.requestAnimationFrame(e);
  } : function (e) {
    return setTimeout(function () {
      return e(Kl());
    }, Wl);
  },
      ql = !0,
      Yl = !1,
      Zl = !1,
      Jl = {
    delta: 0,
    timestamp: 0
  },
      $l = ["read", "update", "preRender", "render", "postRender"],
      Ql = $l.reduce(function (e, t) {
    return e[t] = function (e) {
      var t = [],
          n = [],
          r = 0,
          i = !1,
          s = new WeakSet(),
          o = {
        schedule: function (e, o, a) {
          void 0 === o && (o = !1), void 0 === a && (a = !1);
          var l = a && i,
              c = l ? t : n;
          return o && s.add(e), -1 === c.indexOf(e) && (c.push(e), l && i && (r = t.length)), e;
        },
        cancel: function (e) {
          var t = n.indexOf(e);
          -1 !== t && n.splice(t, 1), s.delete(e);
        },
        process: function (a) {
          var l;
          if (i = !0, t = (l = [n, t])[0], (n = l[1]).length = 0, r = t.length) for (var c = 0; c < r; c++) {
            var u = t[c];
            u(a), s.has(u) && (o.schedule(u), e());
          }
          i = !1;
        }
      };
      return o;
    }(function () {
      return Yl = !0;
    }), e;
  }, {}),
      ec = $l.reduce(function (e, t) {
    var n = Ql[t];
    return e[t] = function (e, t, r) {
      return void 0 === t && (t = !1), void 0 === r && (r = !1), Yl || ic(), n.schedule(e, t, r);
    }, e;
  }, {}),
      tc = $l.reduce(function (e, t) {
    return e[t] = Ql[t].cancel, e;
  }, {}),
      nc = function (e) {
    return Ql[e].process(Jl);
  },
      rc = function (e) {
    Yl = !1, Jl.delta = ql ? Wl : Math.max(Math.min(e - Jl.timestamp, 40), 1), Jl.timestamp = e, Zl = !0, $l.forEach(nc), Zl = !1, Yl && (ql = !1, Xl(rc));
  },
      ic = function () {
    Yl = !0, ql = !0, Zl || Xl(rc);
  },
      sc = ec;

  function oc(e, t, n) {
    return void 0 === n && (n = 0), e - t - n;
  }

  var ac = function (e) {
    var t = function (t) {
      var n = t.delta;
      return e(n);
    };

    return {
      start: function () {
        return sc.update(t, !0);
      },
      stop: function () {
        return tc.update(t);
      }
    };
  };

  function lc(e) {
    var t,
        n,
        r,
        i,
        s,
        o = e.from,
        a = e.autoplay,
        l = void 0 === a || a,
        c = e.driver,
        u = void 0 === c ? ac : c,
        p = e.elapsed,
        h = void 0 === p ? 0 : p,
        d = e.repeat,
        f = void 0 === d ? 0 : d,
        _ = e.repeatType,
        m = void 0 === _ ? "loop" : _,
        g = e.repeatDelay,
        v = void 0 === g ? 0 : g,
        b = e.onPlay,
        x = e.onStop,
        y = e.onComplete,
        w = e.onRepeat,
        S = e.onUpdate,
        M = Ra(e, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]),
        T = M.to,
        E = 0,
        A = M.duration,
        C = !1,
        R = !0,
        k = function (e) {
      if (Array.isArray(e.to)) return Gl;
      if (Hl[e.type]) return Hl[e.type];
      var t = new Set(Object.keys(e));
      return t.has("ease") || t.has("duration") && !t.has("dampingRatio") ? Gl : t.has("dampingRatio") || t.has("stiffness") || t.has("mass") || t.has("damping") || t.has("restSpeed") || t.has("restDelta") ? Ia : Gl;
    }(M);

    (null === (n = (t = k).needsInterpolation) || void 0 === n ? void 0 : n.call(t, o, T)) && (s = Tl([0, 100], [o, T], {
      clamp: !1
    }), o = 0, T = 100);
    var P = k(Ca(Ca({}, M), {
      from: o,
      to: T
    }));
    return l && (null == b || b(), (r = u(function (e) {
      if (R || (e = -e), h += e, !C) {
        var t = P.next(Math.max(0, h));
        i = t.value, s && (i = s(i)), C = R ? t.done : h <= 0;
      }

      null == S || S(i), C && (0 === E && (null != A || (A = h)), E < f ? function (e, t, n, r) {
        return r ? e >= t + n : e <= -n;
      }(h, A, v, R) && (E++, "reverse" === m ? h = function (e, t, n, r) {
        return void 0 === n && (n = 0), void 0 === r && (r = !0), r ? oc(t + -e, t, n) : t - (e - t) + n;
      }(h, A, v, R = E % 2 == 0) : (h = oc(h, A, v), "mirror" === m && P.flipTarget()), C = !1, w && w()) : (r.stop(), y && y()));
    })).start()), {
      stop: function () {
        null == x || x(), r.stop();
      }
    };
  }

  const cc = {
    linear: function (e) {
      return e;
    },
    easeIn: kl,
    easeOut: Pl,
    easeInOut: Dl,
    circIn: Ol,
    circOut: Ll,
    circInOut: Il,
    backIn: Fl,
    backOut: Nl,
    backInOut: Ul,
    anticipate: Bl,
    bounceOut: jl,
    bounceIn: zl,
    bounceInOut: function (e) {
      return e < .5 ? .5 * (1 - jl(1 - 2 * e)) : .5 * jl(2 * e - 1) + .5;
    },
    easeInOutSine: function (e) {
      return -(Math.cos(Math.PI * e) - 1) / 2;
    }
  };

  async function uc(e) {
    return new Promise(t => setTimeout(t, Math.max(0, e)));
  }

  function pc(e, t, n) {
    const r = e[t],
          i = () => {
      var t;
      "function" == typeof (null === (t = null == e ? void 0 : e.userData) || void 0 === t ? void 0 : t.setDirty) && e.userData.setDirty(), null == n || n();
    };

    return r.isVector3 || r.isVector2 || r.isVector4 ? e => {
      r.copy(e), i();
    } : n => {
      e[t] = n, i();
    };
  }

  function hc(e) {
    return "boolean" != typeof e;
  }

  async function dc(e, t, n) {
    t in e || console.error("invalid key", t, e);

    const r = pc(e, t),
          i = e[t],
          s = e => {
      var t;
      r(e), null === (t = n.onUpdate) || void 0 === t || t.call(n, e);
    };

    if (hc(i)) return "function" == typeof n.to && (n = { ...n,
      to: n.to(i, e)
    }), fc({ ...n,
      from: i,
      onUpdate: s
    });
    {
      const {
        duration: e
      } = n;
      return uc(null != e ? e : 0).then(() => s(n.to));
    }
  }

  async function fc(e) {
    return new Promise((t, n) => {
      lc({
        onComplete: () => {
          var n;
          null === (n = e.onComplete) || void 0 === n || n.call(e), t();
        },
        onStop: () => {
          var n;
          null === (n = e.onStop) || void 0 === n || n.call(e), t();
        },
        ...e
      });
    });
  }

  class _c extends Gs {
    constructor() {
      super(), this.passId = "frameFade", this._fadeTime = 0, this._fadeTimeState = 0, this._toSaveFrame = !1, this._beforeFilters = ["progressive", "taa"], this._afterFilters = ["render"], this._requiredFilters = ["render", "progressive"], this.dependencies = [po], this.fadeOnActiveCameraChange = !0, this.fadeOnMaterialUpdate = !0, this.fadeOnSceneUpdate = !0, this.pointerEnabled = !0, this._fadeCam = e => !1 !== e.frameFade && this.fadeOnActiveCameraChange && this.startTransition(1e3), this._fadeMat = e => {
        !1 !== e.frameFade && this.fadeOnMaterialUpdate && this.startTransition(200);
      }, this._fadeScene = e => {
        !1 !== e.frameFade && this.fadeOnSceneUpdate && this.startTransition(500);
      }, this._onPointerMove = e => {
        var t;
        const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas;
        if (!n) return void (this.pointerEnabled = !1);
        if (!e.buttons || e.target !== n) return void (this.pointerEnabled = !0);
        const r = n.getBoundingClientRect(),
              i = (e.clientX - r.left) / r.width,
              s = (e.clientY - r.top) / r.height;
        this.pointerEnabled = i < 0 || i > 1 || s < 0 || s > 1;
      }, this._disabledBy = [], this.startTransition = this.startTransition.bind(this), this.stopTransition = this.stopTransition.bind(this), this._fadeCam = this._fadeCam.bind(this), this._fadeMat = this._fadeMat.bind(this);
    }

    async startTransition(e) {
      this._viewer && this._pass && !this.isDisabled() && (this._target || (this._target = this._viewer.renderer.getTempTarget({
        sizeMultiplier: 1,
        minFilter: i.wem,
        magFilter: i.wem,
        encoding: this._viewer.renderer.composerTarget.texture.encoding
      })), this._fadeTimeState = Math.max(e, this._fadeTimeState), this._fadeTime = this._fadeTimeState, this._toSaveFrame = !0, this.setDirty(), await uc(e));
    }

    stopTransition() {
      this._fadeTimeState = 0;
    }

    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("activeCameraChange", this._fadeCam), e.scene.addEventListener("activeCameraUpdate", this.stopTransition), e.scene.addEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.addEventListener("sceneUpdate", this._fadeScene), window.addEventListener("pointermove", this._onPointerMove);
    }

    async onRemove(e) {
      return e.scene.removeEventListener("activeCameraChange", this._fadeCam), e.scene.removeEventListener("activeCameraUpdate", this.stopTransition), e.scene.removeEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.removeEventListener("sceneUpdate", this._fadeScene), window.removeEventListener("pointermove", this._onPointerMove), super.onRemove(e);
    }

    passCtor(e) {
      const t = this,
            n = e.getPlugin(po),
            r = new class extends ao {
        constructor() {
          super(...arguments), this._lastTime = 0, this.uiConfig = $e("Frame Fade", this);
        }

        render(r, i, s, o, a) {
          this.needsSwap = !1;
          const l = t._target;
          if (!l || !t.pointerEnabled || !this.enabled || !t.dirty || t._fadeTimeState < .001) return;
          t._toSaveFrame && n.lastFrame && (e.renderer.blit(n.lastFrame.texture, l), this._lastTime = 0, t._toSaveFrame = !1), this.blendTexture = null == l ? void 0 : l.texture;
          const c = t._fadeTimeState / t._fadeTime;
          this.weights2.setScalar(c), this.weights2.w = 1, this.weights1.setScalar(1 - c), this.weights1.w = 1, super.render(r, i, s, o, a), this.needsSwap = !0;
          const u = At();
          this._lastTime < 10 && (this._lastTime = u - 10);
          const p = u - this._lastTime;
          this._lastTime = u, t._fadeTimeState -= p;
        }

      }();
      return r.enabled = !0, r;
    }

    setDirty() {
      var e;
      this.enabled && (null === (e = this._viewer) || void 0 === e || e.setDirty());
    }

    get dirty() {
      return this.enabled && this._fadeTimeState > 0;
    }

    set dirty(e) {
      console.warn("FrameFadePlugin.dirty is readonly");
    }

    _update(e) {
      return !!super._update(e) && (this.isDisabled() && this.stopTransition(), this._fadeTimeState < .001 && (this._toSaveFrame = !1, this._target && this._viewer && (this._viewer.renderer.releaseTempTarget(this._target), this._target = void 0)), !0);
    }

    get uiConfig() {
      var e, t;
      return null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig;
    }

    disable(e) {
      this._disabledBy.includes(e) || this._disabledBy.push(e);
    }

    enable(e) {
      const t = this._disabledBy.indexOf(e);

      t >= 0 && this._disabledBy.splice(t, 1);
    }

    isDisabled() {
      return !this.pointerEnabled || this._disabledBy.length > 0 || !this.enabled;
    }

  }

  _c.PluginType = "FrameFade";
  var mc = i.M8C.degToRad;

  class gc extends zs {
    constructor(e = Aa, t = !1, n = !0) {
      super(), this.enabled = !0, this.autoFocus = !1, e && (this._widget = new e(() => {
        this.setDirty();
      })), this._controls = t, this._pickUi = n;
    }

    get picker() {
      return this._picker;
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    getSelectedObject() {
      var e;
      if (this.enabled) return (null === (e = this._picker) || void 0 === e ? void 0 : e.selectedObject) || void 0;
    }

    setSelectedObject(e, t = !1) {
      if (this.enabled && this._picker) {
        const n = this.autoFocus;
        n && !t && (this.autoFocus = !1), this._picker.selectedObject = e || null, this.autoFocus = n;
      }
    }

    async onAdded(e) {
      await super.onAdded(e), this._picker = new Bo(e.scene, e.canvas, void 0, e => {
        var t, n;
        if (!e.material) return !1;
        let r = e,
            i = !1;

        for (; r;) {
          if (!r.visible) return !1;
          if ("model" === (null !== (t = r.userData.iModel) && void 0 !== t ? t : r).assetType && (i = !0), "widget" === (null !== (n = r.userData.iModel) && void 0 !== n ? n : r).assetType) return !1;
          if (!1 === r.userData.userSelectable) return !1;
          if (!1 === r.userData.bboxVisible) return !1;
          r = r.parent;
        }

        return i;
      }), this._widget && e.scene.addWidget(this._widget), this._transformControls = new vc(e), this._transformControls.enabled = this._controls, this._picker.addEventListener("selectedObjectChanged", t => {
        var n, r, s, o, a;
        this.dispatchEvent(t);
        const l = null === (n = this._picker) || void 0 === n ? void 0 : n.selectedObject;

        if (this._pickUi) {
          const e = null === (r = l) || void 0 === r ? void 0 : r.uiConfig,
                t = this.uiConfig;
          t.children = e ? [e] : [], null === (s = t.uiRefresh) || void 0 === s || s.call(t);
        }

        const c = this._widget;
        c && (l ? c.attach(l) : c.detach());
        const u = this._transformControls;
        u && (null === (o = this._viewer) || void 0 === o ? void 0 : o.scene.activeCamera.controls) && (l && u.enabled ? u.attach(l) : u.detach()), this.autoFocus && l && (null === (a = this._viewer) || void 0 === a || a.resetCamera({
          rootObject: l,
          centerOffset: new i.Pa4(4, 4, 4)
        })), e.setDirty();
      }), this._picker.addEventListener("hoverObjectChanged", this.dispatchEvent), this._picker.addEventListener("hitObject", this.dispatchEvent), e.scene.addEventListener("select", e => {
        e.value ? this.setSelectedObject(e.value, !0) : console.warn("e.value must be set for picking");
      }), e.scene.addEventListener("addSceneObject", e => {
        var t, n;
        const r = e.object,
              i = this.getSelectedObject();

        if (i && "material" === (null == r ? void 0 : r.assetType) && "function" == typeof (null === (t = i.modelObject) || void 0 === t ? void 0 : t.userData.setMaterial) && confirm("Apply material to selected object?")) {
          const e = i.material;
          if (Array.isArray(e)) console.warn("Dropping on material array not yet fully supported."), i.modelObject.userData.setMaterial(r);else {
            let t = Array.from(null !== (n = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== n ? n : []);
            (t.length > 1 ? !confirm("Apply to all objects using this material?") : t.length < 1) && (t = [i.modelObject]);

            for (const e of t) e && e.userData.setMaterial(r);
          }
        }
      });
    }

    get uiConfig() {
      return this._pickUi ? this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Picker",
        expanded: !0,
        children: [{}]
      } : {};
    }

    get transformControls() {
      return this._transformControls;
    }

    get widget() {
      return this._widget;
    }

  }

  gc.PluginType = "Picking";

  class vc extends Yo {
    constructor(e) {
      super(e.scene.activeCamera.cameraObject, e.canvas), this.modelObject = this, this.assetType = "widget", this._activeCameraChange = this._activeCameraChange.bind(this), this._scene = e.scene, this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.visible = !1, this.userData.bboxVisible = !1, this.addEventListener("objectChange", () => {
        var e;
        null === (e = null == this ? void 0 : this.object) || void 0 === e || e.dispatchEvent({
          type: "objectUpdate",
          fadeFrame: !1
        });
      }), this.addEventListener("dragging-changed", t => {
        const n = null == e ? void 0 : e.getPlugin(_c);
        n && (n.enabled = !t.value), this._scene.activeCamera.interactionsEnabled = !t.value;
      }), this._keyDownListener = this._keyDownListener.bind(this), window.addEventListener("keydown", this._keyDownListener), window.addEventListener("keyup", this._keyUpListener), this._scene.addWidget(this);
    }

    _keyDownListener(e) {
      if (this.enabled && this.object) {
        switch (e.keyCode) {
          case 81:
            this.setSpace("local" === this.space ? "world" : "local");
            break;

          case 16:
            this.setTranslationSnap(100), this.setRotationSnap(mc(15)), this.setScaleSnap(.25);
            break;

          case 87:
            this.setMode("translate");
            break;

          case 69:
            this.setMode("rotate");
            break;

          case 82:
            this.setMode("scale");
            break;

          case 187:
          case 107:
            this.setSize(this.size + .1);
            break;

          case 189:
          case 109:
            this.setSize(Math.max(this.size - .1, .1));
            break;

          case 88:
            this.showX = !this.showX;
            break;

          case 89:
            this.showY = !this.showY;
            break;

          case 90:
            this.showZ = !this.showZ;
            break;

          case 32:
            this.enabled = !this.enabled;
            break;

          default:
            return;
        }

        this._scene.setDirty({
          sceneUpdate: !0,
          frameFade: !0
        });
      }
    }

    _keyUpListener(e) {
      this.enabled && (16 === e.keyCode && (this.setTranslationSnap(null), this.setRotationSnap(null), this.setScaleSnap(null)), this.object && e.keyCode);
    }

    _activeCameraChange() {
      this.camera = this._scene.activeCamera.cameraObject;
    }

    dispose() {
      window.removeEventListener("keydown", this._keyDownListener), window.removeEventListener("keyup", this._keyUpListener), this._scene.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene.modelObject.remove(this), super.dispose();
    }

  }

  var bc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class xc extends zs {
    constructor() {
      super(), this.offsetCache = {}, this.enabled = !0, this.envMap = null, this.forceSceneEnvMap = !1, this.getEnvMap = () => {
        var e;
        return !this.forceSceneEnvMap && this.envMap ? this.envMap : (null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || null;
      }, this._modelProcessor = {
        forAssetType: "model",
        processAsync: async (e, t) => {
          const n = [];
          return e.modelObject.traverse(e => {
            var t, r, i, s;
            const o = null === (r = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === r ? void 0 : r[xc.DIAMOND_GLTF_EXTENSION];
            o && e.geometry && (this.prepareDiamondMesh(e, o), delete e.userData.gltfExtensions[xc.DIAMOND_GLTF_EXTENSION]), e.material && !n.includes(e.material) && (null === (s = null === (i = e.material.userData) || void 0 === i ? void 0 : i.gltfExtensions) || void 0 === s ? void 0 : s[xc.DIAMOND_GLTF_EXTENSION]) && (e.material.materialObject || console.warn("material not processed", e.material), n.push(e.material));
          }), n.forEach(e => {
            const t = e.userData.gltfExtensions[xc.DIAMOND_GLTF_EXTENSION];
            t && this._convertToDiamondMaterial(e, t);
          }), e;
        }
      }, this.uiConfig = {
        type: "folder",
        label: "Diamonds",
        children: [{
          type: "toggle",
          label: "Use Scene Environment",
          property: [this, "forceSceneEnvironment"],
          limitedUi: !0
        }, {
          type: "image",
          label: "Environment",
          hidden: () => this.forceSceneEnvMap,
          property: [this, "envMap"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 2 * Math.PI],
          hidden: () => this.forceSceneEnvMap,
          label: "Env Rotation",
          property: [this, "envMapRotation"],
          limitedUi: !0
        }, {
          type: "button",
          label: "Make Diamond",
          hidden: () => {
            var e, t, n, r;
            return (null === (r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(gc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material) || void 0 === r ? void 0 : r.typeSlug) !== Ht.TypeSlug;
          },
          value: () => {
            var e, t;
            const n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(gc)) || void 0 === t ? void 0 : t.getSelectedObject();
            if (!(null == n ? void 0 : n.material)) return;
            const r = prompt("Cache key?", "");
            let i = parseInt(prompt("Cache size?", "512") || "512");
            isFinite(i) || (i = 512), i < 64 && (i = 64), this.makeDiamond(n.material, {
              cacheKey: r || void 0,
              normalMapRes: i
            }, {}), this.refreshUi();
          },
          limitedUi: !0
        }, {
          type: "button",
          label: "Make Standard",
          hidden: () => {
            var e, t, n, r;
            return (null === (r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(gc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material) || void 0 === r ? void 0 : r.typeSlug) !== Uo.TypeSlug;
          },
          value: () => {
            var e, t, n, r, i, s;
            const o = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(gc)) || void 0 === t ? void 0 : t.getSelectedObject(),
                  a = null == o ? void 0 : o.material;
            if (!a) return;
            const l = a.userData._baseMaterial,
                  c = (null === (i = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getManager()) || void 0 === r ? void 0 : r.materials) || void 0 === i ? void 0 : i.findMaterial(l)) || (null === (s = this._viewer) || void 0 === s ? void 0 : s.createPhysicalMaterial({
              color: a.color
            }));

            if (c) {
              const e = confirm("Convert all with this material?") ? Array.from(a.userData.appliedMeshes) : [o];

              for (const t of e) null == t || t.modelObject.userData.setMaterial(c);
            }

            this.refreshUi();
          },
          limitedUi: !0
        }]
      }, this.refreshEnvMaps = this.refreshEnvMaps.bind(this), this.refreshUi = this.refreshUi.bind(this);
    }

    get envMapRotation() {
      var e, t;
      return null !== (t = null === (e = this.envMap) || void 0 === e ? void 0 : e.rotation) && void 0 !== t ? t : 0;
    }

    set envMapRotation(e) {
      var t;
      const n = this.envMap;
      n && (n.rotation = e, null === (t = this._viewer) || void 0 === t || t.scene.setDirty());
    }

    refreshEnvMaps() {
      var e, t, n;
      if (!this._viewer) return;
      const r = this.getEnvMap(),
            i = (null === (t = null === (e = this._viewer.getPlugin(js)) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.getMaterialsOfType(Uo.TypeSlug)) || [];

      for (const e of i) e && e.envMap !== r && (e.envMap = r, e.needsUpdate = !0);

      null === (n = this._viewer) || void 0 === n || n.scene.setDirty();
    }

    refreshUi() {
      var e, t, n;
      null === (e = this._viewer) || void 0 === e || e.setDirty(), null === (n = null === (t = this.uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    async onAdded(e) {
      var t, n, r, i, s, o;
      this._normalCapture = new Oo(e.renderer), this.offsetCache = {}, e.scene.addEventListener("environmentChanged", this.refreshEnvMaps);
      const a = e.getPlugin(js);
      null === (t = null == a ? void 0 : a.importer) || void 0 === t || t.processors.add("model", this._modelProcessor), null === (n = e.getPlugin(gc)) || void 0 === n || n.addEventListener("selectedObjectChanged", this.refreshUi);
      const l = this.getEnvMap,
            c = new Zt(class extends Qt {
        async loadAsync(e, t) {
          var n;
          const r = await super.loadAsync(e, t);
          return r.type === Uo.TYPE || r.isDiamondMaterialParameters ? (r.envMap = l(), null === (n = null == a ? void 0 : a.materials) || void 0 === n ? void 0 : n.generateFromTemplate("diamond", r)) : (console.error("Invalid material type for Diamond Material.", r), null);
        }

      }, [Uo.TypeSlug], !1);
      return Fs.Importers.push(c), null === (s = null === (i = null === (r = null == a ? void 0 : a.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(yc), null === (o = null == a ? void 0 : a.materials) || void 0 === o || o.registerMaterialTemplate({
        name: "diamond",
        materialType: Uo.TYPE,
        isDiamondMaterialParameters: !0,
        generator: (e, t) => {
          const n = new Uo(e);
          return n.envMap = l(), t && t !== {} && n.copyProps(t), n;
        }
      }), super.onAdded(e);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (t = this._normalCapture) || void 0 === t || t.dispose(), this._normalCapture = void 0, this.offsetCache = {}, null === (r = null === (n = e.getPlugin(js)) || void 0 === n ? void 0 : n.importer) || void 0 === r || r.processors.remove("model", this._modelProcessor), null === (i = e.getPlugin(gc)) || void 0 === i || i.removeEventListener("selectedObjectChanged", this.refreshUi), super.onRemove(e);
    }

    prepareDiamondMesh(e, {
      cacheKey: t,
      normalMapRes: n
    }) {
      var r, i, s;
      e.userData._diamondCacheKey = null != t ? t : e.userData._diamondCacheKey, e.userData._diamondNormalMapRes = null != n ? n : e.userData._diamondNormalMapRes, t = t && t.length > 0 ? t.includes(";" + e.geometry.uuid) ? t : t + ";" + e.geometry.uuid : e.geometry.uuid, this._computeOffsets(e.geometry, e.geometry.uuid);
      const o = null !== (i = null === (r = this._normalCapture) || void 0 === r ? void 0 : r.captureNormalMap(e.geometry, t, n)) && void 0 !== i ? i : [void 0, !1],
            a = null === (s = this._viewer) || void 0 === s ? void 0 : s.getPluginByType("debug");
      a && o && (a.counters.normalsCapture || (a.counters.normalsCapture = 0), a.counters.normalsCapture++, console.log("DEBUG: new normal map captured", a.counters.normalsCapture, t), a.addTexture("normal" + a.counters.normalsCapture, () => {
        var t;
        return null === (t = e.geometry.userData._normalsCaptureMap) || void 0 === t ? void 0 : t.texture;
      }, [40, 110 * a.counters.normalsCapture - 100, 200, 100], void 0, void 0, "postRender", !0));
    }

    makeDiamond(e, t, n) {
      var r, i;
      Array.from(null !== (r = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== r ? r : []).forEach(e => {
        (null == e ? void 0 : e.isMesh) && e.geometry && this.prepareDiamondMesh(e, t);
      }), this._convertToDiamondMaterial(e, n), null === (i = this._viewer) || void 0 === i || i.setDirty();
    }

    _convertToDiamondMaterial(e, t = {
      isDiamond: !0
    }) {
      var n, r, s, o, a, l, c;
      let u = { ...(null != t ? t : {})
      };
      u.isDiamond || u.isDiamondMaterialParameters ? Array.isArray(u.boostFactors) && (u.boostFactors = new i.Pa4().fromArray(u.boostFactors)) : u = {
        isDiamondMaterialParameters: !0
      }, u.color = null !== (s = null !== (n = u.color) && void 0 !== n ? n : null === (r = null == e ? void 0 : e.materialObject) || void 0 === r ? void 0 : r.color) && void 0 !== s ? s : new ve(1, 1, 1);
      const p = null === (l = null === (a = null === (o = this._viewer) || void 0 === o ? void 0 : o.getManager()) || void 0 === a ? void 0 : a.materials) || void 0 === l ? void 0 : l.generateFromTemplate("diamond", u);
      p && e && (p.userData._baseMaterial = e.uuid), Array.from(null !== (c = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== c ? c : []).forEach(e => {
        (e => {
          var t;
          return null !== (t = e.userData.setMaterial) && void 0 !== t ? t : t => {
            e.material = t.materialObject;
          };
        })(e)(p), this.prepareDiamondMesh(e, t);
      });
    }

    _computeOffsets(e, t, n = !1) {
      const r = t.split(";").find(e => this.offsetCache[e]);

      if (r && !n) {
        const n = this.offsetCache[r];
        return t.split(";").forEach(e => e !== r && (this.offsetCache[e] = n)), e.userData._normalsCaptureOffsets = n, n;
      }

      e.computeBoundingBox();
      const s = e.boundingBox.getCenter(new i.Pa4()),
            o = Io(e),
            a = o.clone().invert(),
            l = {
        center: s,
        offsetMatrix: o,
        offsetMatrixInv: a,
        radius: 1,
        centerOffset: new i.Pa4().copy(s).applyMatrix4(a)
      };
      return t.split(";").forEach(e => this.offsetCache[e] = l), e.userData._normalsCaptureOffsets = l, l;
    }

  }

  xc.PluginType = "Diamond", xc.DIAMOND_GLTF_EXTENSION = "WEBGI_materials_diamond", bc([C(xc.prototype.refreshEnvMaps), xe()], xc.prototype, "envMap", void 0), bc([C(xc.prototype.refreshEnvMaps), xe()], xc.prototype, "forceSceneEnvMap", void 0);

  const yc = e => ({
    writeMaterial: (t, n) => {
      t.isDiamondMaterial && (n.extensions = n.extensions || {}, n.extensions[xc.DIAMOND_GLTF_EXTENSION] = t.toJSON(), e.extensionsUsed[xc.DIAMOND_GLTF_EXTENSION] = !0);
    },
    writeMesh: (t, n) => {
      var r, i;
      if (!(null == t ? void 0 : t.material.isDiamondMaterial)) return;
      n.extensions = n.extensions || {};
      const s = {};
      null === (i = null === (r = t.userData) || void 0 === r ? void 0 : r.gltfExtensions) || void 0 === i || delete i[xc.DIAMOND_GLTF_EXTENSION], t.userData._diamondNormalMapRes && (s.normalMapRes = t.userData._diamondNormalMapRes), t.userData._diamondCacheKey && (s.cacheKey = t.userData._diamondCacheKey), n.extensions[xc.DIAMOND_GLTF_EXTENSION] = s, e.extensionsUsed[xc.DIAMOND_GLTF_EXTENSION] = !0;
    }
  });

  var wc,
      Sc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Mc = wc = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.animations = [], this.loopAnimations = !0, this.loopRepetitions = 1 / 0, this.timeScale = 0, this.animateOnScroll = !1, this.animationSpeed = 1, this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this.dependencies = [js], this._lastFrameTime = 0, this._fadeDisabled = !1, this._objectAdded = e => {
        const t = e.object;
        "model" === t.assetType && t.modelObject && this._viewer && t.modelObject.traverse(e => {
          const t = e.animations;
          if (t.length < 1) return;
          const n = Math.max(...t.map(e => e.duration));
          t.forEach(e => e.duration = n);
          const r = new i.Xcj(this._viewer.scene.modelRoot.modelObject),
                s = t.map(e => r.clipAction(e).setLoop(this.loopAnimations ? i.YKA : i.jAl, this.loopRepetitions));
          this.animations.push({
            mixer: r,
            clips: t,
            actions: s,
            duration: n
          }), this.onPropertyChange();
        });
      }, this._animationTime = 0, this._animationDuration = 0, this._animationState = "none", this.uiConfig = void 0, this._lastAnimId = "", this.timelineMarkers = [], this._postFrame = this._postFrame.bind(this), this._wheel = this._wheel.bind(this), this.playClips = this.playClips.bind(this), this.playClip = this.playClip.bind(this), this.playAnimation = this.playAnimation.bind(this), this.playPauseAnimation = this.playPauseAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.stopAnimation = this.stopAnimation.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.onPropertyChange = this.onPropertyChange.bind(this), this._loaderCreate = this._loaderCreate.bind(this);
    }

    get animationState() {
      return this._animationState;
    }

    get animationTime() {
      return this._animationTime;
    }

    get animationDuration() {
      return this._animationDuration;
    }

    _wheel({
      deltaY: e
    }) {
      this.enabled && Math.abs(e) > .001 && (this._scrollAnimationState = -1 * Math.sign(e));
    }

    _postFrame() {
      var e, t;
      if (!this._viewer) return;
      const n = this._viewer,
            r = this.animateOnScroll;
      if (!this.enabled || this.animations.length < 1 || "playing" !== this._animationState && !r) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(wc.PluginType), this._fadeDisabled = !1));
      const i = At() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = i - 1 / 30);
      let s = i - this._lastFrameTime;
      if (s *= this.animationSpeed, this._lastFrameTime = i, r && (s *= this._scrollAnimationState), Math.abs(s) < 1e-4) return;
      const o = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();

      if (o && o > 0 && (s = o), 0 !== o && (this.animations.map(e => e.mixer.update(s)), this._animationTime += s, this._animationTime > this._animationDuration && (this._animationTime -= this._animationDuration), this._animationTime < 0 && (this._animationTime += this._animationDuration), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, n.scene.activeCamera.cameraObject.userData.__animatingCamera && n.scene.activeCamera.setDirty(), n.renderer.resetShadows(), n.setDirty(), !this._fadeDisabled)) {
        const e = this._viewer.getPluginByType("FrameFade");

        e && (e.disable(wc.PluginType), this._fadeDisabled = !0);
      }
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new Tc(e, this));
    }

    async onAdded(e) {
      var t, n, r, i, s, o;
      null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), e.scene.addEventListener("addSceneObject", this._objectAdded), null === (o = null === (s = null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.exporter) || void 0 === i ? void 0 : i.getExporter("gltf", "glb")) || void 0 === s ? void 0 : s.extensions) || void 0 === o || o.push(Ec), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel);
      let a = -1;
      return Object.defineProperty(e.scene.modelRoot, "currentTimelineMarker", {
        get: () => a,
        set: t => e.scene.modelRoot.dispatchEvent({
          type: "animationTimelineMarker",
          marker: this.timelineMarkers[a = t]
        })
      }), e.scene.modelRoot.addEventListener("animationTimelineMarker", ({
        marker: e
      }) => {
        var t;
        if (!this._viewer) return;
        if (!e) return this._viewer.scene.activeCamera = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.defaultCamera, void this._viewer.setDirty();
        const n = e.camera;
        n && (n.userData.__animatingCamera = !0, this._viewer.scene.activeCamera = this._viewer.createCamera(n));
      }), super.onAdded(e);
    }

    async onRemove(e) {
      var t, n;
      return e.scene.removeEventListener("addSceneObject", this._objectAdded), null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), super.onRemove(e);
    }

    onPropertyChange() {
      "playing" === this._animationState && this.playAnimation(), this._animationDuration = Math.max(...this.animations.map(({
        duration: e
      }) => e));
    }

    onStateChange() {
      var e, t;
      null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.children) || void 0 === t || t.map(e => e && x(e)).flat(2).forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e);
      });
    }

    playPauseAnimation() {
      "playing" === this._animationState ? this.pauseAnimation() : this.playAnimation();
    }

    async playClip(e, t = !1) {
      return this.playClips([e], t);
    }

    async playClips(e, t = !1) {
      const n = [];
      return this.animations.forEach(({
        actions: t
      }) => {
        t.forEach(t => {
          e.includes(t.getClip().name) && n.push(t);
        });
      }), this.playAnimation(t, n);
    }

    async playAnimation(e = !1, t) {
      var n, r, s;
      if (!this.enabled) return;
      "playing" === this._animationState && this.stopAnimation(!1), g(null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("Picking")) || void 0 === r ? void 0 : r.transformControls, "enabled", !1);
      let o = 0;
      t || (t = [], this.animations.forEach(({
        mixer: e,
        actions: n,
        clips: r
      }) => {
        t.push(...n);
      }));
      const a = Be();
      this._lastAnimId = a, "paused" !== this._animationState && this.resetAnimation();

      for (const e of t) this.timeScale > 0 && (e.timeScale = this.timeScale), e.setLoop(this.loopAnimations ? i.YKA : i.jAl, this.loopRepetitions), e.play(), o = Math.max(o, e.getClip().duration / e.timeScale);

      if (this._animationState = "playing", null === (s = this._viewer) || void 0 === s || s.setDirty(), o *= this.loopAnimations ? this.loopRepetitions : 1, o /= this.animationSpeed, !isFinite(o)) return;
      const l = 1e3 * o - this._animationTime / this.animationSpeed + .01;
      l > 0 && (await uc(l)), a === this._lastAnimId && this.stopAnimation(e);
    }

    pauseAnimation() {
      var e, t, n;
      this._animationState = "paused", g(null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.transformControls, "enabled", !0), null === (n = this._viewer) || void 0 === n || n.setDirty(), this._lastAnimId = "";
    }

    stopAnimation(e = !1) {
      var t, n, r;
      this._animationState = "stopped", g(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), "enabled", !0), e ? this.resetAnimation() : null === (n = this._viewer) || void 0 === n || n.setDirty(), this._lastAnimId = "", this._viewer && this._fadeDisabled && (null === (r = this._viewer.getPluginByType("FrameFade")) || void 0 === r || r.enable(wc.PluginType), this._fadeDisabled = !1);
    }

    resetAnimation() {
      var e;
      "stopped" === this._animationState ? (this.animations.forEach(({
        mixer: e,
        actions: t,
        clips: n
      }) => {
        e.stopAllAction(), e.setTime(0);
      }), this._animationTime = 0, null === (e = this._viewer) || void 0 === e || e.setDirty()) : this.stopAnimation(!0);
    }

  };
  Mc.PluginType = "GLTFAnimation", Mc.AnimationMarkersExtension = "WEBGI_animation_markers", Sc([Ge()], Mc.prototype, "animationState", null), Sc([Ge()], Mc.prototype, "animationTime", null), Sc([Ge()], Mc.prototype, "animationDuration", null), Sc([C(wc.prototype.onPropertyChange), Ve("Loop", {
    limitedUi: !0
  })], Mc.prototype, "loopAnimations", void 0), Sc([C(wc.prototype.onPropertyChange)], Mc.prototype, "loopRepetitions", void 0), Sc([C(wc.prototype.onPropertyChange)], Mc.prototype, "timeScale", void 0), Sc([Ve(), xe()], Mc.prototype, "animateOnScroll", void 0), Sc([He("Speed", [.1, 4], .1, {
    limitedUi: !0
  }), xe()], Mc.prototype, "animationSpeed", void 0), Sc([C(wc.prototype.onStateChange)], Mc.prototype, "_animationState", void 0), Sc([Xe("Play/Pause", e => ({
    label: () => "playing" === e.animationState ? "Pause" : "Play",
    limitedUi: !0
  }))], Mc.prototype, "playPauseAnimation", null), Sc([Xe("Stop", {
    limitedUi: !0
  })], Mc.prototype, "stopAnimation", null), Sc([Xe("Reset", {
    limitedUi: !0
  })], Mc.prototype, "resetAnimation", null), Mc = wc = Sc([Qe("GLTF Animations")], Mc);

  class Tc {
    constructor(e, t) {
      this.parser = e, this.name = Mc.AnimationMarkersExtension, this.plugin = t;
    }

    async afterRoot(e) {
      var t;
      let n = [];

      for (const e of this.parser.json.scenes) {
        if (!e.extensions) continue;
        const t = e.extensions[this.name];

        for (const e of (null == t ? void 0 : t.markers) || []) {
          const t = void 0 !== e.camera ? await this.parser.getDependency("camera", e.camera) : void 0;

          if (void 0 === e.time) {
            const t = 30;
            e.time = e.frame / t, console.error("Update timeline markers plugin for correct times.");
          }

          n.push({
            name: e.name,
            frame: e.frame,
            time: e.time,
            camera: t
          });
        }
      }

      if (n.length < 1) return;
      n = n.sort((e, t) => e.frame - t.frame);
      const r = null !== (t = e.scene) && void 0 !== t ? t : e.scenes[0];
      if (!r) return;
      r.userData.__markers = n;
      const s = this.plugin.timelineMarkers,
            o = n.map(e => e.time);
      let a = s.length;
      const l = n.map(e => a++),
            c = Math.max(...o) + .01;
      s.push(...n);
      const u = new i.dUE(".currentTimelineMarker", o, l, 2300),
            p = new i.m7l("animationTimelineMarker", c, [u]);
      p.__gltfExport = !1, e.animations.push(p);
    }

  }

  const Ec = e => ({
    afterParse(t) {
      const n = e.json.scenes[e.json.scene || 0];
      n.extensions = n.extensions || {};
      const r = {
        markers: []
      },
            i = [];

      if ((Array.isArray(t) ? t : [t]).forEach(e => e.traverse(e => {
        e.userData.__markers && i.push(...e.userData.__markers);
      })), i.sort((e, t) => e.frame - t.frame), !(i.length < 1)) {
        for (const t of i) {
          const n = t.camera;

          if (n) {
            const i = e.nodeMap.get(n);

            if (void 0 === i) {
              console.warn("Camera not found in gltf export", n, e.nodeMap);
              continue;
            }

            const s = e.json.nodes[i].camera;
            t.camera = s, r.markers.push(t);
          }
        }

        n.extensions[Mc.AnimationMarkersExtension] = r, e.extensionsUsed[Mc.AnimationMarkersExtension] = !0;
      }
    }

  });

  class Ac extends r {
    constructor() {
      super(...arguments), this.dirty = !1, this.counters = {}, this._generators = new Map(), this._preRender = () => this._showDebug("preRender"), this._postRender = () => this._showDebug("postRender");
    }

    async onAdded(e) {
      this._viewer = e, e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender);
    }

    addTexture(e, t, n, r, o, a = "postRender", l = !1) {
      var c;
      this._generators.has(a) || this._generators.set(a, []), null === (c = this._generators.get(a)) || void 0 === c || c.push({
        key: e,
        fn: t,
        rect: n ? [...n] : void 0,
        frag: o || r || l ? new i.jyz({
          vertexShader: s.vertexShader,
          uniforms: {
            tDiffuse: {
              value: null
            },
            opacity: {
              value: 1
            }
          },
          fragmentShader: null != o ? o : `\n        #include <common>\n        #include <packing>\n        uniform float opacity;\n\t\tuniform ${l ? "samplerCube" : "sampler2D"} tDiffuse;\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvec4 texel = ${l ? "textureCube( tDiffuse, vec3(cos(vUv.y * PI2) * cos(vUv.x * PI2), sin(vUv.y * PI2), cos(vUv.y * PI2) * sin(vUv.x * PI2)) )" : "texture2D( tDiffuse, vUv )"};\n\t\t\t${null != r ? r : ""}\n\t\t\tgl_FragColor = opacity * texel;\n\t\t}\n            `
        }) : void 0
      });
    }

    removeTexture(e, t = "postRender") {
      var n, r;

      this._generators.set(t, null !== (r = null === (n = this._generators.get(t)) || void 0 === n ? void 0 : n.filter(t => t.key !== e)) && void 0 !== r ? r : []);
    }

    async onDispose(e) {
      return Promise.resolve(void 0);
    }

    async onRemove(e) {
      return e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), this._viewer = void 0, Promise.resolve(void 0);
    }

    _showDebug(e) {
      var t;
      const n = this._viewer,
            r = null == n ? void 0 : n.renderer;
      r && n && (null === (t = this._generators.get(e)) || void 0 === t || t.forEach(({
        key: e,
        fn: t,
        rect: i,
        frag: s
      }) => {
        const o = t(n);

        if (o) {
          if (o.image && i) {
            const e = o.image.width / o.image.height;
            i[2] < 1 && i[3] < 1 && (i[2] = 200), i[2] < 1 && (i[2] = i[3] * e), i[3] < 1 && (i[3] = i[2] / e);
          }

          r.blit(o, void 0, {
            viewport: i,
            clear: !1,
            material: s
          });
        }
      }));
    }

  }

  Ac.PluginType = "debug";

  var Cc = function (e, t) {
    return Cc = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (e, t) {
      e.__proto__ = t;
    } || function (e, t) {
      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    }, Cc(e, t);
  };

  function Rc(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

    function n() {
      this.constructor = e;
    }

    Cc(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
  }

  var kc,
      Pc = function () {
    function e() {}

    return e._xfnv1a = function (e) {
      for (var t = 2166136261, n = 0; n < e.length; n++) t = Math.imul(t ^ e.charCodeAt(n), 16777619);

      return function () {
        return t += t << 13, t ^= t >>> 7, t += t << 3, t ^= t >>> 17, (t += t << 5) >>> 0;
      };
    }, e;
  }(),
      Dc = function (e) {
    function t(n) {
      var r = e.call(this) || this;
      return r.a = t._xfnv1a(n)(), r;
    }

    return Rc(t, e), t.prototype.next = function () {
      var e = this.a += 1831565813;
      return e = Math.imul(e ^ e >>> 15, 1 | e), (((e ^= e + Math.imul(e ^ e >>> 7, 61 | e)) ^ e >>> 14) >>> 0) / 4294967296;
    }, t;
  }(Pc),
      Oc = function (e) {
    function t(n) {
      var r = e.call(this) || this,
          i = t._xfnv1a(n);

      return r.a = i(), r.b = i(), r.c = i(), r.d = i(), r;
    }

    return Rc(t, e), t.prototype.next = function () {
      this.a >>>= 0, this.b >>>= 0, this.c >>>= 0, this.d >>>= 0;
      var e = this.a + this.b | 0;
      return this.a = this.b ^ this.b >>> 9, this.b = this.c + (this.c << 3) | 0, this.c = this.c << 21 | this.c >>> 11, this.d = this.d + 1 | 0, e = e + this.d | 0, this.c = this.c + e | 0, (e >>> 0) / 4294967296;
    }, t;
  }(Pc),
      Lc = function (e) {
    function t(n) {
      var r = e.call(this) || this,
          i = t._xfnv1a(n);

      return r.a = i(), r.b = i(), r.c = i(), r.d = i(), r;
    }

    return Rc(t, e), t.prototype.next = function () {
      var e = this.b << 9,
          t = 5 * this.a;
      return t = t << 7 | 9 * (t >>> 25), this.c ^= this.a, this.d ^= this.b, this.b ^= this.c, this.a ^= this.d, this.c ^= e, this.d = this.d << 11 | this.d >>> 21, (t >>> 0) / 4294967296;
    }, t;
  }(Pc);

  !function (e) {
    e.sfc32 = "sfc32", e.mulberry32 = "mulberry32", e.xoshiro128ss = "xoshiro128ss";
  }(kc || (kc = {}));

  var Ic = function () {
    function e(e, t) {
      void 0 === t && (t = kc.sfc32), this.str = e, this.prng = t, this.generator = this._initializeGenerator();
    }

    return e.prototype.next = function () {
      return this.generator.next();
    }, e.prototype._initializeGenerator = function () {
      if (function (e) {
        return null === e;
      }(e = this.str) || function (e) {
        return void 0 === e;
      }(e)) return this.wrap();
      var e;

      switch (this.prng) {
        case "sfc32":
          return new Oc(this.str);

        case "mulberry32":
          return new Dc(this.str);

        case "xoshiro128ss":
          return new Lc(this.str);

        default:
          return this.wrap();
      }
    }, e.prototype.wrap = function () {
      return {
        next: function () {
          return Math.random();
        }
      };
    }, e;
  }(),
      Fc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Nc extends Os {
    constructor(e, t, n, r) {
      super(e, t), this._shadowParams = {
        enabled: !0,
        radius: 2,
        width: 1024,
        height: 1024,
        bias: -.001,
        normalBias: 0,
        near: 1.5,
        far: 4,
        frustumSize: 4
      }, this._randomParams = {
        focus: 1,
        spread: .01,
        distanceScale: 50,
        minDistanceScale: new i.Pa4(10, 10, 10),
        normalDirection: new i.Pa4(.01, .98, .01).normalize(),
        direction: new i.Pa4(-.9, .5, -1)
      }, this.isRandomizedDirectionalLight = !0, this.shadowParams = null != n ? n : {}, this.randomParams = null != r ? r : {}, this.updateShadowParams = this.updateShadowParams.bind(this);
    }

    get shadowParams() {
      return this._shadowParams;
    }

    set shadowParams(e) {
      Object.keys(e).forEach(t => void 0 === e[t] && delete e[t]), this._shadowParams = { ...this._shadowParams,
        ...e
      }, this.updateShadowParams();
    }

    get randomParams() {
      return this._randomParams;
    }

    set randomParams(e) {
      Object.keys(e).forEach(t => void 0 === e[t] && delete e[t]), Object.assign(this._randomParams, e);
    }

    updateShadowParams() {
      this.castShadow = this._shadowParams.enabled, this.shadow.mapSize.x = this._shadowParams.width, this.shadow.mapSize.y = this._shadowParams.height, this.shadow.bias = this._shadowParams.bias, this.shadow.normalBias = this._shadowParams.normalBias, this.refreshShadowCamNearFar(), this.shadow.radius = this._shadowParams.radius, this.shadow.camera.right = this._shadowParams.frustumSize / 2, this.shadow.camera.left = -this._shadowParams.frustumSize / 2, this.shadow.camera.top = this._shadowParams.frustumSize / 2, this.shadow.camera.bottom = -this._shadowParams.frustumSize / 2, this.shadow.camera.updateProjectionMatrix(), this.matrixWorldNeedsUpdate = !0;
    }

    randomizePosition(e, t = null, n = null) {
      const r = new Ic(e.toString()),
            s = new i.FM8(r.next() * Math.PI * 2, Math.asin(2 * r.next() - 1));
      let o = new i.Pa4(Math.cos(s.x) * Math.cos(s.y), Math.sin(s.y), Math.sin(s.x) * Math.cos(s.y));
      const a = new i.FM8();

      for (let e = 0; e < 5; e++) {
        a.set(r.next(), r.next()), o = Uc(a, this._randomParams.normalDirection, .4), r.next() < Math.sqrt(null != t ? t : this._randomParams.focus) && (a.set(r.next(), r.next()), o = Uc(a, this._randomParams.direction, Math.pow((null != n ? n : this._randomParams.spread) / 2, 2)));
        const e = o.dot(this._randomParams.normalDirection);
        if (e > 0 && e < .4) break;
      }

      o.normalize(), o.multiplyScalar(this._randomParams.distanceScale), this.position.set(0, 0, 0), this.target.position.copy(o.normalize().negate()), this.target.updateMatrixWorld(), this.refreshShadowCamNearFar(), this.updateMatrixWorld();
    }

    refreshShadowCamNearFar() {
      const e = new i.Pa4().subVectors(this.target.position, this.shadow.camera.position).length();
      this.shadow.camera.near = e - this._shadowParams.near * this._shadowParams.frustumSize / 2, this.shadow.camera.far = e + this._shadowParams.far * this._shadowParams.frustumSize / 2;
    }

    dispose() {}

    get uiConfig() {
      if (this._uiConfig) return this._uiConfig;
    }

    fromJSON(e, t) {
      return super.fromJSON(e, t) ? (this.updateShadowParams(), this) : null;
    }

  }

  function Uc(e, t, n) {
    t = t.clone().normalize();
    const r = new i.Pa4(0, -t.z, t.y).normalize(),
          s = new i.Pa4().crossVectors(t, r).normalize(),
          o = e;
    o.x = 2 * o.x * Math.PI, o.y = 1 - o.y * n;
    const a = Math.sqrt(1 - o.y * o.y);
    return r.multiplyScalar(Math.cos(o.x) * a).add(s.multiplyScalar(Math.sin(o.x) * a)).add(t.multiplyScalar(o.y));
  }

  Fc([xe("shadowParams")], Nc.prototype, "_shadowParams", void 0), Fc([xe("randomParams")], Nc.prototype, "_randomParams", void 0);

  class Bc extends i.Tn7 {
    constructor() {
      super(...arguments), this.typeSlug = "fsShadow", this.assetType = "material", this._uniforms = {}, this.lastFrameTexture = null;
    }

    get materialObject() {
      return this;
    }

    onBeforeCompile(e, t) {
      e.vertexShader = e.vertexShader.replace("#include <project_vertex>", "\n#include <project_vertex>\ngl_Position = vec4(uv*2.-1., 0, 1.); \n        "), e.vertexShader = e.vertexShader.replace("void main() {", "\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n        "), e.fragmentShader = e.fragmentShader.replace("void main() {", "\nvarying vec2 vUv;\nuniform sampler2D tLastThis;\nvoid main() {\n        "), e.fragmentShader = e.fragmentShader.replace("gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );", M`
float shadow = getShadowMask();

//shift the color by dither_shift
shadow = clamp(shadow + mix(-1./512., 1./512., rand( gl_FragCoord.xy )), 0., 1.);

float last = unpackRGBAToDepth(texture2D(tLastThis, vUv));
gl_FragColor = packDepthToRGBA(mix(last, shadow, opacity));
//if not useMovingAverage:
//gl_FragColor = packDepthToRGBA(shadow * opacity + last);
        `), Object.assign(e.uniforms, this._uniforms), super.onBeforeCompile(e, t);
    }

    customProgramCacheKey() {
      return super.customProgramCacheKey();
    }

    toJSON(e) {
      throw new Error("Method not supported for this material.");
    }

    fromJSON(e, t) {
      throw new Error("Method not supported for this material.");
    }

    copyProps(e) {
      throw new Error("Method not supported for this material.");
    }

  }

  function jc(e, t, n, {
    replaceAll: r = !1,
    prepend: i = !1,
    append: s = !1
  } = {}) {
    if (!e.includes(t)) return console.error(`${t} not found in shader`), e;
    let o = n;
    return i ? o = n + t : s && (o = t + n), r ? e.replaceAll(t, o) : e.replace(t, o);
  }

  !function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([V({
    propKey: "tLastThis"
  })], Bc.prototype, "lastFrameTexture", void 0);

  var zc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Vc {
    constructor(e) {
      this.enabled = !0, this._lightLayer = 5, this._frameNumber = 0, this.maxFrameNumber = 400, this.groundMapMode = "aoMap", this.alphaVignette = !0, this.alphaVignetteAxis = "xy", this.shadowAutoUpdate = !0, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          "aoMap" === this.groundMapMode ? e.fragmentShader = jc(e.fragmentShader, "#include <aomap_fragment>", jc(i.WdD.aomap_fragment, "float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;", "float ambientOcclusion = ( unpackRGBAToDepth(texture2D( aoMap, vUv2 ) ) - 1.0) * aoMapIntensity + 1.0;")) : "map" === this.groundMapMode ? e.fragmentShader = jc(e.fragmentShader, "#include <map_fragment>", jc(i.WdD.map_fragment, "diffuseColor *= sampledDiffuseColor;", "float groundShadow = unpackRGBAToDepth(sampledDiffuseColor); diffuseColor.rgb *= groundShadow; diffuseColor.a *= max(0., 1.-groundShadow);")) : "alphaMap" === this.groundMapMode && (e.fragmentShader = jc(e.fragmentShader, "#include <alphamap_fragment>", jc(i.WdD.alphamap_fragment, "texture2D( alphaMap, vUv ).g", "1. - unpackRGBAToDepth( texture2D( alphaMap, vUv ) )", {
            replaceAll: !0
          }))), this.alphaVignette && n.capabilities.isWebGL2 && (e.fragmentShader = jc(e.fragmentShader, "#include <output_fragment>", M`#include <output_fragment>
                    #ifndef OPAQUE
                    float weight = 0.;
                    #ifdef USE_UV
                    weight = 2.*abs(length(0.5 - vUv.${this.alphaVignetteAxis}));
                    #endif
                    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
                    weight = 2.*abs(length(0.5 - vUv2.${this.alphaVignetteAxis}));
                    #endif
                    weight = min(1., max(0., weight))-0.5;
                    weight = min(1., max(0., 1.0-2.*weight));
                    weight = pow(weight, 1.5);
                    gl_FragColor.a *= weight;
                    //gl_FragColor.rgb /= max(0.01, weight);
                    gl_FragColor = saturate(gl_FragColor);
                    //gl_FragColor.a = 0.5;
                    #endif
                    `));
        },
        computeCacheKey: () => this.groundMapMode + "." + this.alphaVignette + "." + this.alphaVignetteAxis,
        onObjectRender: (e, t) => {
          t.materialObject.userData.gMapMode !== this.groundMapMode && (t.materialObject.userData.gMapMode = this.groundMapMode, t.materialObject.needsUpdate = !0);
        },
        isCompatible: e => e.isMeshStandardMaterial2
      }, this._viewer = e;
      const t = new Nc(16777215, 10, {
        near: 1.5,
        far: 20,
        bias: 0,
        frustumSize: 4,
        width: 1024,
        height: 1024,
        enabled: !0,
        radius: 10,
        normalBias: 0
      }, {
        direction: new i.Pa4(.2, 1, .2).normalize(),
        spread: .9,
        focus: 1,
        distanceScale: 20,
        minDistanceScale: new i.Pa4(10, 10, 10),
        normalDirection: new i.Pa4(0, 1, 0)
      });
      t.shadow.camera.updateProjectionMatrix(), t.layers.disableAll(), t.layers.set(this._lightLayer), this._light = t, e.scene.addLight(this._light, {
        addToRoot: !0
      }), this._shadowMat = new Bc({
        color: "#ffffff",
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        premultipliedAlpha: !1,
        opacity: 1,
        transparent: !1,
        blending: i.jFi
      });
    }

    get attachedMesh() {
      return this._attachedMesh;
    }

    set attachedMesh(e) {
      this._attachedMesh !== e && (this._attachedMesh && this.cleanupMaterial(), this._attachedMesh = e, this._attachedMesh && this._updateMaterial());
    }

    get target() {
      return this._target;
    }

    get light() {
      return this._light;
    }

    dispose() {
      this._shadowMat.dispose(), this._target = void 0, this.reset();
    }

    cleanupMaterial() {
      this._updateMaterial(!0);
    }

    _groundMapModeChanged() {
      this._attachedMesh && (this.cleanupMaterial(), this._updateMaterial(), "alphaMap" === this.groundMapMode ? this._attachedMesh.material.transparent = !0 : this._attachedMesh.material.transparent = !1), this.reset();
    }

    _alphaVignetteChanged() {
      var e, t, n;
      null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty();
    }

    fromJSON(e, t) {
      return Te(e, this, !0, t), this.reset(), this;
    }

    reset() {
      this._frameNumber = 0;
    }

    autoUpdateShadow() {
      this.shadowAutoUpdate && this.updateShadow();
    }

    updateShadow() {
      if (!this.enabled) return !1;
      const e = this._attachedMesh;
      if (++this._frameNumber > this.maxFrameNumber || !e) return !1;
      const t = 1024;
      this._target || (this._target = this._viewer.renderer.createTarget({
        isAntialiased: !1,
        type: i.ywz,
        depthBuffer: !1,
        size: new i.FM8(t, t),
        sizeMultiplier: void 0,
        encoding: i.rnI,
        format: i.wk1
      })), this._frameNumber < 3 ? this._light.randomizePosition(0, 1, 0) : this._light.randomizePosition(this._frameNumber), e.castShadow = !1;
      const n = this._viewer.renderer.rendererObject,
            r = n.shadowMap,
            s = r.type,
            o = r.needsUpdate,
            a = r.autoUpdate;
      r.type = i._MY, r.needsUpdate = !0, r.autoUpdate = !1;
      const l = this._viewer.scene,
            c = new i.S9g();
      c.disableAll(), l.modelObject.traverse(e => {
        e.isLight && e !== this._light.lightObject && (e.userData.__gp_layers = e.layers, e.layers = c);
      });
      const u = l.activeCamera.cameraObject;
      if (0 != (u.layers.mask & 1 << this._lightLayer)) throw "Camera can render pseudo directional light, check layers";
      u.layers.enable(this._lightLayer), e.layers.disable(this._lightLayer), K(n, {
        shadowMapRender: !0,
        backgroundRender: !1,
        sceneRender: !1
      }, () => this._viewer.renderer.renderScene(l)), u.layers.disable(this._lightLayer);
      const p = u.layers.mask;
      u.layers.set(this._lightLayer), e.layers.enable(this._lightLayer);

      const h = this._viewer.renderer.getTempTarget({
        isAntialiased: !1,
        type: i.ywz,
        depthBuffer: !1,
        size: new i.FM8(t, t),
        encoding: i.rnI,
        format: i.wk1
      }),
            d = h.texture.encoding;

      h.texture.encoding = i.rnI, this._viewer.renderer.blit(this._target.texture, h, {
        clear: !0
      });
      {
        const t = l.modelObject.environment,
              r = l.modelObject.background,
              i = e.material,
              s = e.frustumCulled,
              o = n.getRenderTarget(),
              a = n.getActiveCubeFace(),
              c = n.getActiveMipmapLevel();
        l.modelObject.background = null, l.modelObject.environment = null, e.material = this._shadowMat, e.frustumCulled = !1, n.setRenderTarget(this._target);
        const u = !1;
        this._shadowMat.opacity = u ? 1 / this.maxFrameNumber : Math.max(1 / this.maxFrameNumber, 1 / this._frameNumber), this._shadowMat.lastFrameTexture = h.texture, this._shadowMat.needsUpdate = !0, K(n, {
          shadowMapRender: !1,
          backgroundRender: !1,
          opaqueRender: !0,
          transparentRender: !1,
          transmissionRender: !1
        }, () => this._viewer.renderer.renderScene(l)), n.setRenderTarget(o, a, c), e.frustumCulled = s, e.material = i, l.modelObject.environment = t, l.modelObject.background = r;
      }
      return h.texture.encoding = d, this._viewer.renderer.releaseTempTarget(h), e.layers.disable(this._lightLayer), u.layers.mask = p, l.modelObject.traverse(e => {
        e.isLight && e !== this._light.lightObject && (e.layers = e.userData.__gp_layers, delete e.userData.__gp_layers);
      }), r.type = s, r.needsUpdate = o, r.autoUpdate = a, e.castShadow = !0, (this._frameNumber < 2 || this._frameNumber > Math.min(30, this.maxFrameNumber) && this._frameNumber % 150 == 0) && (this._updateMaterial(), this._viewer.setDirty(), e.dispatchEvent({
        type: "materialUpdate"
      })), !0;
    }

    _updateMaterial(e = !1) {
      var t, n, r;
      this._attachedMesh && (e ? (this._attachedMesh.material.alphaMap === (null === (t = this._target) || void 0 === t ? void 0 : t.texture) && (this._attachedMesh.material.alphaMap = null), this._attachedMesh.material.aoMap === (null === (n = this._target) || void 0 === n ? void 0 : n.texture) && (this._attachedMesh.material.aoMap = null), this._attachedMesh.material.map === (null === (r = this._target) || void 0 === r ? void 0 : r.texture) && (this._attachedMesh.material.map = null)) : this._target && ("alphaMap" === this.groundMapMode && (this._attachedMesh.material.alphaMap = this._target.texture), "aoMap" === this.groundMapMode && (this._attachedMesh.material.aoMap = this._target.texture), "map" === this.groundMapMode && (this._attachedMesh.material.map = this._target.texture)), this._attachedMesh.material && (this._attachedMesh.material.userData.ALPHA_I_RGBA_PACKING = !e && "alphaMap" === this.groundMapMode, this._attachedMesh.material.alphaTest = e || "alphaMap" !== this.groundMapMode ? 0 : .001, this._attachedMesh.material.needsUpdate = !0));
    }

  }

  zc([xe("randomizedLight")], Vc.prototype, "_light", void 0), zc([C(Vc.prototype.reset), xe()], Vc.prototype, "maxFrameNumber", void 0), zc([C(Vc.prototype._groundMapModeChanged), xe()], Vc.prototype, "groundMapMode", void 0), zc([xe(), C(Vc.prototype._alphaVignetteChanged)], Vc.prototype, "alphaVignette", void 0), zc([xe(), C(Vc.prototype._alphaVignetteChanged)], Vc.prototype, "alphaVignetteAxis", void 0);

  var Gc = "vec2 poisson_disk_samples[16];void setPds(){poisson_disk_samples[0]=vec2(-0.399691779231,0.728591545584);poisson_disk_samples[1]=vec2(-0.48622557676,-0.84016533712);poisson_disk_samples[2]=vec2(0.770309468987,-0.24906070432);poisson_disk_samples[3]=vec2(0.556596796154,0.820359876432);poisson_disk_samples[4]=vec2(-0.933902004071,0.0600539051593);poisson_disk_samples[5]=vec2(0.330144964342,0.207477293384);poisson_disk_samples[6]=vec2(0.289013230975,-0.686749271417);poisson_disk_samples[7]=vec2(-0.0832470893559,-0.187351643125);poisson_disk_samples[8]=vec2(-0.296314525615,0.254474834305);poisson_disk_samples[9]=vec2(-0.850977666059,0.484642744689);poisson_disk_samples[10]=vec2(0.829287915319,0.2345063545);poisson_disk_samples[11]=vec2(-0.773042143899,-0.543741521254);poisson_disk_samples[12]=vec2(0.0561133030864,0.928419742597);poisson_disk_samples[13]=vec2(-0.205799249508,-0.562072714492);poisson_disk_samples[14]=vec2(-0.526991665882,-0.193690188118);poisson_disk_samples[15]=vec2(-0.051789270667,-0.935374050821);}",
      Hc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Wc extends i.Kj0 {
    constructor(e, t, n = 0) {
      super(e), this.type = "Reflector", this.isReflector2 = !0, this.enabled = !0, this.reflectorModePhysical = !0, this.reflectionTargetNeedsUpdate = !0, this.transparentReflectionBackground = !0, this.materialExtension = {
        extraUniforms: {
          tRefDepth: {
            value: null
          },
          tRefDiffuse: {
            value: null
          },
          tRefDiffuseSize: {
            value: new i.FM8()
          },
          refTextureMatrix: {
            value: null
          },
          frameCount: {
            value: 0
          },
          sceneBoundingRadius: {
            value: 0
          }
        },
        updaters: [],
        shaderExtender: (e, t, n) => {
          if (this.enabled) {
            e.vertexShader = e.vertexShader.replace("void main() {", "void main() {\nvRefUv = refTextureMatrix * vec4( position, 1.0 );");
            const t = "#glMarker beforeModulation";
            e.fragmentShader = e.fragmentShader.replace(t, "\n                    if(roughnessFactor < 0.95) {\n                        float d = 0.;//textureProj(tRefDepth, vRefUv).r;\n                        d = min(2., max(0., (d-0.06) * ((7./3.-ior)) * sceneBoundingRadius));\n                        vec4 refBaseColor = getReflectionColor(material.roughness, material.roughness * d);\n                        // refBaseColor.rgb = vec3(refBaseColor.a);\n                        // refBaseColor.a *= 1.0 - clamp(material.roughness * .3, 0., 1.);\n                        " + (this.reflectorModePhysical ? "\n                        #if !defined(SSR_ENABLED) || SSR_ENABLED < 1 \n                        vec3 specularColor = EnvironmentBRDF(geometry.normal, geometry.viewDir, material.specularColor.rgb, material.specularF90, material.roughness);\n                        #endif\n                        reflectedLight.indirectSpecular = mix(vec3(reflectedLight.indirectSpecular), saturate(specularColor.rgb * refBaseColor.rgb), refBaseColor.a);\n                        " : "\n                        reflectedLight.indirectSpecular = saturate(diffuseColor.rgb * refBaseColor.rgb);\n                        diffuseColor.a *= refBaseColor.a;\n                        ") + "}\n" + t);
          }
        },
        parsVertexSnippet: () => this.enabled ? "\n\t\tuniform mat4 refTextureMatrix;\n\t\tvarying vec4 vRefUv;\n" : "",
        parsFragmentSnippet: () => this.enabled ? Gc + "\n" + xo + "\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius\nuniform float sceneBoundingRadius;\n#endif\nvarying vec4 vRefUv;uniform sampler2D tRefDiffuse;uniform vec2 tRefDiffuseSize;uniform sampler2D tRefDepth;float getSpecularMIPLevel(const in float roughness,const in float maxMIPLevel){float sigma=PI*roughness*roughness/(1.+roughness);float desiredMIPLevel=maxMIPLevel+log2(sigma);return clamp(desiredMIPLevel,0.,maxMIPLevel);}vec4 getReflectionColor(const in float roughness,const in float depthModifier){float mip=getSpecularMIPLevel(roughness+depthModifier,5.);vec4 color=texture2D(tRefDiffuse,vRefUv.xy/vRefUv.w,mip);float blurDist=saturate(2./(1.+pow(abs(vViewPosition.z),0.25)))*mip*32.*color.a;float rnd=PI2*random3(vec3(vRefUv.xy,frameCount*0.1));vec4 rotationMatrix=vec4(cos(rnd),-sin(rnd),0.,0.);rotationMatrix.z=-rotationMatrix.y;rotationMatrix.w=rotationMatrix.x;vec3 colorSum=color.rgb*color.a;float weightSum=0.001+color.a;vec2 ofs;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));ofs=vRefUv.xy+vRefUv.w*blurDist*ofs/tRefDiffuseSize.xy;color=texture2D(tRefDiffuse,ofs/vRefUv.w,mip);colorSum+=color.rgb*color.a;weightSum+=color.a;}\n#pragma unroll_loop_end\nreturn vec4(colorSum/weightSum,1.);}" : "",
        computeCacheKey: e => this.enabled + " " + e.materialObject.transparent + " " + this.reflectorModePhysical + " ",
        onObjectRender: (e, {
          materialObject: t
        }) => {
          t.userData.__lastTransparent !== t.transparent && (t.needsUpdate = !0, t.userData.__lastTransparent = t.transparent);
        },
        isCompatible: e => e.isMeshStandardMaterial2
      }, this.material = void 0, this._renderTarget = t, this._renderTarget.depthTexture = new i.$YQ(t.width / 2, t.height / 2, i.ywz);

      const r = new i.JOQ(),
            s = new i.Pa4(),
            o = new i.Pa4(),
            a = new i.Pa4(),
            l = new i.yGw(),
            c = new i.Pa4(0, 0, -1),
            u = new i.Ltg(),
            p = new i.Pa4(),
            h = new i.Pa4(),
            d = new i.Ltg(),
            f = new i.yGw(),
            _ = new i.cPb();

      i.M8C.isPowerOfTwo(t.texture.image.width) && i.M8C.isPowerOfTwo(t.texture.image.height) || (this._renderTarget.texture.generateMipmaps = !1), this.onBeforeRender = (e, t, i) => {
        if (!this.enabled || !e.userData.mainRenderPass) return;
        if (!this.reflectionTargetNeedsUpdate) return;
        const m = i.view ? Object.assign({}, i.view) : null;
        if (m && i.clearViewOffset && i.clearViewOffset(), o.setFromMatrixPosition(this.matrixWorld), a.setFromMatrixPosition(i.matrixWorld), l.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(l), p.subVectors(o, a), p.dot(s) > 0) return;
        p.reflect(s).negate(), p.add(o), l.extractRotation(i.matrixWorld), c.set(0, 0, -1), c.applyMatrix4(l), c.add(a), h.subVectors(o, c), h.reflect(s).negate(), h.add(o), _.position.copy(p), _.up.set(0, 1, 0), _.up.applyMatrix4(l), _.up.reflect(s), _.lookAt(h), _.far = 2, _.near = 0, _.updateMatrixWorld(), _.projectionMatrix.copy(i.projectionMatrix), f.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), f.multiply(_.projectionMatrix), f.multiply(_.matrixWorldInverse), f.multiply(this.matrixWorld), r.setFromNormalAndCoplanarPoint(s, o), r.applyMatrix4(_.matrixWorldInverse), u.set(r.normal.x, r.normal.y, r.normal.z, r.constant);
        const g = _.projectionMatrix;
        d.x = (Math.sign(u.x) + g.elements[8]) / g.elements[0], d.y = (Math.sign(u.y) + g.elements[9]) / g.elements[5], d.z = -1, d.w = (1 + g.elements[10]) / g.elements[14], u.multiplyScalar(2 / u.dot(d)), g.elements[2] = u.x, g.elements[6] = u.y, g.elements[10] = u.z + 1 - n, g.elements[14] = u.w, this.visible = !1;
        const v = e.getRenderTarget(),
              b = e.xr.enabled,
              x = e.shadowMap.autoUpdate;
        e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(this._renderTarget), e.state.buffers.depth.setMask(!0), !1 === e.autoClear && e.clear();
        const y = t.background;
        this.transparentReflectionBackground && (t.background = null);
        const w = !this.transparentReflectionBackground;
        y && w && (y.userData.flipX = !y.userData.flipX), K(e, {
          shadowMapRender: !1,
          backgroundRender: w,
          opaqueRender: !0,
          transparentRender: !0,
          transmissionRender: !1,
          screenSpaceRendering: !1
        }, () => e.render(t, _)), y && w && (y.userData.flipX = !y.userData.flipX || void 0), this.transparentReflectionBackground && (t.background = y), e.xr.enabled = b, e.shadowMap.autoUpdate = x, e.setRenderTarget(v), (null == m ? void 0 : m.enabled) && i.setViewOffset && i.setViewOffset(m.fullWidth, m.fullHeight, m.offsetX, m.offsetY, m.width, m.height);
        const S = i.viewport;
        void 0 !== S && e.state.viewport(S), this.visible = !0, this.reflectionTargetNeedsUpdate = !1;
      }, this.textureMatrix = f, this.materialExtension.extraUniforms.tRefDiffuse.value = this._renderTarget.texture, this.materialExtension.extraUniforms.tRefDiffuseSize.value = new i.FM8(this._renderTarget.width, this._renderTarget.height), this.materialExtension.extraUniforms.tRefDepth.value = this._renderTarget.depthTexture, this.materialExtension.extraUniforms.refTextureMatrix.value = f;
    }

    _updateExtension() {
      var e, t;
      this.transparentReflectionBackground = this.reflectorModePhysical, null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e);
    }

    getRenderTarget() {
      return this._renderTarget;
    }

  }

  Hc([C(Wc.prototype._updateExtension)], Wc.prototype, "enabled", void 0), Hc([C(Wc.prototype._updateExtension)], Wc.prototype, "reflectorModePhysical", void 0), Wc.prototype.isReflector = !0;

  var Kc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Xc extends zs {
    constructor(e = {}) {
      super(), this._transformNeedRefresh = !0, this.dependencies = [js], this.visible = !0, this.size = 8, this.yOffset = 0, this.renderToDepth = !0, this.tonemapGround = !0, this._refreshMaterial = this._refreshMaterial.bind(this), this._refreshTransform = this._refreshTransform.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._refreshOptions2 = this._refreshOptions2.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this._preRender = this._preRender.bind(this), this._postFrame = this._postFrame.bind(this), this._geometry = new i.BKK(1, 1, 1, 1), this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = !0, this._options = {
        shape: "",
        up: [0, 100, 0],
        autoAdjustTransform: !0
      }, this.setOptions(e);
    }

    get enabled() {
      return this.visible;
    }

    set enabled(e) {
      this.visible = e;
    }

    get material() {
      return this._material;
    }

    get mesh() {
      return this._iMesh;
    }

    _createMesh() {
      return new i.Kj0(this._geometry);
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), e.getPluginByType("TweakpaneUi") && console.error("TweakpaneUiPlugin must be added after Ground Plugin"), this._manager = e.getPlugin(js);

      const r = this._createMesh();

      r.userData.physicsMass = 0, this._iMesh = await (null === (t = this._manager) || void 0 === t ? void 0 : t.addImportedSingle(r, {
        pseudoCenter: !1,
        autoScale: !1,
        addToRoot: !0
      })), this._mesh = null === (n = this._iMesh) || void 0 === n ? void 0 : n.modelObject, this._mesh && (this._mesh.userData.userSelectable = !1, this._mesh.castShadow = !0, this._mesh.receiveShadow = !0, this._mesh.name = "Ground Plane"), e.scene.addEventListener("sceneUpdate", this._onSceneUpdate), e.scene.addEventListener("addSceneObject", this._onSceneUpdate), e.addEventListener("preRender", this._preRender), e.addEventListener("postFrame", this._postFrame), this.refreshOptions();
    }

    _postFrame() {
      this._transformNeedRefresh && this._refreshTransform(), this._viewer;
    }

    _preRender() {
      this._viewer;
    }

    async onDispose(e) {
      var t;
      return this._geometry.dispose(), null === (t = this._iMesh) || void 0 === t || t.dispose(), super.onDispose(e);
    }

    async onRemove(e) {
      return this._removeMaterial(), e.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), e.scene.removeEventListener("addSceneObject", this._onSceneUpdate), e.removeEventListener("postFrame", this._postFrame), e.removeEventListener("preRender", this._preRender), this._manager = void 0, super.onRemove(e);
    }

    _removeMaterial() {
      var e, t;
      this._material && (null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t || t.unregisterMaterial(this._material), this._material.userData.renderToDepth = this._material.userData.__renderToDepth, this._material.userData.__renderToDepth = void 0, this._material = void 0);
    }

    _onSceneUpdate(e) {
      !1 !== e.geometryChanged && !1 !== e.updateGround && this.refreshTransform();
    }

    refreshTransform() {
      this._transformNeedRefresh = !0;
    }

    _refreshOptions2() {
      this.refreshOptions();
    }

    refreshOptions() {
      this._viewer && (this._refreshMaterial(), this.refreshTransform());
    }

    _refreshTransform() {
      var e;
      if (!this._mesh) return;
      if (!this._viewer) return;
      let t = !1;

      if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible, t = !0), this.enabled) {
        if (this._options.autoAdjustTransform) {
          this._mesh.userData.bboxVisible = !1;

          const e = this._viewer.scene.getBounds(!0);

          this._mesh.userData.bboxVisible = !0;
          const n = e.getCenter(new i.Pa4()).sub(new i.Pa4(0, e.getSize(new i.Pa4()).y / 2 + this.yOffset, 0));
          t = t || n.clone().sub(this._mesh.position).length() > 1e-4, t && this._mesh.position.copy(n);
        }

        t = t || Math.abs(this._mesh.scale.x - this.size) > 1e-4, t && (this._mesh.scale.setScalar(this.size), this._mesh.setRotationFromEuler(new i.USm(-Math.PI / 2, 0, 0)), this._mesh.matrixWorldNeedsUpdate = !0, this._mesh.userData.setDirty()), this._transformNeedRefresh = !1;
      } else t && (null === (e = this._viewer) || void 0 === e || e.scene.setDirty());
    }

    _refreshMaterial() {
      var e, t, n, r, i, s, o, a, l;
      if (!this._viewer) return !1;
      if (!this.enabled) return !1;
      this._manager || console.error("GroundPlugin requires asset manager");
      const c = null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.findOrCreate(null !== (r = null === (n = this._material) || void 0 === n ? void 0 : n.uuid) && void 0 !== r ? r : "standard", {
        name: "BaseGroundMaterial",
        runtimeMaterial: !0,
        color: 16777215
      });
      let u = !1;

      if ((null == c ? void 0 : c.uuid) !== (null === (i = this._material) || void 0 === i ? void 0 : i.uuid)) {
        if (this._removeMaterial(), c && (this._material = c), (null === (s = this._material) || void 0 === s ? void 0 : s.uuid) || console.warn("No material found for ground"), this._viewer.scene.setDirty(), this._mesh && this._material) {
          this._material.roughness = .2, this._material.metalness = .5;
          const e = null !== (l = null === (a = null === (o = this._mesh) || void 0 === o ? void 0 : o.userData) || void 0 === a ? void 0 : a.setMaterial) && void 0 !== l ? l : e => {
            this._mesh && (this._mesh.material = e.materialObject);
          };
          e(this._material);
        }

        u = !0;
      }

      return this._material && (void 0 === this._material.userData.__renderToDepth && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth), this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth, this._viewer.setDirty()), void 0 === this._material.userData.__postTonemap && (this._material.userData.__postTonemap = this._material.userData.postTonemap), this._material.userData.postTonemap !== this.tonemapGround && (this._material.userData.postTonemap = this.tonemapGround, this._viewer.setDirty()), this._material.materialObject.userData.ssaoDisabled = !0, this._material.materialObject.userData.sscsDisabled = !0), u;
    }

    setOptions(e) {
      Object.assign(this._options, e), this.refreshOptions();
    }

    fromJSON(e, t) {
      return super.fromJSON(e, t) ? (this.refreshOptions(), this) : null;
    }

    _extraUiConfig() {
      return [() => {
        var e;
        return null === (e = this._material) || void 0 === e ? void 0 : e.uiConfig;
      }];
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Ground",
        children: [{
          label: "Visible",
          type: "checkbox",
          property: [this, "visible"],
          limitedUi: !0
        }, {
          label: "Size",
          type: "input",
          property: [this, "size"],
          limitedUi: !0
        }, {
          label: "Render to Depth",
          type: "checkbox",
          property: [this, "renderToDepth"]
        }, {
          label: "Tonemap",
          type: "checkbox",
          property: [this, "tonemapGround"]
        }, {
          label: "Height",
          type: "slider",
          bounds: [-2, 2],
          property: [this, "yOffset"]
        }, ...this._extraUiConfig()]
      };
    }

  }

  Kc([xe("material")], Xc.prototype, "_material", void 0), Kc([C(Xc.prototype.refreshTransform), xe()], Xc.prototype, "visible", void 0), Kc([C(Xc.prototype._onSceneUpdate), xe()], Xc.prototype, "size", void 0), Kc([C(Xc.prototype._onSceneUpdate), xe()], Xc.prototype, "yOffset", void 0), Kc([C(Xc.prototype._refreshOptions2), xe()], Xc.prototype, "renderToDepth", void 0), Kc([C(Xc.prototype._refreshOptions2), xe()], Xc.prototype, "tonemapGround", void 0);

  var qc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Yc extends Xc {
    constructor(e = {}, t = !1) {
      super(e), this.bakedShadows = !0, this.groundReflection = !0, this.physicalReflections = !1, this._showDebug = t, t && this.dependencies.push(Ac), this._onSceneUpdate = this._onSceneUpdate.bind(this);
    }

    get shadowBaker() {
      return this._shadowBaker;
    }

    _createMesh() {
      const e = new Wc(this._geometry, this._viewer.renderer.createTarget({
        type: i.ywz,
        format: i.wk1,
        encoding: i.rnI,
        size: {
          width: 1024,
          height: 1024
        },
        generateMipmaps: !0,
        depthBuffer: !0,
        minFilter: i.D1R,
        magFilter: i.wem,
        isAntialiased: !1
      })),
            t = e.onBeforeRender;
      return e.onBeforeRender = (...e) => {
        var n, r;
        let i = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("SSReflection")) || void 0 === r ? void 0 : r.passes.ssr.passObject;
        i && !i.enabled && (i = void 0), i && (i.enabled = !1), t(...e), i && (i.enabled = !0);
      }, e;
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this._showDebug && (null === (t = e.getPlugin(Ac)) || void 0 === t || t.addTexture("bake_ground_1", () => {
        var e, t;
        return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light.shadow.map) || void 0 === t ? void 0 : t.texture;
      }, [100, 100, 200, 200]), null === (n = e.getPlugin(Ac)) || void 0 === n || n.addTexture("bake_ground_2", () => {
        var e, t;
        return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.target) || void 0 === t ? void 0 : t.texture;
      }, [100, 400, 400, 400], "texel = vec4(vec3(unpackRGBAToDepth(texel)), 1.0);"));
    }

    _postFrame() {
      var e;
      super._postFrame(), this._viewer && this.enabled && this.bakedShadows && (null === (e = this._shadowBaker) || void 0 === e || e.autoUpdateShadow());
    }

    _preRender() {
      super._preRender(), this._viewer && (this._mesh.reflectionTargetNeedsUpdate = this._viewer.renderer.frameCount < 1);
    }

    async onDispose(e) {
      return super.onDispose(e);
    }

    async onRemove(e) {
      return super.onRemove(e);
    }

    _removeMaterial() {
      var e, t, n, r;

      if (this._material) {
        if (this._shadowBaker && this._material.groundMatExtension && (null === (t = (e = this._material).unregisterMaterialExtensions) || void 0 === t || t.call(e, [this._shadowBaker.materialExtension]), delete this._material.groundMatExtension), this._material.reflectorMatExtension) {
          const e = this._mesh.materialExtension;
          e || console.warn("unable to find the extension to unregister"), null === (r = (n = this._material).unregisterMaterialExtensions) || void 0 === r || r.call(n, [e]), delete this._material.reflectorMatExtension;
        }

        super._removeMaterial();
      }
    }

    _onSceneUpdate(e) {
      var t;
      super._onSceneUpdate(e), !1 !== e.geometryChanged && (null === (t = this._shadowBaker) || void 0 === t || t.reset());
    }

    refreshOptions() {
      if (!this._viewer) return;
      this.bakedShadows && !this._shadowBaker ? (this._shadowBaker = new Vc(this._viewer), this._shadowBaker.attachedMesh = this._mesh) : !this.bakedShadows && this._shadowBaker && (this._shadowBaker.reset(), this._shadowBaker.cleanupMaterial());
      const e = this._mesh;
      e.isReflector2 && (e.enabled = this.groundReflection, e.reflectorModePhysical = this.physicalReflections), super.refreshOptions();
    }

    _refreshMaterial() {
      var e, t, n, r;
      if (!this._viewer) return !1;

      const i = super._refreshMaterial();

      if (!this._material) return i;

      if (this.groundReflection && this._mesh.isReflector2 && !this._material.reflectorMatExtension) {
        const n = this._mesh.materialExtension;
        n.updaters = [this._viewer.scene, this._viewer.renderer], null === (t = (e = this._material).registerMaterialExtensions) || void 0 === t || t.call(e, [n]), this._material.reflectorMatExtension = !0;
      }

      return this.bakedShadows && this._shadowBaker && !this._material.groundMatExtension && (null === (r = (n = this._material).registerMaterialExtensions) || void 0 === r || r.call(n, [this._shadowBaker.materialExtension]), this._material.groundMatExtension = !0), this._material.materialObject.userData.ssreflDisabled = this.groundReflection, this._material.materialObject.userData.ssreflNonPhysical = !this.physicalReflections, i;
    }

    _extraUiConfig() {
      var e, t, n, r, i, s, o, a, l, c, u, p, h, d, f, _, m, g, v, b, x, y, w, S, M, T, E, A, C, R;

      return [{
        label: "Baked Shadows",
        type: "checkbox",
        property: [this, "bakedShadows"]
      }, {
        label: "Shadow Frames",
        type: "input",
        hidden: () => !this._shadowBaker,
        stepSize: 1,
        bounds: [1, 1e3],
        property: [this._shadowBaker, "maxFrameNumber"]
      }, {
        label: "Alpha Vignette",
        type: "checkbox",
        hidden: () => !this._material || this._material.transmission < 1e-4 && !this._material.transparent,
        property: [this._shadowBaker, "alphaVignette"],
        limitedUi: !0,
        onChange: () => {
          var e, t;
          return null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e, "postFrame", !0);
        }
      }, {
        label: "Alpha Vignette Axis",
        type: "dropdown",
        hidden: () => {
          var e;
          return !(null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.alphaVignette) || !this._material || this._material.transmission < 1e-4 && !this._material.transparent;
        },
        property: [this._shadowBaker, "alphaVignetteAxis"],
        children: ["x", "y", "xy"].map(e => ({
          label: e,
          value: e
        })),
        limitedUi: !0
      }, {
        label: "Planar Reflections",
        type: "checkbox",
        property: [this, "groundReflection"],
        limitedUi: !0
      }, {
        label: "Physical Reflections",
        type: "checkbox",
        property: [this, "physicalReflections"],
        limitedUi: !0
      }, {
        label: "Shadow type",
        type: "dropdown",
        hidden: () => !this._shadowBaker,
        property: [this._shadowBaker, "groundMapMode"],
        children: [{
          label: "aoMap"
        }, {
          label: "map"
        }, {
          label: "alphaMap"
        }],
        limitedUi: !0
      }, {
        type: "folder",
        label: "Randomized Light",
        hidden: () => !this._shadowBaker,
        limitedUi: !0,
        children: [{
          type: "color",
          label: "Color",
          property: [null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 100],
          property: [null === (t = this._shadowBaker) || void 0 === t ? void 0 : t.light, "intensity"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [null === (r = null === (n = this._shadowBaker) || void 0 === n ? void 0 : n.light) || void 0 === r ? void 0 : r.shadowParams, "enabled"],
          onChange: [null === (s = null === (i = this._shadowBaker) || void 0 === i ? void 0 : i.light) || void 0 === s ? void 0 : s.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [null === (a = null === (o = this._shadowBaker) || void 0 === o ? void 0 : o.light) || void 0 === a ? void 0 : a.randomParams, "focus"],
          onChange: [this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [null === (c = null === (l = this._shadowBaker) || void 0 === l ? void 0 : l.light) || void 0 === c ? void 0 : c.randomParams, "spread"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [.01, 60],
          property: [null === (p = null === (u = this._shadowBaker) || void 0 === u ? void 0 : u.light) || void 0 === p ? void 0 : p.randomParams, "distanceScale"],
          onChange: [null === (d = null === (h = this._shadowBaker) || void 0 === h ? void 0 : h.light) || void 0 === d ? void 0 : d.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "vec3",
          bounds: [-1, 1],
          property: [null === (_ = null === (f = this._shadowBaker) || void 0 === f ? void 0 : f.light) || void 0 === _ ? void 0 : _.randomParams, "direction"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "vec3",
          bounds: [-1, 1],
          property: [null === (g = null === (m = this._shadowBaker) || void 0 === m ? void 0 : m.light) || void 0 === g ? void 0 : g.randomParams, "normalDirection"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [.01, 10],
          property: [null === (b = null === (v = this._shadowBaker) || void 0 === v ? void 0 : v.light) || void 0 === b ? void 0 : b.shadowParams, "radius"],
          onChange: [null === (y = null === (x = this._shadowBaker) || void 0 === x ? void 0 : x.light) || void 0 === y ? void 0 : y.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "input",
          property: [null === (S = null === (w = this._shadowBaker) || void 0 === w ? void 0 : w.light) || void 0 === S ? void 0 : S.shadowParams, "frustumSize"],
          onChange: [null === (T = null === (M = this._shadowBaker) || void 0 === M ? void 0 : M.light) || void 0 === T ? void 0 : T.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [-.1, .1],
          property: [null === (A = null === (E = this._shadowBaker) || void 0 === E ? void 0 : E.light) || void 0 === A ? void 0 : A.shadowParams, "bias"],
          onChange: [null === (R = null === (C = this._shadowBaker) || void 0 === C ? void 0 : C.light) || void 0 === R ? void 0 : R.updateShadowParams, this._onSceneUpdate]
        }]
      }, ...super._extraUiConfig()];
    }

  }

  Yc.PluginType = "Ground", qc([C(Yc.prototype.refreshOptions), xe()], Yc.prototype, "bakedShadows", void 0), qc([C(Yc.prototype.refreshOptions), xe()], Yc.prototype, "groundReflection", void 0), qc([C(Yc.prototype.refreshOptions), xe()], Yc.prototype, "physicalReflections", void 0), qc([xe("shadowBaker")], Yc.prototype, "_shadowBaker", void 0);

  var Zc,
      Jc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let $c = Zc = class extends It {
    constructor() {
      super({
        vertexShader: s.vertexShader,
        defines: {
          PASS_STEP: 1
        },
        uniforms: {
          tSource: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          opacity: {
            value: 1
          },
          tDiffuseSize: {
            value: new i.FM8()
          },
          weight: {
            value: 1
          },
          tNormalDepth: {
            value: null
          }
        },
        fragmentShader: Bt + "\nuniform float intensity;uniform float opacity;uniform vec2 tDiffuseSize;varying vec2 vUv;uniform float weight;\n#if PASS_STEP == 0\nuniform vec4 prefilter;vec4 Prefilter(vec4 c){if(getDepth(vUv)>0.999){return vec4(0.);}float brightness=max(c.r,max(c.g,c.b));float soft=brightness+prefilter.x*(prefilter.y-1.);soft=clamp(soft,0.,prefilter.z);soft=soft*soft*prefilter.w;float contribution=max(soft,brightness-prefilter.x);contribution/=max(brightness,0.001);return vec4(c.rgb*contribution,c.a);}\n#endif\nvec4 Sample(vec2 uv){return tDiffuseTexelToLinear(texture2D(tDiffuse,uv));}vec4 SampleBox(vec2 uv,float delta){vec4 o=vec2(-delta,delta).xxyy/tDiffuseSize.xyxy;vec4 s=Sample(uv+o.xy)+Sample(uv+o.zy)+Sample(uv+o.xw)+Sample(uv+o.zw);return s*0.25;}void main(){\n#if PASS_STEP == 0 \ngl_FragColor=weight*Prefilter(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 1 \ngl_FragColor=weight*(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 2 \ngl_FragColor=(SampleBox(vUv,0.5));gl_FragColor.a=1.;\n#elif PASS_STEP == 3 \nvec4 texel=tSourceTexelToLinear(texture2D(tSource,vUv));vec4 bloom=intensity*SampleBox(vUv,0.5).rgba;float brightness=max(bloom.r,max(bloom.g,bloom.b));texel.rgb+=bloom.rgb;texel.a=min(1.,texel.a+brightness);gl_FragColor=texel;\n#elif PASS_STEP == 4 \nvec4 texel=vec4(0.);texel.rgb+=intensity*SampleBox(vUv,0.5).rgb;texel.a=1.;gl_FragColor=texel;\n#endif\n#include <encodings_fragment>\n}"
      }, "tDiffuse", "tSource"), this.uiConfig = void 0, this.prefilter = new i.Ltg(2, .5, 0, 0), this.threshold = 2, this.softThreshold = .5, this.intensity = .5, this.bloomIterations = 4, this.radius = .6, this.power = 1, this.bloomDebug = !1, this._weights = [], this._updateWeights = this._updateWeights.bind(this), this._thresholdsUpdated = this._thresholdsUpdated.bind(this), this._updateWeights(), this._thresholdsUpdated(), this.clear = !0, this.userData = {
        setDirty: () => {
          this.setDirty();
        }
      };
    }

    _thresholdsUpdated() {
      this.prefilter.x = this.threshold, this.prefilter.y = this.softThreshold, this.prefilter.z = 2 * this.prefilter.x * this.prefilter.y, this.prefilter.w = .125 / (this.uniforms.prefilter.value.z + 1e-5);
    }

    render(e, t, n, r, s) {
      const o = e.baseRenderer;
      this.material.defines.PASS_STEP = 0, this.clear = !0;
      const a = n;
      let l = .5,
          c = a.width * l,
          u = a.height * l;
      const p = [];
      let h = o.getTempTarget({
        sizeMultiplier: .5,
        type: i.cLu
      });
      p.push(h);
      let d = a;
      this.material.needsUpdate = !0, this.material.uniforms.weight.value = this._weights[0], super.render(e, h, d, r, s), d = h;
      let f = 1;

      for (; f < this.bloomIterations && (c /= 2, u /= 2, l /= 2, !(u < 2 || c < 2)); f++) {
        h = o.getTempTarget({
          sizeMultiplier: l,
          type: i.cLu
        }), p.push(h), this.material.defines.PASS_STEP = 1;
        let t = this._weights[f];
        t = 0 !== this._weights[f - 1] ? this._weights[f] / this._weights[f - 1] : this._weights[f], this.material.uniforms.weight.value = t, this.material.needsUpdate = !0, super.render(e, h, d, r, s), d = h;
      }

      this.clear = !1;
      const _ = e.autoClear;

      for (e.autoClear = !1, f -= 2; f >= 0; f--) h = p[f], p[f] = void 0, this.material.defines.PASS_STEP = 2, this.material.transparent = !0, this.material.blending = i.WMw, this.material.needsUpdate = !0, e.autoClear = !1, super.render(e, h, d, r, s), this.material.blending = i.jFi, o.releaseTempTarget(d), d = h;

      this.clear = !0, e.autoClear = _, e.autoClear = !0, this.bloomDebug ? (this.material.defines.PASS_STEP = 4, this.material.needsUpdate = !0, super.render(e, t, d, r, s)) : (this.uniforms.tSource.value = a.texture, this.material.defines.PASS_STEP = 3, this.material.needsUpdate = !0, super.render(e, t, d, r, s), this.uniforms.tSource.value = null), o.releaseTempTarget(d);
    }

    _updateWeights() {
      if (!this._weights) return;
      const e = Math.max(Math.min(this.radius, 1), 0),
            t = 1 / (this.bloomIterations - 1);

      for (let n = 0; n < this.bloomIterations; n++) {
        let r = n * t + .1,
            i = 1.2 - r;
        r = Math.pow(r, this.power), i = Math.pow(i, this.power), this._weights[n] = i * (1 - e) + r * e;
      }

      this.setDirty();
    }

  };
  Jc([V()], $c.prototype, "prefilter", void 0), Jc([He("Threshold", [0, 2]), C(Zc.prototype._thresholdsUpdated), xe()], $c.prototype, "threshold", void 0), Jc([He("Soft Threshold", [0, 1]), C(Zc.prototype._thresholdsUpdated), xe()], $c.prototype, "softThreshold", void 0), Jc([He("Intensity", [0, 3]), xe(), V()], $c.prototype, "intensity", void 0), Jc([He("Iterations", [0, 7], 1), C(Zc.prototype._updateWeights), xe()], $c.prototype, "bloomIterations", void 0), Jc([He("Radius", [0, 1], .01), C(Zc.prototype._updateWeights), xe()], $c.prototype, "radius", void 0), Jc([He("Power", [.2, 10], .01), C(Zc.prototype._updateWeights), xe()], $c.prototype, "power", void 0), Jc([Ve("Debug")], $c.prototype, "bloomDebug", void 0), $c = Zc = Jc([Qe("Bloom")], $c);

  class Qc extends Gs {
    constructor() {
      super(...arguments), this.passId = "bloom", this._beforeFilters = ["tonemap", "screen"], this._afterFilters = ["render", "progressive"], this._requiredFilters = ["render"];
    }

    passCtor(e) {
      return new $c();
    }

    _update(e) {
      var t, n;
      return null === (t = e.getPlugin(Xs)) || void 0 === t || t.updateShaderProperties(null === (n = this.pass) || void 0 === n ? void 0 : n.passObject.material), super._update(e);
    }

    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }

    get params() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject;
    }

  }

  Qc.PluginType = "Bloom";

  var eu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let tu = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [js], this._defines = {
        ANISOTROPY_DEBUG: !1
      }, this._uniforms = {
        anisotropyFactor: {
          value: 1
        },
        anisotropyNoise: {
          value: 1
        },
        anisotropyDirection: {
          value: 1
        },
        anisotropyDirectionMap: {
          value: null
        },
        frameCount: {
          value: 0
        }
      }, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          var r;
          if (!this.enabled || !t.materialObject.userData._isAnisotropic) return;
          const s = null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._anisotropyDirectionMap,
                o = M`
                #include <bsdfs>
                //#if ANISOTROPY_ENABLED
                ${xo}
                ${"uniform float anisotropyFactor;uniform float anisotropyNoise;\n#if ANISOTROPY_TEX_MODE == 0\nuniform float anisotropyDirection;\n#else\nuniform sampler2D anisotropyDirectionMap;\n#endif\nconst float MIN_ROUGHNESS=0.05;float D_GGX_Anisotropy(float at,float ab,float ToH,float BoH,float NoH){float a2=at*ab;highp vec3 d=vec3(ab*ToH,at*BoH,a2*NoH);highp float d2=dot(d,d);float b2=a2/d2;return a2*b2*b2*(1./PI);}float V_GGX_SmithCorrelated_Anisotropy(float at,float ab,float ToV,float BoV,float ToL,float BoL,float NoV,float NoL){float lambdaV=NoL*length(vec3(at*ToV,ab*BoV,NoV));float lambdaL=NoV*length(vec3(at*ToL,ab*BoL,NoL));float v=0.5/(lambdaV+lambdaL);return saturate(v);}vec3 indirectAnisotropyBentNormal(const in vec3 normal,const in vec3 viewDir,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){vec3 aDirection=anisotropyFactor>=0.?anisotropicB:anisotropicT;vec3 aTangent=cross(aDirection,viewDir);vec3 aNormal=cross(aTangent,aDirection);float bendFactor=abs(anisotropyFactor)*saturate(5.*max(roughness,MIN_ROUGHNESS));return normalize(mix(normal,aNormal,bendFactor));}vec3 BRDF_GGX_Anisotropy(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));float dotTV=dot(anisotropicT,viewDir);float dotBV=dot(anisotropicB,viewDir);float dotTL=dot(anisotropicT,lightDir);float dotBL=dot(anisotropicB,lightDir);float dotTH=dot(anisotropicT,halfDir);float dotBH=dot(anisotropicB,halfDir);float aspect=sqrt(1.-min(1.-MIN_ROUGHNESS,abs(anisotropyFactor)*0.9));if(anisotropyFactor>0.)aspect=1./aspect;float at=roughness*aspect;float ab=roughness/aspect;vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated_Anisotropy(at,ab,dotTV,dotBV,dotTL,dotBL,dotNV,dotNL);float D=D_GGX_Anisotropy(at,ab,dotTH,dotBH,dotNH);return F*(V*D);}"}
            ` + (s ? U("anisotropyDirectionMap", s, n.capabilities.isWebGL2) : "");
          e.fragmentShader = e.fragmentShader.replace("#include <bsdfs>", o), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", i.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("IncidentLight directLight;", "float rnd=(random2(vUv.xy,frameCount)-0.5)*anisotropyNoise*material.roughness;\n#if ANISOTROPY_TEX_MODE < 2\n#if ANISOTROPY_TEX_MODE == 0 \nfloat rot=saturate(anisotropyDirection);\n#else \nfloat rot=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).r);\n#endif\nrot=rot*2.*PI+rnd;vec2 rot2=vec2(sin(rot),cos(rot));\n#else \nvec2 rot2=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).rg*2.-1.)+vec2(rnd,rnd);rot2=normalize(rot2);const float anisoSpecMultiplier=0.25;float matSpecAniso=(length(material.specularColor.rgb))*2.*PI;rot2=mix(rot2,vec2(sin(matSpecAniso),cos(matSpecAniso)),anisoSpecMultiplier);rot2=normalize(rot2);\n#endif\nvec3 anisotropicT=(tangent*rot2.x+bitangent*rot2.y);anisotropicT=normalize(anisotropicT-normal*dot(anisotropicT,normal));vec3 anisotropicB=normalize(cross(normal,anisotropicT));IncidentLight directLight;").replaceAll("RE_Direct( directLight, geometry, material, reflectedLight )", "RE_Direct( directLight, geometry, material, reflectedLight, anisotropicT, anisotropicB )");
          const a = i.WdD.lights_physical_pars_fragment.replace("void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {", "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, const in vec3 anisotropicT, const in vec3 anisotropicB ) {").replace("BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness )", "BRDF_GGX_Anisotropy( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness, anisotropicT, anisotropicB )");
          e.fragmentShader = e.fragmentShader.replace("#include <lights_physical_pars_fragment>", a);
          const l = M`
                #if defined( USE_ENVMAP )
                vec3 anisotropyBentNormal = indirectAnisotropyBentNormal(geometry.normal, geometry.viewDir, material.roughness, anisotropicT, anisotropicB);
                #endif
            ` + i.WdD.lights_fragment_maps.replace("getIBLIrradiance( geometry.normal )", "getIBLIrradiance( anisotropyBentNormal )").replace("getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness )", "getIBLRadiance( geometry.viewDir, anisotropyBentNormal, material.roughness )");
          e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_maps>", l), e.vertexUvs = !0, e.vertexTangents = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = t.materialObject.userData;
          if (!(null == r ? void 0 : r._isAnisotropic)) return;
          const i = e;
          if (!i.isMesh || !i.geometry) return;
          if (!i.geometry.attributes.tangent) throw new Error("No tangents on the geometry");
          this._uniforms.anisotropyFactor.value = r._anisotropyFactor, this._uniforms.anisotropyNoise.value = r._anisotropyNoise, this._uniforms.anisotropyDirectionMap.value = (null === (n = r._anisotropyDirectionMap) || void 0 === n ? void 0 : n.isTexture) ? r._anisotropyDirectionMap : null, this._uniforms.anisotropyDirection.value = r._anisotropyDirection;
          let s = this.enabled ? 1 : 0;
          t.materialObject.defines.ANISOTROPY_ENABLED !== s && (t.materialObject.defines.ANISOTROPY_ENABLED = s, t.materialObject.needsUpdate = !0), s = +this._defines.ANISOTROPY_DEBUG, t.materialObject.defines.ANISOTROPY_DEBUG !== s && (t.materialObject.defines.ANISOTROPY_DEBUG = s, t.materialObject.needsUpdate = !0), s = r._anisotropyDirectionMode, this._uniforms.anisotropyDirectionMap.value || (s = "CONSTANT"), s = "DIRECTION" === s ? 2 : "ROTATION" === s ? 1 : 0, t.materialObject.defines.ANISOTROPY_TEX_MODE !== s && (t.materialObject.defines.ANISOTROPY_TEX_MODE = s, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n, r;
          return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._isAnisotropic) ? "1" : "0") + (null === (r = null === (n = e.materialObject.userData) || void 0 === n ? void 0 : n._anisotropyDirectionMap) || void 0 === r ? void 0 : r.uuid);
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => {
          var e;
          return [null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer];
        },
        getUiConfig: e => {
          const t = this.makeAnisotropic,
                n = {
            type: "folder",
            label: "Anisotropy",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                return e.materialObject.userData._isAnisotropic || !1;
              },

              set value(r) {
                var i;
                r !== e.materialObject.userData._isAnisotropic && (r ? t(e) || alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._isAnisotropic = !1, e.materialObject.needsUpdate = !0), null === (i = n.uiRefresh) || void 0 === i || i.call(n, "postFrame", !0));
              },

              onChange: this.setDirty
            }, {
              type: "slider",
              label: "Factor",
              bounds: [-2, 2],
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyFactor"],
              onChange: this.setDirty
            }, {
              type: "slider",
              label: "Noise",
              bounds: [0, 2],
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyNoise"],
              onChange: this.setDirty
            }, {
              type: "image",
              label: "Texture",
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyDirectionMap"],
              onChange: () => {
                e.materialObject.needsUpdate = !0, this.setDirty();
              }
            }, {
              type: "dropdown",
              label: "Mode",
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyDirectionMode"],
              children: ["CONSTANT", "ROTATION", "DIRECTION"].map(e => ({
                label: e
              })),
              onChange: () => {
                e.materialObject.needsUpdate = !0, this.setDirty();
              }
            }]
          };
          return n;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this.makeSelectedAnisotropic = () => {
        var e, t, n;
        const r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(gc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material;
        return "material" === (null == r ? void 0 : r.assetType) && this.makeAnisotropic(r);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    makeAnisotropic(e) {
      var t;
      const n = null === (t = e.materialObject) || void 0 === t ? void 0 : t.userData;
      if (!n) return !1;

      if (void 0 === n._isAnisotropic) {
        const e = n.appliedMeshes;
        let t = !0;
        if (e) for (const {
          geometry: n
        } of e) !n || n.index && n.attributes.position && n.attributes.normal && n.attributes.uv || (t = !1), t && !n.attributes.tangent && n.computeTangents();
        if (!t) return !1;
      }

      return n._isAnisotropic = !0, void 0 === n._anisotropyFactor && (n._anisotropyFactor = 1), void 0 === n._anisotropyNoise && (n._anisotropyNoise = 0), void 0 === n._anisotropyDirectionMode && (n._anisotropyDirectionMode = "DIRECTION"), e.materialObject.needsUpdate = !0, !0;
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new nu(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(js);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(ru);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };
  tu.PluginType = "AnisotropyPlugin", tu.ANISOTROPY_GLTF_EXTENSION = "WEBGI_materials_anisotropy", eu([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], tu.prototype, "enabled", void 0), eu([Xe("Make Anisotropy", e => ({
    hidden: () => {
      var t;
      return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc));
    }
  }))], tu.prototype, "makeSelectedAnisotropic", void 0), tu = eu([Qe("Anisotropy Materials")], tu);

  class nu {
    constructor(e) {
      this.parser = e, this.name = tu.ANISOTROPY_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      var n, r, s;
      const o = this.parser,
            a = o.json.materials[e];
      if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
      const l = [],
            c = a.extensions[this.name];
      t.userData || (t.userData = {}), t.userData._isAnisotropic = !0, t.userData._anisotropyFactor = null !== (n = c.anisotropyFactor) && void 0 !== n ? n : 0, t.userData._anisotropyNoise = null !== (s = null !== (r = c.anisotropyNoiseFactor) && void 0 !== r ? r : c.anisotropyNoise) && void 0 !== s ? s : 0;
      let {
        anisotropyDirectionMode: u,
        anisotropyDirection: p
      } = c;
      return u || (u = c.anisotropyTextureMode), p || (p = c.anisotropyRotation), t.userData._anisotropyDirectionMode = u && "number" == typeof (null == p ? void 0 : p.index) ? u : "CONSTANT", "ROTATION" === u || "DIRECTION" === u ? l.push(o.assignTexture(t.userData, "_anisotropyDirectionMap", p).then(e => {
        e.encoding = i.knz;
      })) : t.userData._anisotropyDirection = null != p ? p : 0, Promise.all(l);
    }

    afterRoot(e) {
      return e.scene.traverse(e => {
        var t, n;
        if (!(null === (n = null === (t = e.material) || void 0 === t ? void 0 : t.userData) || void 0 === n ? void 0 : n._isAnisotropic)) return;
        const r = e.geometry;
        r.attributes.tangent || (r.computeTangents(), r.attributes.tangent.needsUpdate = !0);
      }), null;
    }

  }

  const ru = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._isAnisotropic) return;
      if ((t.userData._anisotropyFactor || 0) < .001) return;
      n.extensions = n.extensions || {};
      const r = {};

      if (r.anisotropyFactor = t.userData._anisotropyFactor || 1, r.anisotropyNoiseFactor = t.userData._anisotropyNoise || 0, r.anisotropyDirectionMode = t.userData._anisotropyDirectionMode || "CONSTANT", t.userData._anisotropyDirectionMap && "CONSTANT" !== r.anisotropyDirectionMode) {
        const n = {
          index: e.processTexture(t.userData._anisotropyDirectionMap)
        };
        e.applyTextureTransform(n, t.userData._anisotropyDirectionMap), r.anisotropyDirection = n;
      } else r.anisotropyDirectionMode = "CONSTANT", r.anisotropyDirection = t.userData._anisotropyDirection || 0;

      n.extensions[tu.ANISOTROPY_GLTF_EXTENSION] = r, e.extensionsUsed[tu.ANISOTROPY_GLTF_EXTENSION] = !0;
    }
  });

  var iu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let su = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [js], this._defines = {}, this._uniforms = {
        thinBaseLayerFactors: {
          value: new i.Ltg()
        },
        thinNoiseLayerFactors: {
          value: new i.Ltg()
        },
        thinColorNoiseParams: {
          value: new i.Ltg()
        },
        thinFilmFactor: {
          value: .8
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var n;
          return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._thinFilmLayer) || void 0 === n ? void 0 : n.hasThinFilm) ? xo + "\n#ifndef VORONOISE_HELPER\n#define VORONOISE_HELPER\nfloat voronoise(in vec2 p,float u,float v){float k=1.+63.*pow(1.-v,6.);vec2 i=floor(p);vec2 f=fract(p);vec2 a=vec2(0.,0.);for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++){vec2 g=vec2(x,y);vec3 o=hash3(i+g)*vec3(u,u,1.);vec2 d=g-f+o.xy;float w=pow(1.-smoothstep(0.,1.414,length(d)),k);a+=vec2(o.z*w,w);}return a.x/a.y;}vec3 voronoise3(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),voronoise(p-vec2(0.83,0.45),u,v));}vec3 voronoiseNormal(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),1.);}\n#endif\n\n#ifndef HSV_HELPERS\n#define HSV_HELPERS\nvec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=c.g<c.b?vec4(c.bg,K.wz):vec4(c.gb,K.xy);vec4 q=c.r<p.x?vec4(p.xyw,c.r):vec4(c.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n#endif \n\nuniform vec4 thinBaseLayerFactors;\nuniform vec4 thinNoiseLayerFactors;\nuniform vec4 thinColorNoiseParams;\nuniform float thinFilmFactor;\n        " : "";
        },
        shaderExtender: (e, t, n) => {
          var r;
          if (!this.enabled || !(null === (r = t.materialObject.userData._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm)) return;
          const i = "#glMarker beforeAccumulation";
          e.fragmentShader = e.fragmentShader.replace(i, "vec3 incident=normalize(vViewPosition.xyz);float hWeight=1.-dot(normal,incident);vec3 noiseV=voronoise3(vUv.xy*thinColorNoiseParams.xy*60.,thinColorNoiseParams.z,thinColorNoiseParams.w);float hWeight2=1.-dot(normalize(noiseV),incident);vec3 film=hsv2rgb(vec3(fract(hWeight+thinBaseLayerFactors.x),thinBaseLayerFactors.y,thinBaseLayerFactors.z))*thinBaseLayerFactors.a;vec3 film2=hsv2rgb(vec3(fract(hWeight2+thinNoiseLayerFactors.x),thinNoiseLayerFactors.y,thinNoiseLayerFactors.z))*thinNoiseLayerFactors.a;film=(film+film2)/(thinBaseLayerFactors.a+thinNoiseLayerFactors.a);diffuseColor.rgb=mix(diffuseColor.rgb,film,thinFilmFactor);" + i), e.vertexUvs = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._thinFilmLayer;
          if (!(null == r ? void 0 : r.hasThinFilm)) return;
          this._uniforms.thinBaseLayerFactors.value.fromArray(r.baseLayerFactors), this._uniforms.thinNoiseLayerFactors.value.fromArray(r.noiseLayerFactors), this._uniforms.thinColorNoiseParams.value.fromArray(r.colorNoiseParams), this._uniforms.thinFilmFactor.value = r.filmFactor;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.THIN_FILM_LAYER_ENABLED !== i && (t.materialObject.defines.THIN_FILM_LAYER_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n;
          return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._thinFilmLayer) || void 0 === n ? void 0 : n.hasThinFilm) ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = {
            type: "folder",
            label: "ThinFilmLayer",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                var t;
                return (null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm) || !1;
              },

              set value(n) {
                var r, i;
                n !== (null === (r = e.materialObject.userData._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm) && (n ? ou(e.materialObject) || alert("Cannot add thin film.") : (e.materialObject.userData._thinFilmLayer.hasThinFilm = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0));
              },

              onChange: this.setDirty
            }, () => ({
              type: "slider",
              bounds: [0, 1],
              label: "Intensity",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "filmFactor"],
              onChange: this.setDirty
            }), () => ({
              type: "vec4",
              label: "Base Layer",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "baseLayerFactors"],
              onChange: this.setDirty
            }), () => ({
              type: "vec4",
              label: "Noise Layer",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "noiseLayerFactors"],
              onChange: this.setDirty
            }), () => ({
              type: "vec4",
              label: "Noise Params",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "colorNoiseParams"],
              onChange: this.setDirty
            })]
          };
          return t;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    addThinFilmLayer(e) {
      return ou(e.materialObject);
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new au(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(js);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(lu);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };

  function ou(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._thinFilmLayer || (t._thinFilmLayer = {});
    const n = t._thinFilmLayer;
    return n.hasThinFilm = !0, void 0 === n.baseLayerFactors && (n.baseLayerFactors = [.3, .6, 1, .9]), void 0 === n.noiseLayerFactors && (n.noiseLayerFactors = [.7, .5, .9, .7]), void 0 === n.colorNoiseParams && (n.colorNoiseParams = [.5, .5, .5, .7]), void 0 === n.filmFactor && (n.filmFactor = .3), e.isMaterial && (e.needsUpdate = !0), !0;
  }

  su.PluginType = "ThinFilmLayerPlugin", su.THIN_FILM_LAYER_GLTF_EXTENSION = "WEBGI_materials_thin_film_layer", iu([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], su.prototype, "enabled", void 0), su = iu([Qe("ThinFilmLayer Materials")], su);

  class au {
    constructor(e) {
      this.parser = e, this.name = su.THIN_FILM_LAYER_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.userData || (t.userData = {}), ou(t), t.userData._thinFilmLayer = Te(r, t.userData._thinFilmLayer, !1, {}), Promise.resolve();
    }

  }

  const lu = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._thinFilmLayer) return;
      if (!t.userData._thinFilmLayer.hasThinFilm) return;
      n.extensions = n.extensions || {};
      const r = Me(t.userData._thinFilmLayer, !1);
      n.extensions[su.THIN_FILM_LAYER_GLTF_EXTENSION] = r, e.extensionsUsed[su.THIN_FILM_LAYER_GLTF_EXTENSION] = !0;
    }
  });

  var cu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let uu = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [js], this._defines = {}, this._uniforms = {
        noiseBumpParams: {
          value: new i.FM8()
        },
        noiseBumpScale: {
          value: .05
        },
        noiseBumpFlakeScale: {
          value: 1e3
        },
        noiseFlakeClamp: {
          value: 1
        },
        noiseFlakeRadius: {
          value: .5
        },
        noiseFlakeRoughnessMod: {
          value: 1
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var n;
          return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._noiseBumpMat) || void 0 === n ? void 0 : n.hasBump) ? xo + "\n#ifndef VORONOI_HELPER\n#define VORONOI_HELPER\nfloat voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius?outColor:vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}\n#endif\n\nuniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform float noiseFlakeRoughnessMod;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n" : "";
        },
        shaderExtender: (e, t, n) => {
          var r;
          if (!this.enabled || !(null === (r = t.materialObject.userData._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump)) return;
          const i = "#glMarker beforeAccumulation";
          e.fragmentShader = e.fragmentShader.replace(i, "\n            vec3 outColor; \n            float voronoiDist = clamp(voronoi_f1_2d( noiseBumpFlakeScale * noiseBumpParams.xy * vUv, 1., noiseFlakeClamp, noiseFlakeRadius, outColor ), 0.0, 1.0);\n            normal = perturbNormalArb_nb( - vViewPosition, normal, (2. * outColor.xy - 1.) * noiseBumpScale, faceDirection ); \n            float avg = (outColor.r + outColor.g)*0.5; \n            diffuseColor *= (clamp(avg+0.5, 0.3, 1.));\n            float roughnessModifier = mix(1. - avg, 1., noiseFlakeRoughnessMod);\n            roughnessFactor *= roughnessModifier;\n            \n" + i), e.vertexUvs = !0, e.extensionDerivatives = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._noiseBumpMat;
          if (!(null == r ? void 0 : r.hasBump)) return;
          this._uniforms.noiseBumpParams.value.fromArray(r.bumpNoiseParams), this._uniforms.noiseBumpScale.value = r.bumpScale, this._uniforms.noiseBumpFlakeScale.value = r.flakeScale, this._uniforms.noiseFlakeClamp.value = r.flakeClamp, this._uniforms.noiseFlakeRadius.value = r.flakeRadius, this._uniforms.noiseFlakeRoughnessMod.value = r.flakeRoughnessMod;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED !== i && (t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n;
          return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._noiseBumpMat) || void 0 === n ? void 0 : n.hasBump) ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = {
            type: "folder",
            label: "NoiseBumpMaterial",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                var t;
                return (null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump) || !1;
              },

              set value(n) {
                var r, i;
                n !== (null === (r = e.materialObject.userData._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump) && (n ? pu(e.materialObject) || alert("Cannot add noise bump.") : (e.materialObject.userData._noiseBumpMat.hasBump = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0));
              },

              onChange: this.setDirty
            }, () => ({
              type: "vec4",
              label: "Bump Noise Params",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "bumpNoiseParams"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Bump Scale",
              bounds: [0, .01],
              stepSize: 1e-5,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "bumpScale"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Scale",
              bounds: [100, 1e4],
              stepSize: 1e-4,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeScale"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Clamp",
              bounds: [0, 1],
              stepSize: 1,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeClamp"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Radius",
              bounds: [.1, 1],
              stepSize: .01,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeRadius"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Roughness Modifier",
              bounds: [0, 1],
              stepSize: 1,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeRoughnessMod"],
              onChange: this.setDirty
            })]
          };
          return t;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    addNoiseBumpMaterial(e) {
      return pu(e.materialObject);
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new hu(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(js);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(du);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };

  function pu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._noiseBumpMat || (t._noiseBumpMat = {});
    const n = t._noiseBumpMat;
    return n.hasBump = !0, void 0 === n.bumpNoiseParams && (n.bumpNoiseParams = [.5, .5]), void 0 === n.bumpScale && (n.bumpScale = .05), void 0 === n.flakeScale && (n.flakeScale = .05), void 0 === n.flakeClamp && (n.flakeClamp = 1), void 0 === n.flakeRadius && (n.flakeRadius = .3), void 0 === n.flakeRoughnessMod && (n.flakeRoughnessMod = 1), e.isMaterial && (e.needsUpdate = !0), !0;
  }

  uu.PluginType = "NoiseBumpMaterialPlugin", uu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump", cu([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], uu.prototype, "enabled", void 0), uu = cu([Qe("NoiseBumpMaterial Materials")], uu);

  class hu {
    constructor(e) {
      this.parser = e, this.name = uu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.userData || (t.userData = {}), pu(t), t.userData._noiseBumpMat = Te(r, t.userData._noiseBumpMat, !1, {}), Promise.resolve();
    }

  }

  const du = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._noiseBumpMat) return;
      if (!t.userData._noiseBumpMat.hasBump) return;
      n.extensions = n.extensions || {};
      const r = Me(t.userData._noiseBumpMat, !1);
      n.extensions[uu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = r, e.extensionsUsed[uu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = !0;
    }
  });

  var fu,
      _u = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let mu = fu = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [js], this.bicubicFiltering = !0, this._defines = {
        CUSTOM_BUMP_MAP_DEBUG: !1,
        CUSTOM_BUMP_MAP_BICUBIC: !0
      }, this._uniforms = {
        customBumpUvTransform: {
          value: new i.Vkp()
        },
        customBumpScale: {
          value: .001
        },
        customBumpMap: {
          value: null
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => this.enabled && (null == t ? void 0 : t.materialObject.userData._hasCustomBump) ? "#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n#if CUSTOM_BUMP_MAP_BICUBIC > 0  \nvec4 cubic(float v){vec4 n=vec4(1.,2.,3.,4.)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.*s.x;float z=s.z-4.*s.y+6.*s.x;float w=6.-x-y-z;return vec4(x,y,z,w)*(1./6.);}vec4 textureBicubic(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1./texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic(fxy.x);vec4 ycubic=cubic(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}\n#endif\nvarying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);\n#if CUSTOM_BUMP_MAP_BICUBIC > 0\nfloat Hll=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#else\nfloat Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#endif\nreturn vec2(dBx,dBy);}\n#ifndef USE_BUMPMAP\nvec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif\n#endif\n" : "",
        shaderExtender: (e, t, n) => {
          var r;
          this.enabled && t.materialObject.userData._hasCustomBump && (null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._customBumpMap) && (e.fragmentShader = jc(e.fragmentShader, "#glMarker beforeAccumulation", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );\n#endif\n                ", {
            prepend: !0
          }), e.vertexShader = jc(e.vertexShader, "#include <uv_pars_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                varying vec2 vCustomBumpUv;\n                uniform mat3 customBumpUvTransform;\n#endif\n                ", {
            prepend: !0
          }), e.vertexShader = jc(e.vertexShader, "#include <uv_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;\n#endif\n                ", {
            prepend: !0
          }), e.vertexUvs = !0);
        },
        onObjectRender: (e, t) => {
          var n;
          const r = t.materialObject.userData;
          if (!(null == r ? void 0 : r._hasCustomBump)) return;
          const i = e;
          if (!i.isMesh || !i.geometry) return;
          const s = (null === (n = r._customBumpMap) || void 0 === n ? void 0 : n.isTexture) ? r._customBumpMap : null;
          this._uniforms.customBumpMap.value = s, this._uniforms.customBumpScale.value = s ? r._customBumpScale : 0, s && (s.updateMatrix(), this._uniforms.customBumpUvTransform.value.copy(s.matrix));
          let o = this.enabled && s ? 1 : 0;
          t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_DEBUG, t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_BICUBIC, t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC = o, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n, r;
          return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._hasCustomBump) ? "1" : "0") + (null === (r = null === (n = e.materialObject.userData) || void 0 === n ? void 0 : n._customBumpMap) || void 0 === r ? void 0 : r.uuid);
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = this.enableCustomBump,
                n = {
            type: "folder",
            label: "CustomBumpMap",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                return e.materialObject.userData._hasCustomBump || !1;
              },

              set value(r) {
                var i;
                r !== e.materialObject.userData._hasCustomBump && (r ? t(e) || alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._hasCustomBump = !1, e.materialObject.needsUpdate = !0), null === (i = n.uiRefresh) || void 0 === i || i.call(n, "postFrame", !0));
              },

              onChange: this.setDirty
            }, {
              type: "slider",
              label: "Bump Scale",
              hidden: () => !e.materialObject.userData._hasCustomBump,
              property: [e.materialObject.userData, "_customBumpScale"],
              onChange: this.setDirty
            }, {
              type: "image",
              label: "Bump Map",
              hidden: () => !e.materialObject.userData._hasCustomBump,
              property: [e.materialObject.userData, "_customBumpMap"],
              onChange: () => {
                e.materialObject.needsUpdate = !0, this.setDirty();
              }
            }]
          };
          return n;
        }
      }, this.setDirty = () => {
        var e, t, n;
        null === (t = (e = this.materialExtension).setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty();
      }, this.enableCustomBumpSelected = () => {
        var e, t, n;
        const r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(gc)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material;
        return "material" === (null == r ? void 0 : r.assetType) && this.enableCustomBump(r);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    enableCustomBump(e, t, n) {
      var r, i;
      const s = null === (r = e.materialObject) || void 0 === r ? void 0 : r.userData;
      if (!s) return !1;

      if (void 0 === s._hasCustomBump) {
        const e = s.appliedMeshes;
        let t = !0;
        if (e) for (const {
          geometry: n
        } of e) !n || n.attributes.position && n.attributes.normal && n.attributes.uv || (t = !1);
        if (!t) return !1;
      }

      return s._hasCustomBump = !0, s._customBumpScale = null !== (i = null != n ? n : s._customBumpScale) && void 0 !== i ? i : .001, s._customBumpMap = null != t ? t : s._customBumpMap, e.materialObject.needsUpdate = !0, !0;
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new gu(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(js);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(vu);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };
  mu.PluginType = "CustomBumpMapPlugin", mu.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map", _u([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], mu.prototype, "enabled", void 0), _u([Ve("Bicubic", e => ({
    onChange: e.setDirty
  })), G("CUSTOM_BUMP_MAP_BICUBIC", void 0, !0, fu.prototype.setDirty), xe()], mu.prototype, "bicubicFiltering", void 0), _u([Xe("Enable CustomBumpMap", e => ({
    hidden: () => {
      var t;
      return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc));
    }
  }))], mu.prototype, "enableCustomBumpSelected", void 0), mu = fu = _u([Qe("CustomBumpMap Materials")], mu);

  class gu {
    constructor(e) {
      this.parser = e, this.name = mu.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      var n;
      const r = this.parser,
            s = r.json.materials[e];
      if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
      const o = [],
            a = s.extensions[this.name];
      t.userData || (t.userData = {}), t.userData._hasCustomBump = !0, t.userData._customBumpScale = null !== (n = a.customBumpScale) && void 0 !== n ? n : 0;
      const l = a.customBumpMap;
      return l && o.push(r.assignTexture(t.userData, "_customBumpMap", l).then(e => {
        e.encoding = i.knz;
      })), Promise.all(o);
    }

  }

  const vu = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._hasCustomBump) return;
      if ((t.userData._customBumpScale || 0) < .001) return;
      n.extensions = n.extensions || {};
      const r = {};

      if (r.customBumpScale = t.userData._customBumpScale || 1, t.userData._customBumpMap) {
        const n = {
          index: e.processTexture(t.userData._customBumpMap)
        };
        e.applyTextureTransform(n, t.userData._customBumpMap), r.customBumpMap = n;
      }

      n.extensions[mu.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = r, e.extensionsUsed[mu.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = !0;
    }
  });

  var bu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let xu = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [js], this._defines = {}, this._uniforms = {
        ccTintColor: {
          value: new ve()
        },
        ccThickness: {
          value: 0
        },
        ccIor: {
          value: 0
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var n;
          return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === n ? void 0 : n.enableTint) && t.materialObject.clearcoat > 0 ? "\nuniform vec3 ccTintColor;\nuniform float ccThickness;\nuniform float ccIor;\nvec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {\n    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.\n    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law\n    return mix(vec3(1.0), tint, clearcoat);\n}\n        " : "";
        },
        shaderExtender: (e, t, n) => {
          var r;
          if (!(this.enabled && (null === (r = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) && t.materialObject.clearcoat > 0)) return;
          const i = "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;",
                s = "float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );";
          e.fragmentShader.includes(s) && e.fragmentShader.includes(i) || console.error("ClearcoatTintPlugin: shaderExtender cannot patch shader, version changed?"), e.fragmentShader = e.fragmentShader.replace(s, "\n            float dotNVcc = saturate( dot( geometry.clearcoatNormal, -refract(geometry.viewDir, geometry.clearcoatNormal, 1./ccIor) ) );\n            "), e.fragmentShader = e.fragmentShader.replace(i, "\n            outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);\n            " + i), e.vertexUvs = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._clearcoatTint;
          if (!(null == r ? void 0 : r.enableTint)) return;
          this._uniforms.ccTintColor.value.set(r.tintColor), this._uniforms.ccThickness.value = r.thickness, this._uniforms.ccIor.value = r.ior;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.CLEARCOAT_TINT_ENABLED !== i && (t.materialObject.defines.CLEARCOAT_TINT_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n;
          return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._clearcoatTint) || void 0 === n ? void 0 : n.enableTint) ? "1" : "0") + (e.materialObject.clearcoat > 0 ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = {
            type: "folder",
            label: "ClearcoatTint",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                var t;
                return (null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint) || !1;
              },

              set value(n) {
                var r, i;
                n !== (null === (r = e.materialObject.userData._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) && (n ? yu(e.materialObject) || alert("Cannot add clearcoat tint.") : (e.materialObject.userData._clearcoatTint.enableTint = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0));
              },

              onChange: this.setDirty
            }, () => ({
              type: "color",
              label: "Tint color",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
              },
              property: [e.materialObject.userData._clearcoatTint, "tintColor"],
              onChange: this.setDirty
            }), () => ({
              type: "input",
              label: "Thickness",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
              },
              property: [e.materialObject.userData._clearcoatTint, "thickness"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              bounds: [.8, 2.5],
              label: "IOR",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
              },
              property: [e.materialObject.userData._clearcoatTint, "ior"],
              onChange: this.setDirty
            })]
          };
          return t;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    addClearcoatTint(e) {
      return yu(e.materialObject);
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new wu(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(js);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Su);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };

  function yu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._clearcoatTint || (t._clearcoatTint = {});
    const n = t._clearcoatTint;
    return n.enableTint = !0, void 0 === n.tintColor && (n.tintColor = 16777215), void 0 === n.thickness && (n.thickness = .1), void 0 === n.ior && (n.ior = 1.5), e.isMaterial && (e.needsUpdate = !0), !0;
  }

  xu.PluginType = "ClearcoatTintPlugin", xu.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint", bu([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], xu.prototype, "enabled", void 0), xu = bu([Qe("ClearcoatTint Materials")], xu);

  class wu {
    constructor(e) {
      this.parser = e, this.name = xu.CLEARCOAT_TINT_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.userData || (t.userData = {}), yu(t), t.userData._clearcoatTint = Te(r, t.userData._clearcoatTint, !1, {}), Promise.resolve();
    }

  }

  const Su = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._clearcoatTint) return;
      if (!t.userData._clearcoatTint.enableTint) return;
      n.extensions = n.extensions || {};
      const r = Me(t.userData._clearcoatTint, !1);
      n.extensions[xu.CLEARCOAT_TINT_GLTF_EXTENSION] = r, e.extensionsUsed[xu.CLEARCOAT_TINT_GLTF_EXTENSION] = !0;
    }
  });

  var Mu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Tu = class extends Ft {
    constructor(e, t, n) {
      super(e, t, null != n ? n : new Eu(), new ve(0, 0, 0), 1), this.enabled = !0, this._firstCall = !0;
    }

    render(e, t, n, r, i) {
      if (!this.enabled) return;
      const s = this.overrideMaterial;
      s.uniforms.currentProjectionViewMatrix.value.copy(this.camera.projectionMatrix).multiply(this.camera.matrixWorldInverse), this._firstCall && (s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value), this._firstCall = !1), super.render(e, t, n, r, i), s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value);
    }

  };
  Mu([Ve("Enabled")], Tu.prototype, "enabled", void 0), Tu = Mu([Qe("Velocity Buffer (TAA)")], Tu);

  class Eu extends i.jyz {
    constructor() {
      super({
        vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#endif\n#include <uv_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 modelMatrixPrevious;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\nvec4 mvPosition=vec4(transformed,1.);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nvWorldPosition=(modelMatrix*mvPosition).xyz;vWorldPositionPrevious=(modelMatrixPrevious*mvPosition).xyz;mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}",
        fragmentShader: "varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 currentProjectionViewMatrix;uniform mat4 lastProjectionViewMatrix;vec2 computeScreenSpaceVelocity2(){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(vWorldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(vWorldPositionPrevious,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}void main(){vec2 velocity=clamp(computeScreenSpaceVelocity2(),-1.,1.);velocity=sign(velocity)*pow(abs(velocity),vec2(1./4.));velocity=velocity*0.5+0.5;gl_FragColor=vec4(velocity.x,velocity.y,1.,1.);}",
        uniforms: {
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: null
          },
          currentProjectionViewMatrix: {
            value: new i.yGw()
          },
          lastProjectionViewMatrix: {
            value: new i.yGw()
          }
        }
      }), this.extraUniformsToUpload = {
        modelMatrixPrevious: {
          value: new i.yGw().identity()
        }
      }, this._previousWorldMatrices = {};
    }

    onBeforeRender(e, t, n, r, s) {
      var o, a;
      const l = this._previousWorldMatrices[s.uuid];
      this.extraUniformsToUpload.modelMatrixPrevious.value.copy(null != l ? l : s.matrixWorld), l ? l.copy(s.matrixWorld) : this._previousWorldMatrices[s.uuid] = s.matrixWorld.clone();
      let c = s.material;
      Array.isArray(c) && (c = c[0]), this.uniforms.alphaMap.value = null !== (o = null == c ? void 0 : c.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !c || !c.alphaTest || c.alphaTest < 1e-7 ? .001 : c.alphaTest;
      let u = this.uniforms.alphaMap.value ? 1 : void 0;
      u !== this.defines.USE_ALPHAMAP && (this.defines.USE_ALPHAMAP = u, this.needsUpdate = !0), u = c.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u !== this.defines.ALPHA_I_RGBA_PACKING && (this.defines.ALPHA_I_RGBA_PACKING = u, this.needsUpdate = !0), this.side = null !== (a = c.side) && void 0 !== a ? a : i.ehD;
    }

  }

  class Au extends Gs {
    constructor(e = !0) {
      super(), this.passId = "velocityBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._velocityBuffers = [], this.enabled = e;
    }

    passCtor(e) {
      const t = e.renderer.createTarget({
        depthBuffer: !0,
        type: i.ywz
      });
      t.texture.name = "velocityBuffer", this._velocityBuffers.push(t);
      const n = e.getPluginByType("debug");
      n && n.addTexture("velocityBuffer", () => t.texture, [40, 50, 400, 200]);
      const r = new Set(),
            s = new Set();
      return new class extends Tu {
        render(n, i, o, a, l) {
          if (e.renderer.frameCount > 0) return;
          const c = n.getRenderTarget(),
                u = n.getActiveCubeFace(),
                p = n.getActiveMipmapLevel();
          this.scene.traverse(({
            material: e
          }) => {
            e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (r.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (s.add([e, e.transmission]), e.transmission = 0));
          }), K(n, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !0,
            transparentRender: !1,
            transmissionRender: !1,
            mainRenderPass: !1
          }, () => super.render(n, i, t, a, l)), r.forEach(e => e.transparent = !e.transparent), r.clear(), s.forEach(([e, t]) => e.transmission = t), s.clear(), n.setRenderTarget(c, u, p);
        }

      }();
    }

    _update(e) {
      if (!super._update(e)) return !1;
      if (e.renderer.frameCount > 0) return !1;
      const t = this.pass.passObject;
      return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0;
    }

    getVelocityBuffer() {
      return this._velocityBuffers.length > 0 ? this._velocityBuffers[0] : void 0;
    }

    async onDispose(e) {}

    async onRemove(e) {
      return this._velocityBuffers.forEach(t => {
        var n;
        return e.renderer.disposeTarget(null === (n = null == t ? void 0 : t.dispose) || void 0 === n ? void 0 : n.call(t));
      }), super.onRemove(e);
    }

    updateShaderProperties(e) {
      var t, n;
      return e.uniforms.tVelocity ? e.uniforms.tVelocity.value = this.enabled && null !== (n = null === (t = this.getVelocityBuffer()) || void 0 === t ? void 0 : t.texture) && void 0 !== n ? n : null : console.warn("BaseRenderer: no uniform: tVelocity"), this;
    }

    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }

  }

  Au.PluginType = "VelocityBuffer";

  class Cu extends It {
    constructor(e, t) {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: t + "\n" + vo + "\n#include <common>\nvarying vec2 vUv;uniform vec2 previousRTSize;uniform mat4 lastProjectionViewMatrix;uniform mat4 currentProjectionViewMatrix;uniform mat4 inverseViewMatrix;uniform vec2 jitterSample;uniform vec2 feedBack;uniform bool firstFrame;\n#if HAS_VELOCITY_BUFFER == 1\nuniform sampler2D tVelocity;\n#endif\nvec3 find_closest_fragment_3x3(const in vec2 uv){const vec3 offset=vec3(-1.,1.,0.);vec2 texelSize=1./previousRTSize;vec3 dtr=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtc=vec3(0,1,getDepth(uv+offset.zx*texelSize));vec3 dtl=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dml=vec3(-1,0,getDepth(uv+offset.yz*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dmr=vec3(1,0,getDepth(uv+offset.xz*texelSize));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbc=vec3(0,-1,getDepth(uv+offset.zy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtc.z)dmin=dtc;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dml.z)dmin=dml;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dmr.z)dmin=dmr;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbc.z)dmin=dbc;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+texelSize.xy*dmin.xy,dmin.z);}vec3 find_closest_fragment_5tap(const in vec2 uv){vec2 texelSize=1./previousRTSize;vec2 offset=vec2(1.,-1.);vec3 dtl=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtr=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+dmin.xy*texelSize,dmin.z);}vec4 clip_aabb(const in vec4 aabb_min,const in vec4 aabb_max,vec4 p){const float FLT_EPS=1e-8;vec4 p_clip=0.5*(aabb_max+aabb_min);vec4 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=p-p_clip;vec4 v_unit=abs(v_clip/e_clip);float ma_unit=max(v_unit.x,max(v_unit.y,v_unit.z));if(ma_unit>1.)return p_clip+v_clip/ma_unit;else return p;}\n#if HAS_VELOCITY_BUFFER == 0\nvec2 computeScreenSpaceVelocity(const in vec3 worldPosition){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(worldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(worldPosition,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}\n#endif\nvec4 computeTAA(const in vec2 uv,const in vec2 screenSpaceVelocity){vec2 jitterOffset=jitterSample/previousRTSize;vec2 uvUnJitter=uv;vec4 currentColor=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter));vec4 previousColor=previousRTTexelToLinear(texture2D(previousRT,uv-screenSpaceVelocity));const vec3 offset=vec3(1.,-1.,0.);vec2 texelSize=1./previousRTSize;float texelSpeed=length(screenSpaceVelocity);vec4 tl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yx*texelSize));vec4 tc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zx*texelSize));vec4 tr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xx*texelSize));vec4 ml=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yz*texelSize));vec4 mc=currentColor;vec4 mr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xz*texelSize));vec4 bl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yy*texelSize));vec4 bc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zy*texelSize));vec4 br=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xy*texelSize));vec4 corners=2.*(tr+bl+br+tl)-2.*mc;mc+=(mc-(corners*0.166667))*2.718282*0.3;mc=max(vec4(0.),mc);vec4 min5=min(tc,min(ml,min(mc,min(mr,bc))));vec4 max5=max(tc,max(ml,max(mc,max(mr,bc))));vec4 cmin=min(min5,min(tl,min(tr,min(bl,br))));vec4 cmax=max(min5,max(tl,max(tr,max(bl,br))));;cmin=0.5*(cmin+min5);cmax=0.5*(cmax+max5);previousColor=clip_aabb(cmin,cmax,previousColor);float lum0=linearToRelativeLuminance(currentColor.rgb);float lum1=linearToRelativeLuminance(previousColor.rgb);float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedBack.x,feedBack.y,unbiased_weight_sqr);return mix(currentColor,previousColor,k_feedback);}vec3 getWorldPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return(inverseViewMatrix*vec4(xe,ye,viewDepth,1.)).xyz;}void main(){vec2 jitterOffset=jitterSample/previousRTSize;\n#if QUALITY == 1\nvec3 c_frag=find_closest_fragment_3x3(vUv);\n#else\nvec3 c_frag=find_closest_fragment_5tap(vUv);\n#endif\nif(c_frag.z>=0.999){gl_FragColor=currentRTTexelToLinear(texture2D(currentRT,vUv-jitterOffset));}else{float sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);\n#if HAS_VELOCITY_BUFFER == 0\nvec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);\n#else\nvec2 screenSpaceVelocity=(texture2D(tVelocity,vUv).xy*2.-1.);screenSpaceVelocity=sign(screenSpaceVelocity)*pow(abs(screenSpaceVelocity),vec2(4.));\n#endif\ngl_FragColor=firstFrame?currentRTTexelToLinear(texture2D(currentRT,vUv)):computeTAA(vUv,screenSpaceVelocity);}\n#include <encodings_fragment>\n}",
        uniforms: {
          currentRT: {
            value: null
          },
          previousRT: {
            value: null
          },
          previousRTSize: {
            value: new i.FM8()
          },
          cameraNearFar: {
            value: new i.FM8()
          },
          lastProjectionViewMatrix: {
            value: new i.yGw()
          },
          currentProjectionViewMatrix: {
            value: new i.yGw()
          },
          projection: {
            value: new i.yGw()
          },
          inverseViewMatrix: {
            value: new i.yGw()
          },
          jitterSample: {
            value: new i.FM8()
          },
          firstFrame: {
            value: !0
          },
          tNormalDepth: {
            value: null
          },
          tVelocity: {
            value: null
          }
        },
        defines: {
          HAS_VELOCITY_BUFFER: 0,
          QUALITY: 1,
          UNJITTER: 0
        }
      }, "currentRT", "previousRT"), this.taaEnabled = !0, this.feedBack = new i.FM8(.88, .97), this.uiConfig = {
        type: "folder",
        label: "Temporal AA",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"],
          onChange: () => this.onSizeUpdate()
        }, {
          type: "input",
          label: "Feedback",
          property: [this, "feedBack"],
          onChange: this.setDirty
        }]
      }, this.onSizeUpdate = this.onSizeUpdate.bind(this), this.target = e, this.clear = !1, this.needsSwap = !0;
    }

    render(e, t, n, r, i) {
      if (!this.taaEnabled || !this.enabled) return void (this.needsSwap = !1);
      this.needsSwap = !0;
      const s = this.uniforms.tVelocity.value ? 1 : 0;
      s !== this.material.defines.HAS_VELOCITY_BUFFER && (this.material.defines.HAS_VELOCITY_BUFFER = s, this.material.needsUpdate = !0), this.uniforms.previousRT.value = this.target.texture, super.render(e, t, n, r, i), this.uniforms.lastProjectionViewMatrix.value.copy(this.uniforms.currentProjectionViewMatrix.value), this.uniforms.firstFrame.value = !1;
    }

    updateCameraProperties(e) {
      e && (this.uniforms.currentProjectionViewMatrix.value.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this.uniforms.inverseViewMatrix.value.copy(e.matrixWorld));
    }

    onSizeUpdate() {
      this.uniforms.firstFrame.value = !0, this.setDirty();
    }

    setSize(e, t) {
      super.setSize(e, t), this.onSizeUpdate();
    }

  }

  !function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe(), V()], Cu.prototype, "feedBack", void 0);

  class Ru extends Gs {
    constructor() {
      super(...arguments), this.passId = "taa", this._beforeFilters = ["progressive"], this._afterFilters = [], this._requiredFilters = ["render", "progressive"], this.dependencies = [Xs];
    }

    passCtor(e) {
      if (!e.getPlugin(po)) throw "Add ProgressivePlugin before TAA";
      const t = new Cu(e.getPlugin(po).lastFrame, e.getPlugin(Xs).getUnpackSnippet());
      return e.renderer.addEventListener("resize", t.onSizeUpdate), t;
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    async onDispose(e) {
      return this.pass && e.renderer.removeEventListener("resize", this.pass.passObject.onSizeUpdate), super.onDispose(e);
    }

    _update(e) {
      if (!super._update(e)) return !1;
      const t = e.renderer.frameCount,
            n = this._pass.passObject;
      if (n.taaEnabled = t < 1, !n.taaEnabled) return !1;
      const r = e.scene.activeCamera;
      return n.updateShaderProperties([e.getPlugin(Xs), r, e.getPluginByType("VelocityBuffer")]), n.target = e.getPlugin(po).lastFrame, n.updateCameraProperties(null == r ? void 0 : r.cameraObject), !0;
    }

    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }

  }

  Ru.PluginType = "TAA";

  class ku {
    static async GetDataUrl(e, {
      mimeType: t = "image/png",
      rect: n = {
        x: 0,
        y: 0,
        width: e.width,
        height: e.height,
        assumeClientRect: !1
      },
      displayPixelRatio: r = 1,
      scale: i = 1
    }) {
      var s, o, a;
      const l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      l.width = n.width * i * r, l.height = n.height * i * r, n.assumeClientRect && (n.x *= e.width / (r * e.clientWidth), n.y *= e.height / (r * e.clientHeight), n.width *= e.width / (r * e.clientWidth), n.height *= e.height / (r * e.clientHeight));
      const c = l.getContext("2d");
      if (!c) return console.error("snapshot: cannot create context"), "";
      const u = e.style.background || (null === (s = e.parentElement) || void 0 === s ? void 0 : s.style.background) || "";

      if (u.includes("url")) {
        const t = null === (o = /url\("(.*)"\)/gi.exec(u)) || void 0 === o ? void 0 : o[1];

        if (t) {
          const i = new Image();
          i.src = t, await new Promise((e, t) => {
            i.onload = () => e(), i.onerror = () => t(), i.complete && e();
          }), c.drawImage(i, i.width * n.x * r / e.width, i.height * n.y * r / e.height, i.width * n.width * r / e.width, i.height * n.height * r / e.height, 0, 0, l.width, l.height);
        }
      } else c.fillStyle = e.style.background || (null === (a = e.parentElement) || void 0 === a ? void 0 : a.style.backgroundColor) || "#00000000", c.fillRect(0, 0, l.width, l.height);

      null == c || c.drawImage(e, n.x * r, n.y * r, n.width * r, n.height * r, 0, 0, l.width, l.height);
      const p = c.canvas.toDataURL(t);
      return l.remove(), p;
    }

    static async GetImage(e, t = {}) {
      const n = await this.GetDataUrl(e, t);
      return new Promise((e, t) => {
        const r = new Image();
        r.onload = () => {
          e(r);
        }, r.src = n;
      });
    }

    static async GetBlob(e, t = {}) {
      return await (await fetch(await this.GetDataUrl(e, t))).blob();
    }

    static async GetFile(e, t = "image.png", n = {}) {
      var r;
      return n.getDataUrl ? await this.GetDataUrl(e, n) : new File([await this.GetBlob(e, n)], t, {
        type: null !== (r = n.mimeType) && void 0 !== r ? r : "image/png",
        lastModified: At()
      });
    }

  }

  var Pu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Du = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.downloadSnapshot = this.downloadSnapshot.bind(this);
    }

    async getFile(e, t = {}) {
      return t.getDataUrl = !1, await this._getFile(e, t);
    }

    async getDataUrl(e = {}) {
      var t;
      return e.getDataUrl = !0, null !== (t = await this._getFile("", e)) && void 0 !== t ? t : "";
    }

    async _getFile(e, t = {}) {
      var n, r, i;
      const s = null === (n = this._viewer) || void 0 === n ? void 0 : n.canvas;

      if (s) {
        const n = this._viewer.renderer.displayCanvasScaling;
        void 0 !== t.displayPixelRatio && t.displayPixelRatio !== n && (this._viewer.renderer.displayCanvasScaling = t.displayPixelRatio);
        const o = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPlugin(po);
        if (t.waitForProgressive && o && void 0 === t.timeout) for (; !o.isConverged(!0);) await uc(64);else await uc(null !== (i = t.timeout) && void 0 !== i ? i : 200);
        t.displayPixelRatio = 1;
        const a = await ku.GetFile(s, e, t);
        return t.displayPixelRatio = this._viewer.renderer.displayCanvasScaling, this._viewer.renderer.displayCanvasScaling = n, a;
      }
    }

    async downloadSnapshot(e = "snapshot.png", t = {}) {
      const n = await this.getFile(e, t);
      n && bt(n);
    }

  };
  Du.PluginType = "CanvasSnipper", Pu([Xe("Download .png", {
    limitedUi: !0
  })], Du.prototype, "downloadSnapshot", null), Du = Pu([Qe("Canvas Snipper")], Du);

  var Ou = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Lu = 1,
      Iu = class {
    constructor(e, t, n, r, s) {
      this.position = new i.Pa4(), this.target = new i.Pa4(), this.quaternion = new i._fP(), this.up = new i.Pa4(), this.name = "Camera View", this.snap = "", this.focusView = () => {}, this.deleteView = () => {}, this.uiConfig = $e(this.name, this), e && (this.position = e), t && (this.target = t), n && (this.up = n), r && (this.quaternion = r), s && (this.snap = s), this.name = "Camera View" + Lu++;
    }

    _nameChanged() {
      var e, t;
      this.uiConfig && (this.uiConfig.label = this.name, null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e));
    }

  };
  Ou([xe(), We()], Iu.prototype, "position", void 0), Ou([xe(), We()], Iu.prototype, "target", void 0), Ou([xe(), We()], Iu.prototype, "quaternion", void 0), Ou([xe(), We()], Iu.prototype, "up", void 0), Ou([xe(), qe()], Iu.prototype, "name", void 0), Ou([Ze()], Iu.prototype, "snap", void 0), Ou([Xe()], Iu.prototype, "focusView", void 0), Ou([Xe()], Iu.prototype, "deleteView", void 0), Iu = Ou([Ae("CameraView")], Iu);

  class Fu extends zs {
    constructor() {
      super(), this.enabled = !0, this._cameraViews = [], this.viewLooping = !1, this.viewPauseTime = 200, this.animEase = "easeInOutSine", this.animDuration = 1e3, this.rotationOffset = .25, this.interpolateMode = "spherical", this.animateOnScroll = !1, this.seekOnScroll = !1, this._animating = !1, this.dependencies = [], this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this._updaters = [], this._lastFrameTime = 0, this._fadeDisabled = !1, this._viewQueue = [], this._animationLooping = !1, this._infiniteLooping = !0, this._driver = e => ({
        start: () => this._updaters.push({
          u: e,
          time: 0
        }),
        stop: () => this._updaters.splice(this._updaters.findIndex(t => t.u === e), 1)
      }), this.focusNext = (e = !0) => {
        if (this._animating) return;
        if (this._cameraViews.length < 2) return;

        let t = this._cameraViews.findIndex(e => e === this._currentView);

        t < 0 && (t = -1), t += 1, e ? t %= this._cameraViews.length : t = Math.min(t, this._cameraViews.length - 1), this.focusView(this._cameraViews[t]);
      }, this.focusPrevious = (e = !0) => {
        if (this._animating) return;
        if (this._cameraViews.length < 2 || !this._currentView) return;

        let t = this._cameraViews.findIndex(e => e === this._currentView);

        t < 0 && (t = 0), t -= 1, t = e ? (t + this._cameraViews.length) % this._cameraViews.length : Math.max(t, 0), this.focusView(this._cameraViews[t]);
      }, this._popAnimations = [], this.uiConfig = {
        type: "folder",
        label: "Camera Views",
        children: [() => [...this._cameraViews.map(e => e.uiConfig)], ...Je(this)]
      }, this.addCurrentView = this.addCurrentView.bind(this), this.animateAllViews = this.animateAllViews.bind(this), this.recordAllViews = this.recordAllViews.bind(this), this.resetToFirstView = this.resetToFirstView.bind(this), this._wheel = this._wheel.bind(this), this._pointerMove = this._pointerMove.bind(this), this._postFrame = this._postFrame.bind(this);
    }

    get animationLooping() {
      return this._animationLooping;
    }

    get animating() {
      return this._animating;
    }

    get camViews() {
      return this._cameraViews;
    }

    _wheel(e) {
      this.enabled && (this.seekOnScroll && !this._animating || Math.abs(e.deltaY) > .001 && (this._scrollAnimationState = -1 * Math.sign(e.deltaY)));
    }

    _pointerMove(e) {
      var t;

      if (this.enabled && !this._animating && this.seekOnScroll) {
        const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.activeCamera;
        if (!n) return;
        const r = new i.$V(),
              s = n.position,
              o = n.target,
              a = new i._fP().setFromUnitVectors(n.cameraObject.up, new i.Pa4(0, 1, 0)),
              l = a.clone().invert(),
              c = s.clone().sub(o);
        c.applyQuaternion(a), r.setFromVector3(c), r.theta += this.rotationOffset * e.movementX / this._viewer.canvas.clientWidth, r.phi += this.rotationOffset * e.movementY / this._viewer.canvas.clientHeight, r.makeSafe(), c.setFromSpherical(r), c.applyQuaternion(l), s.copy(o).add(c), n.positionUpdated(!1), n.targetUpdated();
      }
    }

    async onAdded(e) {
      await super.onAdded(e);
      let t = !1;
      e.addEventListener("preFrame", e => {
        this.seekOnScroll || this._animating ? this._viewer.scene.activeCamera.interactionsEnabled && (this._viewer.scene.activeCamera.interactionsEnabled = !1, t = !0) : t && (this._viewer.scene.activeCamera.interactionsEnabled = !0, t = !1);
      }), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), window.addEventListener("pointermove", this._pointerMove);
    }

    _postFrame() {
      var e, t;
      if (!this._viewer) return;
      if (!this.enabled || !this._animating) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(Fu.PluginType), this._fadeDisabled = !1));
      const n = At() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = n - 1 / 60);
      let r = n - this._lastFrameTime;
      this._lastFrameTime = n, r *= this.animateOnScroll ? this._scrollAnimationState : 1;
      const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();

      if (i && i > 0 && (r = i), 0 !== i && (r *= 1e3, !(r <= 0 || (this._updaters.forEach(e => {
        let t = r;
        e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t);
      }), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, this._fadeDisabled)))) {
        const e = this._viewer.getPluginByType("FrameFade");

        e && (e.disable(Fu.PluginType), this._fadeDisabled = !0);
      }
    }

    async onRemove(e) {
      return e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), window.removeEventListener("pointermove", this._pointerMove), super.onRemove(e);
    }

    async _animationLoop() {
      if (!this._animationLooping) {
        for (this._animationLooping = !0; (this.viewLooping || !this._infiniteLooping) && this.enabled && !(this._cameraViews.length < 1);) {
          if (0 === this._viewQueue.length) {
            if (!this._infiniteLooping) break;

            this._viewQueue.push(...this._cameraViews);
          }

          await this.animateToView(this._viewQueue.shift()), await uc(2 + this.viewPauseTime);
        }

        this._animationLooping = !1;
      }
    }

    async animateAllViews() {
      if (this.enabled && !(this.viewLooping || this._cameraViews.length < 2)) {
        for (; this._viewQueue.length > 0;) this._viewQueue.pop();

        this._viewQueue.push(...this._cameraViews), this._viewQueue.push(this._viewQueue.shift()), this._infiniteLooping = !1, await this._animationLoop(), this._infiniteLooping = !0;
      }
    }

    async resetToFirstView(e = 100) {
      this.enabled && (this._currentView = void 0, await this.animateToView(this._cameraViews[0], e), await uc(2));
    }

    async recordAllViews(e) {
      var t;
      if (!this.enabled) return;
      const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("CanvasRecorder");
      return n && n.enabled && (await this.resetToFirstView(), n.startRecording()) ? new Promise((t, r) => {
        const i = () => {
          n.removeEventListener("start", s), n.removeEventListener("stop", i), n.removeEventListener("error", o);
        },
              s = async () => {
          i(), null == e || e(), await this.animateAllViews();
          const r = await n.stopRecording();
          r && gt(r, "recording.mp4"), t();
        },
              o = async () => {
          i(), r();
        };

        n.addEventListener("start", s), n.addEventListener("stop", i), n.addEventListener("error", o);
      }) : void 0;
    }

    async addCurrentView() {
      var e, t, n, r, i;
      if (!this.enabled) return;
      const s = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.activeCamera;
      if (!s) return;
      const o = this.getCurrentCameraView(s);
      o.snap = (await (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Du)) || void 0 === n ? void 0 : n.getDataUrl({
        displayPixelRatio: .25,
        mimeType: "image/jpg"
      }))) || "", this._cameraViews.push(o), null === (i = (r = this.uiConfig).uiRefresh) || void 0 === i || i.call(r);
    }

    getCurrentCameraView(e) {
      const t = new i.Pa4(),
            n = e.cameraObject.matrixWorld;
      t.x = n.elements[4], t.y = n.elements[5], t.z = n.elements[6];
      const r = new Iu(e.position.clone(), e.target.clone(), t.normalize(), e.cameraObject.quaternion.clone(), "");
      return r.focusView = async () => this.focusView(r), r.deleteView = () => this.deleteView(r), r;
    }

    async focusView(e) {
      return this.animateToView(e);
    }

    deleteView(e) {
      var t, n;

      const r = this._cameraViews.indexOf(e);

      r >= 0 && this._cameraViews.splice(r, 1), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t);
    }

    async stopAllAnimations() {
      for (this.viewLooping = !1, this._popAnimations.forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.stop) || void 0 === t ? void 0 : t.call(e);
      }), this._popAnimations = []; this._animating || this._animationLooping;) await uc(100);
    }

    async animateToView(e, t, n) {
      var r;
      const s = null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.activeCamera;
      if (!s) return;
      if (this._animating && (this._popAnimations.forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.stop) || void 0 === t ? void 0 : t.call(e);
      }), await uc(100), this._animating)) return void console.warn("todo: still animating?");
      this._currentView = e, this._animating = !0, this.dispatchEvent({
        type: "startViewChange",
        view: e
      }), void 0 === t && (t = this.animDuration);
      const o = "function" == typeof n ? n : cc[n || this.animEase],
            a = this._driver,
            l = [];
      this._popAnimations = [];
      const c = this._popAnimations;
      if ("spherical" === this.interpolateMode) l.push(async function (e, t, n, r, s, o) {
        const a = e.target.clone(),
              l = new i.Pa4(),
              c = new i.Pa4(),
              u = Uu(e.cameraObject, a),
              p = Uu(t, t.target),
              h = new i.$V();
        return Nu({
          from: 0,
          to: 1,
          duration: n,
          ease: r,
          driver: s,
          onUpdate: n => {
            h.phi = Bu(u.phi, p.phi, n), h.theta = Bu(u.theta, p.theta, n), h.radius = ee(u.radius, p.radius, n), l.copy(a).lerp(t.target, n), c.setFromSpherical(h), c.add(l), e.position = c, e.target = l, e.positionUpdated(!1), e.targetUpdated();
          },
          onComplete: () => {
            e.position = t.position, e.target = t.target, e.positionUpdated(!1), e.targetUpdated();
          }
        }, o);
      }(s, e, t, o, a, c));else if ("linear" === this.interpolateMode) {
        l.push(Nu({
          from: s.position.clone(),
          to: e.position.clone(),
          duration: t,
          ease: o,
          driver: a,
          onUpdate: e => s.position = e,
          onComplete: () => s.position = e.position
        }, c)), l.push(Nu({
          from: s.target.clone(),
          to: e.target.clone(),
          duration: t,
          ease: o,
          driver: a,
          onUpdate: e => {
            s.target = e, s.targetUpdated();
          },
          onComplete: () => {
            s.target = e.target, s.targetUpdated();
          }
        }, c));
        const n = s.cameraObject.quaternion.clone(),
              r = new i._fP();
        l.push(Nu({
          from: 0,
          to: 1,
          duration: t,
          ease: o,
          driver: a,
          onUpdate: t => {
            r.copy(n).slerp(e.quaternion, t), s.cameraObject.quaternion.copy(r), s.cameraObject.updateProjectionMatrix();
          },
          onComplete: () => {
            s.cameraObject.quaternion.copy(e.quaternion), s.cameraObject.updateProjectionMatrix();
          }
        }, c));
      }
      await Promise.all(l), this._animating = !1, this.dispatchEvent({
        type: "viewChange",
        view: e
      }), await uc(10);
    }

    fromJSON(e, t) {
      var n, r;
      return this._cameraViews.forEach(e => this.deleteView(e)), super.fromJSON(e, t) ? (this._cameraViews.forEach(e => e.focusView = async () => this.focusView(e)), this._cameraViews.forEach(e => e.deleteView = () => this.deleteView(e)), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n), this) : null;
    }

  }

  async function Nu(e, t) {
    const n = e.onComplete,
          r = e.onStop;
    return e = { ...e
    }, new Promise((i, s) => {
      e.onComplete = () => {
        null == n || n(), i();
      }, e.onStop = () => {
        null == r || r(), i();
      };
      const o = lc(e);
      t.push(o);
    });
  }

  function Uu(e, t) {
    const n = e.position.clone();
    n.sub(t);
    const r = new i.$V().setFromVector3(n);
    return r.makeSafe(), r;
  }

  function Bu(e, t, n) {
    const r = t - e;
    return r >= Math.PI ? e + (r - 2 * Math.PI) * n : r <= -Math.PI ? e + (r + 2 * Math.PI) * n : e + r * n;
  }

  function ju(e, t, n) {
    const r = (1 - n) * Math.cos(e) + n * Math.cos(t),
          i = (1 - n) * Math.sin(e) + n * Math.sin(t);
    return Math.atan2(i, r);
  }

  Fu.PluginType = "CameraViews", Ou([xe("cameraViews")], Fu.prototype, "_cameraViews", void 0), Ou([C(Fu.prototype._animationLoop), xe(), Ve("Loop All Views", {
    limitedUi: !0
  })], Fu.prototype, "viewLooping", void 0), Ou([xe(), qe("View Pause Time")], Fu.prototype, "viewPauseTime", void 0), Ou([xe(), Ke("Ease", Object.keys(cc).map(e => ({
    label: e
  })))], Fu.prototype, "animEase", void 0), Ou([xe(), He("Duration", [10, 1e4], 10, {
    limitedUi: !0
  })], Fu.prototype, "animDuration", void 0), Ou([xe(), He("RotationOffset", [.2, .75], .01)], Fu.prototype, "rotationOffset", void 0), Ou([xe(), Ke("Interpolation", ["spherical", "linear"].map(e => ({
    label: e
  })))], Fu.prototype, "interpolateMode", void 0), Ou([Ve(), xe()], Fu.prototype, "seekOnScroll", void 0), Ou([Xe("Animate All Views", {
    limitedUi: !0
  })], Fu.prototype, "animateAllViews", null), Ou([Xe("Record All Views")], Fu.prototype, "recordAllViews", null), Ou([Xe("Add Current View")], Fu.prototype, "addCurrentView", null), Ou([Xe("Focus Next")], Fu.prototype, "focusNext", void 0), Ou([Xe("Focus Previous")], Fu.prototype, "focusPrevious", void 0);
  const zu = new i.Pa4();

  function Vu(e, t, n) {
    let r = e.dot(t);
    r = Math.min(Math.max(r, -1), 1);
    const i = Math.acos(r) * n;
    return zu.copy(e).multiplyScalar(r).sub(t).negate().normalize(), e.multiplyScalar(Math.cos(i)).add(zu.multiplyScalar(Math.sin(i)));
  }

  var Gu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Hu extends zs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.light = new Nc("#cceeff", 1), this.lightLayers = 1, this._preRender = () => {
        var e, t, n;
        if (!this.enabled) return void (this.light.layers.mask = 0);
        const r = null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) && void 0 !== t ? t : 0;
        (r < 1 || r > 5) && this.light.randomizePosition(r < 5 ? 0 : r), this.light.layers.mask = this.lightLayers, this.light.updateShadowParams(), null === (n = this._cameraHelper) || void 0 === n || n.update();
      }, this._setDirty = this._setDirty.bind(this), this.enabled = e;
    }

    get cameraHelper() {
      return this._cameraHelper;
    }

    async onAdded(e) {
      await super.onAdded(e), this._cameraHelper = new i.Rki(this.light.shadow.camera), this._cameraHelper.visible = !1, this._cameraHelper.userData.bboxVisible = !1, e.scene.add(this._cameraHelper), e.scene.addLight(this.light, {
        addToRoot: !0
      }), e.addEventListener("preRender", this._preRender);
    }

    async onRemove(e) {
      return e.removeEventListener("preRender", this._preRender), this.light.removeFromParent(), super.onRemove(e);
    }

    _setDirty(e = !1) {
      var t, n;
      e ? null === (t = this._viewer) || void 0 === t || t.scene.setDirty() : null === (n = this._viewer) || void 0 === n || n.setDirty();
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Progressive Shadow",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"],
          onChange: this._setDirty
        }, {
          type: "folder",
          label: "Directional Light",
          children: [{
            type: "checkbox",
            label: "Visible",
            property: [this.light, "visible"],
            onChange: this._setDirty
          }, {
            type: "slider",
            label: "Intensity",
            bounds: [0, 10],
            property: [this.light, "intensity"],
            onChange: this._setDirty
          }, {
            type: "color",
            label: "Intensity",
            property: [this.light, "color"],
            onChange: this._setDirty
          }, {
            type: "checkbox",
            label: "Shadow Enabled",
            property: [this.light.shadowParams, "enabled"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [0, 1],
            property: [this.light.randomParams, "focus"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [0, 1],
            property: [this.light.randomParams, "spread"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [.01, 60],
            property: [this.light.randomParams, "distanceScale"],
            onChange: this._setDirty
          }, {
            type: "vec3",
            bounds: [-5, 5],
            property: [this.light.randomParams, "direction"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [.01, 10],
            property: [this.light.shadowParams, "radius"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [.01, 30],
            property: [this.light.shadowParams, "frustumSize"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [-.01, .01],
            property: [this.light.shadowParams, "bias"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }]
        }]
      };
    }

  }

  Hu.PluginType = "RandomizedDirectionalLight", Gu([xe()], Hu.prototype, "enabled", void 0), Gu([xe("rdLight")], Hu.prototype, "light", void 0), Gu([xe()], Hu.prototype, "lightLayers", void 0);

  var Wu,
      Ku = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Xu = Wu = class extends zs {
    constructor(e = !1) {
      super(), this.enabled = !1, this.worldRadius = 100, this.tripodHeight = 10, this._paramsChanged = this._paramsChanged.bind(this), this.enabled = e;
    }

    _paramsChanged() {
      var e, t, n, r, s, o, a, l, c, u, p;
      const h = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0);
      if (this.enabled && h && h !== no) if (h.isDataTexture) h.mapping = i.dSO;else if (confirm("Background must be same as environment, do you want to change it?")) {
        const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SimpleBackgroundEnvUiPlugin1");
        e ? (e.envmapBg = !0, null === (r = (n = e.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0)) : null === (s = this._viewer) || void 0 === s || s.setBackground(no);
      } else this.enabled = !1;
      const d = null === (c = null === (l = null === (a = null === (o = this._viewer) || void 0 === o ? void 0 : o.renderer) || void 0 === a ? void 0 : a.rendererObject) || void 0 === l ? void 0 : l.background.getBoxMesh2()) || void 0 === c ? void 0 : c.material,
            f = null !== (u = null == d ? void 0 : d.uniforms) && void 0 !== u ? u : i.Vj0.cube.uniforms;
      f.tripodHeight || (f.tripodHeight = {
        value: 1
      }), f.worldRadius || (f.worldRadius = {
        value: 1
      }), f.tripodHeight.value = this.tripodHeight, f.worldRadius.value = this.worldRadius, d && (!this.enabled && d.defines.HDRi_GROUND_PROJ ? delete d.defines.HDRi_GROUND_PROJ : this.enabled && (d.defines.HDRi_GROUND_PROJ = "1"), d.needsUpdate = !0), null === (p = this._viewer) || void 0 === p || p.setDirty();
    }

    async onAdded(e) {
      var t, n, r;
      await super.onAdded(e), (null === (r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer) || void 0 === n ? void 0 : n.rendererObject) || void 0 === r ? void 0 : r.background.getBoxMesh()) && console.error("HDRi Ground Plugin must be added before setting any cube or env map"), i.Vj0.cube.fragmentShader = i.Vj0.cube.fragmentShader.replace("void main() {", "\n#ifdef HDRi_GROUND_PROJ\nfloat intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0.?1000.:t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.?t:-b+sqrt(t);}\n#define PI_HALF 1.5707963267948966\nuniform float worldRadius;uniform float tripodHeight;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,vec3(0.,0.,0.),worldRadius);if(t>0.){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),vec3(0.,-tripodHeight,0.));p=(camPos+min(t,t2)*p)/worldRadius;}else p=vec3(0.,1.,0.);return p;}\n#endif\n\nvoid main() {"), i.Vj0.cube.fragmentShader = i.Vj0.cube.fragmentShader.replace("vec3 vReflect = vWorldDirection;", "\nvec3 vReflect = \n#ifdef HDRi_GROUND_PROJ\nhdriProject()\n#else\nvWorldDirection\n#endif\n;\n"), e.scene.addEventListener("environmentChanged", this._paramsChanged);
    }

  };
  Xu.PluginType = "HDRiGroundPlugin", Ku([xe(), C(Wu.prototype._paramsChanged), Ve("Enabled")], Xu.prototype, "enabled", void 0), Ku([xe(), C(Wu.prototype._paramsChanged), He("World Radius", [1, 1e3])], Xu.prototype, "worldRadius", void 0), Ku([xe(), C(Wu.prototype._paramsChanged), He("Tripod height", [0, 50])], Xu.prototype, "tripodHeight", void 0), Xu = Wu = Ku([Qe("HDRi Ground")], Xu);

  var qu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const Yu = {
    uniforms: {
      colorTexture: {
        value: null
      },
      tNormalDepth: {
        value: null
      },
      blurTexture: {
        value: null
      },
      cocTexture: {
        value: null
      },
      cocTextureSize: {
        value: new i.FM8()
      },
      cameraNearFar: {
        value: new i.FM8()
      }
    },
    vertexShader: go,
    fragmentShader: Bt + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cocTextureSize;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;uniform vec2 crossCenter;uniform float crossRadius;uniform float crossAlpha;uniform vec3 crossColor;float smoothBoundary(float d,float smooothFactor){smooothFactor*=0.5;float value=smoothstep(-smooothFactor,smooothFactor,d);return value;}float circle(vec2 p,float r){return min((length(p)-r),-(length(p)-r-0.01));}float computeCoc(){float depth=getDepth(vUv);if(depth>1.-0.01)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){vec4 blur=blurTextureTexelToLinear(texture2D(blurTexture,vUv));float scale=0.5;blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,-1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,-1.)/cocTextureSize));blur/=5.;vec2 uvNearest=(floor(vUv*cocTextureSize)+0.5)/cocTextureSize;float coc=abs(min(2.*cocTextureTexelToLinear(texture2D(cocTexture,uvNearest)).a-1.,computeCoc()));float cocLower=0.005;float cocHigher=0.3;vec4 outColor=vec4(mix(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,blur.rgb,smoothstep(cocLower,cocHigher,coc)),1.);vec2 d=vUv-crossCenter;if(length(d)>crossRadius+0.05){float dist=circle(d,crossRadius);gl_FragColor=outColor;}else{d.x*=cocTextureSize.x/cocTextureSize.y;float dist=circle(d,crossRadius);dist=smoothBoundary(dist,2.*fwidth(dist));vec4 color=outColor;vec3 dofCircleColor=mix(crossColor,color.rgb,1.-crossAlpha);gl_FragColor=vec4(mix(color.rgb,dofCircleColor,dist),color.a);}\n#include <encodings_fragment>\n}"
  },
        Zu = (Lt({
    uniforms: {
      cocTexture: {
        value: null
      },
      colorTexture: {
        value: null
      },
      colorTextureSize: {
        value: new i.FM8()
      },
      direction: {
        value: new i.FM8()
      }
    },
    vertexShader: go,
    fragmentShader: "#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;const float MAXIMUM_BLUR_SIZE=16.;const float SIGMA=5.;const int NUM_SAMPLES=4;float normpdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}vec3 weightedBlur(){float cocIn=2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv)).a-1.;float kernelRadius=MAXIMUM_BLUR_SIZE*cocIn;vec2 invSize=1./colorTextureSize;cocIn*=cocIn*cocIn;float centreSpaceWeight=normpdf(0.,SIGMA)*abs(cocIn);float weightSum=centreSpaceWeight;vec3 centreSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb;vec3 diffuseSum=centreSample*weightSum;vec2 delta=invSize*kernelRadius/float(NUM_SAMPLES);for(int i=1;i<=NUM_SAMPLES;i++){float spaceWeight=normpdf(float(i),SIGMA);vec2 texcoord=direction*delta*float(i);vec4 rightSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv+texcoord));vec4 leftSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv-texcoord));float leftCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv-texcoord)).a-1.);float rightCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv+texcoord)).a-1.);leftCocWeight*=leftCocWeight*leftCocWeight;rightCocWeight*=rightCocWeight*rightCocWeight;diffuseSum+=((leftSample.rgb*leftCocWeight)+(rightSample.rgb*rightCocWeight))*spaceWeight;weightSum+=(spaceWeight*(leftCocWeight+rightCocWeight));}return diffuseSum/weightSum;}void main(){gl_FragColor=vec4(weightedBlur(),1.);\n#include <encodings_fragment>\n}"
  }, "colorTexture", "cocTexture"), Lt({
    uniforms: {
      colorTexture: {
        value: null
      },
      colorTextureSize: {
        value: new i.FM8()
      },
      direction: {
        value: new i.FM8()
      },
      frameCount: {
        value: 0
      },
      blurRadius: {
        value: 16
      }
    },
    vertexShader: go,
    fragmentShader: xo + "\n" + Gc + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform float blurRadius;vec4 CircularBlur(){vec4 color=colorTextureTexelToLinear(texture2D(colorTexture,vUv));\n#ifdef DOF_MODE\nfloat blurDist=blurRadius*(2.*color.a-1.);\n#else\nfloat blurDist=blurRadius*color.a;\n#endif\nfloat rnd=PI2*random3(vec3(vUv,frameCount*0.1));float costheta=cos(rnd);float sintheta=sin(rnd);vec4 rotationMatrix=vec4(costheta,-sintheta,sintheta,costheta);vec3 colorSum=vec3(0.);float weightSum=0.001;vec2 ofs;vec4 sampleColor;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));sampleColor=colorTextureTexelToLinear(texture2D(colorTexture,vUv+blurDist*ofs/colorTextureSize.xy));\n#ifdef DOF_MODE\nsampleColor.a=abs(sampleColor.a*2.-1.);sampleColor.a*=sampleColor.a*sampleColor.a;\n#endif\ncolorSum+=sampleColor.rgb*sampleColor.a;weightSum+=sampleColor.a;}\n#pragma unroll_loop_end\ncolorSum/=weightSum;return vec4(saturate(colorSum),1.);}void main(){gl_FragColor=CircularBlur();\n#include <encodings_fragment>\n}",
    defines: {
      DOF_MODE: 1
    }
  }, "colorTexture"));

  class Ju extends It {
    constructor() {
      super(Yu, "colorTexture", "cocTexture", "blurTexture"), this.dofBlurMaterial = Zu, this.nearFarBlurScale = new i.FM8(.25, .25), this.focalDepthRange = new i.FM8(.5, 1.5), this.crossCenter = new i.FM8(.5, .5), this.crossRadius = .04, this.crossAlpha = 1, this.crossColor = new ve(16750848), this.uiConfig = {
        type: "folder",
        label: "Depth of Field",
        children: [{
          type: "checkbox",
          label: "Enabled",
          limitedUi: !0,
          property: [this, "enabled"]
        }, {
          type: "slider",
          label: "Depth Range",
          bounds: [.5, 3],
          property: [this.focalDepthRange, "y"]
        }, {
          type: "slider",
          label: "Near Blur scale",
          bounds: [0, 1],
          property: [this.nearFarBlurScale, "x"]
        }, {
          type: "slider",
          label: "Far Blur scale",
          bounds: [0, 1],
          property: [this.nearFarBlurScale, "y"]
        }]
      }, this.material.extensions.derivatives = !0, this.computeCocMaterial = Lt({
        uniforms: {
          colorTexture: {
            value: null
          },
          tNormalDepth: this.uniforms.tNormalDepth,
          cameraNearFar: this.uniforms.cameraNearFar,
          nearFarBlurScale: this.uniforms.nearFarBlurScale,
          focalDepthRange: this.uniforms.focalDepthRange
        },
        vertexShader: go,
        fragmentShader: Bt + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;float computeCoc(){float depth=getDepth(vUv);if(depth==1.)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*computeCoc()+0.5);\n#include <encodings_fragment>\n}"
      }, "colorTexture"), this.expandCocMaterial = Lt({
        uniforms: {
          colorTexture: {
            value: null
          },
          colorTextureSize: {
            value: new i.FM8()
          },
          direction: {
            value: new i.FM8()
          },
          tNormalDepth: this.uniforms.tNormalDepth,
          nearFarBlurScale: this.uniforms.nearFarBlurScale
        },
        vertexShader: go,
        fragmentShader: Bt + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;uniform vec2 nearFarBlurScale;const float MAXIMUM_BLUR_SIZE=4.;float expandNear(const in vec2 offset,const in bool isBackground){float coc=0.;vec2 sampleOffsets=MAXIMUM_BLUR_SIZE*offset/5.;float coc0=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv)).a-1.;float coc1=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-5.*sampleOffsets)).a-1.;float coc2=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-4.*sampleOffsets)).a-1.;float coc3=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-3.*sampleOffsets)).a-1.;float coc4=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-2.*sampleOffsets)).a-1.;float coc5=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-1.*sampleOffsets)).a-1.;float coc6=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+1.*sampleOffsets)).a-1.;float coc7=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+2.*sampleOffsets)).a-1.;float coc8=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+3.*sampleOffsets)).a-1.;float coc9=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+4.*sampleOffsets)).a-1.;float coc10=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+5.*sampleOffsets)).a-1.;if(isBackground){coc=abs(coc0)*0.095474+(abs(coc1)+abs(coc10))*0.084264+(abs(coc2)+abs(coc9))*0.088139+(abs(coc3)+abs(coc8))*0.091276+(abs(coc4)+abs(coc7))*0.093585+(abs(coc5)+abs(coc6))*0.094998;}else{coc=min(coc0,0.);coc=min(coc1*0.3,coc);coc=min(coc2*0.5,coc);coc=min(coc3*0.75,coc);coc=min(coc4*0.8,coc);coc=min(coc5*0.95,coc);coc=min(coc6*0.95,coc);coc=min(coc7*0.8,coc);coc=min(coc8*0.75,coc);coc=min(coc9*0.5,coc);coc=min(coc10*0.3,coc);if(abs(coc0)>abs(coc))coc=coc0;}return coc;}void main(){vec2 offset=2.*direction/colorTextureSize;bool isBackground=getDepth(vUv)>1.-0.001;float coc=expandNear(offset,isBackground);gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*coc+0.5);\n#include <encodings_fragment>\n}"
      }, "colorTexture");
    }

    render(e, t, n, r, s) {
      if (!this.enabled) return;
      const o = e.baseRenderer,
            a = {
        minFilter: i.TyD,
        magFilter: i.TyD,
        type: i.cLu,
        encoding: i.rnI,
        sizeMultiplier: .5,
        isAntialiased: !1,
        format: i.wk1,
        depthBuffer: !1,
        generateMipmaps: !1
      },
            l = o.getTempTarget(a),
            c = o.getTempTarget(a);
      if (this.computeCocMaterial.uniforms.colorTexture.value = n.texture, o.blit(void 0, l, {
        material: this.computeCocMaterial
      }), this.expandCocMaterial.uniforms.colorTexture.value = l.texture, this.expandCocMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, c, {
        material: this.expandCocMaterial
      }), this.expandCocMaterial.uniforms.colorTexture.value = c.texture, this.expandCocMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, l, {
        material: this.expandCocMaterial
      }), this.dofBlurMaterial.uniforms.frameCount) this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, o.blit(void 0, c, {
        material: this.dofBlurMaterial
      });else {
        const e = o.getTempTarget(a);
        this.dofBlurMaterial.uniforms.cocTexture.value = l.texture, this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, this.dofBlurMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, e, {
          material: this.dofBlurMaterial
        }), this.dofBlurMaterial.uniforms.colorTexture.value = e.texture, this.dofBlurMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, c, {
          material: this.dofBlurMaterial
        }), o.releaseTempTarget(e);
      }
      this.material.uniforms.blurTexture.value = c.texture, this.material.uniforms.cocTexture.value = l.texture, super.render(e, t, n, r, s), o.releaseTempTarget(l), o.releaseTempTarget(c);
    }

  }

  qu([xe(), V()], Ju.prototype, "nearFarBlurScale", void 0), qu([xe(), V()], Ju.prototype, "focalDepthRange", void 0), qu([V()], Ju.prototype, "crossCenter", void 0), qu([V()], Ju.prototype, "crossRadius", void 0), qu([V()], Ju.prototype, "crossAlpha", void 0), qu([V()], Ju.prototype, "crossColor", void 0);

  var $u = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Qu extends Gs {
    constructor(e = !0, t = !1) {
      super(), this.passId = "depthOfField", this._beforeFilters = ["progressive", "tonemap", "screen"], this._afterFilters = ["render"], this._requiredFilters = ["render"], this.dependencies = [Xs], this.enableEdit = !1, this._focalPointHit = new i.Pa4(0, 0, 0), this.crossFadeTime = 200, this._focalPointHitTime = 0, this._tempVec = new i.Pa4(), this.enabled = e, this.enableEdit = t, this._onObjectHit = this._onObjectHit.bind(this), this.setDirty = this.setDirty.bind(this);
    }

    passCtor(e) {
      return new Ju();
    }

    setFocalPoint(e, t = !0, n = !1) {
      var r, i;
      this._focalPointHit.copy(e), t && (null === (i = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPlugin(_c)) || void 0 === i || i.startTransition(this._frameFadeTime)), n && (this._focalPointHitTime = At()), this.setDirty();
    }

    getFocalPoint() {
      return this._focalPointHit;
    }

    get depthRange() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.focalDepthRange.y) && void 0 !== t ? t : 0;
    }

    set depthRange(e) {
      this.pass && (this.pass.passObject.focalDepthRange.y = e), this.setDirty();
    }

    get nearBlurScale() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.nearFarBlurScale.x) && void 0 !== t ? t : 0;
    }

    set nearBlurScale(e) {
      this.pass && (this.pass.passObject.nearFarBlurScale.x = e), this.setDirty();
    }

    get farBlurScale() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.nearFarBlurScale.y) && void 0 !== t ? t : 0;
    }

    set farBlurScale(e) {
      this.pass && (this.pass.passObject.nearFarBlurScale.y = e), this.setDirty();
    }

    get _frameFadeTime() {
      return 2.5 * this.crossFadeTime;
    }

    _onObjectHit(e) {
      var t, n;
      this._pass && e.intersects.intersect && this.enabled && this.enableEdit && (this._focalPointHit.copy(e.intersects.intersect.point), this._focalPointHitTime = e.time, e.intersects.selectedObject = null, null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(_c)) || void 0 === n || n.startTransition(this._frameFadeTime), this.setDirty());
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("hitObject", this._onObjectHit);
    }

    async onRemove(e) {
      var t;
      return null === (t = e.getPluginByType("Picking")) || void 0 === t || t.removeEventListener("hitObject", this._onObjectHit), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    _update(e) {
      var t, n;
      if (!super._update(e)) return !1;
      const r = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
      if (!r) return !1;
      const s = e.getPlugin(Xs);
      null == s || s.updateShaderProperties(r.material), r.dofBlurMaterial.uniforms.frameCount && (null === (n = e.renderer) || void 0 === n || n.updateShaderProperties(r.dofBlurMaterial));
      const o = e.scene.activeCamera;
      if (!o) return !1;
      o.cameraObject.updateMatrixWorld(!0), o.updateShaderProperties(r.material), this._tempVec.subVectors(this._focalPointHit, o.cameraObject.position), r.focalDepthRange.x = this._tempVec.length(), r.focalDepthRange.x *= o.cameraObject.getWorldDirection(new i.Pa4()).dot(this._tempVec.normalize());
      let a = (At() - this._focalPointHitTime) / this.crossFadeTime;

      if (a = 1 - Math.min(1, Math.max(0, a)), Math.abs(a - r.crossAlpha) > .01 && (r.crossAlpha = a, this.setDirty()), a > 0) {
        const e = this._tempVec.copy(this._focalPointHit).project(o.cameraObject).addScalar(1).divideScalar(2);

        r.crossCenter.set(e.x, e.y), r.computeCocMaterial.uniformsNeedUpdate = !0, r.expandCocMaterial.uniformsNeedUpdate = !0;
      }

      return !0;
    }

    get uiConfig() {
      var e, t, n, r, i;
      if (this._uiConfig) return this._uiConfig;
      const s = null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig;
      return s ? (null === (r = null === (n = s.children) || void 0 === n ? void 0 : n.map(e => x(e))) || void 0 === r || r.flat(2).forEach(e => e && (e.onChange = this.setDirty)), null === (i = s.children) || void 0 === i || i.push({
        type: "checkbox",
        label: "Enable Edit",
        limitedUi: !0,
        property: [this, "enableEdit"]
      }), this._uiConfig = s, s) : {};
    }

  }

  Qu.PluginType = "DepthOfField", $u([xe()], Qu.prototype, "enableEdit", void 0), $u([xe("focalPoint")], Qu.prototype, "_focalPointHit", void 0), $u([xe()], Qu.prototype, "crossFadeTime", void 0);

  var ep,
      tp = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let np = ep = class extends zs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.radius = .015, this.intensity = 1, this.tolerance = 1.5, this._defines = {}, this.onlySSCSDebug = !1, this.stepCount = 2, this.dependencies = [Xs, js], this.materialExtension = {
        shaderExtender: (e, t, n) => {
          if (!e.defines.SSCS_ENABLED) return;
          const r = M`
                #ifndef D_sceneBoundingRadius
                #define D_sceneBoundingRadius
                uniform float sceneBoundingRadius;
                #endif
                float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightDirection ) {
                    vec3 ray_origin_view = -vViewPosition;
                    float rnd = interleavedGradientNoise(gl_FragCoord.xy, frameCount+34.);
                    float cameraDist = length(cameraPositionWorld);
//                    float radius = mix((cameraNearFar.y) + ray_origin_view.z, -ray_origin_view.z - cameraNearFar.x, rnd * 0.5 + 0.5)*sscsRadius;
                    float radius = mix((cameraDist + sceneBoundingRadius) + ray_origin_view.z, -ray_origin_view.z - max(0.0, cameraDist - sceneBoundingRadius), rnd * 0.5 + 0.5)*sscsRadius;
                    vec3 state = vec3(1.,(rnd+0.5)/float(SSCS_STEP_COUNT),2.);
                    traceRay(ray_origin_view, normalize(lightDirection) * radius, sscsTolerance * radius * 2., state, SSCS_STEP_COUNT);
                    state.z = state.z > 0.99 ? 1. : max(0.,min(state.z * state.z * (1.-sscsIntensity), 1.));
                    
                #if defined(SSCS_DEBUG) && SSCS_DEBUG > 0
                    return state.z;
                #endif
            `,
                s = `\n#if SSCS_ENABLED\n\n    uniform float sscsIntensity;\n    uniform float sscsRadius;\n    uniform float sscsTolerance;\n\n    ${bo}\n    \n    #define THREE_PACKING_INCLUDED\n    ${vo}\n    \n    ${Bt}\n    ${xo}\n    \n    ${wo}\n\n#endif\n            \n            ` + i.WdD.shadowmap_pars_fragment.replace("float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {", `${r}\n`).replace("return shadow;", "return min(shadow, state.z);");
          e.fragmentShader = e.fragmentShader.replace("#include <shadowmap_pars_fragment>", s), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", i.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ], directLight.direction ) : 1.0;").replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ], directLight.direction ) : 1.0;");
        },
        onObjectRender: (e, t, n) => {
          var r;
          const i = t.materialObject;
          let s = this.enabled && !1 !== n.userData.screenSpaceRendering && !(null === (r = i.userData) || void 0 === r ? void 0 : r.sscsDisabled) ? 1 : 0;
          i.defines.SSCS_ENABLED !== s && (i.defines.SSCS_ENABLED = s, i.needsUpdate = !0), s = this._defines.SSCS_STEP_COUNT, i.defines.SSCS_STEP_COUNT !== s && (i.defines.SSCS_STEP_COUNT = s, i.needsUpdate = !0), s = +this._defines.SSCS_DEBUG, i.defines.SSCS_DEBUG !== s && (i.defines.SSCS_DEBUG = s, i.needsUpdate = !0);
        },
        parsFragmentSnippet: () => "\n",
        extraUniforms: { ...ep._uniforms
        },
        computeCacheKey: e => this.enabled ? "1" : "0",
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => {
          var e, t, n, r, i;
          return [null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Xs), null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(po), null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.activeCamera, null === (r = this._viewer) || void 0 === r ? void 0 : r.renderer, null === (i = this._viewer) || void 0 === i ? void 0 : i.scene];
        }
      }, this.enabled = e, this.userData = {
        setDirty: () => {
          var e;
          null === (e = this._viewer) || void 0 === e || e.setDirty();
        }
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.registerMaterialExtension(this.materialExtension);
    }

    async onRemove(e) {
      var t, n;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), super.onRemove(e);
    }

  };
  np.PluginType = "SSContactShadows", np._uniforms = {
    tNormalDepth: {
      value: null
    },
    frameCount: {
      value: 0
    },
    projection: {
      value: new i.yGw()
    },
    cameraPositionWorld: {
      value: new i.Pa4()
    },
    cameraNearFar: {
      value: new i.FM8(.1, 1e3)
    },
    sceneBoundingRadius: {
      value: 0
    }
  }, tp([Ve("Enabled"), xe()], np.prototype, "enabled", void 0), tp([V({
    uniforms: ep._uniforms,
    propKey: "sscsRadius"
  }), He("Radius", [1e-4, .1], 1e-4), xe()], np.prototype, "radius", void 0), tp([V({
    uniforms: ep._uniforms,
    propKey: "sscsIntensity"
  }), He("Intensity", [1e-4, 1], 1e-4), xe()], np.prototype, "intensity", void 0), tp([V({
    uniforms: ep._uniforms,
    propKey: "sscsTolerance"
  }), He("Tolerance", [.1, 5]), xe()], np.prototype, "tolerance", void 0), tp([G("SSCS_DEBUG", void 0, !0), Ve("Debug only SSCS"), xe()], np.prototype, "onlySSCSDebug", void 0), tp([G("SSCS_STEP_COUNT", void 0, !0), He("Step count", [1, 8], 1), xe()], np.prototype, "stepCount", void 0), np = ep = tp([Qe("Screen Space Contact Shadows")], np);

  class rp {
    constructor(e = 4) {
      this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
    }

    _initWorker(e) {
      if (!this.workers[e]) {
        const t = this.workerCreator();
        t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
      }
    }

    _getIdleWorker() {
      for (let e = 0; e < this.pool; e++) if (!(this.workerStatus & 1 << e)) return e;

      return -1;
    }

    _onMessage(e, t) {
      const n = this.workersResolve[e];

      if (n && n(t), this.queue.length) {
        const {
          resolve: t,
          msg: n,
          transfer: r
        } = this.queue.shift();
        this.workersResolve[e] = t, this.workers[e].postMessage(n, r);
      } else this.workerStatus ^= 1 << e;
    }

    setWorkerCreator(e) {
      this.workerCreator = e;
    }

    setWorkerLimit(e) {
      this.pool = e;
    }

    postMessage(e, t) {
      return new Promise(n => {
        const r = this._getIdleWorker();

        -1 !== r ? (this._initWorker(r), this.workerStatus |= 1 << r, this.workersResolve[r] = n, this.workers[r].postMessage(e, t)) : this.queue.push({
          resolve: n,
          msg: e,
          transfer: t
        });
      });
    }

    dispose() {
      this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }

  }

  const ip = 0,
        sp = 1,
        op = 2,
        ap = 3,
        lp = 0,
        cp = 0,
        up = 2,
        pp = 0,
        hp = 1,
        dp = 160,
        fp = 161,
        _p = 162,
        mp = 163,
        gp = 0,
        vp = 1,
        bp = 0,
        xp = 1,
        yp = 2,
        wp = 3,
        Sp = 4,
        Mp = 5,
        Tp = 6,
        Ep = 7,
        Ap = 8,
        Cp = 9,
        Rp = 10,
        kp = 11,
        Pp = 12,
        Dp = 13,
        Op = 14,
        Lp = 15,
        Ip = 16,
        Fp = 17,
        Np = 18,
        Up = 0,
        Bp = 1,
        jp = 2,
        zp = 3,
        Vp = 4,
        Gp = 5,
        Hp = 6,
        Wp = 7,
        Kp = 8,
        Xp = 9,
        qp = 10,
        Yp = 11,
        Zp = 0,
        Jp = 1,
        $p = 2,
        Qp = 13,
        eh = 14,
        th = 15,
        nh = 128,
        rh = 64,
        ih = 32,
        sh = 16,
        oh = 0,
        ah = 1,
        lh = 2,
        ch = 3,
        uh = 4,
        ph = 5,
        hh = 6,
        dh = 7,
        fh = 8,
        _h = 9,
        mh = 10,
        gh = 13,
        vh = 14,
        bh = 15,
        xh = 16,
        yh = 17,
        wh = 20,
        Sh = 21,
        Mh = 22,
        Th = 23,
        Eh = 24,
        Ah = 27,
        Ch = 28,
        Rh = 29,
        kh = 30,
        Ph = 31,
        Dh = 34,
        Oh = 35,
        Lh = 36,
        Ih = 37,
        Fh = 38,
        Nh = 41,
        Uh = 42,
        Bh = 43,
        jh = 44,
        zh = 45,
        Vh = 48,
        Gh = 49,
        Hh = 50,
        Wh = 58,
        Kh = 59,
        Xh = 62,
        qh = 63,
        Yh = 64,
        Zh = 65,
        Jh = 68,
        $h = 69,
        Qh = 70,
        ed = 71,
        td = 74,
        nd = 75,
        rd = 76,
        id = 77,
        sd = 78,
        od = 81,
        ad = 82,
        ld = 83,
        cd = 84,
        ud = 85,
        pd = 88,
        hd = 89,
        dd = 90,
        fd = 91,
        _d = 92,
        md = 95,
        gd = 96,
        vd = 97,
        bd = 98,
        xd = 99,
        yd = 100,
        wd = 101,
        Sd = 102,
        Md = 103,
        Td = 104,
        Ed = 105,
        Ad = 106,
        Cd = 107,
        Rd = 108,
        kd = 109,
        Pd = 110,
        Dd = 111,
        Od = 112,
        Ld = 113,
        Id = 114,
        Fd = 115,
        Nd = 116,
        Ud = 117,
        Bd = 118,
        jd = 119,
        zd = 120,
        Vd = 121,
        Gd = 122,
        Hd = 123,
        Wd = 124,
        Kd = 125,
        Xd = 126,
        qd = 127,
        Yd = 128,
        Zd = 129,
        Jd = 130,
        $d = 131,
        Qd = 132,
        ef = 133,
        tf = 134,
        nf = 135,
        rf = 136,
        sf = 137,
        of = 138,
        af = 139,
        lf = 140,
        cf = 141,
        uf = 142,
        pf = 143,
        hf = 144,
        df = 145,
        ff = 146,
        _f = 147,
        mf = 148,
        gf = 149,
        vf = 150,
        bf = 151,
        xf = 152,
        yf = 153,
        wf = 154,
        Sf = 155,
        Mf = 156,
        Tf = 157,
        Ef = 158,
        Af = 159,
        Cf = 160,
        Rf = 161,
        kf = 162,
        Pf = 163,
        Df = 164,
        Of = 165,
        Lf = 166,
        If = 167,
        Ff = 168,
        Nf = 169,
        Uf = 170,
        Bf = 171,
        jf = 172,
        zf = 173,
        Vf = 174,
        Gf = 175,
        Hf = 176,
        Wf = 177,
        Kf = 178,
        Xf = 179,
        qf = 180,
        Yf = 181,
        Zf = 182,
        Jf = 183,
        $f = 184,
        Qf = 1000156007,
        e_ = 1000156008,
        t_ = 1000156009,
        n_ = 1000156010,
        r_ = 1000156011,
        i_ = 1000156017,
        s_ = 1000156018,
        o_ = 1000156019,
        a_ = 1000156020,
        l_ = 1000156021,
        c_ = 1000054e3,
        u_ = 1000054001,
        p_ = 1000054002,
        h_ = 1000054003,
        d_ = 1000054004,
        f_ = 1000054005,
        __ = 1000054006,
        m_ = 1000054007,
        g_ = 1000066e3,
        v_ = 1000066001,
        b_ = 1000066002,
        x_ = 1000066003,
        y_ = 1000066004,
        w_ = 1000066005,
        S_ = 1000066006,
        M_ = 1000066007,
        T_ = 1000066008,
        E_ = 1000066009,
        A_ = 1000066010,
        C_ = 1000066011,
        R_ = 1000066012,
        k_ = 1000066013,
        P_ = 100034e4,
        D_ = 1000340001;

  class O_ {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
        vendorId: 0,
        descriptorType: 0,
        descriptorBlockSize: 0,
        versionNumber: 2,
        colorModel: 0,
        colorPrimaries: 1,
        transferFunction: 2,
        flags: 0,
        texelBlockDimension: [0, 0, 0, 0],
        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
        samples: []
      }], this.keyValue = {}, this.globalData = null;
    }

  }

  class L_ {
    constructor(e, t, n, r) {
      this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = r, this._offset = 0;
    }

    _nextUint8() {
      const e = this._dataView.getUint8(this._offset);

      return this._offset += 1, e;
    }

    _nextUint16() {
      const e = this._dataView.getUint16(this._offset, this._littleEndian);

      return this._offset += 2, e;
    }

    _nextUint32() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _nextUint64() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);

      return this._offset += 8, e;
    }

    _nextInt32() {
      const e = this._dataView.getInt32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _skip(e) {
      return this._offset += e, this;
    }

    _scan(e, t = 0) {
      const n = this._offset;
      let r = 0;

      for (; this._dataView.getUint8(this._offset) !== t && r < e;) r++, this._offset++;

      return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r);
    }

  }

  const I_ = new Uint8Array([0]),
        F_ = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

  function N_(e) {
    return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e) : Buffer.from(e);
  }

  function U_(e) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
  }

  function B_(e) {
    let t = 0;

    for (const n of e) t += n.byteLength;

    const n = new Uint8Array(t);
    let r = 0;

    for (const t of e) n.set(new Uint8Array(t), r), r += t.byteLength;

    return n;
  }

  function j_(e) {
    const t = new Uint8Array(e.buffer, e.byteOffset, F_.length);
    if (t[0] !== F_[0] || t[1] !== F_[1] || t[2] !== F_[2] || t[3] !== F_[3] || t[4] !== F_[4] || t[5] !== F_[5] || t[6] !== F_[6] || t[7] !== F_[7] || t[8] !== F_[8] || t[9] !== F_[9] || t[10] !== F_[10] || t[11] !== F_[11]) throw new Error("Missing KTX 2.0 identifier.");
    const n = new O_(),
          r = 17 * Uint32Array.BYTES_PER_ELEMENT,
          i = new L_(e, F_.length, r, !0);
    n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();

    const s = i._nextUint32();

    n.supercompressionScheme = i._nextUint32();

    const o = i._nextUint32(),
          a = i._nextUint32(),
          l = i._nextUint32(),
          c = i._nextUint32(),
          u = i._nextUint64(),
          p = i._nextUint64(),
          h = new L_(e, F_.length + r, 3 * s * 8, !0);

    for (let t = 0; t < s; t++) n.levels.push({
      levelData: new Uint8Array(e.buffer, e.byteOffset + h._nextUint64(), h._nextUint64()),
      uncompressedByteLength: h._nextUint64()
    });

    const d = new L_(e, o, a, !0),
          f = {
      vendorId: d._skip(4)._nextUint16(),
      descriptorType: d._nextUint16(),
      versionNumber: d._nextUint16(),
      descriptorBlockSize: d._nextUint16(),
      colorModel: d._nextUint8(),
      colorPrimaries: d._nextUint8(),
      transferFunction: d._nextUint8(),
      flags: d._nextUint8(),
      texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      samples: []
    },
          _ = (f.descriptorBlockSize / 4 - 6) / 4;

    for (let e = 0; e < _; e++) {
      const t = {
        bitOffset: d._nextUint16(),
        bitLength: d._nextUint8(),
        channelType: d._nextUint8(),
        samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
        sampleLower: -1 / 0,
        sampleUpper: 1 / 0
      };
      64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t;
    }

    n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f);
    const m = new L_(e, l, c, !0);

    for (; m._offset < c;) {
      const e = m._nextUint32(),
            t = m._scan(e),
            r = U_(t),
            i = m._scan(e - t.byteLength);

      n.keyValue[r] = r.match(/^ktx/i) ? U_(i) : i, m._offset % 4 && m._skip(4 - m._offset % 4);
    }

    if (p <= 0) return n;

    const g = new L_(e, u, p, !0),
          v = g._nextUint16(),
          b = g._nextUint16(),
          x = g._nextUint32(),
          y = g._nextUint32(),
          w = g._nextUint32(),
          S = g._nextUint32(),
          M = [];

    for (let e = 0; e < s; e++) M.push({
      imageFlags: g._nextUint32(),
      rgbSliceByteOffset: g._nextUint32(),
      rgbSliceByteLength: g._nextUint32(),
      alphaSliceByteOffset: g._nextUint32(),
      alphaSliceByteLength: g._nextUint32()
    });

    const T = u + g._offset,
          E = T + x,
          A = E + y,
          C = A + w,
          R = new Uint8Array(e.buffer, e.byteOffset + T, x),
          k = new Uint8Array(e.buffer, e.byteOffset + E, y),
          P = new Uint8Array(e.buffer, e.byteOffset + A, w),
          D = new Uint8Array(e.buffer, e.byteOffset + C, S);
    return n.globalData = {
      endpointCount: v,
      selectorCount: b,
      imageDescs: M,
      endpointsData: R,
      selectorsData: k,
      tablesData: P,
      extendedData: D
    }, n;
  }

  function z_() {
    return (z_ = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }).apply(this, arguments);
  }

  const V_ = {
    keepWriter: !1
  };

  function G_(e, t = {}) {
    t = z_({}, V_, t);
    let n = new ArrayBuffer(0);

    if (e.globalData) {
      const t = new ArrayBuffer(20 + 5 * e.globalData.imageDescs.length * 4),
            r = new DataView(t);
      r.setUint16(0, e.globalData.endpointCount, !0), r.setUint16(2, e.globalData.selectorCount, !0), r.setUint32(4, e.globalData.endpointsData.byteLength, !0), r.setUint32(8, e.globalData.selectorsData.byteLength, !0), r.setUint32(12, e.globalData.tablesData.byteLength, !0), r.setUint32(16, e.globalData.extendedData.byteLength, !0);

      for (let t = 0; t < e.globalData.imageDescs.length; t++) {
        const n = e.globalData.imageDescs[t];
        r.setUint32(20 + 5 * t * 4 + 0, n.imageFlags, !0), r.setUint32(20 + 5 * t * 4 + 4, n.rgbSliceByteOffset, !0), r.setUint32(20 + 5 * t * 4 + 8, n.rgbSliceByteLength, !0), r.setUint32(20 + 5 * t * 4 + 12, n.alphaSliceByteOffset, !0), r.setUint32(20 + 5 * t * 4 + 16, n.alphaSliceByteLength, !0);
      }

      n = B_([t, e.globalData.endpointsData, e.globalData.selectorsData, e.globalData.tablesData, e.globalData.extendedData]);
    }

    const r = [];
    let i = e.keyValue;
    t.keepWriter || (i = z_({}, e.keyValue, {
      KTXwriter: "KTX-Parse v0.3.1"
    }));

    for (const e in i) {
      const t = i[e],
            n = N_(e),
            s = "string" == typeof t ? N_(t) : t,
            o = n.byteLength + 1 + s.byteLength + 1,
            a = o % 4 ? 4 - o % 4 : 0;
      r.push(B_([new Uint32Array([o]), n, I_, s, I_, new Uint8Array(a).fill(0)]));
    }

    const s = B_(r);
    if (1 !== e.dataFormatDescriptor.length || 0 !== e.dataFormatDescriptor[0].descriptorType) throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");
    const o = e.dataFormatDescriptor[0],
          a = new ArrayBuffer(28 + 16 * o.samples.length),
          l = new DataView(a),
          c = 24 + 16 * o.samples.length;
    if (l.setUint32(0, a.byteLength, !0), l.setUint16(4, o.vendorId, !0), l.setUint16(6, o.descriptorType, !0), l.setUint16(8, o.versionNumber, !0), l.setUint16(10, c, !0), l.setUint8(12, o.colorModel), l.setUint8(13, o.colorPrimaries), l.setUint8(14, o.transferFunction), l.setUint8(15, o.flags), !Array.isArray(o.texelBlockDimension)) throw new Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
    l.setUint8(16, o.texelBlockDimension[0]), l.setUint8(17, o.texelBlockDimension[1]), l.setUint8(18, o.texelBlockDimension[2]), l.setUint8(19, o.texelBlockDimension[3]);

    for (let e = 0; e < 8; e++) l.setUint8(20 + e, o.bytesPlane[e]);

    for (let e = 0; e < o.samples.length; e++) {
      const t = o.samples[e],
            n = 28 + 16 * e;
      if (t.channelID) throw new Error("channelID has been renamed to channelType.");
      l.setUint16(n + 0, t.bitOffset, !0), l.setUint8(n + 2, t.bitLength), l.setUint8(n + 3, t.channelType), l.setUint8(n + 4, t.samplePosition[0]), l.setUint8(n + 5, t.samplePosition[1]), l.setUint8(n + 6, t.samplePosition[2]), l.setUint8(n + 7, t.samplePosition[3]), 64 & t.channelType ? (l.setInt32(n + 8, t.sampleLower, !0), l.setInt32(n + 12, t.sampleUpper, !0)) : (l.setUint32(n + 8, t.sampleLower, !0), l.setUint32(n + 12, t.sampleUpper, !0));
    }

    const u = F_.length + 68 + 3 * e.levels.length * 8,
          p = u + a.byteLength;
    let h = n.byteLength > 0 ? p + s.byteLength : 0;
    h % 8 && (h += 8 - h % 8);
    const d = [],
          f = new DataView(new ArrayBuffer(3 * e.levels.length * 8));

    let _ = (h || p + s.byteLength) + n.byteLength;

    for (let t = 0; t < e.levels.length; t++) {
      const n = e.levels[t];
      d.push(n.levelData), f.setBigUint64(24 * t + 0, BigInt(_), !0), f.setBigUint64(24 * t + 8, BigInt(n.levelData.byteLength), !0), f.setBigUint64(24 * t + 16, BigInt(n.uncompressedByteLength), !0), _ += n.levelData.byteLength;
    }

    const m = new ArrayBuffer(68),
          g = new DataView(m);
    return g.setUint32(0, e.vkFormat, !0), g.setUint32(4, e.typeSize, !0), g.setUint32(8, e.pixelWidth, !0), g.setUint32(12, e.pixelHeight, !0), g.setUint32(16, e.pixelDepth, !0), g.setUint32(20, e.layerCount, !0), g.setUint32(24, e.faceCount, !0), g.setUint32(28, e.levels.length, !0), g.setUint32(32, e.supercompressionScheme, !0), g.setUint32(36, u, !0), g.setUint32(40, a.byteLength, !0), g.setUint32(44, p, !0), g.setUint32(48, s.byteLength, !0), g.setBigUint64(52, BigInt(n.byteLength > 0 ? h : 0), !0), g.setBigUint64(60, BigInt(n.byteLength), !0), new Uint8Array(B_([new Uint8Array(F_).buffer, m, f.buffer, a, s, h > 0 ? new ArrayBuffer(h - (p + s.byteLength)) : new ArrayBuffer(0), n, ...d]));
  }

  const {
    read: H_,
    KHR_DF_FLAG_ALPHA_PREMULTIPLIED: W_,
    KHR_DF_TRANSFER_SRGB: K_,
    VK_FORMAT_UNDEFINED: X_,
    VK_FORMAT_R16_SFLOAT: q_,
    VK_FORMAT_R16G16_SFLOAT: Y_,
    VK_FORMAT_R16G16B16A16_SFLOAT: Z_,
    VK_FORMAT_R32_SFLOAT: J_,
    VK_FORMAT_R32G32_SFLOAT: $_,
    VK_FORMAT_R32G32B32A32_SFLOAT: Q_,
    VK_FORMAT_R8_SRGB: em,
    VK_FORMAT_R8_UNORM: tm,
    VK_FORMAT_R8G8_SRGB: nm,
    VK_FORMAT_R8G8_UNORM: rm,
    VK_FORMAT_R8G8B8A8_SRGB: im,
    VK_FORMAT_R8G8B8A8_UNORM: sm
  } = e,
        om = new WeakMap();
  let am = 0;

  class lm extends i.aNw {
    constructor(e) {
      super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new rp(), this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }

    setTranscoderPath(e) {
      return this.transcoderPath = e, this;
    }

    setWorkerLimit(e) {
      return this.workerPool.setWorkerLimit(e), this;
    }

    detectSupport(e) {
      return this.workerConfig = {
        astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this;
    }

    init() {
      if (!this.transcoderPending) {
        const e = new i.hH6(this.manager);
        e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
        const t = e.loadAsync("basis_transcoder.js"),
              n = new i.hH6(this.manager);
        n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
        const r = n.loadAsync("basis_transcoder.wasm");
        this.transcoderPending = Promise.all([t, r]).then(([e, t]) => {
          const n = lm.BasisWorker.toString(),
                r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(lm.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(lm.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(lm.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([r])), this.transcoderBinary = t, this.workerPool.setWorkerCreator(() => {
            const e = new Worker(this.workerSourceURL),
                  t = this.transcoderBinary.slice(0);
            return e.postMessage({
              type: "init",
              config: this.workerConfig,
              transcoderBinary: t
            }, [t]), e;
          });
        }), am > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), am++;
      }

      return this.transcoderPending;
    }

    load(e, t, n, r) {
      if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
      const s = new i.hH6(this.manager);
      s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials), s.load(e, e => {
        if (om.has(e)) return om.get(e).promise.then(t).catch(r);
        this.createTexture(e).then(e => t ? t(e) : null).catch(r);
      }, n, r);
    }

    _createTextureFrom(e) {
      const {
        mipmaps: t,
        width: n,
        height: r,
        format: s,
        type: o,
        error: a,
        dfdTransferFn: l,
        dfdFlags: c
      } = e;
      if ("error" === o) return Promise.reject(a);
      const u = new i.EB7(t, n, r, s, i.ywz);
      return u.minFilter = 1 === t.length ? i.wem : i.D1R, u.magFilter = i.wem, u.generateMipmaps = !1, u.needsUpdate = !0, u.encoding = l === K_ ? i.knz : i.rnI, u.premultiplyAlpha = !!(c & W_), u;
    }

    createTexture(e, t = {}) {
      const n = H_(new Uint8Array(e));
      if (n.vkFormat !== X_) return function (e) {
        const {
          vkFormat: t,
          pixelWidth: n,
          pixelHeight: r,
          pixelDepth: s
        } = e;
        if (void 0 === cm[t]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
        let o;
        const a = e.levels[0].levelData;
        o = um[t] === i.VzW ? new Float32Array(a.buffer, a.byteOffset, a.byteLength / Float32Array.BYTES_PER_ELEMENT) : um[t] === i.cLu ? new Uint16Array(a.buffer, a.byteOffset, a.byteLength / Uint16Array.BYTES_PER_ELEMENT) : a;
        const l = 0 === s ? new i.IEO(o, n, r) : new i.JUT(o, n, r, s);
        return l.type = um[t], l.format = cm[t], l.encoding = pm[t] || i.rnI, l.needsUpdate = !0, Promise.resolve(l);
      }(n);
      const r = t,
            s = this.init().then(() => this.workerPool.postMessage({
        type: "transcode",
        buffer: e,
        taskConfig: r
      }, [e])).then(e => this._createTextureFrom(e.data));
      return om.set(e, {
        promise: s
      }), s;
    }

    dispose() {
      return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), am--, this;
    }

  }

  lm.BasisFormat = {
    ETC1S: 0,
    UASTC_4x4: 1
  }, lm.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16
  }, lm.EngineFormat = {
    RGBAFormat: i.wk1,
    RGBA_ASTC_4x4_Format: i.ptH,
    RGBA_BPTC_Format: i.bsb,
    RGBA_ETC2_EAC_Format: i.ekQ,
    RGBA_PVRTC_4BPPV1_Format: i.eaV,
    RGBA_S3TC_DXT5_Format: i.ILR,
    RGB_ETC1_Format: i.fto,
    RGB_ETC2_Format: i.l0P,
    RGB_PVRTC_4BPPV1_Format: i._AM,
    RGB_S3TC_DXT1_Format: i.wuA
  }, lm.BasisWorker = function () {
    let e, t, n;
    const r = _EngineFormat,
          i = _TranscoderFormat,
          s = _BasisFormat;
    self.addEventListener("message", function (o) {
      const u = o.data;

      switch (u.type) {
        case "init":
          e = u.config, p = u.transcoderBinary, t = new Promise(e => {
            n = {
              wasmBinary: p,
              onRuntimeInitialized: e
            }, BASIS(n);
          }).then(() => {
            n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          });
          break;

        case "transcode":
          t.then(() => {
            try {
              const {
                width: t,
                height: o,
                hasAlpha: p,
                mipmaps: h,
                format: d,
                dfdTransferFn: f,
                dfdFlags: _
              } = function (t) {
                const o = new n.KTX2File(new Uint8Array(t));

                function u() {
                  o.close(), o.delete();
                }

                if (!o.isValid()) throw u(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");

                const p = o.isUASTC() ? s.UASTC_4x4 : s.ETC1S,
                      h = o.getWidth(),
                      d = o.getHeight(),
                      f = o.getLevels(),
                      _ = o.getHasAlpha(),
                      m = o.getDFDTransferFunc(),
                      g = o.getDFDFlags(),
                      {
                  transcoderFormat: v,
                  engineFormat: b
                } = function (t, n, o, u) {
                  let p, h;
                  const d = t === s.ETC1S ? a : l;

                  for (let r = 0; r < d.length; r++) {
                    const i = d[r];
                    if (e[i.if] && i.basisFormat.includes(t) && !(u && i.transcoderFormat.length < 2) && (!i.needsPowerOfTwo || c(n) && c(o))) return p = i.transcoderFormat[u ? 1 : 0], h = i.engineFormat[u ? 1 : 0], {
                      transcoderFormat: p,
                      engineFormat: h
                    };
                  }

                  return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), p = i.RGBA32, h = r.RGBAFormat, {
                    transcoderFormat: p,
                    engineFormat: h
                  };
                }(p, h, d, _);

                if (!h || !d || !f) throw u(), new Error("THREE.KTX2Loader:\tInvalid texture");
                if (!o.startTranscoding()) throw u(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                const x = [];

                for (let e = 0; e < f; e++) {
                  const t = o.getImageLevelInfo(e, 0, 0),
                        n = t.origWidth,
                        r = t.origHeight,
                        i = new Uint8Array(o.getImageTranscodedSizeInBytes(e, 0, 0, v));
                  if (!o.transcodeImage(i, e, 0, 0, v, 0, -1, -1)) throw u(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                  x.push({
                    data: i,
                    width: n,
                    height: r
                  });
                }

                return u(), {
                  width: h,
                  height: d,
                  hasAlpha: _,
                  mipmaps: x,
                  format: b,
                  dfdTransferFn: m,
                  dfdFlags: g
                };
              }(u.buffer),
                    m = [];

              for (let e = 0; e < h.length; ++e) m.push(h[e].data.buffer);

              self.postMessage({
                type: "transcode",
                id: u.id,
                width: t,
                height: o,
                hasAlpha: p,
                mipmaps: h,
                format: d,
                dfdTransferFn: f,
                dfdFlags: _
              }, m);
            } catch (e) {
              console.error(e), self.postMessage({
                type: "error",
                id: u.id,
                error: e.message
              });
            }
          });
      }

      var p;
    });
    const o = [{
      if: "astcSupported",
      basisFormat: [s.UASTC_4x4],
      transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
      engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    }, {
      if: "bptcSupported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.BC7_M5, i.BC7_M5],
      engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    }, {
      if: "dxtSupported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.BC1, i.BC3],
      engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    }, {
      if: "etc2Supported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.ETC1, i.ETC2],
      engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    }, {
      if: "etc1Supported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.ETC1],
      engineFormat: [r.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    }, {
      if: "pvrtcSupported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
      engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    }],
          a = o.sort(function (e, t) {
      return e.priorityETC1S - t.priorityETC1S;
    }),
          l = o.sort(function (e, t) {
      return e.priorityUASTC - t.priorityUASTC;
    });

    function c(e) {
      return e <= 2 || 0 == (e & e - 1) && 0 !== e;
    }
  };
  const cm = {
    [Q_]: i.wk1,
    [Z_]: i.wk1,
    [sm]: i.wk1,
    [im]: i.wk1,
    [$_]: i.av9,
    [Y_]: i.av9,
    [rm]: i.av9,
    [nm]: i.av9,
    [J_]: i.hEm,
    [q_]: i.hEm,
    [em]: i.hEm,
    [tm]: i.hEm
  },
        um = {
    [Q_]: i.VzW,
    [Z_]: i.cLu,
    [sm]: i.ywz,
    [im]: i.ywz,
    [$_]: i.VzW,
    [Y_]: i.cLu,
    [rm]: i.ywz,
    [nm]: i.ywz,
    [J_]: i.VzW,
    [q_]: i.cLu,
    [em]: i.ywz,
    [tm]: i.ywz
  },
        pm = {
    [im]: i.knz,
    [nm]: i.knz,
    [em]: i.knz
  },
        hm = "KHR_texture_basisu";

  class dm extends r {
    constructor() {
      super(...arguments), this.dependencies = [js];
    }

    async onAdded(e) {
      var t, n, r, i;
      this._importer || (this._importer = new Zt(class extends lm {
        constructor(t) {
          super(t), this.setTranscoderPath("https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@master/webgl/transcoder/build/").detectSupport(e.renderer.rendererObject);
        }

        async createTexture(e, t) {
          const n = e.map(e => new Uint8Array(e.slice(0))),
                r = await super.createTexture(e, t);
          return r.source._sourceImgBuffer = n, r.userData.mimeType = "image/ktx2", r;
        }

      }, ["ktx2"], !1)), Fs.Importers.push(this._importer), null === (i = null === (r = null === (n = null === (t = e.getManager()) || void 0 === t ? void 0 : t.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === r ? void 0 : r.extensions) || void 0 === i || i.push(fm);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Fs.Importers.splice(Fs.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  dm.PluginType = "KTX2LoadPlugin";

  const fm = e => ({
    writeTexture: (t, n) => {
      if ("image/ktx2" !== t.userData.mimeType) return;
      if (void 0 !== n.source) return void console.warn("ktx2 export: source already set");
      const r = t.source._sourceImgBuffer;
      if (!r || !r.length) return void console.warn("ktx2 export: no source buffer for ktx2");
      n.extensions = n.extensions || {};
      const i = {},
            s = new Blob(Array.isArray(r) ? r : [r], {
        type: "image/ktx2"
      });
      i.source = e.processImageBlob(s, t), n.extensions[hm] = i, e.extensionsUsed[hm] = !0;
    }
  });

  class _m {
    constructor(e) {
      this.presets = [], this.name = "", this.selected = void 0, e && (this.name = e);
    }

    async apply(e, t, n) {
      var r, i;
      if (!t) return void (this.selected = void 0);
      let s = this.presets.find(e => e.path === t.path);
      return s || (this.presets.push(t), s = t), this.selected = s, null === (i = null === (r = e.getManager()) || void 0 === r ? void 0 : r.importer) || void 0 === i ? void 0 : i.importAsset(s, n);
    }

  }

  class mm extends _m {
    constructor() {
      super(...arguments), this.name = "Background";
    }

    async apply(e, t) {
      const n = await super.apply(e, t),
            r = null == n ? void 0 : n[0];
      return r && (r.encoding = i.knz, await e.setBackground(r)), r;
    }

  }

  class gm extends _m {
    constructor() {
      super(...arguments), this.name = "Environment";
    }

    async apply(e, t) {
      const n = await super.apply(e, t),
            r = null == n ? void 0 : n[0];
      return r && (await e.scene.setEnvironment(r)), r;
    }

  }

  class vm extends _m {
    constructor() {
      super(...arguments), this.name = "GemEnvironment";
    }

    async apply(e, t) {
      const n = await super.apply(e, t),
            r = null == n ? void 0 : n[0];
      return g(e.getPluginByType("Diamond"), "envMap", r), r;
    }

  }

  class bm extends _m {
    async apply(e, t) {
      var n, r;
      const i = await super.apply(e, t, {
        processImported: !1
      });
      return i ? null === (r = null === (n = e.getManager()) || void 0 === n ? void 0 : n.importer) || void 0 === r ? void 0 : r.processImported(i) : void 0;
    }

  }

  class xm extends bm {
    constructor() {
      super(...arguments), this.name = "MaterialLibraries";
    }

    async apply(e, t) {
      const n = await super.apply(e, t);
      return n && alert("Material Library successfully imported."), n;
    }

  }

  class ym extends zs {
    constructor() {
      super(...arguments), this.toJSON = null, this.enabled = !0, this.presetGroups = [], this.uiConfig = {
        type: "folder",
        label: "Presets",
        expanded: !0,
        limitedUi: !0,
        children: [() => this.presetGroups.map(e => ({
          type: "dropdown",
          label: e.name,
          limitedUi: !0,
          children: [{
            value: "",
            label: "none"
          }, ...e.presets.map(e => ({
            label: e.path.split("/").pop(),
            value: e.path
          }))],
          getValue: () => {
            var t;
            return (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || "";
          },
          setValue: t => {
            e.apply(this._viewer, e.presets.find(e => e.path === t));
          }
        })), {
          type: "button",
          label: "Download Selection",
          limitedUi: !0,
          value: () => {
            const e = this.exportPresets();
            bt(new File([JSON.stringify(e, null, 2)], "preset.template.json", {
              type: "application/json"
            }));
          }
        }, {
          type: "button",
          label: "Export Preset Groups",
          hidden: !0,
          limitedUi: !1,
          value: () => {
            const e = this.exportPresetGroups();
            bt(new File([JSON.stringify(e, null, 2)], "presetGroups.json", {
              type: "application/json"
            }));
          }
        }]
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.presetGroups.push(new mm()), this.presetGroups.push(new gm()), this.presetGroups.push(new vm()), this.presetGroups.push(new bm("Ground")), this.presetGroups.push(new bm("CameraViews")), this.presetGroups.push(new bm("MaterialConfiguration")), this.presetGroups.push(new xm()), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    exportPresets() {
      const e = Object.fromEntries(this.presetGroups.map(e => {
        var t;
        return [e.name, (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || void 0];
      }).filter(([, e]) => e));
      return e.type = ym.PluginType, e;
    }

    async fromJSON(e, t) {
      var n, r;
      if (!super.fromJSON(e, t)) return null;
      const i = { ...e
      };
      delete i.type;
      const s = [];

      for (const [e, t] of Object.entries(i)) {
        const n = this.presetGroups.find(t => t.name === e),
              r = null == n ? void 0 : n.presets;
        if (!n || !r) continue;
        const i = "string" == typeof t ? {
          path: t
        } : t;
        s.push(n.apply(this._viewer, i));
      }

      return await Promise.all(s), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0), this;
    }

    loadPresetGroups(e) {
      var t;

      for (const [n, r] of Object.entries(e)) {
        const e = null === (t = this.presetGroups.find(e => e.name === n)) || void 0 === t ? void 0 : t.presets;
        null == e || e.push(...r);
      }
    }

    exportPresetGroups() {
      return Object.fromEntries(this.presetGroups.map(e => [e.name, e.presets.map(e => e.path)]).filter(([, e]) => e.length > 0));
    }

  }

  ym.PluginType = "PresetLibraryPlugin";

  var wm = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Sm = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [js], this.scenes = [], this.assets = {}, this.toJSON = void 0, this._isPlaying = !1, this._isPlayingLoop = !1, this._options = {}, this.minSceneTime = 2e3, this.loadScenes = this.loadScenes.bind(this), this.play = this.play.bind(this), this.stop = this.stop.bind(this), this.downloadScenes = this.downloadScenes.bind(this), this.promptLoadScenes = this.promptLoadScenes.bind(this);
    }

    get loadedScenes() {
      return this.scenes.length;
    }

    async promptLoadScenes() {
      const e = await xt(!0, !1, "model/gltf");
      await this.loadScenes(e);
    }

    async loadScenes(e) {
      var t, n;
      const r = await Promise.all(e.map(async e => await e.arrayBuffer()));

      for (let t = 0; t < e.length; t++) {
        const n = e[t];
        this.scenes.push({
          [n.name]: new Uint8Array(r[t])
        }), this.assets[n.name] = {
          path: n.name,
          file: n
        };
      }

      null === (n = null === (t = this.uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === n || n.call(t);
    }

    async play() {
      var e;
      if (!this._viewer) return;
      if (this._isPlaying || this._isPlayingLoop) return;
      this._isPlaying = !0, this._isPlayingLoop = !0;

      const t = this._viewer.getPluginByType("AssetManagerBasicPopupPlugin");

      null == t || t.enabled, t && (t.enabled = !1);

      const n = this._viewer.getPluginByType("FrameFade"),
            r = this._viewer.getPluginByType("GLTFAnimation"),
            i = this._viewer.getPluginByType("CameraViews");

      for (; this._isPlaying;) for (const s of this.scenes) {
        if (!this._isPlaying) break;
        const o = Object.keys(s);
        null == r || r.stopAnimation(!1), await (null == i ? void 0 : i.stopAllAnimations()), this._viewer.scene.removeSceneModels(), this._viewer.renderEnabled = !1;

        for (const t of o) {
          let n = this.assets[t];
          n || (n = {
            path: t,
            file: new File([s[t]], t)
          }, this.assets[t] = n), await (null === (e = this._viewer.getManager()) || void 0 === e ? void 0 : e.addAssetSingle(n, this._options));
        }

        if (!this._isPlaying) break;
        this._viewer.renderEnabled = !0, t && (t.enabled = !1), n && (n.enabled = !0, await n.startTransition(1e3));
        const a = [uc(this.minSceneTime)];
        r && a.push(r.playAnimation()), i && a.push(i.animateAllViews()), await Promise.all(a);
      }

      this._isPlayingLoop = !1;
    }

    stop() {
      this._isPlaying = !1;
    }

    async downloadScenes() {
      const e = {};

      for (const t of this.scenes) for (const n of Object.keys(t)) {
        const r = e[n] ? n + "_" : n;
        e[r] = t[r];
      }

      const t = Ms(e);
      gt(new Blob([t], {
        type: "application/zip"
      }), "scenes.glbloop");
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = this;
      Fs.Importers.push(new Zt(class extends Ps {
        load(e, n, r, i) {
          super.load(e, e => {
            t.loadScenes([...e.values()]), null == n || n(null), uc(100).then(t.play);
          }, r, i);
        }

      }, ["glbloop"], !0));
    }

  };
  Sm.PluginType = "SceneLoopPlugin", wm([Ge("Loaded scenes")], Sm.prototype, "loadedScenes", null), wm([Xe("Load Scenes")], Sm.prototype, "promptLoadScenes", null), wm([Ge("Playing")], Sm.prototype, "_isPlaying", void 0), wm([qe("Min Scene Time")], Sm.prototype, "minSceneTime", void 0), wm([Xe("Play")], Sm.prototype, "play", null), wm([Xe("Stop")], Sm.prototype, "stop", null), wm([Xe("Download Scenes")], Sm.prototype, "downloadScenes", null), Sm = wm([Qe("Scene Loop")], Sm);

  var Mm = __webpackgi_require__(701),
      Tm = __webpackgi_require__.n(Mm),
      Em = __webpackgi_require__(236),
      Am = __webpackgi_require__.n(Em),
      Cm = __webpackgi_require__(850),
      Rm = __webpackgi_require__.n(Cm),
      km = __webpackgi_require__(182),
      Pm = __webpackgi_require__.n(km),
      Dm = __webpackgi_require__(213),
      Om = __webpackgi_require__.n(Dm),
      Lm = __webpackgi_require__(798),
      Im = {};

  Lm.Z && Lm.Z.locals && (Im.locals = Lm.Z.locals);
  var Fm,
      Nm = 0,
      Um = {};
  Um.styleTagTransform = Om(), Um.setAttributes = Rm(), Um.insert = function (e, t) {
    (t.target || document.head).appendChild(e);
  }, Um.domAPI = Am(), Um.insertStyleElement = Pm(), Im.use = function (e) {
    return Um.options = e || {}, Nm++ || (Fm = Tm()(Lm.Z, Um)), Im;
  }, Im.unuse = function () {
    Nm > 0 && ! --Nm && (Fm(), Fm = null);
  };

  var Bm,
      jm = Im,
      zm = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Vm = Bm = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [js], this._popupDiv = yt({
        id: "assetManagerPopup",
        addToBody: !1,
        innerHTML: ""
      });
      const e = yt({
        id: "assetManagerPopupClose",
        addToBody: !1,
        innerHTML: "&#10005"
      });
      e.addEventListener("click", () => {
        this._popupDiv.style.display = "none";
      }), this._popupContent = yt({
        id: "assetManagerPopupContent",
        addToBody: !1,
        innerHTML: ""
      }), this.enabled || (this._popupDiv.style.display = "none"), this._popupDiv.appendChild(e), this._popupDiv.appendChild(this._popupContent);
    }

    _onEnabledChange() {
      this.enabled || (this._popupDiv.style.display = "none");
    }

    _updatePopupDiv(e) {
      if (!this._popupContent) return;
      if (!this.enabled) return void (this._popupDiv.style.display = "none");
      let t = "";
      e.forEach((e, n) => {
        t += `<span class="processState">${e}</span>: ${n.split("/").pop()}<br>`;
      }), this._popupContent.innerHTML = t, 0 === e.size ? this._popupDiv.style.display = "none" : this._popupDiv.style.display = "block";
    }

    async onAdded(e) {
      var t, n, r, i;
      await super.onAdded(e), jm.use({
        target: e.container
      }), e.container.appendChild(this._popupDiv);
      const s = new Map();
      null === (n = null === (t = e.getManager()) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("importFile", e => {
        "done" !== e.state ? s.set(e.path, e.state) : s.delete(e.path), this._updatePopupDiv(s);
      }), null === (i = null === (r = e.getManager()) || void 0 === r ? void 0 : r.exporter) || void 0 === i || i.addEventListener("exportFile", e => {
        "done" !== e.state ? s.set(e.obj.name, e.state) : s.delete(e.obj.name), this._updatePopupDiv(s);
      });
    }

  };

  async function Gm(e, {
    ground: t = !0,
    bloom: n = !0,
    depthTonemap: r = !1,
    enableDrop: i = !1,
    tonemapScreenFrag: s = ["", ""]
  } = {}) {
    await e.addPlugin(Xs), await e.addPlugin(io), i && (await e.addPlugin(oo)), await e.addPlugin(new po(32)), await e.addPlugin(new mo(r || !e.useRgbm, !0, s)), await e.addPlugin(Ao), await e.addPlugin(Do), await e.addPlugin(xc), await e.addPlugin(_c), await e.addPlugin(Mc), t && (await e.addPlugin(Yc)), n && (await e.addPlugin(Qc)), await e.addPlugin(tu), await e.addPlugin(su), await e.addPlugin(uu), await e.addPlugin(mu), await e.addPlugin(xu), await e.addPlugin(Au, !1), await e.addPlugin(Ru), await e.addPlugin(Fu), await e.addPlugin(Hu, !1), await e.addPlugin(Xu, !1), await e.addPlugin(Qu, !1), await e.addPlugin(np, !1), await e.addPlugin(dm), await e.addPlugin(ym), await e.addPlugin(Sm);
  }

  async function Hm(e, {
    debug: t = !1,
    ground: n = !0,
    bloom: r = !0,
    depthTonemap: i = !1,
    importPopup: s = !0,
    enableDrop: o = !1
  } = {}) {
    var a;
    const l = new to(e);
    t && (await l.addPlugin(Ac));
    const c = await l.addPlugin(js, void 0, void 0, {
      storage: caches ? await caches.open("webgi-cache-storage") : void 0
    });
    return s && (await l.addPlugin(Vm)), await Gm(l, {
      ground: n,
      bloom: r,
      depthTonemap: i,
      enableDrop: o
    }), l.renderer.refreshPipeline(), null === (a = c.importer) || void 0 === a || a.processors.add("model", {
      forAssetType: "model",
      process: (e, t) => e
    }), l;
  }

  Vm.PluginType = "AssetManagerBasicPopupPlugin", zm([Ve("Enabled"), C(Bm.prototype._onEnabledChange), xe()], Vm.prototype, "enabled", void 0), Vm = Bm = zm([Qe("Asset manager popup")], Vm);
  let Wm = 0;

  class Km extends HTMLElement {
    constructor() {
      super(), this._initialized = !1, this._state = {
        src: "",
        environment: ""
      }, this._models = {}, this._refreshingModels = !1, this._refreshingEnvironment = !1, this.viewerIndex = Wm++, this.canvasId = "webgi-viewer-" + this.viewerIndex, this.attachShadow({
        mode: "open"
      }), this.wrapper = document.createElement("div"), this.wrapper.style.width = "100%", this.wrapper.style.height = "100%", this.wrapper.style.display = "block", this.canvas = _t(), this.canvas.setAttribute("id", this.canvasId);
      const e = document.createElement("style");
      e.textContent = T`
            #${this.canvasId}{
              width: 100%; height: 100%; z-index: 1;
              display: block;
            }
        `, this.wrapper.append(this.canvas), this.shadowRoot.append(e, this.wrapper), this._initialize().then(async () => this.refreshAll());
    }

    async refreshAll() {
      await Promise.all([this.refreshModelSource(), this.refreshEnvironment()]);
    }

    async _initialize() {
      this._initialized || (this.viewer = await Hm({
        canvas: this.canvas,
        useRgbm: "true" === this._getAttr("rgbm", "true"),
        useGBufferDepth: "true" === this._getAttr("depth-prepass", "true")
      }, {
        debug: "true" === this._getAttr("debug", "false"),
        ground: "baked" === this._getAttr("ground", "baked"),
        bloom: "true" === this._getAttr("bloom", "true"),
        depthTonemap: !0
      }), this._initialized = !0, this.dispatchEvent(new Event("initialized")));
    }

    connectedCallback() {
      console.log("WebGiViewerElement added to page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0);
    }

    disconnectedCallback() {
      console.log("WebGiViewerElement removed from page."), this.viewer && (this.viewer.enabled = !1);
    }

    adoptedCallback() {
      console.log("WebGiViewerElement moved to new page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0);
    }

    static get observedAttributes() {
      return ["src", "environment"];
    }

    attributeChangedCallback(e, t, n) {
      console.log("WebGiViewerElement attributes changed.", e, t, n), this.refreshAll();
    }

    clearModels() {}

    async refreshModelSource() {
      if (!this.viewer) return;

      const e = this._getAttr("src", "");

      if (e === this._state.src) return;
      if (this._refreshingModels) return;
      this._refreshingModels = !0;
      const t = [e],
            n = [],
            r = [];

      for (const e of t) !this._models[e] && e && (this._models[e] = this.viewer.getManager().importer.importPath(e, {
        autoScale: this._getAttr("auto-scale", "true"),
        autoCenter: this._getAttr("auto-center", "true"),
        processImported: !1
      }));

      for (const [e, i] of Object.entries(this._models)) t.includes(e) ? n.push(i) : r.push(i);

      await Promise.all([Promise.all(n).then(async e => Promise.all(e.map(async e => this.viewer.getManager().importer.processImported(e)))).then(e => {
        for (const t of e) for (const e of t) e && "model" === e.assetType && this.viewer.scene.addSceneObject(e);
      }), Promise.all(r).then(e => {
        for (const t of e) for (const e of t) e && "model" === e.assetType && e.modelObject.removeFromParent();
      })]), this._state.src = e, this._refreshingModels = !1;
    }

    async refreshEnvironment() {
      if (!this.viewer) return;
      if (!this.hasAttribute("environment")) return void (this._state.environment = null);

      const e = this._getAttr("environment", "");

      if (e === this._state.src) return;
      if (this._refreshingEnvironment) return;
      this._refreshingEnvironment = !0;
      const t = this.viewer.scene.getEnvironment(),
            n = e ? await this.viewer.getManager().importer.importSinglePath(e) : void 0;
      n && "texture" !== n.assetType || (await this.viewer.scene.setEnvironment(n)), null == t || t.dispose(), this._state.environment = e, this._refreshingEnvironment = !1;
    }

    _getAttr(e, t) {
      return this.hasAttribute(e) ? this.getAttribute(e) : t;
    }

  }

  window && window.customElements && !window.customElements.get("webgi-viewer") && window.customElements.define("webgi-viewer", Km);

  class Xm {
    constructor(e) {
      var t, n, r;
      this._basePath = null !== (t = null == e ? void 0 : e.basePath) && void 0 !== t ? t : "", this._assets = null !== (r = null === (n = null == e ? void 0 : e.assets) || void 0 === n ? void 0 : n.map(e => this._resolveAsset(e))) && void 0 !== r ? r : [];
    }

    get basePath() {
      return this._basePath;
    }

    get assets() {
      return this._assets;
    }

    find(e) {
      const t = this._assets.find(e);

      return null != t ? t : void 0;
    }

    _resolveAsset(e) {
      return { ...e,
        path: mt([this._basePath, e.path])
      };
    }

  }

  class qm extends r {
    constructor(...e) {
      super(), this._assets = e;
    }

    addAssetList(e) {
      this._assets.push(e);
    }

    removeAssetList(e) {
      const t = this._assets.indexOf(e);

      t >= 0 && this._assets.splice(t, 1);
    }

    async findAssetRegex(e) {
      for (const t of this._assets) {
        const n = t.find(t => {
          var n, r;
          return t && (e.test(t.path) || e.test(null !== (r = null === (n = t.file) || void 0 === n ? void 0 : n.name) && void 0 !== r ? r : ""));
        });
        if (n) return n;
      }

      console.warn("Asset not found:", e);
    }

    async findAsset(e) {
      return this.findAssetRegex(e.query);
    }

    async findAssetSimple(e, t = !1) {
      return this.findAssetRegex(new RegExp(e, t ? "i" : ""));
    }

  }

  var Ym = {},
      Zm = function (e) {
    return URL.createObjectURL(new Blob([e], {
      type: "text/javascript"
    }));
  },
      Jm = function (e) {
    return new Worker(e);
  };

  try {
    URL.revokeObjectURL(Zm(""));
  } catch (Lc) {
    Zm = function (e) {
      return "data:application/javascript;charset=UTF-8," + encodeURI(e);
    }, Jm = function (e) {
      return new Worker(e, {
        type: "module"
      });
    };
  }

  var $m = Uint8Array,
      Qm = Uint16Array,
      eg = Uint32Array,
      tg = new $m([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
      ng = new $m([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
      rg = new $m([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
      ig = function (e, t) {
    for (var n = new Qm(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];

    var i = new eg(n[30]);

    for (r = 1; r < 30; ++r) for (var s = n[r]; s < n[r + 1]; ++s) i[s] = s - n[r] << 5 | r;

    return [n, i];
  },
      sg = ig(tg, 2),
      og = sg[0],
      ag = sg[1];

  og[28] = 258, ag[258] = 28;

  for (var lg = ig(ng, 0), cg = lg[0], ug = lg[1], pg = new Qm(32768), hg = 0; hg < 32768; ++hg) {
    var dg = (43690 & hg) >>> 1 | (21845 & hg) << 1;
    dg = (61680 & (dg = (52428 & dg) >>> 2 | (13107 & dg) << 2)) >>> 4 | (3855 & dg) << 4, pg[hg] = ((65280 & dg) >>> 8 | (255 & dg) << 8) >>> 1;
  }

  var fg = function (e, t, n) {
    for (var r = e.length, i = 0, s = new Qm(t); i < r; ++i) ++s[e[i] - 1];

    var o,
        a = new Qm(t);

    for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;

    if (n) {
      o = new Qm(1 << t);
      var l = 15 - t;

      for (i = 0; i < r; ++i) if (e[i]) for (var c = i << 4 | e[i], u = t - e[i], p = a[e[i] - 1]++ << u, h = p | (1 << u) - 1; p <= h; ++p) o[pg[p] >>> l] = c;
    } else for (o = new Qm(r), i = 0; i < r; ++i) e[i] && (o[i] = pg[a[e[i] - 1]++] >>> 15 - e[i]);

    return o;
  },
      _g = new $m(288);

  for (hg = 0; hg < 144; ++hg) _g[hg] = 8;

  for (hg = 144; hg < 256; ++hg) _g[hg] = 9;

  for (hg = 256; hg < 280; ++hg) _g[hg] = 7;

  for (hg = 280; hg < 288; ++hg) _g[hg] = 8;

  var mg = new $m(32);

  for (hg = 0; hg < 32; ++hg) mg[hg] = 5;

  var gg = fg(_g, 9, 0),
      vg = fg(_g, 9, 1),
      bg = fg(mg, 5, 0),
      xg = fg(mg, 5, 1),
      yg = function (e) {
    for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);

    return t;
  },
      wg = function (e, t, n) {
    var r = t / 8 | 0;
    return (e[r] | e[r + 1] << 8) >> (7 & t) & n;
  },
      Sg = function (e, t) {
    var n = t / 8 | 0;
    return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t);
  },
      Mg = function (e) {
    return (e / 8 | 0) + (7 & e && 1);
  },
      Tg = function (e, t, n) {
    (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
    var r = new (e instanceof Qm ? Qm : e instanceof eg ? eg : $m)(n - t);
    return r.set(e.subarray(t, n)), r;
  },
      Eg = function (e, t, n) {
    var r = e.length;
    if (!r || n && !n.l && r < 5) return t || new $m(0);
    var i = !t || n,
        s = !n || n.i;
    n || (n = {}), t || (t = new $m(3 * r));

    var o = function (e) {
      var n = t.length;

      if (e > n) {
        var r = new $m(Math.max(2 * n, e));
        r.set(t), t = r;
      }
    },
        a = n.f || 0,
        l = n.p || 0,
        c = n.b || 0,
        u = n.l,
        p = n.d,
        h = n.m,
        d = n.n,
        f = 8 * r;

    do {
      if (!u) {
        n.f = a = wg(e, l, 1);

        var _ = wg(e, l + 1, 3);

        if (l += 3, !_) {
          var m = e[(A = Mg(l) + 4) - 4] | e[A - 3] << 8,
              g = A + m;

          if (g > r) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + m), t.set(e.subarray(A, g), c), n.b = c += m, n.p = l = 8 * g;
          continue;
        }

        if (1 == _) u = vg, p = xg, h = 9, d = 5;else {
          if (2 != _) throw "invalid block type";
          var v = wg(e, l, 31) + 257,
              b = wg(e, l + 10, 15) + 4,
              x = v + wg(e, l + 5, 31) + 1;
          l += 14;

          for (var y = new $m(x), w = new $m(19), S = 0; S < b; ++S) w[rg[S]] = wg(e, l + 3 * S, 7);

          l += 3 * b;
          var M = yg(w),
              T = (1 << M) - 1,
              E = fg(w, M, 1);

          for (S = 0; S < x;) {
            var A,
                C = E[wg(e, l, T)];
            if (l += 15 & C, (A = C >>> 4) < 16) y[S++] = A;else {
              var R = 0,
                  k = 0;

              for (16 == A ? (k = 3 + wg(e, l, 3), l += 2, R = y[S - 1]) : 17 == A ? (k = 3 + wg(e, l, 7), l += 3) : 18 == A && (k = 11 + wg(e, l, 127), l += 7); k--;) y[S++] = R;
            }
          }

          var P = y.subarray(0, v),
              D = y.subarray(v);
          h = yg(P), d = yg(D), u = fg(P, h, 1), p = fg(D, d, 1);
        }

        if (l > f) {
          if (s) throw "unexpected EOF";
          break;
        }
      }

      i && o(c + 131072);

      for (var O = (1 << h) - 1, L = (1 << d) - 1, I = l;; I = l) {
        var F = (R = u[Sg(e, l) & O]) >>> 4;

        if ((l += 15 & R) > f) {
          if (s) throw "unexpected EOF";
          break;
        }

        if (!R) throw "invalid length/literal";
        if (F < 256) t[c++] = F;else {
          if (256 == F) {
            I = l, u = null;
            break;
          }

          var N = F - 254;

          if (F > 264) {
            var U = tg[S = F - 257];
            N = wg(e, l, (1 << U) - 1) + og[S], l += U;
          }

          var B = p[Sg(e, l) & L],
              j = B >>> 4;
          if (!B) throw "invalid distance";

          if (l += 15 & B, D = cg[j], j > 3 && (U = ng[j], D += Sg(e, l) & (1 << U) - 1, l += U), l > f) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + 131072);

          for (var z = c + N; c < z; c += 4) t[c] = t[c - D], t[c + 1] = t[c + 1 - D], t[c + 2] = t[c + 2 - D], t[c + 3] = t[c + 3 - D];

          c = z;
        }
      }

      n.l = u, n.p = I, n.b = c, u && (a = 1, n.m = h, n.d = p, n.n = d);
    } while (!a);

    return c == t.length ? t : Tg(t, 0, c);
  },
      Ag = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8;
  },
      Cg = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8, e[r + 2] |= n >>> 16;
  },
      Rg = function (e, t) {
    for (var n = [], r = 0; r < e.length; ++r) e[r] && n.push({
      s: r,
      f: e[r]
    });

    var i = n.length,
        s = n.slice();
    if (!i) return [Fg, 0];

    if (1 == i) {
      var o = new $m(n[0].s + 1);
      return o[n[0].s] = 1, [o, 1];
    }

    n.sort(function (e, t) {
      return e.f - t.f;
    }), n.push({
      s: -1,
      f: 25001
    });
    var a = n[0],
        l = n[1],
        c = 0,
        u = 1,
        p = 2;

    for (n[0] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    }; u != i - 1;) a = n[n[c].f < n[p].f ? c++ : p++], l = n[c != u && n[c].f < n[p].f ? c++ : p++], n[u++] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    };

    var h = s[0].s;

    for (r = 1; r < i; ++r) s[r].s > h && (h = s[r].s);

    var d = new Qm(h + 1),
        f = kg(n[u - 1], d, 0);

    if (f > t) {
      r = 0;
      var _ = 0,
          m = f - t,
          g = 1 << m;

      for (s.sort(function (e, t) {
        return d[t.s] - d[e.s] || e.f - t.f;
      }); r < i; ++r) {
        var v = s[r].s;
        if (!(d[v] > t)) break;
        _ += g - (1 << f - d[v]), d[v] = t;
      }

      for (_ >>>= m; _ > 0;) {
        var b = s[r].s;
        d[b] < t ? _ -= 1 << t - d[b]++ - 1 : ++r;
      }

      for (; r >= 0 && _; --r) {
        var x = s[r].s;
        d[x] == t && (--d[x], ++_);
      }

      f = t;
    }

    return [new $m(d), f];
  },
      kg = function (e, t, n) {
    return -1 == e.s ? Math.max(kg(e.l, t, n + 1), kg(e.r, t, n + 1)) : t[e.s] = n;
  },
      Pg = function (e) {
    for (var t = e.length; t && !e[--t];);

    for (var n = new Qm(++t), r = 0, i = e[0], s = 1, o = function (e) {
      n[r++] = e;
    }, a = 1; a <= t; ++a) if (e[a] == i && a != t) ++s;else {
      if (!i && s > 2) {
        for (; s > 138; s -= 138) o(32754);

        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(i), --s; s > 6; s -= 6) o(8304);

        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }

      for (; s--;) o(i);

      s = 1, i = e[a];
    }

    return [n.subarray(0, r), t];
  },
      Dg = function (e, t) {
    for (var n = 0, r = 0; r < t.length; ++r) n += e[r] * t[r];

    return n;
  },
      Og = function (e, t, n) {
    var r = n.length,
        i = Mg(t + 2);
    e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];

    for (var s = 0; s < r; ++s) e[i + s + 4] = n[s];

    return 8 * (i + 4 + r);
  },
      Lg = function (e, t, n, r, i, s, o, a, l, c, u) {
    Ag(t, u++, n), ++i[256];

    for (var p = Rg(i, 15), h = p[0], d = p[1], f = Rg(s, 15), _ = f[0], m = f[1], g = Pg(h), v = g[0], b = g[1], x = Pg(_), y = x[0], w = x[1], S = new Qm(19), M = 0; M < v.length; ++M) S[31 & v[M]]++;

    for (M = 0; M < y.length; ++M) S[31 & y[M]]++;

    for (var T = Rg(S, 7), E = T[0], A = T[1], C = 19; C > 4 && !E[rg[C - 1]]; --C);

    var R,
        k,
        P,
        D,
        O = c + 5 << 3,
        L = Dg(i, _g) + Dg(s, mg) + o,
        I = Dg(i, h) + Dg(s, _) + o + 14 + 3 * C + Dg(S, E) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
    if (O <= L && O <= I) return Og(t, u, e.subarray(l, l + c));

    if (Ag(t, u, 1 + (I < L)), u += 2, I < L) {
      R = fg(h, d, 0), k = h, P = fg(_, m, 0), D = _;
      var F = fg(E, A, 0);

      for (Ag(t, u, b - 257), Ag(t, u + 5, w - 1), Ag(t, u + 10, C - 4), u += 14, M = 0; M < C; ++M) Ag(t, u + 3 * M, E[rg[M]]);

      u += 3 * C;

      for (var N = [v, y], U = 0; U < 2; ++U) {
        var B = N[U];

        for (M = 0; M < B.length; ++M) {
          var j = 31 & B[M];
          Ag(t, u, F[j]), u += E[j], j > 15 && (Ag(t, u, B[M] >>> 5 & 127), u += B[M] >>> 12);
        }
      }
    } else R = gg, k = _g, P = bg, D = mg;

    for (M = 0; M < a; ++M) if (r[M] > 255) {
      j = r[M] >>> 18 & 31, Cg(t, u, R[j + 257]), u += k[j + 257], j > 7 && (Ag(t, u, r[M] >>> 23 & 31), u += tg[j]);
      var z = 31 & r[M];
      Cg(t, u, P[z]), u += D[z], z > 3 && (Cg(t, u, r[M] >>> 5 & 8191), u += ng[z]);
    } else Cg(t, u, R[r[M]]), u += k[r[M]];

    return Cg(t, u, R[256]), u + k[256];
  },
      Ig = new eg([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
      Fg = new $m(0),
      Ng = function (e, t, n, r, i, s) {
    var o = e.length,
        a = new $m(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
        l = a.subarray(r, a.length - i),
        c = 0;
    if (!t || o < 8) for (var u = 0; u <= o; u += 65535) {
      var p = u + 65535;
      p < o ? c = Og(l, c, e.subarray(u, p)) : (l[u] = s, c = Og(l, c, e.subarray(u, o)));
    } else {
      for (var h = Ig[t - 1], d = h >>> 13, f = 8191 & h, _ = (1 << n) - 1, m = new Qm(32768), g = new Qm(_ + 1), v = Math.ceil(n / 3), b = 2 * v, x = function (t) {
        return (e[t] ^ e[t + 1] << v ^ e[t + 2] << b) & _;
      }, y = new eg(25e3), w = new Qm(288), S = new Qm(32), M = 0, T = 0, E = (u = 0, 0), A = 0, C = 0; u < o; ++u) {
        var R = x(u),
            k = 32767 & u,
            P = g[R];

        if (m[k] = P, g[R] = k, A <= u) {
          var D = o - u;

          if ((M > 7e3 || E > 24576) && D > 423) {
            c = Lg(e, l, 0, y, w, S, T, E, C, u - C, c), E = M = T = 0, C = u;

            for (var O = 0; O < 286; ++O) w[O] = 0;

            for (O = 0; O < 30; ++O) S[O] = 0;
          }

          var L = 2,
              I = 0,
              F = f,
              N = k - P & 32767;
          if (D > 2 && R == x(u - N)) for (var U = Math.min(d, D) - 1, B = Math.min(32767, u), j = Math.min(258, D); N <= B && --F && k != P;) {
            if (e[u + L] == e[u + L - N]) {
              for (var z = 0; z < j && e[u + z] == e[u + z - N]; ++z);

              if (z > L) {
                if (L = z, I = N, z > U) break;
                var V = Math.min(N, z - 2),
                    G = 0;

                for (O = 0; O < V; ++O) {
                  var H = u - N + O + 32768 & 32767,
                      W = H - m[H] + 32768 & 32767;
                  W > G && (G = W, P = H);
                }
              }
            }

            N += (k = P) - (P = m[k]) + 32768 & 32767;
          }

          if (I) {
            y[E++] = 268435456 | ag[L] << 18 | ug[I];
            var K = 31 & ag[L],
                X = 31 & ug[I];
            T += tg[K] + ng[X], ++w[257 + K], ++S[X], A = u + L, ++M;
          } else y[E++] = e[u], ++w[e[u]];
        }
      }

      c = Lg(e, l, s, y, w, S, T, E, C, u - C, c), !s && 7 & c && (c = Og(l, c + 1, Fg));
    }
    return Tg(a, 0, r + Mg(c) + i);
  },
      Ug = function () {
    for (var e = new eg(256), t = 0; t < 256; ++t) {
      for (var n = t, r = 9; --r;) n = (1 & n && 3988292384) ^ n >>> 1;

      e[t] = n;
    }

    return e;
  }(),
      Bg = function () {
    var e = -1;
    return {
      p: function (t) {
        for (var n = e, r = 0; r < t.length; ++r) n = Ug[255 & n ^ t[r]] ^ n >>> 8;

        e = n;
      },
      d: function () {
        return ~e;
      }
    };
  },
      jg = function () {
    var e = 1,
        t = 0;
    return {
      p: function (n) {
        for (var r = e, i = t, s = n.length, o = 0; o != s;) {
          for (var a = Math.min(o + 2655, s); o < a; ++o) i += r += n[o];

          r = (65535 & r) + 15 * (r >> 16), i = (65535 & i) + 15 * (i >> 16);
        }

        e = r, t = i;
      },
      d: function () {
        return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8;
      }
    };
  },
      zg = function (e, t, n, r, i) {
    return Ng(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, r, !i);
  },
      Vg = function (e, t) {
    var n = {};

    for (var r in e) n[r] = e[r];

    for (var r in t) n[r] = t[r];

    return n;
  },
      Gg = function (e, t, n) {
    for (var r = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) {
      var a = r[o],
          l = s[o];

      if ("function" == typeof a) {
        t += ";" + l + "=";
        var c = a.toString();
        if (a.prototype) {
          if (-1 != c.indexOf("[native code]")) {
            var u = c.indexOf(" ", 8) + 1;
            t += c.slice(u, c.indexOf("(", u));
          } else for (var p in t += c, a.prototype) t += ";" + l + ".prototype." + p + "=" + a.prototype[p].toString();
        } else t += c;
      } else n[l] = a;
    }

    return [t, n];
  },
      Hg = [],
      Wg = function (e, t, n, r) {
    var i;

    if (!Hg[n]) {
      for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = Gg(e[l], s, o))[0], o = i[1];

      Hg[n] = Gg(e[a], s, o);
    }

    var c = Vg({}, Hg[n][1]);
    return function (e, t, n, r, i) {
      var s = Jm(Ym[t] || (Ym[t] = Zm(e)));
      return s.onerror = function (e) {
        return i(e.error, null);
      }, s.onmessage = function (e) {
        return i(null, e.data);
      }, s.postMessage(n, r), s;
    }(Hg[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, c, function (e) {
      var t = [];

      for (var n in e) (e[n] instanceof $m || e[n] instanceof Qm || e[n] instanceof eg) && t.push((e[n] = new e[n].constructor(e[n])).buffer);

      return t;
    }(c), r);
  },
      Kg = function () {
    return [$m, Qm, eg, tg, ng, rg, og, cg, vg, xg, pg, fg, yg, wg, Sg, Mg, Tg, Eg, yv, $g, Qg];
  },
      Xg = function () {
    return [$m, Qm, eg, tg, ng, rg, ag, ug, gg, _g, bg, mg, pg, Ig, Fg, fg, Ag, Cg, Rg, kg, Pg, Dg, Og, Lg, Mg, Tg, Ng, zg, gv, $g];
  },
      qg = function () {
    return [av, uv, ov, Bg, Ug];
  },
      Yg = function () {
    return [lv, cv];
  },
      Zg = function () {
    return [pv, ov, jg];
  },
      Jg = function () {
    return [hv];
  },
      $g = function (e) {
    return postMessage(e, [e.buffer]);
  },
      Qg = function (e) {
    return e && e.size && new $m(e.size);
  },
      ev = function (e, t, n, r, i, s) {
    var o = Wg(n, r, i, function (e, t) {
      o.terminate(), s(e, t);
    });
    return o.postMessage([e, t], t.consume ? [e.buffer] : []), function () {
      o.terminate();
    };
  },
      tv = function (e) {
    return e.ondata = function (e, t) {
      return postMessage([e, t], [e.buffer]);
    }, function (t) {
      return e.push(t.data[0], t.data[1]);
    };
  },
      nv = function (e, t, n, r, i) {
    var s,
        o = Wg(e, r, i, function (e, n) {
      e ? (o.terminate(), t.ondata.call(t, e)) : (n[1] && o.terminate(), t.ondata.call(t, e, n[0], n[1]));
    });
    o.postMessage(n), t.push = function (e, n) {
      if (s) throw "stream finished";
      if (!t.ondata) throw "no stream handler";
      o.postMessage([e, s = n], [e.buffer]);
    }, t.terminate = function () {
      o.terminate();
    };
  },
      rv = function (e, t) {
    return e[t] | e[t + 1] << 8;
  },
      iv = function (e, t) {
    return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;
  },
      sv = function (e, t) {
    return iv(e, t) + 4294967296 * iv(e, t + 4);
  },
      ov = function (e, t, n) {
    for (; n; ++t) e[t] = n, n >>>= 8;
  },
      av = function (e, t) {
    var n = t.filename;

    if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && ov(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), n) {
      e[3] = 8;

      for (var r = 0; r <= n.length; ++r) e[r + 10] = n.charCodeAt(r);
    }
  },
      lv = function (e) {
    if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
    var t = e[3],
        n = 10;
    4 & t && (n += e[10] | 2 + (e[11] << 8));

    for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[n++]);

    return n + (2 & t);
  },
      cv = function (e) {
    var t = e.length;
    return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
  },
      uv = function (e) {
    return 10 + (e.filename && e.filename.length + 1 || 0);
  },
      pv = function (e, t) {
    var n = t.level,
        r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
    e[0] = 120, e[1] = r << 6 | (r ? 32 - 2 * r : 1);
  },
      hv = function (e) {
    if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
    if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported";
  };

  function dv(e, t) {
    return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e;
  }

  var fv = function () {
    function e(e, t) {
      t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {};
    }

    return e.prototype.p = function (e, t) {
      this.ondata(zg(e, this.o, 0, 0, !t), t);
    }, e.prototype.push = function (e, t) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      this.d = t, this.p(e, t || !1);
    }, e;
  }(),
      _v = function () {
    return function (e, t) {
      nv([Xg, function () {
        return [tv, fv];
      }], this, dv.call(this, e, t), function (e) {
        var t = new fv(e.data);
        onmessage = tv(t);
      }, 6);
    };
  }();

  function mv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return ev(e, t, [Xg], function (e) {
      return $g(gv(e.data[0], e.data[1]));
    }, 0, n);
  }

  function gv(e, t) {
    return zg(e, t || {}, 0, 0);
  }

  var vv = function () {
    function e(e) {
      this.s = {}, this.p = new $m(0), this.ondata = e;
    }

    return e.prototype.e = function (e) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      var t = this.p.length,
          n = new $m(t + e.length);
      n.set(this.p), n.set(e, t), this.p = n;
    }, e.prototype.c = function (e) {
      this.d = this.s.i = e || !1;
      var t = this.s.b,
          n = Eg(this.p, this.o, this.s);
      this.ondata(Tg(n, t, this.s.b), this.d), this.o = Tg(n, this.s.b - 32768), this.s.b = this.o.length, this.p = Tg(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, e.prototype.push = function (e, t) {
      this.e(e), this.c(t);
    }, e;
  }(),
      bv = function () {
    return function (e) {
      this.ondata = e, nv([Kg, function () {
        return [tv, vv];
      }], this, 0, function () {
        var e = new vv();
        onmessage = tv(e);
      }, 7);
    };
  }();

  function xv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return ev(e, t, [Kg], function (e) {
      return $g(yv(e.data[0], Qg(e.data[1])));
    }, 1, n);
  }

  function yv(e, t) {
    return Eg(e, t);
  }

  var wv = function () {
    function e(e, t) {
      this.c = Bg(), this.l = 0, this.v = 1, fv.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      fv.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e), this.l += e.length;
      var n = zg(e, this.o, this.v && uv(this.o), t && 8, !t);
      this.v && (av(n, this.o), this.v = 0), t && (ov(n, n.length - 8, this.c.d()), ov(n, n.length - 4, this.l)), this.ondata(n, t);
    }, e;
  }(),
      Sv = function () {
    return function (e, t) {
      nv([Xg, qg, function () {
        return [tv, fv, wv];
      }], this, dv.call(this, e, t), function (e) {
        var t = new wv(e.data);
        onmessage = tv(t);
      }, 8);
    };
  }();

  function Mv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return ev(e, t, [Xg, qg, function () {
      return [Tv];
    }], function (e) {
      return $g(Tv(e.data[0], e.data[1]));
    }, 2, n);
  }

  function Tv(e, t) {
    t || (t = {});
    var n = Bg(),
        r = e.length;
    n.p(e);
    var i = zg(e, t, uv(t), 8),
        s = i.length;
    return av(i, t), ov(i, s - 8, n.d()), ov(i, s - 4, r), i;
  }

  var Ev = function () {
    function e(e) {
      this.v = 1, vv.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (vv.prototype.e.call(this, e), this.v) {
        var n = this.p.length > 3 ? lv(this.p) : 4;
        if (n >= this.p.length && !t) return;
        this.p = this.p.subarray(n), this.v = 0;
      }

      if (t) {
        if (this.p.length < 8) throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }

      vv.prototype.c.call(this, t);
    }, e;
  }(),
      Av = function () {
    return function (e) {
      this.ondata = e, nv([Kg, Yg, function () {
        return [tv, vv, Ev];
      }], this, 0, function () {
        var e = new Ev();
        onmessage = tv(e);
      }, 9);
    };
  }();

  function Cv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return ev(e, t, [Kg, Yg, function () {
      return [Rv];
    }], function (e) {
      return $g(Rv(e.data[0]));
    }, 3, n);
  }

  function Rv(e, t) {
    return Eg(e.subarray(lv(e), -8), t || new $m(cv(e)));
  }

  var kv = function () {
    function e(e, t) {
      this.c = jg(), this.v = 1, fv.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      fv.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e);
      var n = zg(e, this.o, this.v && 2, t && 4, !t);
      this.v && (pv(n, this.o), this.v = 0), t && ov(n, n.length - 4, this.c.d()), this.ondata(n, t);
    }, e;
  }(),
      Pv = function () {
    return function (e, t) {
      nv([Xg, Zg, function () {
        return [tv, fv, kv];
      }], this, dv.call(this, e, t), function (e) {
        var t = new kv(e.data);
        onmessage = tv(t);
      }, 10);
    };
  }();

  function Dv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return ev(e, t, [Xg, Zg, function () {
      return [Ov];
    }], function (e) {
      return $g(Ov(e.data[0], e.data[1]));
    }, 4, n);
  }

  function Ov(e, t) {
    t || (t = {});
    var n = jg();
    n.p(e);
    var r = zg(e, t, 2, 4);
    return pv(r, t), ov(r, r.length - 4, n.d()), r;
  }

  var Lv = function () {
    function e(e) {
      this.v = 1, vv.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (vv.prototype.e.call(this, e), this.v) {
        if (this.p.length < 2 && !t) return;
        this.p = this.p.subarray(2), this.v = 0;
      }

      if (t) {
        if (this.p.length < 4) throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }

      vv.prototype.c.call(this, t);
    }, e;
  }(),
      Iv = function () {
    return function (e) {
      this.ondata = e, nv([Kg, Jg, function () {
        return [tv, vv, Lv];
      }], this, 0, function () {
        var e = new Lv();
        onmessage = tv(e);
      }, 11);
    };
  }();

  function Fv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return ev(e, t, [Kg, Jg, function () {
      return [Nv];
    }], function (e) {
      return $g(Nv(e.data[0], Qg(e.data[1])));
    }, 5, n);
  }

  function Nv(e, t) {
    return Eg((hv(e), e.subarray(2, -4)), t);
  }

  var Uv = function () {
    function e(e) {
      this.G = Ev, this.I = vv, this.Z = Lv, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no stream handler";
      if (this.s) this.s.push(e, t);else {
        if (this.p && this.p.length) {
          var n = new $m(this.p.length + e.length);
          n.set(this.p), n.set(e, this.p.length);
        } else this.p = e;

        if (this.p.length > 2) {
          var r = this,
              i = function () {
            r.ondata.apply(r, arguments);
          };

          this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null;
        }
      }
    }, e;
  }(),
      Bv = function () {
    function e(e) {
      this.G = Av, this.I = bv, this.Z = Iv, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      Uv.prototype.push.call(this, e, t);
    }, e;
  }();

  function jv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Cv(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? xv(e, t, n) : Fv(e, t, n);
  }

  function zv(e, t) {
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Rv(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? yv(e, t) : Nv(e, t);
  }

  var Vv = function (e, t, n, r) {
    for (var i in e) {
      var s = e[i],
          o = t + i;
      s instanceof $m ? n[o] = [s, r] : Array.isArray(s) ? n[o] = [s[0], Vg(r, s[1])] : Vv(s, o + "/", n, r);
    }
  },
      Gv = "undefined" != typeof TextEncoder && new TextEncoder(),
      Hv = "undefined" != typeof TextDecoder && new TextDecoder(),
      Wv = 0;

  try {
    Hv.decode(Fg, {
      stream: !0
    }), Wv = 1;
  } catch (Lc) {}

  var Kv = function (e) {
    for (var t = "", n = 0;;) {
      var r = e[n++],
          i = (r > 127) + (r > 223) + (r > 239);
      if (n + i > e.length) return [t, Tg(e, n - 1)];
      i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[n++]) : String.fromCharCode((15 & r) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(r);
    }
  },
      Xv = function () {
    function e(e) {
      this.ondata = e, Wv ? this.t = new TextDecoder() : this.p = Fg;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";

      if (t = !!t, this.t) {
        if (this.ondata(this.t.decode(e, {
          stream: !0
        }), t), t) {
          if (this.t.decode().length) throw "invalid utf-8 data";
          this.t = null;
        }
      } else {
        if (!this.p) throw "stream finished";
        var n = new $m(this.p.length + e.length);
        n.set(this.p), n.set(e, this.p.length);
        var r = Kv(n),
            i = r[0],
            s = r[1];

        if (t) {
          if (s.length) throw "invalid utf-8 data";
          this.p = null;
        } else this.p = s;

        this.ondata(i, t);
      }
    }, e;
  }(),
      qv = function () {
    function e(e) {
      this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";
      if (this.d) throw "stream finished";
      this.ondata(Yv(e), this.d = t || !1);
    }, e;
  }();

  function Yv(e, t) {
    if (t) {
      for (var n = new $m(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);

      return n;
    }

    if (Gv) return Gv.encode(e);

    var i = e.length,
        s = new $m(e.length + (e.length >> 1)),
        o = 0,
        a = function (e) {
      s[o++] = e;
    };

    for (r = 0; r < i; ++r) {
      if (o + 5 > s.length) {
        var l = new $m(o + 8 + (i - r << 1));
        l.set(s), s = l;
      }

      var c = e.charCodeAt(r);
      c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++r)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c));
    }

    return Tg(s, 0, o);
  }

  function Zv(e, t) {
    if (t) {
      for (var n = "", r = 0; r < e.length; r += 16384) n += String.fromCharCode.apply(null, e.subarray(r, r + 16384));

      return n;
    }

    if (Hv) return Hv.decode(e);
    var i = Kv(e),
        s = i[0];
    if (i[1].length) throw "invalid utf-8 data";
    return s;
  }

  var Jv = function (e) {
    return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0;
  },
      $v = function (e, t) {
    return t + 30 + rv(e, t + 26) + rv(e, t + 28);
  },
      Qv = function (e, t, n) {
    var r = rv(e, t + 28),
        i = Zv(e.subarray(t + 46, t + 46 + r), !(2048 & rv(e, t + 8))),
        s = t + 46 + r,
        o = iv(e, t + 20),
        a = n && 4294967295 == o ? eb(e, s) : [o, iv(e, t + 24), iv(e, t + 42)],
        l = a[0],
        c = a[1],
        u = a[2];
    return [rv(e, t + 10), l, c, i, s + rv(e, t + 30) + rv(e, t + 32), u];
  },
      eb = function (e, t) {
    for (; 1 != rv(e, t); t += 4 + rv(e, t + 2));

    return [sv(e, t + 12), sv(e, t + 4), sv(e, t + 20)];
  },
      tb = function (e) {
    var t = 0;
    if (e) for (var n in e) {
      var r = e[n].length;
      if (r > 65535) throw "extra field too long";
      t += r + 4;
    }
    return t;
  },
      nb = function (e, t, n, r, i, s, o, a) {
    var l = r.length,
        c = n.extra,
        u = a && a.length,
        p = tb(c);
    ov(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
    var h = new Date(null == n.mtime ? Date.now() : n.mtime),
        d = h.getFullYear() - 1980;
    if (d < 0 || d > 119) throw "date not in range 1980-2099";
    if (ov(e, t, d << 25 | h.getMonth() + 1 << 21 | h.getDate() << 16 | h.getHours() << 11 | h.getMinutes() << 5 | h.getSeconds() >>> 1), t += 4, null != s && (ov(e, t, n.crc), ov(e, t + 4, s), ov(e, t + 8, n.size)), ov(e, t + 12, l), ov(e, t + 14, p), t += 16, null != o && (ov(e, t, u), ov(e, t + 6, n.attrs), ov(e, t + 10, o), t += 14), e.set(r, t), t += l, p) for (var f in c) {
      var _ = c[f],
          m = _.length;
      ov(e, t, +f), ov(e, t + 2, m), e.set(_, t + 4), t += 4 + m;
    }
    return u && (e.set(a, t), t += u), t;
  },
      rb = function (e, t, n, r, i) {
    ov(e, t, 101010256), ov(e, t + 8, n), ov(e, t + 10, n), ov(e, t + 12, r), ov(e, t + 16, i);
  },
      ib = function () {
    function e(e) {
      this.filename = e, this.c = Bg(), this.size = 0, this.compression = 0;
    }

    return e.prototype.process = function (e, t) {
      this.ondata(null, e, t);
    }, e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
      this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1);
    }, e;
  }(),
      sb = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), ib.call(this, e), this.d = new fv(t, function (e, t) {
        n.ondata(null, e, t);
      }), this.compression = 8, this.flag = Jv(t.level);
    }

    return e.prototype.process = function (e, t) {
      try {
        this.d.push(e, t);
      } catch (e) {
        this.ondata(e, null, t);
      }
    }, e.prototype.push = function (e, t) {
      ib.prototype.push.call(this, e, t);
    }, e;
  }(),
      ob = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), ib.call(this, e), this.d = new _v(t, function (e, t, r) {
        n.ondata(e, t, r);
      }), this.compression = 8, this.flag = Jv(t.level), this.terminate = this.d.terminate;
    }

    return e.prototype.process = function (e, t) {
      this.d.push(e, t);
    }, e.prototype.push = function (e, t) {
      ib.prototype.push.call(this, e, t);
    }, e;
  }(),
      ab = function () {
    function e(e) {
      this.ondata = e, this.u = [], this.d = 1;
    }

    return e.prototype.add = function (e) {
      var t = this;
      if (2 & this.d) throw "stream finished";
      var n = Yv(e.filename),
          r = n.length,
          i = e.comment,
          s = i && Yv(i),
          o = r != e.filename.length || s && i.length != s.length,
          a = r + tb(e.extra) + 30;
      if (r > 65535) throw "filename too long";
      var l = new $m(a);
      nb(l, 0, e, n, o);

      var c = [l],
          u = function () {
        for (var e = 0, n = c; e < n.length; e++) {
          var r = n[e];
          t.ondata(null, r, !1);
        }

        c = [];
      },
          p = this.d;

      this.d = 0;
      var h = this.u.length,
          d = Vg(e, {
        f: n,
        u: o,
        o: s,
        t: function () {
          e.terminate && e.terminate();
        },
        r: function () {
          if (u(), p) {
            var e = t.u[h + 1];
            e ? e.r() : t.d = 1;
          }

          p = 1;
        }
      }),
          f = 0;
      e.ondata = function (n, r, i) {
        if (n) t.ondata(n, r, i), t.terminate();else if (f += r.length, c.push(r), i) {
          var s = new $m(16);
          ov(s, 0, 134695760), ov(s, 4, e.crc), ov(s, 8, f), ov(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, p && d.r(), p = 1;
        } else p && u();
      }, this.u.push(d);
    }, e.prototype.end = function () {
      var e = this;

      if (2 & this.d) {
        if (1 & this.d) throw "stream finishing";
        throw "stream finished";
      }

      this.d ? this.e() : this.u.push({
        r: function () {
          1 & e.d && (e.u.splice(-1, 1), e.e());
        },
        t: function () {}
      }), this.d = 3;
    }, e.prototype.e = function () {
      for (var e = 0, t = 0, n = 0, r = 0, i = this.u; r < i.length; r++) n += 46 + (l = i[r]).f.length + tb(l.extra) + (l.o ? l.o.length : 0);

      for (var s = new $m(n + 22), o = 0, a = this.u; o < a.length; o++) {
        var l = a[o];
        nb(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + tb(l.extra) + (l.o ? l.o.length : 0), t += l.b;
      }

      rb(s, e, this.u.length, n, t), this.ondata(null, s, !0), this.d = 2;
    }, e.prototype.terminate = function () {
      for (var e = 0, t = this.u; e < t.length; e++) t[e].t();

      this.d = 2;
    }, e;
  }();

  function lb(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    var r = {};
    Vv(e, "", r, t);

    var i = Object.keys(r),
        s = i.length,
        o = 0,
        a = 0,
        l = s,
        c = new Array(s),
        u = [],
        p = function () {
      for (var e = 0; e < u.length; ++e) u[e]();
    },
        h = function () {
      var e = new $m(a + 22),
          t = o,
          r = a - o;
      a = 0;

      for (var i = 0; i < l; ++i) {
        var s = c[i];

        try {
          var u = s.c.length;
          nb(e, a, s, s.f, s.u, u);
          var p = 30 + s.f.length + tb(s.extra),
              h = a + p;
          e.set(s.c, h), nb(e, o, s, s.f, s.u, u, a, s.m), o += 16 + p + (s.m ? s.m.length : 0), a = h + u;
        } catch (e) {
          return n(e, null);
        }
      }

      rb(e, o, c.length, r, t), n(null, e);
    };

    s || h();

    for (var d = function (e) {
      var t = i[e],
          l = r[t],
          d = l[0],
          f = l[1],
          _ = Bg(),
          m = d.length;

      _.p(d);

      var g = Yv(t),
          v = g.length,
          b = f.comment,
          x = b && Yv(b),
          y = x && x.length,
          w = tb(f.extra),
          S = 0 == f.level ? 0 : 8,
          M = function (r, i) {
        if (r) p(), n(r, null);else {
          var l = i.length;
          c[e] = Vg(f, {
            size: m,
            crc: _.d(),
            c: i,
            f: g,
            m: x,
            u: v != t.length || x && b.length != y,
            compression: S
          }), o += 30 + v + w + l, a += 76 + 2 * (v + w) + (y || 0) + l, --s || h();
        }
      };

      if (v > 65535 && M("filename too long", null), S) {
        if (m < 16e4) try {
          M(null, gv(d, f));
        } catch (e) {
          M(e, null);
        } else u.push(mv(d, f, M));
      } else M(null, d);
    }, f = 0; f < l; ++f) d(f);

    return p;
  }

  function cb(e, t) {
    t || (t = {});
    var n = {},
        r = [];
    Vv(e, "", n, t);
    var i = 0,
        s = 0;

    for (var o in n) {
      var a = n[o],
          l = a[0],
          c = a[1],
          u = 0 == c.level ? 0 : 8,
          p = (S = Yv(o)).length,
          h = c.comment,
          d = h && Yv(h),
          f = d && d.length,
          _ = tb(c.extra);

      if (p > 65535) throw "filename too long";
      var m = u ? gv(l, c) : l,
          g = m.length,
          v = Bg();
      v.p(l), r.push(Vg(c, {
        size: l.length,
        crc: v.d(),
        c: m,
        f: S,
        m: d,
        u: p != o.length || d && h.length != f,
        o: i,
        compression: u
      })), i += 30 + p + _ + g, s += 76 + 2 * (p + _) + (f || 0) + g;
    }

    for (var b = new $m(s + 22), x = i, y = s - i, w = 0; w < r.length; ++w) {
      var S = r[w];
      nb(b, S.o, S, S.f, S.u, S.c.length);
      var M = 30 + S.f.length + tb(S.extra);
      b.set(S.c, S.o + M), nb(b, i, S, S.f, S.u, S.c.length, S.o, S.m), i += 16 + M + (S.m ? S.m.length : 0);
    }

    return rb(b, i, r.length, y, x), b;
  }

  var ub = function () {
    function e() {}

    return e.prototype.push = function (e, t) {
      this.ondata(null, e, t);
    }, e.compression = 0, e;
  }(),
      pb = function () {
    function e() {
      var e = this;
      this.i = new vv(function (t, n) {
        e.ondata(null, t, n);
      });
    }

    return e.prototype.push = function (e, t) {
      try {
        this.i.push(e, t);
      } catch (n) {
        this.ondata(n, e, t);
      }
    }, e.compression = 8, e;
  }(),
      hb = function () {
    function e(e, t) {
      var n = this;
      t < 32e4 ? this.i = new vv(function (e, t) {
        n.ondata(null, e, t);
      }) : (this.i = new bv(function (e, t, r) {
        n.ondata(e, t, r);
      }), this.terminate = this.i.terminate);
    }

    return e.prototype.push = function (e, t) {
      this.i.terminate && (e = Tg(e, 0)), this.i.push(e, t);
    }, e.compression = 8, e;
  }(),
      db = function () {
    function e(e) {
      this.onfile = e, this.k = [], this.o = {
        0: ub
      }, this.p = Fg;
    }

    return e.prototype.push = function (e, t) {
      var n = this;
      if (!this.onfile) throw "no callback";
      if (!this.p) throw "stream finished";

      if (this.c > 0) {
        var r = Math.min(this.c, e.length),
            i = e.subarray(0, r);
        if (this.c -= r, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(r)).length) return this.push(e, t);
      } else {
        var s = 0,
            o = 0,
            a = void 0,
            l = void 0;
        this.p.length ? e.length ? ((l = new $m(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;

        for (var c = l.length, u = this.c, p = u && this.d, h = function () {
          var e,
              t = iv(l, o);

          if (67324752 == t) {
            s = 1, a = o, d.d = null, d.c = 0;

            var r = rv(l, o + 6),
                i = rv(l, o + 8),
                p = 2048 & r,
                h = 8 & r,
                f = rv(l, o + 26),
                _ = rv(l, o + 28);

            if (c > o + 30 + f + _) {
              var m = [];
              d.k.unshift(m), s = 2;
              var g,
                  v = iv(l, o + 18),
                  b = iv(l, o + 22),
                  x = Zv(l.subarray(o + 30, o += 30 + f), !p);
              4294967295 == v ? (e = h ? [-2] : eb(l, o), v = e[0], b = e[1]) : h && (v = -1), o += _, d.c = v;
              var y = {
                name: x,
                compression: i,
                start: function () {
                  if (!y.ondata) throw "no callback";

                  if (v) {
                    var e = n.o[i];
                    if (!e) throw "unknown compression type " + i;

                    (g = v < 0 ? new e(x) : new e(x, v, b)).ondata = function (e, t, n) {
                      y.ondata(e, t, n);
                    };

                    for (var t = 0, r = m; t < r.length; t++) {
                      var s = r[t];
                      g.push(s, !1);
                    }

                    n.k[0] == m && n.c ? n.d = g : g.push(Fg, !0);
                  } else y.ondata(null, Fg, !0);
                },
                terminate: function () {
                  g && g.terminate && g.terminate();
                }
              };
              v >= 0 && (y.size = v, y.originalSize = b), d.onfile(y);
            }

            return "break";
          }

          if (u) {
            if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
            if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break";
          }
        }, d = this; o < c - 4 && "break" !== h(); ++o);

        if (this.p = Fg, u < 0) {
          var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == iv(l, a - 16) && 4)) : l.subarray(0, o);
          p ? p.push(f, !!s) : this.k[+(2 == s)].push(f);
        }

        if (2 & s) return this.push(l.subarray(o), t);
        this.p = l.subarray(o);
      }

      if (t) {
        if (this.c) throw "invalid zip file";
        this.p = null;
      }
    }, e.prototype.register = function (e) {
      this.o[e.compression] = e;
    }, e;
  }();

  function fb(e, t) {
    if ("function" != typeof t) throw "no callback";

    for (var n = [], r = function () {
      for (var e = 0; e < n.length; ++e) n[e]();
    }, i = {}, s = e.length - 22; 101010256 != iv(e, s); --s) if (!s || e.length - s > 65558) return void t("invalid zip file", null);

    var o = rv(e, s + 8);
    o || t(null, {});
    var a = o,
        l = iv(e, s + 16),
        c = 4294967295 == l;

    if (c) {
      if (s = iv(e, s - 12), 101075792 != iv(e, s)) return void t("invalid zip file", null);
      a = o = iv(e, s + 32), l = iv(e, s + 48);
    }

    for (var u = function (s) {
      var a = Qv(e, l, c),
          u = a[0],
          p = a[1],
          h = a[2],
          d = a[3],
          f = a[4],
          _ = a[5],
          m = $v(e, _);
      l = f;

      var g = function (e, n) {
        e ? (r(), t(e, null)) : (i[d] = n, --o || t(null, i));
      };

      if (u) {
        if (8 == u) {
          var v = e.subarray(m, m + p);
          if (p < 32e4) try {
            g(null, yv(v, new $m(h)));
          } catch (e) {
            g(e, null);
          } else n.push(xv(v, {
            size: h
          }, g));
        } else g("unknown compression type " + u, null);
      } else g(null, Tg(e, m, m + p));
    }, p = 0; p < a; ++p) u();

    return r;
  }

  function _b(e) {
    for (var t = {}, n = e.length - 22; 101010256 != iv(e, n); --n) if (!n || e.length - n > 65558) throw "invalid zip file";

    var r = rv(e, n + 8);
    if (!r) return {};
    var i = iv(e, n + 16),
        s = 4294967295 == i;

    if (s) {
      if (n = iv(e, n - 12), 101075792 != iv(e, n)) throw "invalid zip file";
      r = iv(e, n + 32), i = iv(e, n + 48);
    }

    for (var o = 0; o < r; ++o) {
      var a = Qv(e, i, s),
          l = a[0],
          c = a[1],
          u = a[2],
          p = a[3],
          h = a[4],
          d = a[5],
          f = $v(e, d);

      if (i = h, l) {
        if (8 != l) throw "unknown compression type " + l;
        t[p] = yv(e.subarray(f, f + c), new $m(u));
      } else t[p] = Tg(e, f, f + c);
    }

    return t;
  }

  class mb extends i.yxD {
    constructor(e) {
      super(e), this.type = i.cLu;
    }

    parse(e) {
      const t = 65536,
            r = 14,
            s = 65537,
            o = Math.pow(2.7182818, 2.2),
            a = {
        l: 0,
        c: 0,
        lc: 0
      };

      function l(e, t, n, r, i) {
        for (; n < e;) t = t << 8 | B(r, i), n += 8;

        n -= e, a.l = t >> n & (1 << e) - 1, a.c = t, a.lc = n;
      }

      const c = new Array(59);

      function u(e) {
        return 63 & e;
      }

      function p(e) {
        return e >> 6;
      }

      const h = {
        c: 0,
        lc: 0
      };

      function d(e, t, n, r) {
        e = e << 8 | B(n, r), t += 8, h.c = e, h.lc = t;
      }

      const f = {
        c: 0,
        lc: 0
      };

      function _(e, t, n, r, i, s, o, a, l) {
        if (e == t) {
          r < 8 && (d(n, r, i, s), n = h.c, r = h.lc);
          let e = n >> (r -= 8);
          if (e = new Uint8Array([e])[0], a.value + e > l) return !1;
          const t = o[a.value - 1];

          for (; e-- > 0;) o[a.value++] = t;
        } else {
          if (!(a.value < l)) return !1;
          o[a.value++] = e;
        }

        f.c = n, f.lc = r;
      }

      function m(e) {
        return 65535 & e;
      }

      function g(e) {
        const t = m(e);
        return t > 32767 ? t - 65536 : t;
      }

      const v = {
        a: 0,
        b: 0
      };

      function b(e, t) {
        const n = g(e),
              r = g(t),
              i = n + (1 & r) + (r >> 1),
              s = i,
              o = i - r;
        v.a = s, v.b = o;
      }

      function x(e, t) {
        const n = m(e),
              r = m(t),
              i = n - (r >> 1) & 65535,
              s = r + i - 32768 & 65535;
        v.a = s, v.b = i;
      }

      function y(e, t, n, r, i, s, o) {
        const a = o < 16384,
              l = n > i ? i : n;
        let c,
            u,
            p = 1;

        for (; p <= l;) p <<= 1;

        for (p >>= 1, c = p, p >>= 1; p >= 1;) {
          u = 0;
          const o = u + s * (i - c),
                l = s * p,
                h = s * c,
                d = r * p,
                f = r * c;

          let _, m, g, y;

          for (; u <= o; u += h) {
            let i = u;
            const s = u + r * (n - c);

            for (; i <= s; i += f) {
              const n = i + d,
                    r = i + l,
                    s = r + d;
              a ? (b(e[i + t], e[r + t]), _ = v.a, g = v.b, b(e[n + t], e[s + t]), m = v.a, y = v.b, b(_, m), e[i + t] = v.a, e[n + t] = v.b, b(g, y), e[r + t] = v.a, e[s + t] = v.b) : (x(e[i + t], e[r + t]), _ = v.a, g = v.b, x(e[n + t], e[s + t]), m = v.a, y = v.b, x(_, m), e[i + t] = v.a, e[n + t] = v.b, x(g, y), e[r + t] = v.a, e[s + t] = v.b);
            }

            if (n & p) {
              const n = i + l;
              a ? b(e[i + t], e[n + t]) : x(e[i + t], e[n + t]), _ = v.a, e[n + t] = v.b, e[i + t] = _;
            }
          }

          if (i & p) {
            let i = u;
            const s = u + r * (n - c);

            for (; i <= s; i += f) {
              const n = i + d;
              a ? b(e[i + t], e[n + t]) : x(e[i + t], e[n + t]), _ = v.a, e[n + t] = v.b, e[i + t] = _;
            }
          }

          c = p, p >>= 1;
        }

        return u;
      }

      function w(e, t, n, i, o, m) {
        const g = n.value,
              v = U(t, n),
              b = U(t, n);
        n.value += 4;
        const x = U(t, n);
        if (n.value += 4, v < 0 || v >= s || b < 0 || b >= s) throw new Error("Something wrong with HUF_ENCSIZE");
        const y = new Array(s),
              w = new Array(16384);
        if (function (e) {
          for (let t = 0; t < 16384; t++) e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null;
        }(w), function (e, t, n, r, i, o) {
          const u = t;
          let p = 0,
              h = 0;

          for (; r <= i; r++) {
            if (u.value - t.value > n) return !1;
            l(6, p, h, e, u);
            const s = a.l;

            if (p = a.c, h = a.lc, o[r] = s, 63 == s) {
              if (u.value - t.value > n) throw new Error("Something wrong with hufUnpackEncTable");
              l(8, p, h, e, u);
              let s = a.l + 6;
              if (p = a.c, h = a.lc, r + s > i + 1) throw new Error("Something wrong with hufUnpackEncTable");

              for (; s--;) o[r++] = 0;

              r--;
            } else if (s >= 59) {
              let e = s - 59 + 2;
              if (r + e > i + 1) throw new Error("Something wrong with hufUnpackEncTable");

              for (; e--;) o[r++] = 0;

              r--;
            }
          }

          !function (e) {
            for (let e = 0; e <= 58; ++e) c[e] = 0;

            for (let t = 0; t < s; ++t) c[e[t]] += 1;

            let t = 0;

            for (let e = 58; e > 0; --e) {
              const n = t + c[e] >> 1;
              c[e] = t, t = n;
            }

            for (let t = 0; t < s; ++t) {
              const n = e[t];
              n > 0 && (e[t] = n | c[n]++ << 6);
            }
          }(o);
        }(e, n, i - (n.value - g), v, b, y), x > 8 * (i - (n.value - g))) throw new Error("Something wrong with hufUncompress");
        !function (e, t, n, i) {
          for (; t <= n; t++) {
            const n = p(e[t]),
                  s = u(e[t]);
            if (n >> s) throw new Error("Invalid table entry");

            if (s > r) {
              const e = i[n >> s - r];
              if (e.len) throw new Error("Invalid table entry");

              if (e.lit++, e.p) {
                const t = e.p;
                e.p = new Array(e.lit);

                for (let n = 0; n < e.lit - 1; ++n) e.p[n] = t[n];
              } else e.p = new Array(1);

              e.p[e.lit - 1] = t;
            } else if (s) {
              let e = 0;

              for (let o = 1 << r - s; o > 0; o--) {
                const o = i[(n << r - s) + e];
                if (o.len || o.p) throw new Error("Invalid table entry");
                o.len = s, o.lit = t, e++;
              }
            }
          }
        }(y, v, b, w), function (e, t, n, i, s, o, a, l, c) {
          let m = 0,
              g = 0;
          const v = a,
                b = Math.trunc(i.value + (s + 7) / 8);

          for (; i.value < b;) for (d(m, g, n, i), m = h.c, g = h.lc; g >= r;) {
            const s = t[m >> g - r & 16383];
            if (s.len) g -= s.len, _(s.lit, o, m, g, n, i, l, c, v), m = f.c, g = f.lc;else {
              if (!s.p) throw new Error("hufDecode issues");
              let t;

              for (t = 0; t < s.lit; t++) {
                const r = u(e[s.p[t]]);

                for (; g < r && i.value < b;) d(m, g, n, i), m = h.c, g = h.lc;

                if (g >= r && p(e[s.p[t]]) == (m >> g - r & (1 << r) - 1)) {
                  g -= r, _(s.p[t], o, m, g, n, i, l, c, v), m = f.c, g = f.lc;
                  break;
                }
              }

              if (t == s.lit) throw new Error("hufDecode issues");
            }
          }

          const x = 8 - s & 7;

          for (m >>= x, g -= x; g > 0;) {
            const e = t[m << r - g & 16383];
            if (!e.len) throw new Error("hufDecode issues");
            g -= e.len, _(e.lit, o, m, g, n, i, l, c, v), m = f.c, g = f.lc;
          }
        }(y, w, e, n, x, b, m, o, {
          value: 0
        });
      }

      function S(e) {
        for (let t = 1; t < e.length; t++) {
          const n = e[t - 1] + e[t] - 128;
          e[t] = n;
        }
      }

      function M(e, t) {
        let n = 0,
            r = Math.floor((e.length + 1) / 2),
            i = 0;
        const s = e.length - 1;

        for (; !(i > s || (t[i++] = e[n++], i > s));) t[i++] = e[r++];
      }

      function T(e) {
        let t = e.byteLength;
        const n = new Array();
        let r = 0;
        const i = new DataView(e);

        for (; t > 0;) {
          const e = i.getInt8(r++);

          if (e < 0) {
            const s = -e;
            t -= s + 1;

            for (let e = 0; e < s; e++) n.push(i.getUint8(r++));
          } else {
            const s = e;
            t -= 2;
            const o = i.getUint8(r++);

            for (let e = 0; e < s + 1; e++) n.push(o);
          }
        }

        return n;
      }

      function E(e, t, n) {
        let r,
            i = 1;

        for (; i < 64;) r = t[e.value], 65280 == r ? i = 64 : r >> 8 == 255 ? i += 255 & r : (n[i] = r, i++), e.value++;
      }

      function A(e) {
        const t = .5 * Math.cos(.7853975),
              n = .5 * Math.cos(3.14159 / 16),
              r = .5 * Math.cos(3.14159 / 8),
              i = .5 * Math.cos(3 * 3.14159 / 16),
              s = .5 * Math.cos(.981746875),
              o = .5 * Math.cos(3 * 3.14159 / 8),
              a = .5 * Math.cos(1.374445625),
              l = new Array(4),
              c = new Array(4),
              u = new Array(4),
              p = new Array(4);

        for (let h = 0; h < 8; ++h) {
          const d = 8 * h;
          l[0] = r * e[d + 2], l[1] = o * e[d + 2], l[2] = r * e[d + 6], l[3] = o * e[d + 6], c[0] = n * e[d + 1] + i * e[d + 3] + s * e[d + 5] + a * e[d + 7], c[1] = i * e[d + 1] - a * e[d + 3] - n * e[d + 5] - s * e[d + 7], c[2] = s * e[d + 1] - n * e[d + 3] + a * e[d + 5] + i * e[d + 7], c[3] = a * e[d + 1] - s * e[d + 3] + i * e[d + 5] - n * e[d + 7], u[0] = t * (e[d + 0] + e[d + 4]), u[3] = t * (e[d + 0] - e[d + 4]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], p[0] = u[0] + u[1], p[1] = u[3] + u[2], p[2] = u[3] - u[2], p[3] = u[0] - u[1], e[d + 0] = p[0] + c[0], e[d + 1] = p[1] + c[1], e[d + 2] = p[2] + c[2], e[d + 3] = p[3] + c[3], e[d + 4] = p[3] - c[3], e[d + 5] = p[2] - c[2], e[d + 6] = p[1] - c[1], e[d + 7] = p[0] - c[0];
        }

        for (let h = 0; h < 8; ++h) l[0] = r * e[16 + h], l[1] = o * e[16 + h], l[2] = r * e[48 + h], l[3] = o * e[48 + h], c[0] = n * e[8 + h] + i * e[24 + h] + s * e[40 + h] + a * e[56 + h], c[1] = i * e[8 + h] - a * e[24 + h] - n * e[40 + h] - s * e[56 + h], c[2] = s * e[8 + h] - n * e[24 + h] + a * e[40 + h] + i * e[56 + h], c[3] = a * e[8 + h] - s * e[24 + h] + i * e[40 + h] - n * e[56 + h], u[0] = t * (e[h] + e[32 + h]), u[3] = t * (e[h] - e[32 + h]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], p[0] = u[0] + u[1], p[1] = u[3] + u[2], p[2] = u[3] - u[2], p[3] = u[0] - u[1], e[0 + h] = p[0] + c[0], e[8 + h] = p[1] + c[1], e[16 + h] = p[2] + c[2], e[24 + h] = p[3] + c[3], e[32 + h] = p[3] - c[3], e[40 + h] = p[2] - c[2], e[48 + h] = p[1] - c[1], e[56 + h] = p[0] - c[0];
      }

      function C(e) {
        for (let t = 0; t < 64; ++t) {
          const n = e[0][t],
                r = e[1][t],
                i = e[2][t];
          e[0][t] = n + 1.5747 * i, e[1][t] = n - .1873 * r - .4682 * i, e[2][t] = n + 1.8556 * r;
        }
      }

      function R(e, t, n) {
        for (let s = 0; s < 64; ++s) t[n + s] = i.A5E.toHalfFloat((r = e[s]) <= 1 ? Math.sign(r) * Math.pow(Math.abs(r), 2.2) : Math.sign(r) * Math.pow(o, Math.abs(r) - 1));

        var r;
      }

      function k(e) {
        return new DataView(e.array.buffer, e.offset.value, e.size);
      }

      function P(e) {
        const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size),
              n = new Uint8Array(T(t)),
              r = new Uint8Array(n.length);
        return S(n), M(n, r), new DataView(r.buffer);
      }

      function D(e) {
        const t = e.array.slice(e.offset.value, e.offset.value + e.size);
        void 0 === n && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const r = Nv(t),
              i = new Uint8Array(r.length);
        return S(r), M(r, i), new DataView(i.buffer);
      }

      function O(e) {
        const n = e.viewer,
              r = {
          value: e.offset.value
        },
              i = new Uint16Array(e.width * e.scanlineBlockSize * (e.channels * e.type)),
              s = new Uint8Array(8192);
        let o = 0;
        const a = new Array(e.channels);

        for (let t = 0; t < e.channels; t++) a[t] = {}, a[t].start = o, a[t].end = a[t].start, a[t].nx = e.width, a[t].ny = e.lines, a[t].size = e.type, o += a[t].nx * a[t].ny * a[t].size;

        const l = W(n, r),
              c = W(n, r);
        if (c >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
        if (l <= c) for (let e = 0; e < c - l + 1; e++) s[e + l] = j(n, r);

        const u = new Uint16Array(t),
              p = function (e, n) {
          let r = 0;

          for (let i = 0; i < t; ++i) (0 == i || e[i >> 3] & 1 << (7 & i)) && (n[r++] = i);

          const i = r - 1;

          for (; r < t;) n[r++] = 0;

          return i;
        }(s, u),
              h = U(n, r);

        w(e.array, n, r, h, i, o);

        for (let t = 0; t < e.channels; ++t) {
          const e = a[t];

          for (let n = 0; n < a[t].size; ++n) y(i, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, p);
        }

        !function (e, t, n) {
          for (let r = 0; r < n; ++r) t[r] = e[t[r]];
        }(u, i, o);
        let d = 0;
        const f = new Uint8Array(i.buffer.byteLength);

        for (let t = 0; t < e.lines; t++) for (let t = 0; t < e.channels; t++) {
          const e = a[t],
                n = e.nx * e.size,
                r = new Uint8Array(i.buffer, 2 * e.end, 2 * n);
          f.set(r, d), d += 2 * n, e.end += n;
        }

        return new DataView(f.buffer);
      }

      function L(e) {
        const t = e.array.slice(e.offset.value, e.offset.value + e.size);
        void 0 === n && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const r = Nv(t),
              i = e.lines * e.channels * e.width,
              s = 1 == e.type ? new Uint16Array(i) : new Uint32Array(i);
        let o = 0,
            a = 0;
        const l = new Array(4);

        for (let t = 0; t < e.lines; t++) for (let t = 0; t < e.channels; t++) {
          let t = 0;

          switch (e.type) {
            case 1:
              l[0] = o, l[1] = l[0] + e.width, o = l[1] + e.width;

              for (let n = 0; n < e.width; ++n) t += r[l[0]++] << 8 | r[l[1]++], s[a] = t, a++;

              break;

            case 2:
              l[0] = o, l[1] = l[0] + e.width, l[2] = l[1] + e.width, o = l[2] + e.width;

              for (let n = 0; n < e.width; ++n) t += r[l[0]++] << 24 | r[l[1]++] << 16 | r[l[2]++] << 8, s[a] = t, a++;

          }
        }

        return new DataView(s.buffer);
      }

      function I(e) {
        const t = e.viewer,
              n = {
          value: e.offset.value
        },
              r = new Uint8Array(e.width * e.lines * (e.channels * e.type * 2)),
              i = {
          version: z(t, n),
          unknownUncompressedSize: z(t, n),
          unknownCompressedSize: z(t, n),
          acCompressedSize: z(t, n),
          dcCompressedSize: z(t, n),
          rleCompressedSize: z(t, n),
          rleUncompressedSize: z(t, n),
          rleRawSize: z(t, n),
          totalAcUncompressedCount: z(t, n),
          totalDcUncompressedCount: z(t, n),
          acCompression: z(t, n)
        };
        if (i.version < 2) throw new Error("EXRLoader.parse: " + J.compression + " version " + i.version + " is unsupported");
        const s = new Array();
        let o = W(t, n) - 2;

        for (; o > 0;) {
          const e = F(t.buffer, n),
                r = j(t, n),
                i = r >> 2 & 3,
                a = new Int8Array([(r >> 4) - 1])[0],
                l = j(t, n);
          s.push({
            name: e,
            index: a,
            type: l,
            compression: i
          }), o -= e.length + 3;
        }

        const a = J.channels,
              l = new Array(e.channels);

        for (let t = 0; t < e.channels; ++t) {
          const n = l[t] = {},
                r = a[t];
          n.name = r.name, n.compression = 0, n.decoded = !1, n.type = r.pixelType, n.pLinear = r.pLinear, n.width = e.width, n.height = e.lines;
        }

        const c = {
          idx: new Array(3)
        };

        for (let t = 0; t < e.channels; ++t) {
          const e = l[t];

          for (let n = 0; n < s.length; ++n) {
            const r = s[n];
            e.name == r.name && (e.compression = r.compression, r.index >= 0 && (c.idx[r.index] = t), e.offset = t);
          }
        }

        let u, p, h;
        if (i.acCompressedSize > 0) switch (i.acCompression) {
          case 0:
            u = new Uint16Array(i.totalAcUncompressedCount), w(e.array, t, n, i.acCompressedSize, u, i.totalAcUncompressedCount);
            break;

          case 1:
            const r = Nv(e.array.slice(n.value, n.value + i.totalAcUncompressedCount));
            u = new Uint16Array(r.buffer), n.value += i.totalAcUncompressedCount;
        }

        if (i.dcCompressedSize > 0) {
          const t = {
            array: e.array,
            offset: n,
            size: i.dcCompressedSize
          };
          p = new Uint16Array(D(t).buffer), n.value += i.dcCompressedSize;
        }

        i.rleRawSize > 0 && (h = T(Nv(e.array.slice(n.value, n.value + i.rleCompressedSize)).buffer), n.value += i.rleCompressedSize);
        let d = 0;
        const f = new Array(l.length);

        for (let e = 0; e < f.length; ++e) f[e] = new Array();

        for (let t = 0; t < e.lines; ++t) for (let t = 0; t < l.length; ++t) f[t].push(d), d += l[t].width * e.type * 2;

        !function (e, t, n, r, i, s) {
          let o = new DataView(s.buffer);

          const a = n[e.idx[0]].width,
                l = n[e.idx[0]].height,
                c = Math.floor(a / 8),
                u = Math.ceil(a / 8),
                p = Math.ceil(l / 8),
                h = a - 8 * (u - 1),
                d = l - 8 * (p - 1),
                f = {
            value: 0
          },
                _ = new Array(3),
                m = new Array(3),
                g = new Array(3),
                v = new Array(3),
                b = new Array(3);

          for (let n = 0; n < 3; ++n) b[n] = t[e.idx[n]], _[n] = n < 1 ? 0 : _[n - 1] + u * p, m[n] = new Float32Array(64), g[n] = new Uint16Array(64), v[n] = new Uint16Array(64 * u);

          for (let t = 0; t < p; ++t) {
            let s = 8;
            t == p - 1 && (s = d);
            let a = 8;

            for (let e = 0; e < u; ++e) {
              e == u - 1 && (a = h);

              for (let e = 0; e < 3; ++e) g[e].fill(0), g[e][0] = i[_[e]++], E(f, r, g[e]), x = g[e], (y = m[e])[0] = H(x[0]), y[1] = H(x[1]), y[2] = H(x[5]), y[3] = H(x[6]), y[4] = H(x[14]), y[5] = H(x[15]), y[6] = H(x[27]), y[7] = H(x[28]), y[8] = H(x[2]), y[9] = H(x[4]), y[10] = H(x[7]), y[11] = H(x[13]), y[12] = H(x[16]), y[13] = H(x[26]), y[14] = H(x[29]), y[15] = H(x[42]), y[16] = H(x[3]), y[17] = H(x[8]), y[18] = H(x[12]), y[19] = H(x[17]), y[20] = H(x[25]), y[21] = H(x[30]), y[22] = H(x[41]), y[23] = H(x[43]), y[24] = H(x[9]), y[25] = H(x[11]), y[26] = H(x[18]), y[27] = H(x[24]), y[28] = H(x[31]), y[29] = H(x[40]), y[30] = H(x[44]), y[31] = H(x[53]), y[32] = H(x[10]), y[33] = H(x[19]), y[34] = H(x[23]), y[35] = H(x[32]), y[36] = H(x[39]), y[37] = H(x[45]), y[38] = H(x[52]), y[39] = H(x[54]), y[40] = H(x[20]), y[41] = H(x[22]), y[42] = H(x[33]), y[43] = H(x[38]), y[44] = H(x[46]), y[45] = H(x[51]), y[46] = H(x[55]), y[47] = H(x[60]), y[48] = H(x[21]), y[49] = H(x[34]), y[50] = H(x[37]), y[51] = H(x[47]), y[52] = H(x[50]), y[53] = H(x[56]), y[54] = H(x[59]), y[55] = H(x[61]), y[56] = H(x[35]), y[57] = H(x[36]), y[58] = H(x[48]), y[59] = H(x[49]), y[60] = H(x[57]), y[61] = H(x[58]), y[62] = H(x[62]), y[63] = H(x[63]), A(m[e]);

              C(m);

              for (let t = 0; t < 3; ++t) R(m[t], v[t], 64 * e);
            }

            let l = 0;

            for (let r = 0; r < 3; ++r) {
              const i = n[e.idx[r]].type;

              for (let e = 8 * t; e < 8 * t + s; ++e) {
                l = b[r][e];

                for (let t = 0; t < c; ++t) {
                  const n = 64 * t + 8 * (7 & e);
                  o.setUint16(l + 0 * i, v[r][n + 0], !0), o.setUint16(l + 2 * i, v[r][n + 1], !0), o.setUint16(l + 4 * i, v[r][n + 2], !0), o.setUint16(l + 6 * i, v[r][n + 3], !0), o.setUint16(l + 8 * i, v[r][n + 4], !0), o.setUint16(l + 10 * i, v[r][n + 5], !0), o.setUint16(l + 12 * i, v[r][n + 6], !0), o.setUint16(l + 14 * i, v[r][n + 7], !0), l += 16 * i;
                }
              }

              if (c != u) for (let e = 8 * t; e < 8 * t + s; ++e) {
                const t = b[r][e] + 8 * c * 2 * i,
                      n = 64 * c + 8 * (7 & e);

                for (let e = 0; e < a; ++e) o.setUint16(t + 2 * e * i, v[r][n + e], !0);
              }
            }
          }

          var x, y;
          const w = new Uint16Array(a);
          o = new DataView(s.buffer);

          for (let t = 0; t < 3; ++t) {
            n[e.idx[t]].decoded = !0;
            const r = n[e.idx[t]].type;
            if (2 == n[t].type) for (let e = 0; e < l; ++e) {
              const n = b[t][e];

              for (let e = 0; e < a; ++e) w[e] = o.getUint16(n + 2 * e * r, !0);

              for (let e = 0; e < a; ++e) o.setFloat32(n + 2 * e * r, H(w[e]), !0);
            }
          }
        }(c, f, l, u, p, r);

        for (let t = 0; t < l.length; ++t) {
          const n = l[t];

          if (!n.decoded) {
            if (2 !== n.compression) throw new Error("EXRLoader.parse: unsupported channel compression");
            {
              let i = 0,
                  s = 0;

              for (let o = 0; o < e.lines; ++o) {
                let e = f[t][i];

                for (let t = 0; t < n.width; ++t) {
                  for (let t = 0; t < 2 * n.type; ++t) r[e++] = h[s + t * n.width * n.height];

                  s++;
                }

                i++;
              }
            }
          }
        }

        return new DataView(r.buffer);
      }

      function F(e, t) {
        const n = new Uint8Array(e);
        let r = 0;

        for (; 0 != n[t.value + r];) r += 1;

        const i = new TextDecoder().decode(n.slice(t.value, t.value + r));
        return t.value = t.value + r + 1, i;
      }

      function N(e, t) {
        const n = e.getInt32(t.value, !0);
        return t.value = t.value + 4, n;
      }

      function U(e, t) {
        const n = e.getUint32(t.value, !0);
        return t.value = t.value + 4, n;
      }

      function B(e, t) {
        const n = e[t.value];
        return t.value = t.value + 1, n;
      }

      function j(e, t) {
        const n = e.getUint8(t.value);
        return t.value = t.value + 1, n;
      }

      const z = function (e, t) {
        const n = Number(e.getBigInt64(t.value, !0));
        return t.value += 8, n;
      };

      function V(e, t) {
        const n = e.getFloat32(t.value, !0);
        return t.value += 4, n;
      }

      function G(e, t) {
        return i.A5E.toHalfFloat(V(e, t));
      }

      function H(e) {
        const t = (31744 & e) >> 10,
              n = 1023 & e;
        return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14);
      }

      function W(e, t) {
        const n = e.getUint16(t.value, !0);
        return t.value += 2, n;
      }

      function K(e, t) {
        return H(W(e, t));
      }

      function X(e, t, n, r, i) {
        return "string" === r || "stringvector" === r || "iccProfile" === r ? function (e, t, n) {
          const r = new TextDecoder().decode(new Uint8Array(e).slice(t.value, t.value + n));
          return t.value = t.value + n, r;
        }(t, n, i) : "chlist" === r ? function (e, t, n, r) {
          const i = n.value,
                s = [];

          for (; n.value < i + r - 1;) {
            const r = F(t, n),
                  i = N(e, n),
                  o = j(e, n);
            n.value += 3;
            const a = N(e, n),
                  l = N(e, n);
            s.push({
              name: r,
              pixelType: i,
              pLinear: o,
              xSampling: a,
              ySampling: l
            });
          }

          return n.value += 1, s;
        }(e, t, n, i) : "chromaticities" === r ? function (e, t) {
          return {
            redX: V(e, t),
            redY: V(e, t),
            greenX: V(e, t),
            greenY: V(e, t),
            blueX: V(e, t),
            blueY: V(e, t),
            whiteX: V(e, t),
            whiteY: V(e, t)
          };
        }(e, n) : "compression" === r ? function (e, t) {
          return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][j(e, t)];
        }(e, n) : "box2i" === r ? function (e, t) {
          return {
            xMin: U(e, t),
            yMin: U(e, t),
            xMax: U(e, t),
            yMax: U(e, t)
          };
        }(e, n) : "lineOrder" === r ? function (e, t) {
          return ["INCREASING_Y"][j(e, t)];
        }(e, n) : "float" === r ? V(e, n) : "v2f" === r ? function (e, t) {
          return [V(e, t), V(e, t)];
        }(e, n) : "v3f" === r ? function (e, t) {
          return [V(e, t), V(e, t), V(e, t)];
        }(e, n) : "int" === r ? N(e, n) : "rational" === r ? function (e, t) {
          return [N(e, t), U(e, t)];
        }(e, n) : "timecode" === r ? function (e, t) {
          return [U(e, t), U(e, t)];
        }(e, n) : "preview" === r ? (n.value += i, "skipped") : void (n.value += i);
      }

      const q = new DataView(e),
            Y = new Uint8Array(e),
            Z = {
        value: 0
      },
            J = function (e, t, n) {
        const r = {};
        if (20000630 != e.getUint32(0, !0)) throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
        r.version = e.getUint8(4);
        const i = e.getUint8(5);
        r.spec = {
          singleTile: !!(2 & i),
          longName: !!(4 & i),
          deepFormat: !!(8 & i),
          multiPart: !!(16 & i)
        }, n.value = 8;
        let s = !0;

        for (; s;) {
          const i = F(t, n);
          if (0 == i) s = !1;else {
            const s = F(t, n),
                  o = X(e, t, n, s, U(e, n));
            void 0 === o ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s}'.`) : r[i] = o;
          }
        }

        if (0 != (-5 & i)) throw console.error("EXRHeader:", r), new Error("THREE.EXRLoader: provided file is currently unsupported.");
        return r;
      }(q, e, Z),
            $ = function (e, t, n, r, s) {
        const o = {
          size: 0,
          viewer: t,
          array: n,
          offset: r,
          width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
          height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
          channels: e.channels.length,
          bytesPerLine: null,
          lines: null,
          inputSize: null,
          type: e.channels[0].pixelType,
          uncompress: null,
          getter: null,
          format: null,
          encoding: null
        };

        switch (e.compression) {
          case "NO_COMPRESSION":
            o.lines = 1, o.uncompress = k;
            break;

          case "RLE_COMPRESSION":
            o.lines = 1, o.uncompress = P;
            break;

          case "ZIPS_COMPRESSION":
            o.lines = 1, o.uncompress = D;
            break;

          case "ZIP_COMPRESSION":
            o.lines = 16, o.uncompress = D;
            break;

          case "PIZ_COMPRESSION":
            o.lines = 32, o.uncompress = O;
            break;

          case "PXR24_COMPRESSION":
            o.lines = 16, o.uncompress = L;
            break;

          case "DWAA_COMPRESSION":
            o.lines = 32, o.uncompress = I;
            break;

          case "DWAB_COMPRESSION":
            o.lines = 256, o.uncompress = I;
            break;

          default:
            throw new Error("EXRLoader.parse: " + e.compression + " is unsupported");
        }

        if (o.scanlineBlockSize = o.lines, 1 == o.type) switch (s) {
          case i.VzW:
            o.getter = K, o.inputSize = 2;
            break;

          case i.cLu:
            o.getter = W, o.inputSize = 2;
        } else {
          if (2 != o.type) throw new Error("EXRLoader.parse: unsupported pixelType " + o.type + " for " + e.compression + ".");

          switch (s) {
            case i.VzW:
              o.getter = V, o.inputSize = 4;
              break;

            case i.cLu:
              o.getter = G, o.inputSize = 4;
          }
        }
        o.blockCount = (e.dataWindow.yMax + 1) / o.scanlineBlockSize;

        for (let e = 0; e < o.blockCount; e++) z(t, r);

        o.outputChannels = 3 == o.channels ? 4 : o.channels;
        const a = o.width * o.height * o.outputChannels;

        switch (s) {
          case i.VzW:
            o.byteArray = new Float32Array(a), o.channels < o.outputChannels && o.byteArray.fill(1, 0, a);
            break;

          case i.cLu:
            o.byteArray = new Uint16Array(a), o.channels < o.outputChannels && o.byteArray.fill(15360, 0, a);
            break;

          default:
            console.error("THREE.EXRLoader: unsupported type: ", s);
        }

        return o.bytesPerLine = o.width * o.inputSize * o.channels, 4 == o.outputChannels ? (o.format = i.wk1, o.encoding = i.rnI) : (o.format = i.hEm, o.encoding = i.rnI), o;
      }(J, q, Y, Z, this.type),
            Q = {
        value: 0
      },
            ee = {
        R: 0,
        G: 1,
        B: 2,
        A: 3,
        Y: 0
      };

      for (let e = 0; e < $.height / $.scanlineBlockSize; e++) {
        const t = U(q, Z);
        $.size = U(q, Z), $.lines = t + $.scanlineBlockSize > $.height ? $.height - t : $.scanlineBlockSize;
        const n = $.size < $.lines * $.bytesPerLine ? $.uncompress($) : k($);
        Z.value += $.size;

        for (let t = 0; t < $.scanlineBlockSize; t++) {
          const r = t + e * $.scanlineBlockSize;
          if (r >= $.height) break;

          for (let e = 0; e < $.channels; e++) {
            const i = ee[J.channels[e].name];

            for (let s = 0; s < $.width; s++) {
              Q.value = (t * ($.channels * $.width) + e * $.width + s) * $.inputSize;
              const o = ($.height - 1 - r) * ($.width * $.outputChannels) + s * $.outputChannels + i;
              $.byteArray[o] = $.getter(n, Q);
            }
          }
        }
      }

      return {
        header: J,
        width: $.width,
        height: $.height,
        data: $.byteArray,
        format: $.format,
        encoding: $.encoding,
        type: this.type
      };
    }

    setDataType(e) {
      return this.type = e, this;
    }

    load(e, t, n, r) {
      return super.load(e, function (e, n) {
        e.encoding = n.encoding, e.minFilter = i.wem, e.magFilter = i.wem, e.generateMipmaps = !1, e.flipY = !1, t && t(e, n);
      }, n, r);
    }

  }

  class gb extends r {
    constructor() {
      super(...arguments), this.dependencies = [js];
    }

    async onAdded(e) {
      this._importer || (this._importer = new Zt(class extends mb {
        constructor(t) {
          super(t), this.setDataType(Ns(e.renderer.rendererObject));
        }

      }, ["exr"], !1)), Fs.Importers.push(this._importer);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Fs.Importers.splice(Fs.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  function vb(e, t, n) {
    const r = n.length - e - 1;
    if (t >= n[r]) return r - 1;
    if (t <= n[e]) return e;
    let i = e,
        s = r,
        o = Math.floor((i + s) / 2);

    for (; t < n[o] || t >= n[o + 1];) t < n[o] ? s = o : i = o, o = Math.floor((i + s) / 2);

    return o;
  }

  function bb(e, t) {
    let n = 1;

    for (let t = 2; t <= e; ++t) n *= t;

    let r = 1;

    for (let e = 2; e <= t; ++e) r *= e;

    for (let n = 2; n <= e - t; ++n) r *= n;

    return n / r;
  }

  gb.PluginType = "EXRLoadPlugin";

  class xb extends i.Hyl {
    constructor(e, t, n, r, s) {
      super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = s || this.knots.length - 1;

      for (let e = 0; e < n.length; ++e) {
        const t = n[e];
        this.controlPoints[e] = new i.Ltg(t.x, t.y, t.z, t.w);
      }
    }

    getPoint(e, t = new i.Pa4()) {
      const n = t,
            r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
            s = function (e, t, n, r) {
        const s = vb(e, r, t),
              o = function (e, t, n, r) {
          const i = [],
                s = [],
                o = [];
          i[0] = 1;

          for (let a = 1; a <= n; ++a) {
            s[a] = t - r[e + 1 - a], o[a] = r[e + a] - t;
            let n = 0;

            for (let e = 0; e < a; ++e) {
              const t = o[e + 1],
                    r = s[a - e],
                    l = i[e] / (t + r);
              i[e] = n + t * l, n = r * l;
            }

            i[a] = n;
          }

          return i;
        }(s, r, e, t),
              a = new i.Ltg(0, 0, 0, 0);

        for (let t = 0; t <= e; ++t) {
          const r = n[s - e + t],
                i = o[t],
                l = r.w * i;
          a.x += r.x * l, a.y += r.y * l, a.z += r.z * l, a.w += r.w * i;
        }

        return a;
      }(this.degree, this.knots, this.controlPoints, r);

      return 1 !== s.w && s.divideScalar(s.w), n.set(s.x, s.y, s.z);
    }

    getTangent(e, t = new i.Pa4()) {
      const n = t,
            r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
            s = function (e, t, n, r, s) {
        const o = function (e, t, n, r, s) {
          const o = s < e ? s : e,
                a = [],
                l = vb(e, r, t),
                c = function (e, t, n, r, i) {
            const s = [];

            for (let e = 0; e <= n; ++e) s[e] = 0;

            const o = [];

            for (let e = 0; e <= r; ++e) o[e] = s.slice(0);

            const a = [];

            for (let e = 0; e <= n; ++e) a[e] = s.slice(0);

            a[0][0] = 1;
            const l = s.slice(0),
                  c = s.slice(0);

            for (let r = 1; r <= n; ++r) {
              l[r] = t - i[e + 1 - r], c[r] = i[e + r] - t;
              let n = 0;

              for (let e = 0; e < r; ++e) {
                const t = c[e + 1],
                      i = l[r - e];
                a[r][e] = t + i;
                const s = a[e][r - 1] / a[r][e];
                a[e][r] = n + t * s, n = i * s;
              }

              a[r][r] = n;
            }

            for (let e = 0; e <= n; ++e) o[0][e] = a[e][n];

            for (let e = 0; e <= n; ++e) {
              let t = 0,
                  i = 1;
              const l = [];

              for (let e = 0; e <= n; ++e) l[e] = s.slice(0);

              l[0][0] = 1;

              for (let s = 1; s <= r; ++s) {
                let r = 0;
                const c = e - s,
                      u = n - s;
                e >= s && (l[i][0] = l[t][0] / a[u + 1][c], r = l[i][0] * a[c][u]);
                const p = e - 1 <= u ? s - 1 : n - e;

                for (let e = c >= -1 ? 1 : -c; e <= p; ++e) l[i][e] = (l[t][e] - l[t][e - 1]) / a[u + 1][c + e], r += l[i][e] * a[c + e][u];

                e <= u && (l[i][s] = -l[t][s - 1] / a[u + 1][e], r += l[i][s] * a[e][u]), o[s][e] = r;
                const h = t;
                t = i, i = h;
              }
            }

            let u = n;

            for (let e = 1; e <= r; ++e) {
              for (let t = 0; t <= n; ++t) o[e][t] *= u;

              u *= n - e;
            }

            return o;
          }(l, r, e, o, t),
                u = [];

          for (let e = 0; e < n.length; ++e) {
            const t = n[e].clone(),
                  r = t.w;
            t.x *= r, t.y *= r, t.z *= r, u[e] = t;
          }

          for (let t = 0; t <= o; ++t) {
            const n = u[l - e].clone().multiplyScalar(c[t][0]);

            for (let r = 1; r <= e; ++r) n.add(u[l - e + r].clone().multiplyScalar(c[t][r]));

            a[t] = n;
          }

          for (let e = o + 1; e <= s + 1; ++e) a[e] = new i.Ltg(0, 0, 0);

          return a;
        }(e, t, n, r, s);

        return function (e) {
          const t = e.length,
                n = [],
                r = [];

          for (let s = 0; s < t; ++s) {
            const t = e[s];
            n[s] = new i.Pa4(t.x, t.y, t.z), r[s] = t.w;
          }

          const s = [];

          for (let e = 0; e < t; ++e) {
            const t = n[e].clone();

            for (let n = 1; n <= e; ++n) t.sub(s[e - n].clone().multiplyScalar(bb(e, n) * r[n]));

            s[e] = t.divideScalar(r[0]);
          }

          return s;
        }(o);
      }(this.degree, this.knots, this.controlPoints, r, 1);

      return n.copy(s[1]).normalize(), n;
    }

  }

  let yb, wb, Sb;

  class Mb extends i.aNw {
    constructor(e) {
      super(e);
    }

    load(e, t, n, r) {
      const s = this,
            o = "" === s.path ? i.Zp0.extractUrlBase(e) : s.path,
            a = new i.hH6(this.manager);
      a.setPath(s.path), a.setResponseType("arraybuffer"), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function (n) {
        try {
          t(s.parse(n, o));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    parse(e, t) {
      if (function (e) {
        const t = "Kaydara FBX Binary  \0";
        return e.byteLength >= t.length && t === zb(e, 0, t.length);
      }(e)) yb = new Rb().parse(e);else {
        const t = zb(e);
        if (!function (e) {
          const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
          let n = 0;

          function r(t) {
            const r = e[t - 1];
            return e = e.slice(n + t), n++, r;
          }

          for (let e = 0; e < t.length; ++e) if (r(1) === t[e]) return !1;

          return !0;
        }(t)) throw new Error("THREE.FBXLoader: Unknown format.");
        if (Db(t) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Db(t));
        yb = new Cb().parse(t);
      }
      const n = new i.dpR(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
      return new Tb(n, this.manager).parse(yb);
    }

  }

  class Tb {
    constructor(e, t) {
      this.textureLoader = e, this.manager = t;
    }

    parse() {
      wb = this.parseConnections();
      const e = this.parseImages(),
            t = this.parseTextures(e),
            n = this.parseMaterials(t),
            r = this.parseDeformers(),
            i = new Eb().parse(r);
      return this.parseScene(r, i, n), Sb;
    }

    parseConnections() {
      const e = new Map();
      return "Connections" in yb && yb.Connections.connections.forEach(function (t) {
        const n = t[0],
              r = t[1],
              i = t[2];
        e.has(n) || e.set(n, {
          parents: [],
          children: []
        });
        const s = {
          ID: r,
          relationship: i
        };
        e.get(n).parents.push(s), e.has(r) || e.set(r, {
          parents: [],
          children: []
        });
        const o = {
          ID: n,
          relationship: i
        };
        e.get(r).children.push(o);
      }), e;
    }

    parseImages() {
      const e = {},
            t = {};

      if ("Video" in yb.Objects) {
        const n = yb.Objects.Video;

        for (const r in n) {
          const i = n[r];

          if (e[parseInt(r)] = i.RelativeFilename || i.Filename, "Content" in i) {
            const e = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0,
                  s = "string" == typeof i.Content && "" !== i.Content;

            if (e || s) {
              const e = this.parseImage(n[r]);
              t[i.RelativeFilename || i.Filename] = e;
            }
          }
        }
      }

      for (const n in e) {
        const r = e[n];
        void 0 !== t[r] ? e[n] = t[r] : e[n] = e[n].split("\\").pop();
      }

      return e;
    }

    parseImage(e) {
      const t = e.Content,
            n = e.RelativeFilename || e.Filename,
            r = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
      let i;

      switch (r) {
        case "bmp":
          i = "image/bmp";
          break;

        case "jpg":
        case "jpeg":
          i = "image/jpeg";
          break;

        case "png":
          i = "image/png";
          break;

        case "tif":
          i = "image/tiff";
          break;

        case "tga":
          null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga";
          break;

        default:
          return void console.warn('FBXLoader: Image type "' + r + '" is not supported.');
      }

      if ("string" == typeof t) return "data:" + i + ";base64," + t;
      {
        const e = new Uint8Array(t);
        return window.URL.createObjectURL(new Blob([e], {
          type: i
        }));
      }
    }

    parseTextures(e) {
      const t = new Map();

      if ("Texture" in yb.Objects) {
        const n = yb.Objects.Texture;

        for (const r in n) {
          const i = this.parseTexture(n[r], e);
          t.set(parseInt(r), i);
        }
      }

      return t;
    }

    parseTexture(e, t) {
      const n = this.loadTexture(e, t);
      n.ID = e.id, n.name = e.attrName;
      const r = e.WrapModeU,
            s = e.WrapModeV,
            o = void 0 !== r ? r.value : 0,
            a = void 0 !== s ? s.value : 0;

      if (n.wrapS = 0 === o ? i.rpg : i.uWy, n.wrapT = 0 === a ? i.rpg : i.uWy, "Scaling" in e) {
        const t = e.Scaling.value;
        n.repeat.x = t[0], n.repeat.y = t[1];
      }

      if ("Translation" in e) {
        const t = e.Translation.value;
        n.offset.x = t[0], n.offset.y = t[1];
      }

      return n;
    }

    loadTexture(e, t) {
      let n;
      const r = this.textureLoader.path,
            s = wb.get(e.id).children;
      let o;
      void 0 !== s && s.length > 0 && void 0 !== t[s[0].ID] && (n = t[s[0].ID], 0 !== n.indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0));
      const a = e.FileName.slice(-3).toLowerCase();

      if ("tga" === a) {
        const t = this.manager.getHandler(".tga");
        null === t ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new i.xEZ()) : (t.setPath(this.textureLoader.path), o = t.load(n));
      } else "psd" === a ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new i.xEZ()) : o = this.textureLoader.load(n);

      return this.textureLoader.setPath(r), o;
    }

    parseMaterials(e) {
      const t = new Map();

      if ("Material" in yb.Objects) {
        const n = yb.Objects.Material;

        for (const r in n) {
          const i = this.parseMaterial(n[r], e);
          null !== i && t.set(parseInt(r), i);
        }
      }

      return t;
    }

    parseMaterial(e, t) {
      const n = e.id,
            r = e.attrName;
      let s = e.ShadingModel;
      if ("object" == typeof s && (s = s.value), !wb.has(n)) return null;
      const o = this.parseParameters(e, t, n);
      let a;

      switch (s.toLowerCase()) {
        case "phong":
          a = new i.xoR();
          break;

        case "lambert":
          a = new i.YBo();
          break;

        default:
          console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), a = new i.xoR();
      }

      return a.setValues(o), a.name = r, a;
    }

    parseParameters(e, t, n) {
      const r = {};
      e.BumpFactor && (r.bumpScale = e.BumpFactor.value), e.Diffuse ? r.color = new i.Ilk().fromArray(e.Diffuse.value) : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (r.color = new i.Ilk().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value), e.Emissive ? r.emissive = new i.Ilk().fromArray(e.Emissive.value) : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (r.emissive = new i.Ilk().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (r.opacity = parseFloat(e.Opacity.value)), r.opacity < 1 && (r.transparent = !0), e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value), e.Shininess && (r.shininess = e.Shininess.value), e.Specular ? r.specular = new i.Ilk().fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (r.specular = new i.Ilk().fromArray(e.SpecularColor.value));
      const s = this;
      return wb.get(n).children.forEach(function (e) {
        const n = e.relationship;

        switch (n) {
          case "Bump":
            r.bumpMap = s.getTexture(t, e.ID);
            break;

          case "Maya|TEX_ao_map":
            r.aoMap = s.getTexture(t, e.ID);
            break;

          case "DiffuseColor":
          case "Maya|TEX_color_map":
            r.map = s.getTexture(t, e.ID), void 0 !== r.map && (r.map.encoding = i.knz);
            break;

          case "DisplacementColor":
            r.displacementMap = s.getTexture(t, e.ID);
            break;

          case "EmissiveColor":
            r.emissiveMap = s.getTexture(t, e.ID), void 0 !== r.emissiveMap && (r.emissiveMap.encoding = i.knz);
            break;

          case "NormalMap":
          case "Maya|TEX_normal_map":
            r.normalMap = s.getTexture(t, e.ID);
            break;

          case "ReflectionColor":
            r.envMap = s.getTexture(t, e.ID), void 0 !== r.envMap && (r.envMap.mapping = i.dSO, r.envMap.encoding = i.knz);
            break;

          case "SpecularColor":
            r.specularMap = s.getTexture(t, e.ID), void 0 !== r.specularMap && (r.specularMap.encoding = i.knz);
            break;

          case "TransparentColor":
          case "TransparencyFactor":
            r.alphaMap = s.getTexture(t, e.ID), r.transparent = !0;
            break;

          default:
            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n);
        }
      }), r;
    }

    getTexture(e, t) {
      return "LayeredTexture" in yb.Objects && t in yb.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = wb.get(t).children[0].ID), e.get(t);
    }

    parseDeformers() {
      const e = {},
            t = {};

      if ("Deformer" in yb.Objects) {
        const n = yb.Objects.Deformer;

        for (const r in n) {
          const i = n[r],
                s = wb.get(parseInt(r));

          if ("Skin" === i.attrType) {
            const t = this.parseSkeleton(s, n);
            t.ID = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t.geometryID = s.parents[0].ID, e[r] = t;
          } else if ("BlendShape" === i.attrType) {
            const e = {
              id: r
            };
            e.rawTargets = this.parseMorphTargets(s, n), e.id = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[r] = e;
          }
        }
      }

      return {
        skeletons: e,
        morphTargets: t
      };
    }

    parseSkeleton(e, t) {
      const n = [];
      return e.children.forEach(function (e) {
        const r = t[e.ID];
        if ("Cluster" !== r.attrType) return;
        const s = {
          ID: e.ID,
          indices: [],
          weights: [],
          transformLink: new i.yGw().fromArray(r.TransformLink.a)
        };
        "Indexes" in r && (s.indices = r.Indexes.a, s.weights = r.Weights.a), n.push(s);
      }), {
        rawBones: n,
        bones: []
      };
    }

    parseMorphTargets(e, t) {
      const n = [];

      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r],
              s = t[i.ID],
              o = {
          name: s.attrName,
          initialWeight: s.DeformPercent,
          id: s.id,
          fullWeights: s.FullWeights.a
        };
        if ("BlendShapeChannel" !== s.attrType) return;
        o.geoID = wb.get(parseInt(i.ID)).children.filter(function (e) {
          return void 0 === e.relationship;
        })[0].ID, n.push(o);
      }

      return n;
    }

    parseScene(e, t, n) {
      Sb = new i.ZAu();
      const r = this.parseModels(e.skeletons, t, n),
            s = yb.Objects.Model,
            o = this;
      r.forEach(function (e) {
        const t = s[e.ID];
        o.setLookAtProperties(e, t), wb.get(e.ID).parents.forEach(function (t) {
          const n = r.get(t.ID);
          void 0 !== n && n.add(e);
        }), null === e.parent && Sb.add(e);
      }), this.bindSkeleton(e.skeletons, t, r), this.createAmbientLight(), Sb.traverse(function (e) {
        if (e.userData.transformData) {
          e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix, e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld);
          const t = Ub(e.userData.transformData);
          e.applyMatrix4(t), e.updateWorldMatrix();
        }
      });
      const a = new Ab().parse();
      1 === Sb.children.length && Sb.children[0].isGroup && (Sb.children[0].animations = a, Sb = Sb.children[0]), Sb.animations = a;
    }

    parseModels(e, t, n) {
      const r = new Map(),
            s = yb.Objects.Model;

      for (const o in s) {
        const a = parseInt(o),
              l = s[o],
              c = wb.get(a);
        let u = this.buildSkeleton(c, e, a, l.attrName);

        if (!u) {
          switch (l.attrType) {
            case "Camera":
              u = this.createCamera(c);
              break;

            case "Light":
              u = this.createLight(c);
              break;

            case "Mesh":
              u = this.createMesh(c, t, n);
              break;

            case "NurbsCurve":
              u = this.createCurve(c, t);
              break;

            case "LimbNode":
            case "Root":
              u = new i.N$j();
              break;

            default:
              u = new i.ZAu();
          }

          u.name = l.attrName ? i.iUV.sanitizeNodeName(l.attrName) : "", u.ID = a;
        }

        this.getTransformData(u, l), r.set(a, u);
      }

      return r;
    }

    buildSkeleton(e, t, n, r) {
      let s = null;
      return e.parents.forEach(function (e) {
        for (const o in t) {
          const a = t[o];
          a.rawBones.forEach(function (t, o) {
            if (t.ID === e.ID) {
              const e = s;
              s = new i.N$j(), s.matrixWorld.copy(t.transformLink), s.name = r ? i.iUV.sanitizeNodeName(r) : "", s.ID = n, a.bones[o] = s, null !== e && s.add(e);
            }
          });
        }
      }), s;
    }

    createCamera(e) {
      let t, n;
      if (e.children.forEach(function (e) {
        const t = yb.Objects.NodeAttribute[e.ID];
        void 0 !== t && (n = t);
      }), void 0 === n) t = new i.Tme();else {
        let e = 0;
        void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (e = 1);
        let r = 1;
        void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3);
        let s = 1e3;
        void 0 !== n.FarPlane && (s = n.FarPlane.value / 1e3);
        let o = window.innerWidth,
            a = window.innerHeight;
        void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (o = n.AspectWidth.value, a = n.AspectHeight.value);
        const l = o / a;
        let c = 45;
        void 0 !== n.FieldOfView && (c = n.FieldOfView.value);
        const u = n.FocalLength ? n.FocalLength.value : null;

        switch (e) {
          case 0:
            t = new i.cPb(c, l, r, s), null !== u && t.setFocalLength(u);
            break;

          case 1:
            t = new i.iKG(-o / 2, o / 2, a / 2, -a / 2, r, s);
            break;

          default:
            console.warn("THREE.FBXLoader: Unknown camera type " + e + "."), t = new i.Tme();
        }
      }
      return t;
    }

    createLight(e) {
      let t, n;
      if (e.children.forEach(function (e) {
        const t = yb.Objects.NodeAttribute[e.ID];
        void 0 !== t && (n = t);
      }), void 0 === n) t = new i.Tme();else {
        let e;
        e = void 0 === n.LightType ? 0 : n.LightType.value;
        let r = 16777215;
        void 0 !== n.Color && (r = new i.Ilk().fromArray(n.Color.value));
        let s = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
        void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (s = 0);
        let o = 0;
        void 0 !== n.FarAttenuationEnd && (o = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value);
        const a = 1;

        switch (e) {
          case 0:
            t = new i.cek(r, s, o, a);
            break;

          case 1:
            t = new i.Ox3(r, s);
            break;

          case 2:
            let e = Math.PI / 3;
            void 0 !== n.InnerAngle && (e = i.M8C.degToRad(n.InnerAngle.value));
            let l = 0;
            void 0 !== n.OuterAngle && (l = i.M8C.degToRad(n.OuterAngle.value), l = Math.max(l, 1)), t = new i.PMe(r, s, o, e, l, a);
            break;

          default:
            console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new i.cek(r, s);
        }

        void 0 !== n.CastShadows && 1 === n.CastShadows.value && (t.castShadow = !0);
      }
      return t;
    }

    createMesh(e, t, n) {
      let r,
          s = null,
          o = null;
      const a = [];
      return e.children.forEach(function (e) {
        t.has(e.ID) && (s = t.get(e.ID)), n.has(e.ID) && a.push(n.get(e.ID));
      }), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new i.xoR({
        color: 13421772
      }), a.push(o)), "color" in s.attributes && a.forEach(function (e) {
        e.vertexColors = !0;
      }), s.FBX_Deformer ? (r = new i.TUv(s, o), r.normalizeSkinWeights()) : r = new i.Kj0(s, o), r;
    }

    createCurve(e, t) {
      const n = e.children.reduce(function (e, n) {
        return t.has(n.ID) && (e = t.get(n.ID)), e;
      }, null),
            r = new i.nls({
        color: 3342591,
        linewidth: 1
      });
      return new i.x12(n, r);
    }

    getTransformData(e, t) {
      const n = {};
      "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), n.eulerOrder = "RotationOrder" in t ? Bb(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
    }

    setLookAtProperties(e, t) {
      "LookAtProperty" in t && wb.get(e.ID).children.forEach(function (t) {
        if ("LookAtProperty" === t.relationship) {
          const n = yb.Objects.Model[t.ID];

          if ("Lcl_Translation" in n) {
            const t = n.Lcl_Translation.value;
            void 0 !== e.target ? (e.target.position.fromArray(t), Sb.add(e.target)) : e.lookAt(new i.Pa4().fromArray(t));
          }
        }
      });
    }

    bindSkeleton(e, t, n) {
      const r = this.parsePoseNodes();

      for (const s in e) {
        const o = e[s];
        wb.get(parseInt(o.ID)).parents.forEach(function (e) {
          if (t.has(e.ID)) {
            const t = e.ID;
            wb.get(t).parents.forEach(function (e) {
              n.has(e.ID) && n.get(e.ID).bind(new i.OdW(o.bones), r[e.ID]);
            });
          }
        });
      }
    }

    parsePoseNodes() {
      const e = {};

      if ("Pose" in yb.Objects) {
        const t = yb.Objects.Pose;

        for (const n in t) if ("BindPose" === t[n].attrType && t[n].NbPoseNodes > 0) {
          const r = t[n].PoseNode;
          Array.isArray(r) ? r.forEach(function (t) {
            e[t.Node] = new i.yGw().fromArray(t.Matrix.a);
          }) : e[r.Node] = new i.yGw().fromArray(r.Matrix.a);
        }
      }

      return e;
    }

    createAmbientLight() {
      if ("GlobalSettings" in yb && "AmbientColor" in yb.GlobalSettings) {
        const e = yb.GlobalSettings.AmbientColor.value,
              t = e[0],
              n = e[1],
              r = e[2];

        if (0 !== t || 0 !== n || 0 !== r) {
          const e = new i.Ilk(t, n, r);
          Sb.add(new i.Mig(e, 1));
        }
      }
    }

  }

  class Eb {
    parse(e) {
      const t = new Map();

      if ("Geometry" in yb.Objects) {
        const n = yb.Objects.Geometry;

        for (const r in n) {
          const i = wb.get(parseInt(r)),
                s = this.parseGeometry(i, n[r], e);
          t.set(parseInt(r), s);
        }
      }

      return t;
    }

    parseGeometry(e, t, n) {
      switch (t.attrType) {
        case "Mesh":
          return this.parseMeshGeometry(e, t, n);

        case "NurbsCurve":
          return this.parseNurbsGeometry(t);
      }
    }

    parseMeshGeometry(e, t, n) {
      const r = n.skeletons,
            i = [],
            s = e.parents.map(function (e) {
        return yb.Objects.Model[e.ID];
      });
      if (0 === s.length) return;
      const o = e.children.reduce(function (e, t) {
        return void 0 !== r[t.ID] && (e = r[t.ID]), e;
      }, null);
      e.children.forEach(function (e) {
        void 0 !== n.morphTargets[e.ID] && i.push(n.morphTargets[e.ID]);
      });
      const a = s[0],
            l = {};
      "RotationOrder" in a && (l.eulerOrder = Bb(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
      const c = Ub(l);
      return this.genGeometry(t, o, i, c);
    }

    genGeometry(e, t, n, r) {
      const s = new i.u9r();
      e.attrName && (s.name = e.attrName);
      const o = this.parseGeoNode(e, t),
            a = this.genBuffers(o),
            l = new i.a$l(a.vertex, 3);

      if (l.applyMatrix4(r), s.setAttribute("position", l), a.colors.length > 0 && s.setAttribute("color", new i.a$l(a.colors, 3)), t && (s.setAttribute("skinIndex", new i.qlB(a.weightsIndices, 4)), s.setAttribute("skinWeight", new i.a$l(a.vertexWeights, 4)), s.FBX_Deformer = t), a.normal.length > 0) {
        const e = new i.Vkp().getNormalMatrix(r),
              t = new i.a$l(a.normal, 3);
        t.applyNormalMatrix(e), s.setAttribute("normal", t);
      }

      if (a.uvs.forEach(function (e, t) {
        let n = "uv" + (t + 1).toString();
        0 === t && (n = "uv"), s.setAttribute(n, new i.a$l(a.uvs[t], 2));
      }), o.material && "AllSame" !== o.material.mappingType) {
        let e = a.materialIndex[0],
            t = 0;

        if (a.materialIndex.forEach(function (n, r) {
          n !== e && (s.addGroup(t, r - t, e), e = n, t = r);
        }), s.groups.length > 0) {
          const t = s.groups[s.groups.length - 1],
                n = t.start + t.count;
          n !== a.materialIndex.length && s.addGroup(n, a.materialIndex.length - n, e);
        }

        0 === s.groups.length && s.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
      }

      return this.addMorphTargets(s, e, n, r), s;
    }

    parseGeoNode(e, t) {
      const n = {};

      if (n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], n.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
        n.uv = [];
        let t = 0;

        for (; e.LayerElementUV[t];) e.LayerElementUV[t].UV && n.uv.push(this.parseUVs(e.LayerElementUV[t])), t++;
      }

      return n.weightTable = {}, null !== t && (n.skeleton = t, t.rawBones.forEach(function (e, t) {
        e.indices.forEach(function (r, i) {
          void 0 === n.weightTable[r] && (n.weightTable[r] = []), n.weightTable[r].push({
            id: t,
            weight: e.weights[i]
          });
        });
      })), n;
    }

    genBuffers(e) {
      const t = {
        vertex: [],
        normal: [],
        colors: [],
        uvs: [],
        materialIndex: [],
        vertexWeights: [],
        weightsIndices: []
      };
      let n = 0,
          r = 0,
          i = !1,
          s = [],
          o = [],
          a = [],
          l = [],
          c = [],
          u = [];
      const p = this;
      return e.vertexIndices.forEach(function (h, d) {
        let f,
            _ = !1;

        h < 0 && (h ^= -1, _ = !0);
        let m = [],
            g = [];

        if (s.push(3 * h, 3 * h + 1, 3 * h + 2), e.color) {
          const t = Ib(d, n, h, e.color);
          a.push(t[0], t[1], t[2]);
        }

        if (e.skeleton) {
          if (void 0 !== e.weightTable[h] && e.weightTable[h].forEach(function (e) {
            g.push(e.weight), m.push(e.id);
          }), g.length > 4) {
            i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0);
            const e = [0, 0, 0, 0],
                  t = [0, 0, 0, 0];
            g.forEach(function (n, r) {
              let i = n,
                  s = m[r];
              t.forEach(function (t, n, r) {
                if (i > t) {
                  r[n] = i, i = t;
                  const o = e[n];
                  e[n] = s, s = o;
                }
              });
            }), m = e, g = t;
          }

          for (; g.length < 4;) g.push(0), m.push(0);

          for (let e = 0; e < 4; ++e) c.push(g[e]), u.push(m[e]);
        }

        if (e.normal) {
          const t = Ib(d, n, h, e.normal);
          o.push(t[0], t[1], t[2]);
        }

        e.material && "AllSame" !== e.material.mappingType && (f = Ib(d, n, h, e.material)[0]), e.uv && e.uv.forEach(function (e, t) {
          const r = Ib(d, n, h, e);
          void 0 === l[t] && (l[t] = []), l[t].push(r[0]), l[t].push(r[1]);
        }), r++, _ && (p.genFace(t, e, s, f, o, a, l, c, u, r), n++, r = 0, s = [], o = [], a = [], l = [], c = [], u = []);
      }), t;
    }

    genFace(e, t, n, r, i, s, o, a, l, c) {
      for (let u = 2; u < c; u++) e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1)]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1) + 1]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1) + 2]]), e.vertex.push(t.vertexPositions[n[3 * u]]), e.vertex.push(t.vertexPositions[n[3 * u + 1]]), e.vertex.push(t.vertexPositions[n[3 * u + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[4 * (u - 1)]), e.vertexWeights.push(a[4 * (u - 1) + 1]), e.vertexWeights.push(a[4 * (u - 1) + 2]), e.vertexWeights.push(a[4 * (u - 1) + 3]), e.vertexWeights.push(a[4 * u]), e.vertexWeights.push(a[4 * u + 1]), e.vertexWeights.push(a[4 * u + 2]), e.vertexWeights.push(a[4 * u + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[4 * (u - 1)]), e.weightsIndices.push(l[4 * (u - 1) + 1]), e.weightsIndices.push(l[4 * (u - 1) + 2]), e.weightsIndices.push(l[4 * (u - 1) + 3]), e.weightsIndices.push(l[4 * u]), e.weightsIndices.push(l[4 * u + 1]), e.weightsIndices.push(l[4 * u + 2]), e.weightsIndices.push(l[4 * u + 3])), t.color && (e.colors.push(s[0]), e.colors.push(s[1]), e.colors.push(s[2]), e.colors.push(s[3 * (u - 1)]), e.colors.push(s[3 * (u - 1) + 1]), e.colors.push(s[3 * (u - 1) + 2]), e.colors.push(s[3 * u]), e.colors.push(s[3 * u + 1]), e.colors.push(s[3 * u + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(r), e.materialIndex.push(r), e.materialIndex.push(r)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[3 * (u - 1)]), e.normal.push(i[3 * (u - 1) + 1]), e.normal.push(i[3 * (u - 1) + 2]), e.normal.push(i[3 * u]), e.normal.push(i[3 * u + 1]), e.normal.push(i[3 * u + 2])), t.uv && t.uv.forEach(function (t, n) {
        void 0 === e.uvs[n] && (e.uvs[n] = []), e.uvs[n].push(o[n][0]), e.uvs[n].push(o[n][1]), e.uvs[n].push(o[n][2 * (u - 1)]), e.uvs[n].push(o[n][2 * (u - 1) + 1]), e.uvs[n].push(o[n][2 * u]), e.uvs[n].push(o[n][2 * u + 1]);
      });
    }

    addMorphTargets(e, t, n, r) {
      if (0 === n.length) return;
      e.morphTargetsRelative = !0, e.morphAttributes.position = [];
      const i = this;
      n.forEach(function (n) {
        n.rawTargets.forEach(function (n) {
          const s = yb.Objects.Geometry[n.geoID];
          void 0 !== s && i.genMorphGeometry(e, t, s, r, n.name);
        });
      });
    }

    genMorphGeometry(e, t, n, r, s) {
      const o = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
            a = void 0 !== n.Vertices ? n.Vertices.a : [],
            l = void 0 !== n.Indexes ? n.Indexes.a : [],
            c = 3 * e.attributes.position.count,
            u = new Float32Array(c);

      for (let e = 0; e < l.length; e++) {
        const t = 3 * l[e];
        u[t] = a[3 * e], u[t + 1] = a[3 * e + 1], u[t + 2] = a[3 * e + 2];
      }

      const p = {
        vertexIndices: o,
        vertexPositions: u
      },
            h = this.genBuffers(p),
            d = new i.a$l(h.vertex, 3);
      d.name = s || n.attrName, d.applyMatrix4(r), e.morphAttributes.position.push(d);
    }

    parseNormals(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            r = e.Normals.a;
      let i = [];
      return "IndexToDirect" === n && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
        dataSize: 3,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseUVs(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            r = e.UV.a;
      let i = [];
      return "IndexToDirect" === n && (i = e.UVIndex.a), {
        dataSize: 2,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseVertexColors(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            r = e.Colors.a;
      let i = [];
      return "IndexToDirect" === n && (i = e.ColorIndex.a), {
        dataSize: 4,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseMaterialIndices(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType;
      if ("NoMappingInformation" === t) return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n
      };
      const r = e.Materials.a,
            i = [];

      for (let e = 0; e < r.length; ++e) i.push(e);

      return {
        dataSize: 1,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseNurbsGeometry(e) {
      if (void 0 === xb) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new i.u9r();
      const t = parseInt(e.Order);
      if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new i.u9r();
      const n = t - 1,
            r = e.KnotVector.a,
            s = [],
            o = e.Points.a;

      for (let e = 0, t = o.length; e < t; e += 4) s.push(new i.Ltg().fromArray(o, e));

      let a, l;
      if ("Closed" === e.Form) s.push(s[0]);else if ("Periodic" === e.Form) {
        a = n, l = r.length - 1 - a;

        for (let e = 0; e < n; ++e) s.push(s[e]);
      }
      const c = new xb(n, r, s, a, l).getPoints(12 * s.length);
      return new i.u9r().setFromPoints(c);
    }

  }

  class Ab {
    parse() {
      const e = [],
            t = this.parseClips();
      if (void 0 !== t) for (const n in t) {
        const r = t[n],
              i = this.addClip(r);
        e.push(i);
      }
      return e;
    }

    parseClips() {
      if (void 0 === yb.Objects.AnimationCurve) return;
      const e = this.parseAnimationCurveNodes();
      this.parseAnimationCurves(e);
      const t = this.parseAnimationLayers(e);
      return this.parseAnimStacks(t);
    }

    parseAnimationCurveNodes() {
      const e = yb.Objects.AnimationCurveNode,
            t = new Map();

      for (const n in e) {
        const r = e[n];

        if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
          const e = {
            id: r.id,
            attr: r.attrName,
            curves: {}
          };
          t.set(e.id, e);
        }
      }

      return t;
    }

    parseAnimationCurves(e) {
      const t = yb.Objects.AnimationCurve;

      for (const n in t) {
        const r = {
          id: t[n].id,
          times: t[n].KeyTime.a.map(Ob),
          values: t[n].KeyValueFloat.a
        },
              i = wb.get(r.id);

        if (void 0 !== i) {
          const t = i.parents[0].ID,
                n = i.parents[0].relationship;
          n.match(/X/) ? e.get(t).curves.x = r : n.match(/Y/) ? e.get(t).curves.y = r : n.match(/Z/) ? e.get(t).curves.z = r : n.match(/d|DeformPercent/) && e.has(t) && (e.get(t).curves.morph = r);
        }
      }
    }

    parseAnimationLayers(e) {
      const t = yb.Objects.AnimationLayer,
            n = new Map();

      for (const r in t) {
        const t = [],
              s = wb.get(parseInt(r));
        void 0 !== s && (s.children.forEach(function (n, r) {
          if (e.has(n.ID)) {
            const s = e.get(n.ID);

            if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
              if (void 0 === t[r]) {
                const e = wb.get(n.ID).parents.filter(function (e) {
                  return void 0 !== e.relationship;
                })[0].ID;

                if (void 0 !== e) {
                  const s = yb.Objects.Model[e.toString()];
                  if (void 0 === s) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n);
                  const o = {
                    modelName: s.attrName ? i.iUV.sanitizeNodeName(s.attrName) : "",
                    ID: s.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  Sb.traverse(function (e) {
                    e.ID === s.id && (o.transform = e.matrix, e.userData.transformData && (o.eulerOrder = e.userData.transformData.eulerOrder));
                  }), o.transform || (o.transform = new i.yGw()), "PreRotation" in s && (o.preRotation = s.PreRotation.value), "PostRotation" in s && (o.postRotation = s.PostRotation.value), t[r] = o;
                }
              }

              t[r] && (t[r][s.attr] = s);
            } else if (void 0 !== s.curves.morph) {
              if (void 0 === t[r]) {
                const e = wb.get(n.ID).parents.filter(function (e) {
                  return void 0 !== e.relationship;
                })[0].ID,
                      s = wb.get(e).parents[0].ID,
                      o = wb.get(s).parents[0].ID,
                      a = wb.get(o).parents[0].ID,
                      l = yb.Objects.Model[a],
                      c = {
                  modelName: l.attrName ? i.iUV.sanitizeNodeName(l.attrName) : "",
                  morphName: yb.Objects.Deformer[e].attrName
                };
                t[r] = c;
              }

              t[r][s.attr] = s;
            }
          }
        }), n.set(parseInt(r), t));
      }

      return n;
    }

    parseAnimStacks(e) {
      const t = yb.Objects.AnimationStack,
            n = {};

      for (const r in t) {
        const i = wb.get(parseInt(r)).children;
        i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
        const s = e.get(i[0].ID);
        n[r] = {
          name: t[r].attrName,
          layer: s
        };
      }

      return n;
    }

    addClip(e) {
      let t = [];
      const n = this;
      return e.layer.forEach(function (e) {
        t = t.concat(n.generateTracks(e));
      }), new i.m7l(e.name, -1, t);
    }

    generateTracks(e) {
      const t = [];
      let n = new i.Pa4(),
          r = new i._fP(),
          s = new i.Pa4();

      if (e.transform && e.transform.decompose(n, r, s), n = n.toArray(), r = new i.USm().setFromQuaternion(r, e.eulerOrder).toArray(), s = s.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
        const r = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
        void 0 !== r && t.push(r);
      }

      if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
        const n = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder);
        void 0 !== n && t.push(n);
      }

      if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
        const n = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
        void 0 !== n && t.push(n);
      }

      if (void 0 !== e.DeformPercent) {
        const n = this.generateMorphTrack(e);
        void 0 !== n && t.push(n);
      }

      return t;
    }

    generateVectorTrack(e, t, n, r) {
      const s = this.getTimesForAllAxes(t),
            o = this.getKeyframeTrackValues(s, t, n);
      return new i.yC1(e + "." + r, s, o);
    }

    generateRotationTrack(e, t, n, r, s, o) {
      void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(i.M8C.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(i.M8C.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(i.M8C.degToRad));
      const a = this.getTimesForAllAxes(t),
            l = this.getKeyframeTrackValues(a, t, n);
      void 0 !== r && ((r = r.map(i.M8C.degToRad)).push(o), r = new i.USm().fromArray(r), r = new i._fP().setFromEuler(r)), void 0 !== s && ((s = s.map(i.M8C.degToRad)).push(o), s = new i.USm().fromArray(s), s = new i._fP().setFromEuler(s).invert());
      const c = new i._fP(),
            u = new i.USm(),
            p = [];

      for (let e = 0; e < l.length; e += 3) u.set(l[e], l[e + 1], l[e + 2], o), c.setFromEuler(u), void 0 !== r && c.premultiply(r), void 0 !== s && c.multiply(s), c.toArray(p, e / 3 * 4);

      return new i.iLg(e + ".quaternion", a, p);
    }

    generateMorphTrack(e) {
      const t = e.DeformPercent.curves.morph,
            n = t.values.map(function (e) {
        return e / 100;
      }),
            r = Sb.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
      return new i.dUE(e.modelName + ".morphTargetInfluences[" + r + "]", t.times, n);
    }

    getTimesForAllAxes(e) {
      let t = [];

      if (void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), t = t.sort(function (e, t) {
        return e - t;
      }), t.length > 1) {
        let e = 1,
            n = t[0];

        for (let r = 1; r < t.length; r++) {
          const i = t[r];
          i !== n && (t[e] = i, n = i, e++);
        }

        t = t.slice(0, e);
      }

      return t;
    }

    getKeyframeTrackValues(e, t, n) {
      const r = n,
            i = [];
      let s = -1,
          o = -1,
          a = -1;
      return e.forEach(function (e) {
        if (t.x && (s = t.x.times.indexOf(e)), t.y && (o = t.y.times.indexOf(e)), t.z && (a = t.z.times.indexOf(e)), -1 !== s) {
          const e = t.x.values[s];
          i.push(e), r[0] = e;
        } else i.push(r[0]);

        if (-1 !== o) {
          const e = t.y.values[o];
          i.push(e), r[1] = e;
        } else i.push(r[1]);

        if (-1 !== a) {
          const e = t.z.values[a];
          i.push(e), r[2] = e;
        } else i.push(r[2]);
      }), i;
    }

    interpolateRotations(e) {
      for (let t = 1; t < e.values.length; t++) {
        const n = e.values[t - 1],
              r = e.values[t] - n,
              i = Math.abs(r);

        if (i >= 180) {
          const s = i / 180,
                o = r / s;
          let a = n + o;
          const l = e.times[t - 1],
                c = (e.times[t] - l) / s;
          let u = l + c;
          const p = [],
                h = [];

          for (; u < e.times[t];) p.push(u), u += c, h.push(a), a += o;

          e.times = Vb(e.times, t, p), e.values = Vb(e.values, t, h);
        }
      }
    }

  }

  class Cb {
    getPrevNode() {
      return this.nodeStack[this.currentIndent - 2];
    }

    getCurrentNode() {
      return this.nodeStack[this.currentIndent - 1];
    }

    getCurrentProp() {
      return this.currentProp;
    }

    pushStack(e) {
      this.nodeStack.push(e), this.currentIndent += 1;
    }

    popStack() {
      this.nodeStack.pop(), this.currentIndent -= 1;
    }

    setCurrentProp(e, t) {
      this.currentProp = e, this.currentPropName = t;
    }

    parse(e) {
      this.currentIndent = 0, this.allNodes = new Pb(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
      const t = this,
            n = e.split(/[\r\n]+/);
      return n.forEach(function (e, r) {
        const i = e.match(/^[\s\t]*;/),
              s = e.match(/^[\s\t]*$/);
        if (i || s) return;
        const o = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
              a = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
              l = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
        o ? t.parseNodeBegin(e, o) : a ? t.parseNodeProperty(e, a, n[++r]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e);
      }), this.allNodes;
    }

    parseNodeBegin(e, t) {
      const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
            r = t[2].split(",").map(function (e) {
        return e.trim().replace(/^"/, "").replace(/"$/, "");
      }),
            i = {
        name: n
      },
            s = this.parseNodeAttr(r),
            o = this.getCurrentNode();
      0 === this.currentIndent ? this.allNodes.add(n, i) : n in o ? ("PoseNode" === n ? o.PoseNode.push(i) : void 0 !== o[n].id && (o[n] = {}, o[n][o[n].id] = o[n]), "" !== s.id && (o[n][s.id] = i)) : "number" == typeof s.id ? (o[n] = {}, o[n][s.id] = i) : "Properties70" !== n && (o[n] = "PoseNode" === n ? [i] : i), "number" == typeof s.id && (i.id = s.id), "" !== s.name && (i.attrName = s.name), "" !== s.type && (i.attrType = s.type), this.pushStack(i);
    }

    parseNodeAttr(e) {
      let t = e[0];
      "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
      let n = "",
          r = "";
      return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), r = e[2]), {
        id: t,
        name: n,
        type: r
      };
    }

    parseNodeProperty(e, t, n) {
      let r = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
          i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
      "Content" === r && "," === i && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
      const s = this.getCurrentNode();

      if ("Properties70" !== s.name) {
        if ("C" === r) {
          const e = i.split(",").slice(1),
                t = parseInt(e[0]),
                n = parseInt(e[1]);
          let o = i.split(",").slice(3);
          o = o.map(function (e) {
            return e.trim().replace(/^"/, "");
          }), r = "connections", i = [t, n], function (e, t) {
            for (let n = 0, r = e.length, i = t.length; n < i; n++, r++) e[r] = t[n];
          }(i, o), void 0 === s[r] && (s[r] = []);
        }

        "Node" === r && (s.id = i), r in s && Array.isArray(s[r]) ? s[r].push(i) : "a" !== r ? s[r] = i : s.a = i, this.setCurrentProp(s, r), "a" === r && "," !== i.slice(-1) && (s.a = jb(i));
      } else this.parseNodeSpecialProperty(e, r, i);
    }

    parseNodePropertyContinued(e) {
      const t = this.getCurrentNode();
      t.a += e, "," !== e.slice(-1) && (t.a = jb(t.a));
    }

    parseNodeSpecialProperty(e, t, n) {
      const r = n.split('",').map(function (e) {
        return e.trim().replace(/^\"/, "").replace(/\s/, "_");
      }),
            i = r[0],
            s = r[1],
            o = r[2],
            a = r[3];
      let l = r[4];

      switch (s) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
          l = parseFloat(l);
          break;

        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
          l = jb(l);
      }

      this.getPrevNode()[i] = {
        type: s,
        type2: o,
        flag: a,
        value: l
      }, this.setCurrentProp(this.getPrevNode(), i);
    }

  }

  class Rb {
    parse(e) {
      const t = new kb(e);
      t.skip(23);
      const n = t.getUint32();
      if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
      const r = new Pb();

      for (; !this.endOfContent(t);) {
        const e = this.parseNode(t, n);
        null !== e && r.add(e.name, e);
      }

      return r;
    }

    endOfContent(e) {
      return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
    }

    parseNode(e, t) {
      const n = {},
            r = t >= 7500 ? e.getUint64() : e.getUint32(),
            i = t >= 7500 ? e.getUint64() : e.getUint32();
      t >= 7500 ? e.getUint64() : e.getUint32();
      const s = e.getUint8(),
            o = e.getString(s);
      if (0 === r) return null;
      const a = [];

      for (let t = 0; t < i; t++) a.push(this.parseProperty(e));

      const l = a.length > 0 ? a[0] : "",
            c = a.length > 1 ? a[1] : "",
            u = a.length > 2 ? a[2] : "";

      for (n.singleProperty = 1 === i && e.getOffset() === r; r > e.getOffset();) {
        const r = this.parseNode(e, t);
        null !== r && this.parseSubNode(o, n, r);
      }

      return n.propertyList = a, "number" == typeof l && (n.id = l), "" !== c && (n.attrName = c), "" !== u && (n.attrType = u), "" !== o && (n.name = o), n;
    }

    parseSubNode(e, t, n) {
      if (!0 === n.singleProperty) {
        const e = n.propertyList[0];
        Array.isArray(e) ? (t[n.name] = n, n.a = e) : t[n.name] = e;
      } else if ("Connections" === e && "C" === n.name) {
        const e = [];
        n.propertyList.forEach(function (t, n) {
          0 !== n && e.push(t);
        }), void 0 === t.connections && (t.connections = []), t.connections.push(e);
      } else if ("Properties70" === n.name) Object.keys(n).forEach(function (e) {
        t[e] = n[e];
      });else if ("Properties70" === e && "P" === n.name) {
        let e = n.propertyList[0],
            r = n.propertyList[1];
        const i = n.propertyList[2],
              s = n.propertyList[3];
        let o;
        0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")), 0 === r.indexOf("Lcl ") && (r = r.replace("Lcl ", "Lcl_")), o = "Color" === r || "ColorRGB" === r || "Vector" === r || "Vector3D" === r || 0 === r.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], t[e] = {
          type: r,
          type2: i,
          flag: s,
          value: o
        };
      } else void 0 === t[n.name] ? "number" == typeof n.id ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : "PoseNode" === n.name ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n);
    }

    parseProperty(e) {
      const t = e.getString(1);
      let r;

      switch (t) {
        case "C":
          return e.getBoolean();

        case "D":
          return e.getFloat64();

        case "F":
          return e.getFloat32();

        case "I":
          return e.getInt32();

        case "L":
          return e.getInt64();

        case "R":
          return r = e.getUint32(), e.getArrayBuffer(r);

        case "S":
          return r = e.getUint32(), e.getString(r);

        case "Y":
          return e.getInt16();

        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
          const i = e.getUint32(),
                s = e.getUint32(),
                o = e.getUint32();
          if (0 === s) switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(i);

            case "d":
              return e.getFloat64Array(i);

            case "f":
              return e.getFloat32Array(i);

            case "i":
              return e.getInt32Array(i);

            case "l":
              return e.getInt64Array(i);
          }
          void 0 === n && console.error("THREE.FBXLoader: External library fflate.min.js required.");
          const a = Nv(new Uint8Array(e.getArrayBuffer(o))),
                l = new kb(a.buffer);

          switch (t) {
            case "b":
            case "c":
              return l.getBooleanArray(i);

            case "d":
              return l.getFloat64Array(i);

            case "f":
              return l.getFloat32Array(i);

            case "i":
              return l.getInt32Array(i);

            case "l":
              return l.getInt64Array(i);
          }

          break;

        default:
          throw new Error("THREE.FBXLoader: Unknown property type " + t);
      }
    }

  }

  class kb {
    constructor(e, t) {
      this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t;
    }

    getOffset() {
      return this.offset;
    }

    size() {
      return this.dv.buffer.byteLength;
    }

    skip(e) {
      this.offset += e;
    }

    getBoolean() {
      return 1 == (1 & this.getUint8());
    }

    getBooleanArray(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getBoolean());

      return t;
    }

    getUint8() {
      const e = this.dv.getUint8(this.offset);
      return this.offset += 1, e;
    }

    getInt16() {
      const e = this.dv.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, e;
    }

    getInt32() {
      const e = this.dv.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }

    getInt32Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getInt32());

      return t;
    }

    getUint32() {
      const e = this.dv.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }

    getInt64() {
      let e, t;
      return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, e = 4294967295 & ~e, 4294967295 === e && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e;
    }

    getInt64Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getInt64());

      return t;
    }

    getUint64() {
      let e, t;
      return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e;
    }

    getFloat32() {
      const e = this.dv.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }

    getFloat32Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getFloat32());

      return t;
    }

    getFloat64() {
      const e = this.dv.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, e;
    }

    getFloat64Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getFloat64());

      return t;
    }

    getArrayBuffer(e) {
      const t = this.dv.buffer.slice(this.offset, this.offset + e);
      return this.offset += e, t;
    }

    getString(e) {
      let t = [];

      for (let n = 0; n < e; n++) t[n] = this.getUint8();

      const n = t.indexOf(0);
      return n >= 0 && (t = t.slice(0, n)), i.Zp0.decodeText(new Uint8Array(t));
    }

  }

  class Pb {
    add(e, t) {
      this[e] = t;
    }

  }

  function Db(e) {
    const t = e.match(/FBXVersion: (\d+)/);
    if (t) return parseInt(t[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
  }

  function Ob(e) {
    return e / 46186158e3;
  }

  const Lb = [];

  function Ib(e, t, n, r) {
    let i;

    switch (r.mappingType) {
      case "ByPolygonVertex":
        i = e;
        break;

      case "ByPolygon":
        i = t;
        break;

      case "ByVertice":
        i = n;
        break;

      case "AllSame":
        i = r.indices[0];
        break;

      default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType);
    }

    "IndexToDirect" === r.referenceType && (i = r.indices[i]);
    const s = i * r.dataSize,
          o = s + r.dataSize;
    return function (e, t, n, r) {
      for (let i = n, s = 0; i < r; i++, s++) e[s] = t[i];

      return e;
    }(Lb, r.buffer, s, o);
  }

  const Fb = new i.USm(),
        Nb = new i.Pa4();

  function Ub(e) {
    const t = new i.yGw(),
          n = new i.yGw(),
          r = new i.yGw(),
          s = new i.yGw(),
          o = new i.yGw(),
          a = new i.yGw(),
          l = new i.yGw(),
          c = new i.yGw(),
          u = new i.yGw(),
          p = new i.yGw(),
          h = new i.yGw(),
          d = new i.yGw(),
          f = e.inheritType ? e.inheritType : 0;

    if (e.translation && t.setPosition(Nb.fromArray(e.translation)), e.preRotation) {
      const t = e.preRotation.map(i.M8C.degToRad);
      t.push(e.eulerOrder), n.makeRotationFromEuler(Fb.fromArray(t));
    }

    if (e.rotation) {
      const t = e.rotation.map(i.M8C.degToRad);
      t.push(e.eulerOrder), r.makeRotationFromEuler(Fb.fromArray(t));
    }

    if (e.postRotation) {
      const t = e.postRotation.map(i.M8C.degToRad);
      t.push(e.eulerOrder), s.makeRotationFromEuler(Fb.fromArray(t)), s.invert();
    }

    e.scale && o.scale(Nb.fromArray(e.scale)), e.scalingOffset && l.setPosition(Nb.fromArray(e.scalingOffset)), e.scalingPivot && a.setPosition(Nb.fromArray(e.scalingPivot)), e.rotationOffset && c.setPosition(Nb.fromArray(e.rotationOffset)), e.rotationPivot && u.setPosition(Nb.fromArray(e.rotationPivot)), e.parentMatrixWorld && (h.copy(e.parentMatrix), p.copy(e.parentMatrixWorld));

    const _ = n.clone().multiply(r).multiply(s),
          m = new i.yGw();

    m.extractRotation(p);
    const g = new i.yGw();
    g.copyPosition(p);
    const v = g.clone().invert().multiply(p),
          b = m.clone().invert().multiply(v),
          x = o,
          y = new i.yGw();
    if (0 === f) y.copy(m).multiply(_).multiply(b).multiply(x);else if (1 === f) y.copy(m).multiply(b).multiply(_).multiply(x);else {
      const e = new i.yGw().scale(new i.Pa4().setFromMatrixScale(h)).clone().invert(),
            t = b.clone().multiply(e);
      y.copy(m).multiply(_).multiply(t).multiply(x);
    }
    const w = u.clone().invert(),
          S = a.clone().invert();
    let M = t.clone().multiply(c).multiply(u).multiply(n).multiply(r).multiply(s).multiply(w).multiply(l).multiply(a).multiply(o).multiply(S);
    const T = new i.yGw().copyPosition(M),
          E = p.clone().multiply(T);
    return d.copyPosition(E), M = d.clone().multiply(y), M.premultiply(p.invert()), M;
  }

  function Bb(e) {
    const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e];
  }

  function jb(e) {
    return e.split(",").map(function (e) {
      return parseFloat(e);
    });
  }

  function zb(e, t, n) {
    return void 0 === t && (t = 0), void 0 === n && (n = e.byteLength), i.Zp0.decodeText(new Uint8Array(e, t, n));
  }

  function Vb(e, t, n) {
    return e.slice(0, t).concat(n).concat(e.slice(t));
  }

  class Gb extends r {
    constructor() {
      super(...arguments), this.dependencies = [js], this._importer = new Zt(Mb, ["fbx"], !0);
    }

    async onAdded(e) {
      Fs.Importers.push(this._importer);
    }

    async onDispose(e) {}

    async onRemove(e) {
      Fs.Importers.splice(Fs.Importers.indexOf(this._importer), 1);
    }

  }

  Gb.PluginType = "FBXLoadPlugin";
  const Hb = new WeakMap();

  class Wb extends i.aNw {
    constructor(e) {
      super(e), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = [];
    }

    setLibraryPath(e) {
      return this.libraryPath = e, this;
    }

    setWorkerLimit(e) {
      return this.workerLimit = e, this;
    }

    load(e, t, n, r) {
      const s = new i.hH6(this.manager);
      s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), this.url = e, s.load(e, n => {
        if (Hb.has(n)) return Hb.get(n).promise.then(t).catch(r);
        this.decodeObjects(n, e).then(e => {
          e.userData.warnings = this.warnings, t(e);
        }).catch(e => r(e));
      }, n, r);
    }

    debug() {
      console.log("Task load: ", this.workerPool.map(e => e._taskLoad));
    }

    decodeObjects(e, t) {
      let n, r;

      const i = e.byteLength,
            s = this._getWorker(i).then(t => (n = t, r = this.workerNextTaskID++, new Promise((t, i) => {
        n._callbacks[r] = {
          resolve: t,
          reject: i
        }, n.postMessage({
          type: "decode",
          id: r,
          buffer: e
        }, [e]);
      }))).then(e => this._createGeometry(e.data)).catch(e => {
        throw e;
      });

      return s.catch(() => !0).then(() => {
        n && r && this._releaseTask(n, r);
      }), Hb.set(e, {
        url: t,
        promise: s
      }), s;
    }

    parse(e, t, n) {
      this.decodeObjects(e, "").then(e => {
        e.userData.warnings = this.warnings, t(e);
      }).catch(e => n(e));
    }

    _compareMaterials(e) {
      const t = {};
      t.name = e.name, t.color = {}, t.color.r = e.color.r, t.color.g = e.color.g, t.color.b = e.color.b, t.type = e.type;

      for (let e = 0; e < this.materials.length; e++) {
        const n = this.materials[e],
              r = {};
        if (r.name = n.name, r.color = {}, r.color.r = n.color.r, r.color.g = n.color.g, r.color.b = n.color.b, r.type = n.type, JSON.stringify(t) === JSON.stringify(r)) return n;
      }

      return this.materials.push(e), e;
    }

    _createMaterial(e) {
      if (void 0 === e) return new i.Wid({
        color: new i.Ilk(1, 1, 1),
        metalness: .8,
        name: "default",
        side: 2
      });
      const t = e.diffuseColor,
            n = new i.Ilk(t.r / 255, t.g / 255, t.b / 255);
      0 === t.r && 0 === t.g && 0 === t.b && (n.r = 1, n.g = 1, n.b = 1);
      const r = new i.Wid({
        color: n,
        name: e.name,
        side: 2,
        transparent: e.transparency > 0,
        opacity: 1 - e.transparency
      }),
            s = new i.dpR();

      for (let t = 0; t < e.textures.length; t++) {
        const n = e.textures[t];

        if (null !== n.image) {
          const e = s.load(n.image);

          switch (n.type) {
            case "Diffuse":
              r.map = e;
              break;

            case "Bump":
              r.bumpMap = e;
              break;

            case "Transparency":
              r.alphaMap = e, r.transparent = !0;
              break;

            case "Emap":
              r.envMap = e;
          }

          e.wrapS = 0 === n.wrapU ? i.rpg : i.uWy, e.wrapT = 0 === n.wrapV ? i.rpg : i.uWy, e.repeat.set(n.repeat[0], n.repeat[1]);
        }
      }

      return r;
    }

    _createGeometry(e) {
      const t = new i.Tme(),
            n = [],
            r = [],
            s = [];
      t.userData.layers = e.layers, t.userData.groups = e.groups, t.userData.settings = e.settings, t.userData.objectType = "File3dm", t.userData.materials = null, t.name = this.url;
      let o = e.objects;
      const a = e.materials;

      for (let i = 0; i < o.length; i++) {
        const l = o[i],
              c = l.attributes;

        switch (l.objectType) {
          case "InstanceDefinition":
            r.push(l);
            break;

          case "InstanceReference":
            s.push(l);
            break;

          default:
            let i;

            if (c.materialIndex >= 0) {
              const e = a[c.materialIndex];

              let t = this._createMaterial(e);

              t = this._compareMaterials(t), i = this._createObject(l, t);
            } else {
              const e = this._createMaterial();

              i = this._createObject(l, e);
            }

            if (void 0 === i) continue;
            const o = e.layers[c.layerIndex];
            i.visible = !o || e.layers[c.layerIndex].visible, c.isInstanceDefinitionObject ? n.push(i) : t.add(i);
        }
      }

      for (let e = 0; e < r.length; e++) {
        const a = r[e];
        o = [];

        for (let e = 0; e < a.attributes.objectIds.length; e++) {
          const t = a.attributes.objectIds[e];

          for (let e = 0; e < n.length; e++) t === n[e].userData.attributes.id && o.push(n[e]);
        }

        for (let e = 0; e < s.length; e++) {
          const n = s[e];

          if (n.geometry.parentIdefId === a.attributes.id) {
            const e = new i.Tme(),
                  r = n.geometry.xform.array,
                  s = new i.yGw();
            s.set(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]), e.applyMatrix4(s);

            for (let t = 0; t < o.length; t++) e.add(o[t].clone(!0));

            t.add(e);
          }
        }
      }

      return t.userData.materials = this.materials, t;
    }

    _createObject(e, t) {
      const n = new i.s4_(),
            r = e.attributes;
      let s, o, a, l;

      switch (e.objectType) {
        case "Point":
        case "PointSet":
          s = n.parse(e.geometry), s.attributes.hasOwnProperty("color") ? o = new i.UY4({
            vertexColors: !0,
            sizeAttenuation: !1,
            size: 2
          }) : (a = r.drawColor, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new i.UY4({
            color: l,
            sizeAttenuation: !1,
            size: 2
          })), o = this._compareMaterials(o);
          const c = new i.woe(s, o);
          return c.userData.attributes = r, c.userData.objectType = e.objectType, r.name && (c.name = r.name), c;

        case "Mesh":
        case "Extrusion":
        case "SubD":
        case "Brep":
          if (null === e.geometry) return;
          s = n.parse(e.geometry), s.attributes.hasOwnProperty("color") && (t.vertexColors = !0), null === t && (t = this._createMaterial(), t = this._compareMaterials(t));
          const u = new i.Kj0(s, t);
          return u.castShadow = r.castsShadows, u.receiveShadow = r.receivesShadows, u.userData.attributes = r, u.userData.objectType = e.objectType, r.name && (u.name = r.name), u;

        case "Curve":
          s = n.parse(e.geometry), a = r.drawColor, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new i.nls({
            color: l
          }), o = this._compareMaterials(o);
          const p = new i.x12(s, o);
          return p.userData.attributes = r, p.userData.objectType = e.objectType, r.name && (p.name = r.name), p;

        case "TextDot":
          s = e.geometry;
          const h = document.createElement("canvas").getContext("2d"),
                d = `${s.fontHeight}px ${s.fontFace}`;
          h.font = d;

          const f = h.measureText(s.text).width + 10,
                _ = s.fontHeight + 10,
                m = window.devicePixelRatio;

          h.canvas.width = f * m, h.canvas.height = _ * m, h.canvas.style.width = f + "px", h.canvas.style.height = _ + "px", h.setTransform(m, 0, 0, m, 0, 0), h.font = d, h.textBaseline = "middle", h.textAlign = "center", l = r.drawColor, h.fillStyle = `rgba(${l.r},${l.g},${l.b},${l.a})`, h.fillRect(0, 0, f, _), h.fillStyle = "white", h.fillText(s.text, f / 2, _ / 2);
          const g = new i.ROQ(h.canvas);
          g.minFilter = i.wem, g.wrapS = i.uWy, g.wrapT = i.uWy, o = new i.xeV({
            map: g,
            depthTest: !1
          });
          const v = new i.jyi(o);
          return v.position.set(s.point[0], s.point[1], s.point[2]), v.scale.set(f / 10, _ / 10, 1), v.userData.attributes = r, v.userData.objectType = e.objectType, r.name && (v.name = r.name), v;

        case "Light":
          let b;

          switch (s = e.geometry, s.lightStyle.name) {
            case "LightStyle_WorldPoint":
              b = new i.cek(), b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.shadow.normalBias = .1;
              break;

            case "LightStyle_WorldSpot":
              b = new i.PMe(), b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.target.position.set(s.direction[0], s.direction[1], s.direction[2]), b.angle = s.spotAngleRadians, b.shadow.normalBias = .1;
              break;

            case "LightStyle_WorldRectangular":
              b = new i.T_f();
              const e = Math.abs(s.width[2]),
                    t = Math.abs(s.length[0]);
              b.position.set(s.location[0] - t / 2, s.location[1], s.location[2] - e / 2), b.height = t, b.width = e, b.lookAt(new i.Pa4(s.direction[0], s.direction[1], s.direction[2]));
              break;

            case "LightStyle_WorldDirectional":
              b = new i.Ox3(), b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.target.position.set(s.direction[0], s.direction[1], s.direction[2]), b.shadow.normalBias = .1;
          }

          return b && (b.intensity = s.intensity, a = s.diffuse, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), b.color = l, b.userData.attributes = r, b.userData.objectType = e.objectType), b;
      }
    }

    _initLibrary() {
      if (!this.libraryPending) {
        const e = new i.hH6(this.manager);
        e.setPath(this.libraryPath);
        const t = new Promise((t, n) => {
          e.load("rhino3dm.js", t, void 0, n);
        }),
              n = new i.hH6(this.manager);
        n.setPath(this.libraryPath), n.setResponseType("arraybuffer");
        const r = new Promise((e, t) => {
          n.load("rhino3dm.wasm", e, void 0, t);
        });
        this.libraryPending = Promise.all([t, r]).then(([e, t]) => {
          this.libraryConfig.wasmBinary = t;
          const n = Kb.toString(),
                r = ["/* rhino3dm.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([r]));
        });
      }

      return this.libraryPending;
    }

    _getWorker(e) {
      return this._initLibrary().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const e = new Worker(this.workerSourceURL);
          e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
            type: "init",
            libraryConfig: this.libraryConfig
          }), e.onmessage = t => {
            const n = t.data;

            switch (n.type) {
              case "warning":
                this.warnings.push(n.data), console.warn(n.data);
                break;

              case "decode":
                e._callbacks[n.id].resolve(n);

                break;

              case "error":
                e._callbacks[n.id].reject(n);

                break;

              default:
                console.error('THREE.Rhino3dmLoader: Unexpected message, "' + n.type + '"');
            }
          }, this.workerPool.push(e);
        } else this.workerPool.sort(function (e, t) {
          return e._taskLoad > t._taskLoad ? -1 : 1;
        });

        const t = this.workerPool[this.workerPool.length - 1];
        return t._taskLoad += e, t;
      });
    }

    _releaseTask(e, t) {
      e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
    }

    dispose() {
      for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();

      return this.workerPool.length = 0, this;
    }

  }

  function Kb() {
    let e, t, n, r;

    function i(e, t) {
      const i = e.geometry(),
            a = e.attributes();
      let l,
          c,
          u,
          p,
          h,
          d = i.objectType;

      switch (d) {
        case n.ObjectType.Curve:
          const e = o(i, 100);
          u = {}, c = {}, p = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [];

          for (let t = 0; t < e.length; t++) u.array.push(e[t][0]), u.array.push(e[t][1]), u.array.push(e[t][2]);

          c.position = u, p.attributes = c, l = {
            data: p
          };
          break;

        case n.ObjectType.Point:
          const f = i.location;
          u = {};
          const _ = {};
          c = {}, p = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [f[0], f[1], f[2]];
          const m = a.drawColor(t);
          _.itemSize = 3, _.type = "Float32Array", _.array = [m.r / 255, m.g / 255, m.b / 255], c.position = u, c.color = _, p.attributes = c, l = {
            data: p
          };
          break;

        case n.ObjectType.PointSet:
        case n.ObjectType.Mesh:
          l = i.toThreejsJSON();
          break;

        case n.ObjectType.Brep:
          const g = i.faces();
          h = new n.Mesh();

          for (let e = 0; e < g.count; e++) {
            const t = g.get(e),
                  r = t.getMesh(n.MeshType.Any);
            r && (h.append(r), r.delete()), t.delete();
          }

          h.faces().count > 0 && (h.compact(), l = h.toThreejsJSON(), g.delete()), h.delete();
          break;

        case n.ObjectType.Extrusion:
          h = i.getMesh(n.MeshType.Any), h && (l = h.toThreejsJSON(), h.delete());
          break;

        case n.ObjectType.TextDot:
          l = s(i);
          break;

        case n.ObjectType.Light:
          l = s(i), "LightStyle_WorldLinear" === l.lightStyle.name && self.postMessage({
            type: "warning",
            id: r,
            data: {
              message: `THREE.3DMLoader: No conversion exists for ${d.constructor.name} ${l.lightStyle.name}`,
              type: "no conversion",
              guid: a.id
            }
          });
          break;

        case n.ObjectType.InstanceReference:
          l = s(i), l.xform = s(i.xform), l.xform.array = i.xform.toFloatArray(!0);
          break;

        case n.ObjectType.SubD:
          i.subdivide(3), h = n.Mesh.createFromSubDControlNet(i), h && (l = h.toThreejsJSON(), h.delete());
          break;

        default:
          self.postMessage({
            type: "warning",
            id: r,
            data: {
              message: `THREE.3DMLoader: Conversion not implemented for ${d.constructor.name}`,
              type: "not implemented",
              guid: a.id
            }
          });
      }

      if (l) return c = s(a), c.geometry = s(i), a.groupCount > 0 && (c.groupIds = a.getGroupList()), a.userStringCount > 0 && (c.userStrings = a.getUserStrings()), i.userStringCount > 0 && (c.geometry.userStrings = i.getUserStrings()), c.drawColor = a.drawColor(t), d = d.constructor.name, d = d.substring(11, d.length), {
        geometry: l,
        attributes: c,
        objectType: d
      };
      self.postMessage({
        type: "warning",
        id: r,
        data: {
          message: `THREE.3DMLoader: ${d.constructor.name} has no associated mesh geometry.`,
          type: "missing mesh",
          guid: a.id
        }
      });
    }

    function s(e) {
      const t = {};

      for (const n in e) {
        const r = e[n];
        "function" != typeof r && ("object" == typeof r && null !== r && r.hasOwnProperty("constructor") ? t[n] = {
          name: r.constructor.name,
          value: r.value
        } : t[n] = r);
      }

      return t;
    }

    function o(e, t) {
      let r = t,
          i = [];
      const s = [];
      if (e instanceof n.LineCurve) return [e.pointAtStart, e.pointAtEnd];

      if (e instanceof n.PolylineCurve) {
        r = e.pointCount;

        for (let t = 0; t < r; t++) i.push(e.point(t));

        return i;
      }

      if (e instanceof n.PolyCurve) {
        const t = e.segmentCount;

        for (let n = 0; n < t; n++) {
          const t = e.segmentCurve(n),
                s = o(t, r);
          i = i.concat(s), t.delete();
        }

        return i;
      }

      if (e instanceof n.ArcCurve && (r = Math.floor(e.angleDegrees / 5), r = r < 2 ? 2 : r), e instanceof n.NurbsCurve && 1 === e.degree) {
        const t = e.tryGetPolyline();

        for (let e = 0; e < t.count; e++) i.push(t.get(e));

        return t.delete(), i;
      }

      const a = e.domain,
            l = r - 1;

      for (let t = 0; t < r; t++) {
        const n = a[0] + t / l * (a[1] - a[0]);

        if (n === a[0] || n === a[1]) {
          s.push(n);
          continue;
        }

        const r = e.tangentAt(n),
              i = e.tangentAt(s.slice(-1)[0]),
              o = r[0] * r[0] + r[1] * r[1] + r[2] * r[2],
              c = i[0] * i[0] + i[1] * i[1] + i[2] * i[2],
              u = Math.sqrt(o * c);
        let p;
        if (0 === u) p = Math.PI / 2;else {
          const e = (r.x * i.x + r.y * i.y + r.z * i.z) / u;
          p = Math.acos(Math.max(-1, Math.min(1, e)));
        }
        p < .1 || s.push(n);
      }

      return i = s.map(t => e.pointAt(t)), i;
    }

    onmessage = function (o) {
      const a = o.data;

      switch (a.type) {
        case "init":
          t = a.libraryConfig;
          const o = t.wasmBinary;
          let l;
          e = new Promise(function (e) {
            l = {
              wasmBinary: o,
              onRuntimeInitialized: e
            }, rhino3dm(l);
          }).then(() => {
            n = l;
          });
          break;

        case "decode":
          r = a.id;
          const c = a.buffer;
          e.then(() => {
            try {
              const e = function (e, t) {
                const n = new Uint8Array(t),
                      o = e.File3dm.fromByteArray(n),
                      a = [],
                      l = [],
                      c = [],
                      u = [],
                      p = [],
                      h = [],
                      d = [],
                      f = o.objects(),
                      _ = f.count;

                for (let e = 0; e < _; e++) {
                  const t = f.get(e),
                        n = i(t, o);
                  t.delete(), n && a.push(n);
                }

                for (let e = 0; e < o.instanceDefinitions().count(); e++) {
                  const t = o.instanceDefinitions().get(e),
                        n = s(t);
                  n.objectIds = t.getObjectIds(), a.push({
                    geometry: null,
                    attributes: n,
                    objectType: "InstanceDefinition"
                  });
                }

                const m = [e.TextureType.Diffuse, e.TextureType.Bump, e.TextureType.Transparency, e.TextureType.Opacity, e.TextureType.Emap],
                      g = [e.TextureType.PBR_BaseColor, e.TextureType.PBR_Subsurface, e.TextureType.PBR_SubsurfaceScattering, e.TextureType.PBR_SubsurfaceScatteringRadius, e.TextureType.PBR_Metallic, e.TextureType.PBR_Specular, e.TextureType.PBR_SpecularTint, e.TextureType.PBR_Roughness, e.TextureType.PBR_Anisotropic, e.TextureType.PBR_Anisotropic_Rotation, e.TextureType.PBR_Sheen, e.TextureType.PBR_SheenTint, e.TextureType.PBR_Clearcoat, e.TextureType.PBR_ClearcoatBump, e.TextureType.PBR_ClearcoatRoughness, e.TextureType.PBR_OpacityIor, e.TextureType.PBR_OpacityRoughness, e.TextureType.PBR_Emission, e.TextureType.PBR_AmbientOcclusion, e.TextureType.PBR_Displacement];

                for (let e = 0; e < o.materials().count(); e++) {
                  const t = o.materials().get(e),
                        n = t.physicallyBased();
                  let i = s(t);
                  const a = [];

                  for (let e = 0; e < m.length; e++) {
                    const n = t.getTexture(m[e]);

                    if (n) {
                      let t = m[e].constructor.name;
                      t = t.substring(12, t.length);
                      const i = {
                        type: t
                      },
                            s = o.getEmbeddedFileAsBase64(n.fileName);
                      i.wrapU = n.wrapU, i.wrapV = n.wrapV, i.wrapW = n.wrapW;
                      const l = n.uvwTransform.toFloatArray(!0);
                      i.repeat = [l[0], l[5]], s ? i.image = "data:image/png;base64," + s : (self.postMessage({
                        type: "warning",
                        id: r,
                        data: {
                          message: `THREE.3DMLoader: Image for ${t} texture not embedded in file.`,
                          type: "missing resource"
                        }
                      }), i.image = null), a.push(i), n.delete();
                    }
                  }

                  if (i.textures = a, n.supported) {
                    for (let e = 0; e < g.length; e++) {
                      const n = t.getTexture(g[e]);

                      if (n) {
                        const t = o.getEmbeddedFileAsBase64(n.fileName);
                        let r = g[e].constructor.name;
                        r = r.substring(12, r.length);
                        const i = {
                          type: r,
                          image: "data:image/png;base64," + t
                        };
                        a.push(i), n.delete();
                      }
                    }

                    const e = s(t.physicallyBased());
                    i = Object.assign(e, i);
                  }

                  l.push(i), t.delete(), n.delete();
                }

                for (let e = 0; e < o.layers().count(); e++) {
                  const t = o.layers().get(e),
                        n = s(t);
                  c.push(n), t.delete();
                }

                for (let e = 0; e < o.views().count(); e++) {
                  const t = o.views().get(e),
                        n = s(t);
                  u.push(n), t.delete();
                }

                for (let e = 0; e < o.namedViews().count(); e++) {
                  const t = o.namedViews().get(e),
                        n = s(t);
                  p.push(n), t.delete();
                }

                for (let e = 0; e < o.groups().count(); e++) {
                  const t = o.groups().get(e),
                        n = s(t);
                  h.push(n), t.delete();
                }

                const v = s(o.settings()),
                      b = o.strings().count();

                for (let e = 0; e < b; e++) d.push(o.strings().get(e));

                return o.delete(), {
                  objects: a,
                  materials: l,
                  layers: c,
                  views: u,
                  namedViews: p,
                  groups: h,
                  strings: d,
                  settings: v
                };
              }(n, c);

              self.postMessage({
                type: "decode",
                id: a.id,
                data: e
              });
            } catch (e) {
              self.postMessage({
                type: "error",
                id: a.id,
                error: e
              });
            }
          });
      }
    };
  }

  class Xb extends Wb {
    constructor(e) {
      super(e), this.setLibraryPath("https://cdn.jsdelivr.net/npm/rhino3dm@7.11.1/");
    }

    async loadAsync(e, t) {
      return await super.loadAsync(e, t);
    }

  }

  class qb extends r {
    constructor() {
      super(...arguments), this.dependencies = [js], this._importer = new Zt(Xb, ["3dm"], !0);
    }

    async onAdded(e) {
      Fs.Importers.push(this._importer);
    }

    async onDispose(e) {}

    async onRemove(e) {
      Fs.Importers.splice(Fs.Importers.indexOf(this._importer), 1);
    }

  }

  qb.PluginType = "Rhino3dmLoadPlugin";

  class Yb extends r {
    constructor() {
      super(...arguments), this.dependencies = [js];
    }

    async onAdded(e) {
      const t = document.createElement("script");
      t.type = "module", t.innerHTML = "\nimport { MeshoptDecoder } from 'https://cdn.jsdelivr.net/gh/zeux/meshoptimizer@master/js/meshopt_decoder.module.js'\nwindow.MeshoptDecoder = MeshoptDecoder\n", document.head.appendChild(t), this._script = t;
    }

    async onDispose(e) {}

    async onRemove(e) {
      this._script && (document.head.removeChild(this._script), this._script = void 0);
    }

  }

  Yb.PluginType = "GLTFMeshOptPlugin";

  class Zb extends i.aNw {
    constructor(e) {
      super(e);
    }

    load(e, t, n, r) {
      const s = this,
            o = new i.hH6(this.manager);
      o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (n) {
        try {
          t(s.parse(n));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    parse(e) {
      function t(e, t, n) {
        for (let r = 0, i = e.length; r < i; r++) if (e[r] !== t.getUint8(n + r)) return !1;

        return !0;
      }

      const n = function (e) {
        if ("string" == typeof e) {
          const t = new Uint8Array(e.length);

          for (let n = 0; n < e.length; n++) t[n] = 255 & e.charCodeAt(n);

          return t.buffer || t;
        }

        return e;
      }(e);

      return function (e) {
        const n = new DataView(e);
        if (84 + 50 * n.getUint32(80, !0) === n.byteLength) return !0;
        const r = [115, 111, 108, 105, 100];

        for (let e = 0; e < 5; e++) if (t(r, n, e)) return !1;

        return !0;
      }(n) ? function (e) {
        const t = new DataView(e),
              n = t.getUint32(80, !0);
        let r,
            s,
            o,
            a,
            l,
            c,
            u,
            p,
            h = !1;

        for (let e = 0; e < 70; e++) 1129270351 == t.getUint32(e, !1) && 82 == t.getUint8(e + 4) && 61 == t.getUint8(e + 5) && (h = !0, a = new Float32Array(3 * n * 3), l = t.getUint8(e + 6) / 255, c = t.getUint8(e + 7) / 255, u = t.getUint8(e + 8) / 255, p = t.getUint8(e + 9) / 255);

        const d = new i.u9r(),
              f = new Float32Array(3 * n * 3),
              _ = new Float32Array(3 * n * 3);

        for (let e = 0; e < n; e++) {
          const n = 84 + 50 * e,
                i = t.getFloat32(n, !0),
                p = t.getFloat32(n + 4, !0),
                d = t.getFloat32(n + 8, !0);

          if (h) {
            const e = t.getUint16(n + 48, !0);
            0 == (32768 & e) ? (r = (31 & e) / 31, s = (e >> 5 & 31) / 31, o = (e >> 10 & 31) / 31) : (r = l, s = c, o = u);
          }

          for (let l = 1; l <= 3; l++) {
            const c = n + 12 * l,
                  u = 3 * e * 3 + 3 * (l - 1);
            f[u] = t.getFloat32(c, !0), f[u + 1] = t.getFloat32(c + 4, !0), f[u + 2] = t.getFloat32(c + 8, !0), _[u] = i, _[u + 1] = p, _[u + 2] = d, h && (a[u] = r, a[u + 1] = s, a[u + 2] = o);
          }
        }

        return d.setAttribute("position", new i.TlE(f, 3)), d.setAttribute("normal", new i.TlE(_, 3)), h && (d.setAttribute("color", new i.TlE(a, 3)), d.hasColors = !0, d.alpha = p), d;
      }(n) : function (e) {
        const t = new i.u9r(),
              n = /solid([\s\S]*?)endsolid/g,
              r = /facet([\s\S]*?)endfacet/g;
        let s = 0;
        const o = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,
              a = new RegExp("vertex" + o + o + o, "g"),
              l = new RegExp("normal" + o + o + o, "g"),
              c = [],
              u = [],
              p = new i.Pa4();
        let h,
            d = 0,
            f = 0,
            _ = 0;

        for (; null !== (h = n.exec(e));) {
          f = _;
          const e = h[0];

          for (; null !== (h = r.exec(e));) {
            let e = 0,
                t = 0;
            const n = h[0];

            for (; null !== (h = l.exec(n));) p.x = parseFloat(h[1]), p.y = parseFloat(h[2]), p.z = parseFloat(h[3]), t++;

            for (; null !== (h = a.exec(n));) c.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), u.push(p.x, p.y, p.z), e++, _++;

            1 !== t && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + s), 3 !== e && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + s), s++;
          }

          const n = f,
                i = _ - f;
          t.addGroup(n, i, d), d++;
        }

        return t.setAttribute("position", new i.a$l(c, 3)), t.setAttribute("normal", new i.a$l(u, 3)), t;
      }("string" != typeof (r = e) ? i.Zp0.decodeText(new Uint8Array(r)) : r);
      var r;
    }

  }

  class Jb extends r {
    constructor() {
      super(...arguments), this.dependencies = [js];
    }

    async onAdded(e) {
      this._importer || (this._importer = new Zt(Zb, ["stl"], !0)), Fs.Importers.push(this._importer);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Fs.Importers.splice(Fs.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  Jb.PluginType = "STLLoadPlugin";

  class $b extends i.aNw {
    constructor(e) {
      super(e);
    }

    load(e, t, n, r) {
      const s = this,
            o = "" === this.path ? i.Zp0.extractUrlBase(e) : this.path,
            a = new i.hH6(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (n) {
        try {
          t(s.parse(n, o));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    setMaterialOptions(e) {
      return this.materialOptions = e, this;
    }

    parse(e, t) {
      const n = e.split("\n");
      let r = {};
      const i = /\s+/,
            s = {};

      for (let e = 0; e < n.length; e++) {
        let t = n[e];
        if (t = t.trim(), 0 === t.length || "#" === t.charAt(0)) continue;
        const o = t.indexOf(" ");
        let a = o >= 0 ? t.substring(0, o) : t;
        a = a.toLowerCase();
        let l = o >= 0 ? t.substring(o + 1) : "";
        if (l = l.trim(), "newmtl" === a) r = {
          name: l
        }, s[l] = r;else if ("ka" === a || "kd" === a || "ks" === a || "ke" === a) {
          const e = l.split(i, 3);
          r[a] = [parseFloat(e[0]), parseFloat(e[1]), parseFloat(e[2])];
        } else r[a] = l;
      }

      const o = new Qb(this.resourcePath || t, this.materialOptions);
      return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(s), o;
    }

  }

  class Qb {
    constructor(e = "", t = {}) {
      this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = void 0 !== this.options.side ? this.options.side : i.Wl3, this.wrap = void 0 !== this.options.wrap ? this.options.wrap : i.rpg;
    }

    setCrossOrigin(e) {
      return this.crossOrigin = e, this;
    }

    setManager(e) {
      this.manager = e;
    }

    setMaterials(e) {
      this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
    }

    convert(e) {
      if (!this.options) return e;
      const t = {};

      for (const n in e) {
        const r = e[n],
              i = {};
        t[n] = i;

        for (const e in r) {
          let t = !0,
              n = r[e];
          const s = e.toLowerCase();

          switch (s) {
            case "kd":
            case "ka":
            case "ks":
              this.options && this.options.normalizeRGB && (n = [n[0] / 255, n[1] / 255, n[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === n[0] && 0 === n[1] && 0 === n[2] && (t = !1);
          }

          t && (i[s] = n);
        }
      }

      return t;
    }

    async preload() {
      for (const e in this.materialsInfo) await this.create(e);
    }

    getIndex(e) {
      return this.nameLookup[e];
    }

    async getAsArray() {
      let e = 0;

      for (const t in this.materialsInfo) this.materialsArray[e] = await this.create(t), this.nameLookup[t] = e, e++;

      return this.materialsArray;
    }

    async create(e) {
      return void 0 === this.materials[e] && (await this.createMaterial_(e)), this.materials[e];
    }

    async createMaterial_(e) {
      const t = this,
            n = this.materialsInfo[e],
            r = {
        name: e,
        side: this.side
      };

      async function s(e, n) {
        if (r[e]) return;
        const i = t.getTextureParams(n, r);
        return new Promise((n, s) => {
          let o = !1,
              a = () => !o && (o = !0) && n();

          const l = t.loadTexture((c = t.baseUrl, "string" != typeof (u = i.url) || "" === u ? "" : /^https?:\/\//i.test(u) ? u : c + u), void 0, t => {
            r[e] = t, a();
          }, void 0, a);
          var c, u;
          setTimeout(a, 50), l.repeat.copy(i.scale), l.offset.copy(i.offset), l.wrapS = t.wrap, l.wrapT = t.wrap;
        });
      }

      const o = Array.from(Object.keys(n || {}));
      let a = o.includes("d") || o.includes("D");

      for (const e of o) {
        const t = n[e];
        let o;
        if ("" !== t) switch (e.toLowerCase()) {
          case "kd":
            r.color = new i.Ilk().fromArray(t);
            break;

          case "ks":
            r.specular = new i.Ilk().fromArray(t);
            break;

          case "ke":
            r.emissive = new i.Ilk().fromArray(t);
            break;

          case "map_kd":
            await s("map", t);
            break;

          case "map_ks":
            await s("specularMap", t);
            break;

          case "map_ke":
            await s("emissiveMap", t);
            break;

          case "norm":
            await s("normalMap", t);
            break;

          case "map_bump":
          case "bump":
            await s("bumpMap", t);
            break;

          case "map_d":
            await s("alphaMap", t), r.transparent = !0;
            break;

          case "ns":
            r.shininess = parseFloat(t);
            break;

          case "d":
            o = parseFloat(t), o < 1 && (r.opacity = o, r.transparent = !0);
            break;

          case "tr":
            if (a) break;
            o = parseFloat(t), this.options && this.options.invertTrProperty && (o = 1 - o), o > 0 && (r.opacity = 1 - o, r.transparent = !0);
        }
      }

      return this.materials[e] = new i.xoR(r), this.materials[e];
    }

    getTextureParams(e, t) {
      const n = {
        scale: new i.FM8(1, 1),
        offset: new i.FM8(0, 0)
      },
            r = e.split(/\s+/);
      let s;
      return s = r.indexOf("-bm"), s >= 0 && (t.bumpScale = parseFloat(r[s + 1]), r.splice(s, 2)), s = r.indexOf("-s"), s >= 0 && (n.scale.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), s = r.indexOf("-o"), s >= 0 && (n.offset.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), n.url = r.join(" ").trim(), n;
    }

    loadTexture(e, t, n, r, s) {
      const o = void 0 !== this.manager ? this.manager : i.tEQ;
      let a = o.getHandler(e);
      null === a && (a = new i.dpR(o)), a.setCrossOrigin && a.setCrossOrigin(this.crossOrigin);
      const l = a.load(e, n, r, s);
      return void 0 !== t && (l.mapping = t), l;
    }

  }

  const ex = /^[og]\s*(.+)?/,
        tx = /^mtllib /,
        nx = /^usemtl /,
        rx = /^usemap /,
        ix = new i.Pa4(),
        sx = new i.Pa4(),
        ox = new i.Pa4(),
        ax = new i.Pa4(),
        lx = new i.Pa4();

  function cx() {
    const e = {
      objects: [],
      object: {},
      vertices: [],
      normals: [],
      colors: [],
      uvs: [],
      materials: {},
      materialLibraries: [],
      startObject: function (e, t) {
        if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void (this.object.fromDeclaration = !1 !== t);
        const n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;

        if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
          name: e || "",
          fromDeclaration: !1 !== t,
          geometry: {
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            hasUVIndices: !1
          },
          materials: [],
          smooth: !0,
          startMaterial: function (e, t) {
            const n = this._finalize(!1);

            n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
            const r = {
              index: this.materials.length,
              name: e || "",
              mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
              smooth: void 0 !== n ? n.smooth : this.smooth,
              groupStart: void 0 !== n ? n.groupEnd : 0,
              groupEnd: -1,
              groupCount: -1,
              inherited: !1,
              clone: function (e) {
                const t = {
                  index: "number" == typeof e ? e : this.index,
                  name: this.name,
                  mtllib: this.mtllib,
                  smooth: this.smooth,
                  groupStart: 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: !1
                };
                return t.clone = this.clone.bind(t), t;
              }
            };
            return this.materials.push(r), r;
          },
          currentMaterial: function () {
            if (this.materials.length > 0) return this.materials[this.materials.length - 1];
          },
          _finalize: function (e) {
            const t = this.currentMaterial();
            if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1) for (let e = this.materials.length - 1; e >= 0; e--) this.materials[e].groupCount <= 0 && this.materials.splice(e, 1);
            return e && 0 === this.materials.length && this.materials.push({
              name: "",
              smooth: this.smooth
            }), t;
          }
        }, n && n.name && "function" == typeof n.clone) {
          const e = n.clone(0);
          e.inherited = !0, this.object.materials.push(e);
        }

        this.objects.push(this.object);
      },
      finalize: function () {
        this.object && "function" == typeof this.object._finalize && this.object._finalize(!0);
      },
      parseVertexIndex: function (e, t) {
        const n = parseInt(e, 10);
        return 3 * (n >= 0 ? n - 1 : n + t / 3);
      },
      parseNormalIndex: function (e, t) {
        const n = parseInt(e, 10);
        return 3 * (n >= 0 ? n - 1 : n + t / 3);
      },
      parseUVIndex: function (e, t) {
        const n = parseInt(e, 10);
        return 2 * (n >= 0 ? n - 1 : n + t / 2);
      },
      addVertex: function (e, t, n) {
        const r = this.vertices,
              i = this.object.geometry.vertices;
        i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2]);
      },
      addVertexPoint: function (e) {
        const t = this.vertices;
        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
      },
      addVertexLine: function (e) {
        const t = this.vertices;
        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
      },
      addNormal: function (e, t, n) {
        const r = this.normals,
              i = this.object.geometry.normals;
        i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2]);
      },
      addFaceNormal: function (e, t, n) {
        const r = this.vertices,
              i = this.object.geometry.normals;
        ix.fromArray(r, e), sx.fromArray(r, t), ox.fromArray(r, n), lx.subVectors(ox, sx), ax.subVectors(ix, sx), lx.cross(ax), lx.normalize(), i.push(lx.x, lx.y, lx.z), i.push(lx.x, lx.y, lx.z), i.push(lx.x, lx.y, lx.z);
      },
      addColor: function (e, t, n) {
        const r = this.colors,
              i = this.object.geometry.colors;
        void 0 !== r[e] && i.push(r[e + 0], r[e + 1], r[e + 2]), void 0 !== r[t] && i.push(r[t + 0], r[t + 1], r[t + 2]), void 0 !== r[n] && i.push(r[n + 0], r[n + 1], r[n + 2]);
      },
      addUV: function (e, t, n) {
        const r = this.uvs,
              i = this.object.geometry.uvs;
        i.push(r[e + 0], r[e + 1]), i.push(r[t + 0], r[t + 1]), i.push(r[n + 0], r[n + 1]);
      },
      addDefaultUV: function () {
        const e = this.object.geometry.uvs;
        e.push(0, 0), e.push(0, 0), e.push(0, 0);
      },
      addUVLine: function (e) {
        const t = this.uvs;
        this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
      },
      addFace: function (e, t, n, r, i, s, o, a, l) {
        const c = this.vertices.length;
        let u = this.parseVertexIndex(e, c),
            p = this.parseVertexIndex(t, c),
            h = this.parseVertexIndex(n, c);

        if (this.addVertex(u, p, h), this.addColor(u, p, h), void 0 !== o && "" !== o) {
          const e = this.normals.length;
          u = this.parseNormalIndex(o, e), p = this.parseNormalIndex(a, e), h = this.parseNormalIndex(l, e), this.addNormal(u, p, h);
        } else this.addFaceNormal(u, p, h);

        if (void 0 !== r && "" !== r) {
          const e = this.uvs.length;
          u = this.parseUVIndex(r, e), p = this.parseUVIndex(i, e), h = this.parseUVIndex(s, e), this.addUV(u, p, h), this.object.geometry.hasUVIndices = !0;
        } else this.addDefaultUV();
      },
      addPointGeometry: function (e) {
        this.object.geometry.type = "Points";
        const t = this.vertices.length;

        for (let n = 0, r = e.length; n < r; n++) {
          const r = this.parseVertexIndex(e[n], t);
          this.addVertexPoint(r), this.addColor(r);
        }
      },
      addLineGeometry: function (e, t) {
        this.object.geometry.type = "Line";
        const n = this.vertices.length,
              r = this.uvs.length;

        for (let t = 0, r = e.length; t < r; t++) this.addVertexLine(this.parseVertexIndex(e[t], n));

        for (let e = 0, n = t.length; e < n; e++) this.addUVLine(this.parseUVIndex(t[e], r));
      }
    };
    return e.startObject("", !1), e;
  }

  class ux extends i.aNw {
    constructor(e) {
      super(e), this.materials = null;
    }

    load(e, t, n, r) {
      const s = this,
            o = new i.hH6(this.manager);
      o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, async function (n) {
        try {
          t(await s.parse(n));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    setMaterials(e) {
      return this.materials = e, this;
    }

    async parse(e) {
      const t = new cx();
      -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")), -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
      const n = e.split("\n");
      let r = "",
          s = "",
          o = 0,
          a = [];
      const l = "function" == typeof "".trimLeft;

      for (let e = 0, i = n.length; e < i; e++) if (r = n[e], r = l ? r.trimLeft() : r.trim(), o = r.length, 0 !== o && (s = r.charAt(0), "#" !== s)) if ("v" === s) {
        const e = r.split(/\s+/);

        switch (e[0]) {
          case "v":
            t.vertices.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])), e.length >= 7 ? t.colors.push(parseFloat(e[4]), parseFloat(e[5]), parseFloat(e[6])) : t.colors.push(void 0, void 0, void 0);
            break;

          case "vn":
            t.normals.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]));
            break;

          case "vt":
            t.uvs.push(parseFloat(e[1]), parseFloat(e[2]));
        }
      } else if ("f" === s) {
        const e = r.substr(1).trim().split(/\s+/),
              n = [];

        for (let t = 0, r = e.length; t < r; t++) {
          const r = e[t];

          if (r.length > 0) {
            const e = r.split("/");
            n.push(e);
          }
        }

        const i = n[0];

        for (let e = 1, r = n.length - 1; e < r; e++) {
          const r = n[e],
                s = n[e + 1];
          t.addFace(i[0], r[0], s[0], i[1], r[1], s[1], i[2], r[2], s[2]);
        }
      } else if ("l" === s) {
        const e = r.substring(1).trim().split(" ");
        let n = [];
        const i = [];
        if (-1 === r.indexOf("/")) n = e;else for (let t = 0, r = e.length; t < r; t++) {
          const r = e[t].split("/");
          "" !== r[0] && n.push(r[0]), "" !== r[1] && i.push(r[1]);
        }
        t.addLineGeometry(n, i);
      } else if ("p" === s) {
        const e = r.substr(1).trim().split(" ");
        t.addPointGeometry(e);
      } else if (null !== (a = ex.exec(r))) {
        const e = (" " + a[0].substr(1).trim()).substr(1);
        t.startObject(e);
      } else if (nx.test(r)) t.object.startMaterial(r.substring(7).trim(), t.materialLibraries);else if (tx.test(r)) {
        t.materialLibraries.push(r.substring(7).trim());
        const e = r.substring(7).trim(),
              n = this.manager.getHandler(e);

        if (n) {
          const t = await n.loadAsync(e).catch(e => {
            console.warn(e);
          });
          t && this.setMaterials(t);
        } else console.warn("OBJLoader2: Set MTLLoader to loading manager to load materials.");
      } else if (rx.test(r)) console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if ("s" === s) {
        if (a = r.split(" "), a.length > 1) {
          const e = a[1].trim().toLowerCase();
          t.object.smooth = "0" !== e && "off" !== e;
        } else t.object.smooth = !0;

        const e = t.object.currentMaterial();
        e && (e.smooth = t.object.smooth);
      } else {
        if ("\0" === r) continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + r + '"');
      }

      t.finalize();
      const c = new i.ZAu();
      if (c.materialLibraries = [].concat(t.materialLibraries), !0 == !(1 === t.objects.length && 0 === t.objects[0].geometry.vertices.length)) for (let e = 0, n = t.objects.length; e < n; e++) {
        const n = t.objects[e],
              r = n.geometry,
              s = n.materials,
              o = "Line" === r.type,
              a = "Points" === r.type;
        let l = !1;
        if (0 === r.vertices.length) continue;
        const u = new i.u9r();
        u.setAttribute("position", new i.a$l(r.vertices, 3)), r.normals.length > 0 && u.setAttribute("normal", new i.a$l(r.normals, 3)), r.colors.length > 0 && (l = !0, u.setAttribute("color", new i.a$l(r.colors, 3))), !0 === r.hasUVIndices && u.setAttribute("uv", new i.a$l(r.uvs, 2));
        const p = [];

        for (let e = 0, n = s.length; e < n; e++) {
          const n = s[e],
                r = n.name + "_" + n.smooth + "_" + l;
          let c = t.materials[r];
          if (null !== this.materials) if (c = await this.materials.create(n.name), !o || !c || c instanceof i.nls) {
            if (a && c && !(c instanceof i.UY4)) {
              const e = new i.UY4({
                size: 10,
                sizeAttenuation: !1
              });
              i.F5T.prototype.copy.call(e, c), e.color.copy(c.color), e.map = c.map, c = e;
            }
          } else {
            const e = new i.nls();
            i.F5T.prototype.copy.call(e, c), e.color.copy(c.color), c = e;
          }
          void 0 === c && (c = o ? new i.nls() : a ? new i.UY4({
            size: 1,
            sizeAttenuation: !1
          }) : new i.xoR(), c.name = n.name, c.flatShading = !n.smooth, c.vertexColors = l, t.materials[r] = c), p.push(c);
        }

        let h;

        if (p.length > 1) {
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            u.addGroup(t.groupStart, t.groupCount, e);
          }

          h = o ? new i.ejS(u, p) : a ? new i.woe(u, p) : new i.Kj0(u, p);
        } else h = o ? new i.ejS(u, p[0]) : a ? new i.woe(u, p[0]) : new i.Kj0(u, p[0]);

        h.name = n.name, c.add(h);
      } else if (t.vertices.length > 0) {
        const e = new i.UY4({
          size: 1,
          sizeAttenuation: !1
        }),
              n = new i.u9r();
        n.setAttribute("position", new i.a$l(t.vertices, 3)), t.colors.length > 0 && void 0 !== t.colors[0] && (n.setAttribute("color", new i.a$l(t.colors, 3)), e.vertexColors = !0);
        const r = new i.woe(n, e);
        c.add(r);
      }
      return c;
    }

  }

  class px extends r {
    constructor() {
      super(...arguments), this.dependencies = [js], this._importer1 = new Zt(ux, ["obj"], !0), this._importer2 = new Zt($b, ["mtl"], !1);
    }

    async onAdded(e) {
      Fs.Importers.push(this._importer1), Fs.Importers.push(this._importer2);
    }

    async onDispose(e) {}

    async onRemove(e) {
      Fs.Importers.splice(Fs.Importers.indexOf(this._importer1), 1), Fs.Importers.splice(Fs.Importers.indexOf(this._importer2), 1);
    }

  }

  px.PluginType = "ObjMtlLoadPlugin";

  class hx extends i.DqL {
    constructor(e) {
      super(e);
    }

    parse(e, t) {
      const n = new dx(e, 1);
      return {
        mipmaps: n.mipmaps(t),
        width: n.pixelWidth,
        height: n.pixelHeight,
        format: n.glInternalFormat,
        isCubemap: 6 === n.numberOfFaces,
        mipmapCount: n.numberOfMipmapLevels
      };
    }

  }

  class dx {
    constructor(e, t) {
      this.arrayBuffer = e;
      const n = new Uint8Array(this.arrayBuffer, 0, 12);
      if (171 !== n[0] || 75 !== n[1] || 84 !== n[2] || 88 !== n[3] || 32 !== n[4] || 49 !== n[5] || 49 !== n[6] || 187 !== n[7] || 13 !== n[8] || 10 !== n[9] || 26 !== n[10] || 10 !== n[11]) return void console.error("texture missing KTX identifier");
      const r = Uint32Array.BYTES_PER_ELEMENT,
            i = new DataView(this.arrayBuffer, 12, 13 * r),
            s = 67305985 === i.getUint32(0, !0);
      this.glType = i.getUint32(1 * r, s), this.glTypeSize = i.getUint32(2 * r, s), this.glFormat = i.getUint32(3 * r, s), this.glInternalFormat = i.getUint32(4 * r, s), this.glBaseInternalFormat = i.getUint32(5 * r, s), this.pixelWidth = i.getUint32(6 * r, s), this.pixelHeight = i.getUint32(7 * r, s), this.pixelDepth = i.getUint32(8 * r, s), this.numberOfArrayElements = i.getUint32(9 * r, s), this.numberOfFaces = i.getUint32(10 * r, s), this.numberOfMipmapLevels = i.getUint32(11 * r, s), this.bytesOfKeyValueData = i.getUint32(12 * r, s), 0 === this.glType ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels), 0 !== this.pixelHeight && 0 === this.pixelDepth ? 0 === this.numberOfArrayElements ? this.numberOfFaces === t ? this.loadType = 0 : console.warn("number of faces expected" + t + ", but found " + this.numberOfFaces) : console.warn("texture arrays not currently supported") : console.warn("only 2D textures currently supported")) : console.warn("only compressed formats currently supported");
    }

    mipmaps(e) {
      const t = [];
      let n = 64 + this.bytesOfKeyValueData,
          r = this.pixelWidth,
          i = this.pixelHeight;
      const s = e ? this.numberOfMipmapLevels : 1;

      for (let e = 0; e < s; e++) {
        const e = new Int32Array(this.arrayBuffer, n, 1)[0];
        n += 4;

        for (let s = 0; s < this.numberOfFaces; s++) {
          const s = new Uint8Array(this.arrayBuffer, n, e);
          t.push({
            data: s,
            width: r,
            height: i
          }), n += e, n += 3 - (e + 3) % 4;
        }

        r = Math.max(1, .5 * r), i = Math.max(1, .5 * i);
      }

      return t;
    }

  }

  class fx extends r {
    constructor() {
      super(...arguments), this.dependencies = [js];
    }

    async onAdded(e) {
      this._importer || (this._importer = new Zt(hx, ["ktx"], !1)), Fs.Importers.push(this._importer);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Fs.Importers.splice(Fs.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  fx.PluginType = "KTXLoadPlugin";

  class _x extends i.hH6 {
    constructor(e) {
      super(e), this.responseType = "blob";
    }

  }

  class mx extends i.hH6 {
    constructor(e) {
      super(e), this.responseType = "blob";
    }

    load(e, t, n, r) {
      return super.load(e, e => {
        try {
          null == t || t(vt(e));
        } catch (e) {
          null == r || r(e);
        }
      }, n, r);
    }

  }

  class gx {
    async parseAsync(e, t) {
      var n;
      return new Blob([JSON.stringify(e, null, null !== (n = t.jsonSpaces) && void 0 !== n ? n : 2)], {
        type: "application/json"
      });
    }

  }

  class vx {
    async parseAsync(e, t) {
      return new Blob([e], {
        type: "text/plain"
      });
    }

  }

  function bx(e, t) {
    const n = e.getPlugin(js).exportViewerConfig(),
          r = [];
    Object.values(n.resources).forEach(e => {
      Object.values(e).forEach(e => {
        e.url && ("Uint16Array" === e.url.type && e.url.data && (e.url.data = new Uint16Array(e.url.data), r.push(e.url)), "Uint8Array" === e.url.type && e.url.data && (e.url.data = new Uint8Array(e.url.data), r.push(e.url)));
      });
    });

    for (const e of r) {
      let n = "application/octet-stream";

      if ("Uint16Array" === e.type) {
        const t = xx(e.data, 4),
              r = new ImageData(t, e.width, e.height),
              s = i.PpQ.getDataURL(r).split(",")[1];
        n = "image/png", e.data = atob(s), e.encoding = "rgbe";
      }

      const r = new Blob([e.data], {
        type: n
      });
      t.json.images || (t.json.images = []);
      const s = {
        mimeType: n
      },
            o = t.json.images.push(s) - 1;
      e.data = {
        image: o
      }, t.pending.push(t.processBufferViewImage(r).then(e => {
        s.bufferView = e;
      }));
    }

    return n;
  }

  function xx(e, t = 3, n) {
    let r, i, s, o, a;
    const l = e.byteLength / (2 * t) | 0;
    n = n || new Uint8ClampedArray(4 * l);

    for (let c = 0; c < l; c++) {
      r = e[c * t], i = e[c * t + 1], s = e[c * t + 2], o = Math.max(Math.max(r, i), s);
      const l = Math.ceil(Math.log2(o));
      a = Math.pow(2, l - 8), n[4 * c] = r / a | 0, n[4 * c + 1] = i / a | 0, n[4 * c + 2] = s / a | 0, n[4 * c + 3] = l + 128;
    }

    return n;
  }

  class yx {
    constructor() {
      this.pluginCallbacks = [], this.register(function (e) {
        return new Px(e);
      }), this.register(function (e) {
        return new Dx(e);
      }), this.register(function (e) {
        return new Ox(e);
      }), this.register(function (e) {
        return new Fx(e);
      }), this.register(function (e) {
        return new Nx(e);
      }), this.register(function (e) {
        return new Lx(e);
      }), this.register(function (e) {
        return new Ux(e);
      }), this.register(function (e) {
        return new Ix(e);
      }), this.register(function (e) {
        return new Bx(e);
      });
    }

    register(e) {
      return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
    }

    unregister(e) {
      return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }

    parse(e, t, n, r, i) {
      "object" == typeof n && (console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."), r = n);
      const s = i || new kx(),
            o = [];

      for (let e = 0, t = this.pluginCallbacks.length; e < t; e++) o.push(this.pluginCallbacks[e](s));

      s.setPlugins(o), s.write(e, t, r).catch(n);
    }

    parseAsync(e, t) {
      const n = this;
      return new Promise(function (r, i) {
        n.parse(e, r, i, t);
      });
    }

  }

  const wx = 5121,
        Sx = 5123,
        Mx = {};
  Mx[i.TyD] = 9728, Mx[i.YLQ] = 9984, Mx[i.aH4] = 9986, Mx[i.wem] = 9729, Mx[i.qyh] = 9985, Mx[i.D1R] = 9987, Mx[i.uWy] = 33071, Mx[i.rpg] = 10497, Mx[i.OoA] = 33648;
  const Tx = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights"
  };

  function Ex(e, t) {
    return e.length === t.length && e.every(function (e, n) {
      return e === t[n];
    });
  }

  function Ax(e) {
    return 4 * Math.ceil(e / 4);
  }

  function Cx(e, t = 0) {
    const n = Ax(e.byteLength);

    if (n !== e.byteLength) {
      const r = new Uint8Array(n);
      if (r.set(new Uint8Array(e)), 0 !== t) for (let i = e.byteLength; i < n; i++) r[i] = t;
      return r.buffer;
    }

    return e;
  }

  function Rx(e, t) {
    if (void 0 !== e.toBlob) return new Promise(n => e.toBlob(n, t));
    let n;
    return "image/jpeg" === t ? n = .92 : "image/webp" === t && (n = .8), e.convertToBlob({
      type: t,
      quality: n
    });
  }

  class kx {
    constructor() {
      this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = new Map(), this.uid = 0, this.json = {
        asset: {
          version: "2.0",
          generator: "THREE.GLTFExporter"
        }
      }, this.cache = {
        meshes: new Map(),
        attributes: new Map(),
        attributesNormalized: new Map(),
        materials: new Map(),
        textures: new Map(),
        images: new Map()
      };
    }

    setPlugins(e) {
      this.plugins = e;
    }

    async write(e, t, n) {
      this.options = Object.assign({}, {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      }, n), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
      const r = this,
            i = r.buffers,
            s = r.json;
      n = r.options;
      const o = r.extensionsUsed,
            a = new Blob(i, {
        type: "application/octet-stream"
      }),
            l = Object.keys(o);

      if (l.length > 0 && (s.extensionsUsed = l), s.buffers && s.buffers.length > 0 && (s.buffers[0].byteLength = a.size), !0 === n.binary) {
        const e = new FileReader();
        e.readAsArrayBuffer(a), e.onloadend = function () {
          const n = Cx(e.result),
                r = new DataView(new ArrayBuffer(8));
          r.setUint32(0, n.byteLength, !0), r.setUint32(4, 5130562, !0);
          const i = Cx((o = JSON.stringify(s), new TextEncoder().encode(o).buffer), 32);
          var o;
          const a = new DataView(new ArrayBuffer(8));
          a.setUint32(0, i.byteLength, !0), a.setUint32(4, 1313821514, !0);
          const l = new ArrayBuffer(12),
                c = new DataView(l);
          c.setUint32(0, 1179937895, !0), c.setUint32(4, 2, !0);
          const u = 12 + a.byteLength + i.byteLength + r.byteLength + n.byteLength;
          c.setUint32(8, u, !0);
          const p = new Blob([l, a, i, r, n], {
            type: "application/octet-stream"
          }),
                h = new FileReader();
          h.readAsArrayBuffer(p), h.onloadend = function () {
            t(h.result);
          };
        };
      } else if (s.buffers && s.buffers.length > 0) {
        const e = new FileReader();
        e.readAsDataURL(a), e.onloadend = function () {
          const n = e.result;
          s.buffers[0].uri = n, t(s);
        };
      } else t(s);
    }

    serializeUserData(e, t) {
      if (0 === Object.keys(e.userData).length) return;
      const n = this.options,
            r = this.extensionsUsed;

      try {
        const i = JSON.parse(JSON.stringify(e.userData));

        if (n.includeCustomExtensions && i.gltfExtensions) {
          void 0 === t.extensions && (t.extensions = {});

          for (const e in i.gltfExtensions) t.extensions[e] = i.gltfExtensions[e], r[e] = !0;

          delete i.gltfExtensions;
        }

        Object.keys(i).length > 0 && (t.extras = i);
      } catch (t) {
        console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message), console.warn({ ...e.userData
        });
      }
    }

    getUID(e, t = !1) {
      if (!1 === this.uids.has(e)) {
        const t = new Map();
        t.set(!0, this.uid++), t.set(!1, this.uid++), this.uids.set(e, t);
      }

      return this.uids.get(e).get(t);
    }

    isNormalizedNormalAttribute(e) {
      if (this.cache.attributesNormalized.has(e)) return !1;
      const t = new i.Pa4();

      for (let n = 0, r = e.count; n < r; n++) if (Math.abs(t.fromBufferAttribute(e, n).length() - 1) > 5e-4) return !1;

      return !0;
    }

    createNormalizedNormalAttribute(e) {
      const t = this.cache;
      if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
      const n = e.clone(),
            r = new i.Pa4();

      for (let e = 0, t = n.count; e < t; e++) r.fromBufferAttribute(n, e), 0 === r.x && 0 === r.y && 0 === r.z ? r.setX(1) : r.normalize(), n.setXYZ(e, r.x, r.y, r.z);

      return t.attributesNormalized.set(e, n), n;
    }

    applyTextureTransform(e, t) {
      let n = !1;
      const r = {};
      0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), n = !0), 0 !== t.rotation && (r.rotation = t.rotation, n = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0);
    }

    buildMetalRoughTexture(e, t) {
      if (e === t) return e;

      function n(e) {
        return e.encoding === i.knz ? function (e) {
          return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
        } : function (e) {
          return e;
        };
      }

      console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
      const r = e ? e.image : void 0,
            s = t ? t.image : void 0,
            o = Math.max(r ? r.width : 0, s ? s.width : 0),
            a = Math.max(r ? r.height : 0, s ? s.height : 0),
            l = document.createElement("canvas");
      l.width = o, l.height = a;
      const c = l.getContext("2d");
      c.fillStyle = "#00ffff", c.fillRect(0, 0, o, a);
      const u = c.getImageData(0, 0, o, a);

      if (r) {
        c.drawImage(r, 0, 0, o, a);
        const t = n(e),
              i = c.getImageData(0, 0, o, a).data;

        for (let e = 2; e < i.length; e += 4) u.data[e] = 256 * t(i[e] / 256);
      }

      if (s) {
        c.drawImage(s, 0, 0, o, a);
        const e = n(t),
              r = c.getImageData(0, 0, o, a).data;

        for (let t = 1; t < r.length; t += 4) u.data[t] = 256 * e(r[t] / 256);
      }

      c.putImageData(u, 0, 0);
      const p = (e || t).clone();
      return p.source = new i.Hw6(l), p.encoding = i.rnI, p;
    }

    processBuffer(e) {
      const t = this.json,
            n = this.buffers;
      return t.buffers || (t.buffers = [{
        byteLength: 0
      }]), n.push(e), 0;
    }

    processBufferView(e, t, n, r, i) {
      const s = this.json;
      let o;
      s.bufferViews || (s.bufferViews = []), o = t === wx ? 1 : t === Sx ? 2 : 4;
      const a = Ax(r * e.itemSize * o),
            l = new DataView(new ArrayBuffer(a));
      let c = 0;

      for (let i = n; i < n + r; i++) for (let n = 0; n < e.itemSize; n++) {
        let r;
        e.itemSize > 4 ? r = e.array[i * e.itemSize + n] : 0 === n ? r = e.getX(i) : 1 === n ? r = e.getY(i) : 2 === n ? r = e.getZ(i) : 3 === n && (r = e.getW(i)), 5126 === t ? l.setFloat32(c, r, !0) : 5125 === t ? l.setUint32(c, r, !0) : t === Sx ? l.setUint16(c, r, !0) : t === wx && l.setUint8(c, r), c += o;
      }

      const u = {
        buffer: this.processBuffer(l.buffer),
        byteOffset: this.byteOffset,
        byteLength: a
      };
      return void 0 !== i && (u.target = i), 34962 === i && (u.byteStride = e.itemSize * o), this.byteOffset += a, s.bufferViews.push(u), {
        id: s.bufferViews.length - 1,
        byteLength: 0
      };
    }

    processBufferViewImage(e) {
      const t = this,
            n = t.json;
      return n.bufferViews || (n.bufferViews = []), new Promise(function (r) {
        const i = new FileReader();
        i.readAsArrayBuffer(e), i.onloadend = function () {
          const e = Cx(i.result),
                s = {
            buffer: t.processBuffer(e),
            byteOffset: t.byteOffset,
            byteLength: e.byteLength
          };
          t.byteOffset += e.byteLength, r(n.bufferViews.push(s) - 1);
        };
      });
    }

    processAccessor(e, t, n, r) {
      const i = this.options,
            s = this.json;
      let o;
      if (e.array.constructor === Float32Array) o = 5126;else if (e.array.constructor === Uint32Array) o = 5125;else if (e.array.constructor === Uint16Array) o = Sx;else {
        if (e.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
        o = wx;
      }

      if (void 0 === n && (n = 0), void 0 === r && (r = e.count), i.truncateDrawRange && void 0 !== t && null === t.index) {
        const i = n + r,
              s = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count;
        n = Math.max(n, t.drawRange.start), r = Math.min(i, s) - n, r < 0 && (r = 0);
      }

      if (0 === r) return null;

      const a = function (e, t, n) {
        const r = {
          min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
          max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
        };

        for (let i = t; i < t + n; i++) for (let t = 0; t < e.itemSize; t++) {
          let n;
          e.itemSize > 4 ? n = e.array[i * e.itemSize + t] : 0 === t ? n = e.getX(i) : 1 === t ? n = e.getY(i) : 2 === t ? n = e.getZ(i) : 3 === t && (n = e.getW(i)), r.min[t] = Math.min(r.min[t], n), r.max[t] = Math.max(r.max[t], n);
        }

        return r;
      }(e, n, r);

      let l;
      void 0 !== t && (l = e === t.index ? 34963 : 34962);
      const c = this.processBufferView(e, o, n, r, l),
            u = {
        bufferView: c.id,
        byteOffset: c.byteOffset,
        componentType: o,
        count: r,
        max: a.max,
        min: a.min,
        type: {
          1: "SCALAR",
          2: "VEC2",
          3: "VEC3",
          4: "VEC4",
          16: "MAT4"
        }[e.itemSize]
      };
      return !0 === e.normalized && (u.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(u) - 1;
    }

    processImage(e, t, n, r = "image/png") {
      const s = this,
            o = s.cache,
            a = s.json,
            l = s.options,
            c = s.pending;
      o.images.has(e) || o.images.set(e, {});
      const u = o.images.get(e),
            p = r + ":flipY/" + n.toString();
      if (void 0 !== u[p]) return u[p];
      a.images || (a.images = []);
      const h = {
        mimeType: r
      },
            d = "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
      d.width = Math.min(e.width, l.maxTextureSize), d.height = Math.min(e.height, l.maxTextureSize);
      const f = d.getContext("2d");

      if (!0 === n && (f.translate(0, d.height), f.scale(1, -1)), void 0 !== e.data) {
        t !== i.wk1 && console.error("GLTFExporter: Only RGBAFormat is supported."), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const n = new Uint8ClampedArray(e.height * e.width * 4);

        for (let t = 0; t < n.length; t += 4) n[t + 0] = e.data[t + 0], n[t + 1] = e.data[t + 1], n[t + 2] = e.data[t + 2], n[t + 3] = e.data[t + 3];

        f.putImageData(new ImageData(n, e.width, e.height), 0, 0);
      } else f.drawImage(e, 0, 0, d.width, d.height);

      !0 === l.binary ? c.push(Rx(d, r).then(e => s.processBufferViewImage(e)).then(e => {
        h.bufferView = e;
      })) : void 0 !== d.toDataURL ? h.uri = d.toDataURL(r) : c.push(Rx(d, r).then(e => new FileReader().readAsDataURL(e)).then(e => {
        h.uri = e;
      }));

      const _ = a.images.push(h) - 1;

      return u[p] = _, _;
    }

    processSampler(e) {
      const t = this.json;
      t.samplers || (t.samplers = []);
      const n = {
        magFilter: Mx[e.magFilter],
        minFilter: Mx[e.minFilter],
        wrapS: Mx[e.wrapS],
        wrapT: Mx[e.wrapT]
      };
      return t.samplers.push(n) - 1;
    }

    processTexture(e) {
      const t = this.cache,
            n = this.json;
      if (t.textures.has(e)) return t.textures.get(e);
      n.textures || (n.textures = []);
      let r = e.userData.mimeType;
      "image/webp" === r && (r = "image/png"), "image/jpg" === r && (r = "image/jpeg");
      const i = ["image/jpeg", "image/png"];
      r && !i.includes(r) && console.error("GLTFExporter: Unsupported mime type: " + r + ". Cannot export texture.", e);
      const s = {
        sampler: this.processSampler(e),
        source: !r || i.includes(r) ? this.processImage(e.image, e.format, e.flipY, r) : null
      };
      e.name && (s.name = e.name), this._invokeAll(function (t) {
        t.writeTexture && t.writeTexture(e, s);
      });
      const o = n.textures.push(s) - 1;
      return t.textures.set(e, o), o;
    }

    processMaterial(e) {
      const t = this.cache,
            n = this.json;
      if (t.materials.has(e)) return t.materials.get(e);
      if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
      n.materials || (n.materials = []);
      const r = {
        pbrMetallicRoughness: {}
      };
      !0 !== e.isMeshStandardMaterial && !0 !== e.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
      const s = e.color.toArray().concat([e.opacity]);

      if (Ex(s, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = s), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = .5, r.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) {
        const t = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap),
              n = {
          index: this.processTexture(t)
        };
        this.applyTextureTransform(n, t), r.pbrMetallicRoughness.metallicRoughnessTexture = n;
      }

      if (e.map) {
        const t = {
          index: this.processTexture(e.map)
        };
        this.applyTextureTransform(t, e.map), r.pbrMetallicRoughness.baseColorTexture = t;
      }

      if (e.emissive) {
        const t = e.emissive.clone().multiplyScalar(e.emissiveIntensity),
              n = Math.max(t.r, t.g, t.b);

        if (n > 1 && (t.multiplyScalar(1 / n), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), n > 0 && (r.emissiveFactor = t.toArray()), e.emissiveMap) {
          const t = {
            index: this.processTexture(e.emissiveMap)
          };
          this.applyTextureTransform(t, e.emissiveMap), r.emissiveTexture = t;
        }
      }

      if (e.normalMap) {
        const t = {
          index: this.processTexture(e.normalMap)
        };
        e.normalScale && 1 !== e.normalScale.x && (t.scale = e.normalScale.x), this.applyTextureTransform(t, e.normalMap), r.normalTexture = t;
      }

      if (e.aoMap) {
        const t = {
          index: this.processTexture(e.aoMap),
          texCoord: 1
        };
        1 !== e.aoMapIntensity && (t.strength = e.aoMapIntensity), this.applyTextureTransform(t, e.aoMap), r.occlusionTexture = t;
      }

      e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest), e.side === i.ehD && (r.doubleSided = !0), "" !== e.name && (r.name = e.name), this.serializeUserData(e, r), this._invokeAll(function (t) {
        t.writeMaterial && t.writeMaterial(e, r);
      });
      const o = n.materials.push(r) - 1;
      return t.materials.set(e, o), o;
    }

    processMesh(e) {
      const t = this.cache,
            n = this.json,
            r = [e.geometry.uuid];
      if (Array.isArray(e.material)) for (let t = 0, n = e.material.length; t < n; t++) r.push(e.material[t].uuid);else r.push(e.material.uuid);
      const s = r.join(":");
      if (t.meshes.has(s)) return t.meshes.get(s);
      const o = e.geometry;
      let a;
      if (a = e.isLineSegments ? 1 : e.isLineLoop ? 2 : e.isLine ? 3 : e.isPoints ? 0 : e.material.wireframe ? 1 : 4, !0 !== o.isBufferGeometry) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
      const l = {},
            c = {},
            u = [],
            p = [],
            h = {
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1",
        color: "COLOR_0",
        skinWeight: "WEIGHTS_0",
        skinIndex: "JOINTS_0"
      },
            d = o.getAttribute("normal");
      void 0 === d || this.isNormalizedNormalAttribute(d) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
      let f = null;

      for (let e in o.attributes) {
        if ("morph" === e.slice(0, 5)) continue;
        const n = o.attributes[e];

        if (e = h[e] || e.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e) || (e = "_" + e), t.attributes.has(this.getUID(n))) {
          c[e] = t.attributes.get(this.getUID(n));
          continue;
        }

        f = null;
        const r = n.array;
        "JOINTS_0" !== e || r instanceof Uint16Array || r instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f = new i.TlE(new Uint16Array(r), n.itemSize, n.normalized));
        const s = this.processAccessor(f || n, o);
        null !== s && (c[e] = s, t.attributes.set(this.getUID(n), s));
      }

      if (void 0 !== d && o.setAttribute("normal", d), 0 === Object.keys(c).length) return null;

      if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
        const n = [],
              r = [],
              i = {};
        if (void 0 !== e.morphTargetDictionary) for (const t in e.morphTargetDictionary) i[e.morphTargetDictionary[t]] = t;

        for (let s = 0; s < e.morphTargetInfluences.length; ++s) {
          const a = {};
          let l = !1;

          for (const e in o.morphAttributes) {
            if ("position" !== e && "normal" !== e) {
              l || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l = !0);
              continue;
            }

            const n = o.morphAttributes[e][s],
                  r = e.toUpperCase(),
                  i = o.attributes[e];

            if (t.attributes.has(this.getUID(n, !0))) {
              a[r] = t.attributes.get(this.getUID(n, !0));
              continue;
            }

            const c = n.clone();
            if (!o.morphTargetsRelative) for (let e = 0, t = n.count; e < t; e++) c.setXYZ(e, n.getX(e) - i.getX(e), n.getY(e) - i.getY(e), n.getZ(e) - i.getZ(e));
            a[r] = this.processAccessor(c, o), t.attributes.set(this.getUID(i, !0), a[r]);
          }

          p.push(a), n.push(e.morphTargetInfluences[s]), void 0 !== e.morphTargetDictionary && r.push(i[s]);
        }

        l.weights = n, r.length > 0 && (l.extras = {}, l.extras.targetNames = r);
      }

      const _ = Array.isArray(e.material);

      if (_ && 0 === o.groups.length) return null;
      const m = _ ? e.material : [e.material],
            g = _ ? o.groups : [{
        materialIndex: 0,
        start: void 0,
        count: void 0
      }];

      for (let e = 0, n = g.length; e < n; e++) {
        const n = {
          mode: a,
          attributes: c
        };

        if (this.serializeUserData(o, n), p.length > 0 && (n.targets = p), null !== o.index) {
          let r = this.getUID(o.index);
          void 0 === g[e].start && void 0 === g[e].count || (r += ":" + g[e].start + ":" + g[e].count), t.attributes.has(r) ? n.indices = t.attributes.get(r) : (n.indices = this.processAccessor(o.index, o, g[e].start, g[e].count), t.attributes.set(r, n.indices)), null === n.indices && delete n.indices;
        }

        const r = this.processMaterial(m[g[e].materialIndex]);
        null !== r && (n.material = r), u.push(n);
      }

      l.primitives = u, n.meshes || (n.meshes = []), this._invokeAll(function (t) {
        t.writeMesh && t.writeMesh(e, l);
      });
      const v = n.meshes.push(l) - 1;
      return t.meshes.set(s, v), v;
    }

    processCamera(e) {
      const t = this.json;
      t.cameras || (t.cameras = []);
      const n = e.isOrthographicCamera,
            r = {
        type: n ? "orthographic" : "perspective"
      };
      return n ? r.orthographic = {
        xmag: 2 * e.right,
        ymag: 2 * e.top,
        zfar: e.far <= 0 ? .001 : e.far,
        znear: e.near < 0 ? 0 : e.near
      } : r.perspective = {
        aspectRatio: e.aspect,
        yfov: i.M8C.degToRad(e.fov),
        zfar: e.far <= 0 ? .001 : e.far,
        znear: e.near < 0 ? 0 : e.near
      }, "" !== e.name && (r.name = e.type), t.cameras.push(r) - 1;
    }

    processAnimation(e, t) {
      const n = this.json,
            r = this.nodeMap;
      n.animations || (n.animations = []);
      const s = (e = yx.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks,
            o = [],
            a = [];

      for (let e = 0; e < s.length; ++e) {
        const n = s[e],
              l = i.iUV.parseTrackName(n.name);
        let c = i.iUV.findNode(t, l.nodeName);
        const u = Tx[l.propertyName];
        if ("bones" === l.objectName && (c = !0 === c.isSkinnedMesh ? c.skeleton.getBoneByName(l.objectIndex) : void 0), !c || !u) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n.name), null;
        const p = 1;
        let h,
            d = n.values.length / n.times.length;
        u === Tx.morphTargetInfluences && (d /= c.morphTargetInfluences.length), !0 === n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (h = "CUBICSPLINE", d /= 3) : h = n.getInterpolation() === i.Syv ? "STEP" : "LINEAR", a.push({
          input: this.processAccessor(new i.TlE(n.times, p)),
          output: this.processAccessor(new i.TlE(n.values, d)),
          interpolation: h
        }), o.push({
          sampler: a.length - 1,
          target: {
            node: r.get(c),
            path: u
          }
        });
      }

      return n.animations.push({
        name: e.name || "clip_" + n.animations.length,
        samplers: a,
        channels: o
      }), n.animations.length - 1;
    }

    processSkin(e) {
      const t = this.json,
            n = this.nodeMap,
            r = t.nodes[n.get(e)],
            s = e.skeleton;
      if (void 0 === s) return null;
      const o = e.skeleton.bones[0];
      if (void 0 === o) return null;
      const a = [],
            l = new Float32Array(16 * s.bones.length),
            c = new i.yGw();

      for (let t = 0; t < s.bones.length; ++t) a.push(n.get(s.bones[t])), c.copy(s.boneInverses[t]), c.multiply(e.bindMatrix).toArray(l, 16 * t);

      return void 0 === t.skins && (t.skins = []), t.skins.push({
        inverseBindMatrices: this.processAccessor(new i.TlE(l, 16)),
        joints: a,
        skeleton: n.get(o)
      }), r.skin = t.skins.length - 1;
    }

    processNode(e) {
      const t = this.json,
            n = this.options,
            r = this.nodeMap;
      t.nodes || (t.nodes = []);
      const i = {};

      if (n.trs) {
        const t = e.quaternion.toArray(),
              n = e.position.toArray(),
              r = e.scale.toArray();
        Ex(t, [0, 0, 0, 1]) || (i.rotation = t), Ex(n, [0, 0, 0]) || (i.translation = n), Ex(r, [1, 1, 1]) || (i.scale = r);
      } else e.matrixAutoUpdate && e.updateMatrix(), !1 === Ex(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (i.matrix = e.matrix.elements);

      if ("" !== e.name && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
        const t = this.processMesh(e);
        null !== t && (i.mesh = t);
      } else e.isCamera && (i.camera = this.processCamera(e));

      if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
        const t = [];

        for (let r = 0, i = e.children.length; r < i; r++) {
          const i = e.children[r];

          if (i.visible || !1 === n.onlyVisible) {
            const e = this.processNode(i);
            null !== e && t.push(e);
          }
        }

        t.length > 0 && (i.children = t);
      }

      this._invokeAll(function (t) {
        t.writeNode && t.writeNode(e, i);
      });

      const s = t.nodes.push(i) - 1;
      return r.set(e, s), s;
    }

    processScene(e) {
      const t = this.json,
            n = this.options;
      t.scenes || (t.scenes = [], t.scene = 0);
      const r = {};
      "" !== e.name && (r.name = e.name), t.scenes.push(r);
      const i = [];

      for (let t = 0, r = e.children.length; t < r; t++) {
        const r = e.children[t];

        if (r.visible || !1 === n.onlyVisible) {
          const e = this.processNode(r);
          null !== e && i.push(e);
        }
      }

      i.length > 0 && (r.nodes = i), this.serializeUserData(e, r);
    }

    processObjects(e) {
      const t = new i.xsS();
      t.name = "AuxScene";

      for (let n = 0; n < e.length; n++) t.children.push(e[n]);

      this.processScene(t);
    }

    processInput(e) {
      const t = this.options;
      e = e instanceof Array ? e : [e], this._invokeAll(function (t) {
        t.beforeParse && t.beforeParse(e);
      });
      const n = [];

      for (let t = 0; t < e.length; t++) e[t] instanceof i.xsS ? this.processScene(e[t]) : n.push(e[t]);

      n.length > 0 && this.processObjects(n);

      for (let e = 0; e < this.skins.length; ++e) this.processSkin(this.skins[e]);

      for (let n = 0; n < t.animations.length; ++n) this.processAnimation(t.animations[n], e[0]);

      this._invokeAll(function (t) {
        t.afterParse && t.afterParse(e);
      });
    }

    _invokeAll(e) {
      for (let t = 0, n = this.plugins.length; t < n; t++) e(this.plugins[t]);
    }

  }

  class Px {
    constructor(e) {
      this.writer = e, this.name = "KHR_lights_punctual";
    }

    writeNode(e, t) {
      if (!e.isLight) return;
      if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      const n = this.writer,
            r = n.json,
            i = n.extensionsUsed,
            s = {};
      e.name && (s.name = e.name), s.color = e.color.toArray(), s.intensity = e.intensity, e.isDirectionalLight ? s.type = "directional" : e.isPointLight ? (s.type = "point", e.distance > 0 && (s.range = e.distance)) : e.isSpotLight && (s.type = "spot", e.distance > 0 && (s.range = e.distance), s.spot = {}, s.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, s.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = {
        lights: []
      }, i[this.name] = !0);
      const o = r.extensions[this.name].lights;
      o.push(s), t.extensions = t.extensions || {}, t.extensions[this.name] = {
        light: o.length - 1
      };
    }

  }

  class Dx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_unlit";
    }

    writeMaterial(e, t) {
      if (!e.isMeshBasicMaterial) return;
      const n = this.writer.extensionsUsed;
      t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9;
    }

  }

  class Ox {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_pbrSpecularGlossiness";
    }

    writeMaterial(e, t) {
      if (!e.isGLTFSpecularGlossinessMaterial) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};
      t.pbrMetallicRoughness.baseColorFactor && (i.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor);
      const s = [1, 1, 1];

      if (e.specular.toArray(s, 0), i.specularFactor = s, i.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (i.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) {
        const t = {
          index: n.processTexture(e.specularMap)
        };
        n.applyTextureTransform(t, e.specularMap), i.specularGlossinessTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Lx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_clearcoat";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
        const t = {
          index: n.processTexture(e.clearcoatMap)
        };
        n.applyTextureTransform(t, e.clearcoatMap), i.clearcoatTexture = t;
      }

      if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
        const t = {
          index: n.processTexture(e.clearcoatRoughnessMap)
        };
        n.applyTextureTransform(t, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = t;
      }

      if (e.clearcoatNormalMap) {
        const t = {
          index: n.processTexture(e.clearcoatNormalMap)
        };
        n.applyTextureTransform(t, e.clearcoatNormalMap), i.clearcoatNormalTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Ix {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_iridescence";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
        const t = {
          index: n.processTexture(e.iridescenceMap)
        };
        n.applyTextureTransform(t, e.iridescenceMap), i.iridescenceTexture = t;
      }

      if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
        const t = {
          index: n.processTexture(e.iridescenceThicknessMap)
        };
        n.applyTextureTransform(t, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Fx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_transmission";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.transmissionFactor = e.transmission, e.transmissionMap) {
        const t = {
          index: n.processTexture(e.transmissionMap)
        };
        n.applyTextureTransform(t, e.transmissionMap), i.transmissionTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Nx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_volume";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.thicknessFactor = e.thickness, e.thicknessMap) {
        const t = {
          index: n.processTexture(e.thicknessMap)
        };
        n.applyTextureTransform(t, e.thicknessMap), i.thicknessTexture = t;
      }

      i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Ux {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_sheen";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || e.sheen < .01) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.sheenColorFactor = e.sheenColor.toArray(), e.sheenColorMap) {
        const t = {
          index: n.processTexture(e.sheenColorMap)
        };
        n.applyTextureTransform(t, e.sheenColorMap), i.sheenColorTexture = t;
      }

      if (i.sheenRoughnessFactor = e.sheenRoughness, e.sheenRoughnessMap) {
        const t = {
          index: n.processTexture(e.sheenRoughnessMap)
        };
        n.applyTextureTransform(t, e.sheenRoughnessMap), i.sheenRoughnessTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, t.extras = t.extras || {}, t.extras.sheenFactor = e.sheen, r[this.name] = !0;
    }

  }

  class Bx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_ior";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const n = this.writer.extensionsUsed,
            r = {};
      r.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
    }

  }

  yx.Utils = {
    GLTFWriter: kx,
    insertKeyframe: function (e, t) {
      const n = .001,
            r = e.getValueSize(),
            i = new e.TimeBufferType(e.times.length + 1),
            s = new e.ValueBufferType(e.values.length + r),
            o = e.createInterpolant(new e.ValueBufferType(r));
      let a;

      if (0 === e.times.length) {
        i[0] = t;

        for (let e = 0; e < r; e++) s[e] = 0;

        a = 0;
      } else if (t < e.times[0]) {
        if (Math.abs(e.times[0] - t) < n) return 0;
        i[0] = t, i.set(e.times, 1), s.set(o.evaluate(t), 0), s.set(e.values, r), a = 0;
      } else if (t > e.times[e.times.length - 1]) {
        if (Math.abs(e.times[e.times.length - 1] - t) < n) return e.times.length - 1;
        i[i.length - 1] = t, i.set(e.times, 0), s.set(e.values, 0), s.set(o.evaluate(t), e.values.length), a = i.length - 1;
      } else for (let l = 0; l < e.times.length; l++) {
        if (Math.abs(e.times[l] - t) < n) return l;

        if (e.times[l] < t && e.times[l + 1] > t) {
          i.set(e.times.slice(0, l + 1), 0), i[l + 1] = t, i.set(e.times.slice(l + 1), l + 2), s.set(e.values.slice(0, (l + 1) * r), 0), s.set(o.evaluate(t), (l + 1) * r), s.set(e.values.slice((l + 1) * r), (l + 2) * r), a = l + 1;
          break;
        }
      }

      return e.times = i, e.values = s, a;
    },
    mergeMorphTargetTracks: function (e, t) {
      const n = [],
            r = {},
            s = e.tracks;

      for (let e = 0; e < s.length; ++e) {
        let o = s[e];
        const a = i.iUV.parseTrackName(o.name),
              l = i.iUV.findNode(t, a.nodeName);

        if ("morphTargetInfluences" !== a.propertyName || void 0 === a.propertyIndex) {
          n.push(o);
          continue;
        }

        if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
          if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
          console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(i.NMF);
        }

        const c = l.morphTargetInfluences.length,
              u = l.morphTargetDictionary[a.propertyIndex];
        if (void 0 === u) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
        let p;

        if (void 0 === r[l.uuid]) {
          p = o.clone();
          const e = new p.ValueBufferType(c * p.times.length);

          for (let t = 0; t < p.times.length; t++) e[t * c + u] = p.values[t];

          p.name = (a.nodeName || "") + ".morphTargetInfluences", p.values = e, r[l.uuid] = p, n.push(p);
          continue;
        }

        const h = o.createInterpolant(new o.ValueBufferType(1));
        p = r[l.uuid];

        for (let e = 0; e < p.times.length; e++) p.values[e * c + u] = h.evaluate(p.times[e]);

        for (let e = 0; e < o.times.length; e++) {
          const t = this.insertKeyframe(p, o.times[e]);
          p.values[t * c + u] = o.values[e];
        }
      }

      return e.tracks = n, e;
    }
  };

  class jx extends yx.Utils.GLTFWriter {
    constructor() {
      super(...arguments), this._defaultMaterial = new i.Wid();
    }

    serializeUserData(e, t) {
      const n = e.userData,
            r = {};
      n.__disposed && console.error("Serializing a disposed object", e), Object.entries(n).forEach(([e, t]) => {
        (!t || "function" == typeof t || t.isObject3D || t.isTexture || t.isMaterial || null != t.assetType || e.startsWith("_") || "uuid" !== e && (lt.includes(e) || ct.includes(e) || Wt.includes(e))) && (r[e] = t, delete n[e]);
      }), super.serializeUserData(e, t), Object.entries(r).forEach(([e, t]) => {
        n[e] = t, delete r[e];
      });
    }

    processObjects(e) {
      var t;
      1 === e.length && (null === (t = e[0]) || void 0 === t ? void 0 : t.userData.rootSceneModelRoot) ? this.processScene(e[0]) : super.processObjects(e);
    }

    processMaterial(e) {
      if (this.cache.materials.has(e)) return this.cache.materials.get(e);
      let t = e;
      t.isShaderMaterial && (t = this._defaultMaterial);
      const n = super.processMaterial(t);
      if (t === e) return n;
      const r = JSON.stringify(this.json.materials[n]),
            i = JSON.parse(r);
      this.serializeUserData(e, i), this._invokeAll(t => {
        t.writeMaterial && t.writeMaterial(e, i);
      });
      const s = this.json.materials.push(i) - 1;
      return this.cache.materials.set(e, s), s;
    }

    processImageBlob(e, t) {
      if (!e) return -1;
      const n = this.cache,
            r = this.options,
            i = this.pending,
            s = this.json,
            o = t.image;
      n.images.has(o) || n.images.set(o, {});
      const a = n.images.get(o),
            l = e.type + ":flipY/" + t.flipY.toString();
      if (void 0 !== a[l]) return a[l];
      s.images || (s.images = []);
      const c = {
        mimeType: e.type
      };
      !0 === r.binary ? i.push(new Promise(t => {
        this.processBufferViewImage(e).then(e => {
          c.bufferView = e, t();
        });
      })) : i.push(vt(e).then(e => {
        c.uri = e;
      }));
      const u = s.images.push(c) - 1;
      return a[l] = u, u;
    }

    processTexture(e) {
      const t = this.cache,
            n = this.json;
      if (t.textures.has(e)) return t.textures.get(e);
      const r = e.source.data,
            i = e.userData.mimeType;
      e.userData.rootPath && !this.options.embedUrlImages && (e.source.data = null, delete e.userData.mimeType);
      const s = super.processTexture(e),
            o = n.textures[s];
      if (!o) return console.error("No texture def", s, e), s;

      if (o.extras || (o.extras = {}), o.extraes, e.userData.rootPath && !this.options.embedUrlImages) {
        if (e.source.data = r, e.userData.mimeType = i, !o) return console.error("textureDef is null", s, e), s;
        o.source >= 0 ? console.warn("textureDef.source is already set", s, e) : o.source = this.processImageUri(e.image, e.userData.rootPath, e.flipY, i);
      }

      return o.source < 0 && console.error("textureDef.source cannot be saved", o, e), s;
    }

    processImage(e, t, n, r = "image/png") {
      return e ? super.processImage(e, t, n, r) : -1;
    }

    processImageUri(e, t, n, r = "image/png") {
      const i = this.cache,
            s = this.json;
      i.images.has(e) || i.images.set(e, {});
      const o = i.images.get(e),
            a = r + ":flipY/" + n.toString();
      if (void 0 !== o[a]) return o[a];
      s.images || (s.images = []);
      const l = {
        mimeType: r,
        uri: t,
        extras: {
          flipY: n
        }
      },
            c = s.images.push(l) - 1;
      return o[a] = c, c;
    }

  }

  class zx extends yx {
    register(e) {
      return super.register(e);
    }

    async parseAsync(e, t) {
      var n;
      if (!e) throw new Error("No object to export");
      const r = e.__isGLTFOutput || !Array.isArray(e) && !e.isObject3D ? e : await new Promise((n, r) => this.parse(e, n, r, t));
      if (r && "object" == typeof r && !r.byteLength) return new Blob([JSON.stringify(r, (e, t) => e.startsWith("__") ? void 0 : t, null !== (n = t.jsonSpaces) && void 0 !== n ? n : 2)], {
        type: "model/gltf+json"
      });
      if (r) return new Blob([r], {
        type: "model/gltf+binary"
      });
      throw new Error("GLTFExporter2.parse() failed");
    }

    parse(e, t, n, r) {
      var i;
      const s = {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        externalImagesInExtras: !r.embedUrlImages && r.externalImagesInExtras || !1,
        embedUrlImages: null !== (i = r.embedUrlImages) && void 0 !== i && i,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !0
      };
      return "glb" === r.exportExt && (s.binary = !0), !1 !== r.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
        e.uuid && (e.userData.gltfUUID = e.uuid);
      })), (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
        if (e.animations) for (const t of e.animations) !1 === t.__gltfExport || s.animations.includes(t) || s.animations.push(...e.animations);
      })), super.parse(e, n => {
        !1 !== r.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
          delete e.userData.gltfUUID;
        })), t(Object.assign(n, {
          __isGLTFOutput: !0
        }));
      }, n, s, new jx());
    }

  }

  class Vx extends r {
    constructor(e, t = {}) {
      super(), this._processors = new rt(), this._cachedParsers = [], Gx(e);
    }

    get processors() {
      return this._processors;
    }

    getExporter(...e) {
      return Vx.Exporters.find(t => t.ext.some(t => e.includes(t)));
    }

    async exportObject(e, t = {}) {
      var n, r, i, s;
      if (!(null == e ? void 0 : e.assetType)) return void console.error("Object has no asset type");
      (null === (r = null === (n = e) || void 0 === n ? void 0 : n.userData) || void 0 === r ? void 0 : r.rootSceneModelRoot) && !1 === t.viewerConfig && (e.userData.__exportViewerConfig = !1);
      const o = await this._exportFile(e, t);
      return (null === (s = null === (i = e) || void 0 === i ? void 0 : i.userData) || void 0 === s ? void 0 : s.rootSceneModelRoot) && !1 === t.viewerConfig && delete e.userData.__exportViewerConfig, o;
    }

    async _exportFile(e, t = {}) {
      var n, r, i;
      let s;
      this.dispatchEvent({
        type: "exportFile",
        obj: e,
        state: "processing"
      });

      try {
        const o = await this.processBeforeExport(e, t),
              a = null !== (r = null !== (n = t.exportExt) && void 0 !== n ? n : null == o ? void 0 : o.typeExt) && void 0 !== r ? r : null == o ? void 0 : o.ext;
        if (!o || !a) throw new Error(`Unable to preprocess before export ${a}`);

        const l = this._getParser(a);

        this.dispatchEvent({
          type: "exportFile",
          obj: e,
          state: "exporting"
        });
        const c = await l.parseAsync(o.obj, {
          exportExt: null !== (i = o.ext) && void 0 !== i ? i : a,
          ...t
        });
        c.ext = o.ext, s = c;
      } catch (t) {
        return console.error("AssetExporter: Unable to Export file", e), console.error(t), void this.dispatchEvent({
          type: "exportFile",
          obj: e,
          state: "error",
          error: t
        });
      }

      return this.dispatchEvent({
        type: "exportFile",
        obj: e,
        state: "done"
      }), s;
    }

    _createParser(e) {
      const t = Vx.Exporters.find(t => t.ext.includes(e));
      if (!t) throw new Error(`No exporter found for extension ${e}`);
      const n = null == t ? void 0 : t.ctor(this);
      if (!n) throw new Error(`Unable to create parser for extension ${e}`);
      return this._cachedParsers.push({
        ext: t.ext,
        parser: n
      }), this.dispatchEvent({
        type: "exporterCreate",
        exporter: t,
        parser: n
      }), n;
    }

    _getParser(e) {
      var t, n;
      return null !== (n = null === (t = this._cachedParsers.find(t => t.ext.includes(e))) || void 0 === t ? void 0 : t.parser) && void 0 !== n ? n : this._createParser(e);
    }

    async processBeforeExport(e, t = {}) {
      switch (null != e.assetType && (e = await this._processors.process(e.assetType, e, t)), e.assetType) {
        case "light":
          return void console.error("AssetExporter: light export not implemented");

        case "model":
          return {
            obj: e,
            ext: "glb"
          };

        case "material":
          return {
            obj: e.toJSON(),
            ext: e.typeSlug || "json",
            typeExt: "json"
          };

        case "texture":
          return {
            obj: e.toJSON(),
            ext: "json"
          };

        default:
          console.error("AssetExporter: unknown asset type", e.assetType);
      }
    }

    dispose() {
      var e;
      null === (e = this._processors) || void 0 === e || e.dispose();
    }

  }

  function Gx(e, t = zx, n) {
    var r;
    if (!e) return;
    const i = Vx.Exporters.findIndex(e => e.ext.includes("gltf") || e.ext.includes("glb")),
          s = [];
    i >= 0 ? (s.push(...(null !== (r = Vx.Exporters[i].extensions) && void 0 !== r ? r : [])), Vx.Exporters.splice(i, 1)) : (s.push(Kx), s.push(Wx), s.push(Hx), s.push(e => new Xx(e)), s.push(e => new qx(e)), s.push(e => new Yx(e))), Vx.Exporters.push({
      ctor: () => {
        const r = new t();
        return s.forEach(e => r.register(e)), r.register(t => ({
          afterParse: n => {
            var r, i;
            if (!(null === (r = null == (n = Array.isArray(n) ? n[0] : n) ? void 0 : n.userData) || void 0 === r ? void 0 : r.rootSceneModelRoot) || !1 === (null === (i = null == n ? void 0 : n.userData) || void 0 === i ? void 0 : i.__exportViewerConfig)) return;
            const s = t.json.scenes[t.json.scene || 0];
            s.extensions || (s.extensions = {}), s.extensions[Yn] = bx(e, t), t.extensionsUsed[Yn] = !0;
          }
        })), null == n || n(r), r;
      },
      ext: ["gltf", "glb"],
      extensions: s
    });
  }

  Vx.Exporters = [{
    ctor: () => new gx(),
    ext: ["json"]
  }, {
    ctor: () => new vx(),
    ext: ["txt", "text"]
  }];

  const Hx = e => ({
    writeNode: (t, n) => {
      if (!(null == t ? void 0 : t.isLight)) return;
      n.extensions || (n.extensions = {});
      const r = {};
      t.shadow && (r.shadow = t.shadow.toJSON()), Object.keys(r).length > 0 && (n.extensions[Jn] = r, e.extensionsUsed[Jn] = !0);
    }
  }),
        Wx = e => ({
    writeNode: (t, n) => {
      if (!(null == t ? void 0 : t.isObject3D)) return;
      n.extensions || (n.extensions = {});
      const r = {};
      void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), !1 === t.visible && (r.visible = !1), !1 === t.frustumCulled && (r.frustumCulled = !1), 0 !== t.renderOrder && (r.renderOrder = t.renderOrder), 1 !== t.layers.mask && (r.layers = t.layers.mask), !1 === t.matrixAutoUpdate && (r.matrixAutoUpdate = !1), Object.keys(r).length > 0 && (n.extensions[$n] = r, e.extensionsUsed[$n] = !0);
    }
  }),
        Kx = e => ({
    writeMaterial(t, n) {
      var r;
      if (!(null == t ? void 0 : t.isMaterial)) return;
      n.extensions || (n.extensions = {});
      const i = {};

      if (void 0 !== t.emissiveIntensity && (null === (r = t.emissive) || void 0 === r ? void 0 : r.isColor)) {
        const e = t.emissive.clone().multiplyScalar(t.emissiveIntensity),
              n = Math.max(e.r, e.g, e.b);
        n > 1 && (i.emissiveIntensity = n);
      }

      void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped);
      const s = this.materialExternalResources[t.uuid];
      s && Object.entries(s).forEach(([e, t]) => {
        e.startsWith("_") || (i[e] = Me(t, !1, this.serializedMeta));
      }), Object.keys(i).length > 0 && (n.extensions[Qn] = i, e.extensionsUsed[Qn] = !0);
    },

    materialExternalResources: {},
    serializedMeta: {
      images: {},
      textures: {}
    },

    beforeParse(t) {
      if (this.materialExternalResources = {}, !e.options.externalImagesInExtras) return;
      const n = [];
      (Array.isArray(t) ? t : [t]).forEach(e => {
        null == e || e.traverse(e => {
          var t;
          e && (null === (t = e.material) || void 0 === t ? void 0 : t.isMaterial) && n.push(e.material);
        });
      }), n.forEach(e => {
        e && (this.materialExternalResources[e.uuid] || (this.materialExternalResources[e.uuid] = {}), this.materialExternalResources[e.uuid].__materialRef = e, Object.entries(e).forEach(([t, n]) => {
          t.startsWith("_") || n && n.isTexture && n.userData.rootPath && (e[t] = null, this.materialExternalResources[e.uuid][t] = n);
        }));
      });
    },

    afterParse(t) {
      const n = Object.values(this.materialExternalResources);
      if (n.length < 1) return;
      n.forEach(e => {
        const t = e.__materialRef;
        t && (Object.entries(e).forEach(([e, n]) => {
          e.startsWith("_") || n && (t[e] = n);
        }), delete this.materialExternalResources[t.uuid]);
      });
      const r = e.json.scenes[e.json.scene || 0];
      r.extensions || (r.extensions = {}), r.extensions[Qn] = {
        resources: this.serializedMeta
      }, e.extensionsUsed[Qn] = !0;
    }

  });

  class Xx {
    constructor(e) {
      this.writer = e, this.name = ir;
    }

    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || 0 === e.bumpScale) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.bumpScale = e.bumpScale, e.bumpMap) {
        const t = {
          index: n.processTexture(e.bumpMap)
        };
        n.applyTextureTransform(t, e.bumpMap), i.bumpTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class qx {
    constructor(e) {
      this.writer = e, this.name = or;
    }

    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || 0 === e.lightMapIntensity) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.lightMapIntensity = e.lightMapIntensity, e.bumpMap) {
        const t = {
          index: n.processTexture(e.bumpMap)
        };
        n.applyTextureTransform(t, e.bumpMap), i.lightMapTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Yx {
    constructor(e) {
      this.writer = e, this.name = sr;
    }

    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || !e.alphaMap) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (e.alphaMap) {
        const t = {
          index: n.processTexture(e.alphaMap)
        };
        n.applyTextureTransform(t, e.alphaMap), i.alphaTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Zx extends zs {
    constructor(e) {
      super(), this.enabled = !0, this.exportOptions = {
        compress: !1,
        name: "scene",
        viewerConfig: !0,
        convertMeshToIndexed: !1,
        embedUrlImages: !1
      }, this.exporter = e, this.exportScene = this.exportScene.bind(this);
    }

    async onAdded(e) {
      await super.onAdded(e), this.exporter || (this.exporter = new Vx(e)), this.exporter.processors.add("model", {
        forAssetType: "model",
        processAsync: async (e, t) => {
          var n;
          return t.convertMeshToIndexed && (null === (n = e.modelObject) || void 0 === n || n.traverse(e => {
            e.geometry && (e.geometry.attributes.index || e.userData.setGeometry(q(e.geometry)));
          })), e;
        }
      });
    }

    async onRemove(e) {
      return super.onRemove(e);
    }

    async exportScene(e) {
      var t, n;
      return null === (t = this.exporter) || void 0 === t ? void 0 : t.exportObject(null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.modelRoot, e || { ...this.exportOptions
      });
    }

    get uiConfig() {
      if (this._uiConfig) return this._uiConfig;
      const e = this._viewer;
      e.addEventListener("addPlugin", e => {
        var t;
        "function" == typeof (null === (t = e.plugin) || void 0 === t ? void 0 : t.toJSON) && console.error("Add all plugins before setting up the export UI, or use `toJSON: any = null` in the plugin ");
      });
      const t = Object.entries(e.plugins).filter(([e, t]) => "function" == typeof (null == t ? void 0 : t.toJSON)).map(([e, t]) => ({
        label: e,
        type: "checkbox",
        value: !0
      }));
      return this._uiConfig = {
        type: "folder",
        label: "Asset Exporter",
        limitedUi: !0,
        children: [{
          type: "input",
          property: [this.exportOptions, "name"],
          limitedUi: !0
        }, {
          type: "folder",
          label: "GLB Export",
          limitedUi: !0,
          children: [{
            type: "checkbox",
            label: "DRACO Compress",
            property: [this.exportOptions, "compress"],
            limitedUi: !0
          }, {
            type: "checkbox",
            label: "Scene Settings",
            property: [this.exportOptions, "viewerConfig"],
            limitedUi: !0
          }, {
            type: "checkbox",
            label: "Indexed meshes only",
            property: [this.exportOptions, "convertMeshToIndexed"]
          }, {
            type: "button",
            label: "Export GLB",
            limitedUi: !0,
            value: async () => {
              const e = await this.exportScene(this.exportOptions);
              e && gt(e, this.exportOptions.name + "." + e.ext);
            }
          }]
        }, {
          type: "folder",
          label: "Preset/Config export",
          children: [{
            type: "folder",
            label: "Plugins",
            children: t
          }, {
            type: "button",
            label: "Select none",
            value: () => {
              t.forEach(e => {
                var t;
                e.value = !1, null === (t = e.uiRefresh) || void 0 === t || t.call(e);
              });
            }
          }, {
            type: "button",
            label: "Select all",
            value: () => {
              t.forEach(e => {
                var t;
                e.value = !0, null === (t = e.uiRefresh) || void 0 === t || t.call(e);
              });
            }
          }, {
            type: "button",
            label: "Export Plugins",
            limitedUi: !0,
            value: async () => {
              const n = new Blob([JSON.stringify(e.getPlugin(js).exportPluginPresets(t.filter(e => !!e.value).map(e => x(e.label) || "")), null, 2)], {
                type: "application/json"
              });
              n && gt(n, this.exportOptions.name + "." + js.ViewerTypeSlug);
            }
          }, {
            type: "button",
            label: "Export All Viewer Config",
            limitedUi: !0,
            value: async () => {
              const t = new Blob([JSON.stringify(e.getPlugin(js).exportViewerConfig(), null, 2)], {
                type: "application/json"
              });
              t && gt(t, this.exportOptions.name + "." + js.ViewerTypeSlug);
            }
          }]
        }]
      };
    }

  }

  Zx.PluginType = "AssetExporterPlugin";

  class Jx {
    constructor() {
      this._listeners = {};
    }

    addEventListener(e, t) {
      const n = this._listeners;
      return void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t), this;
    }

    removeEventListener(e, t) {
      if (void 0 === this._listeners) return this;
      const n = this._listeners[e];

      if (void 0 !== n) {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      }

      return this;
    }

    dispatchEvent(e) {
      if (void 0 === this._listeners) return this;
      const t = this._listeners[e.type];

      if (void 0 !== t) {
        const n = t.slice(0);

        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
      }

      return this;
    }

    dispose() {
      for (const e in this._listeners) delete this._listeners[e];
    }

  }

  class $x extends Jx {
    constructor(e, t, n, r = {}) {
      if (super(), this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = !1, this._name = e, this._parent = t, this._child = n, this._attributes = r, !t.isOnGraph(n)) throw new Error("Cannot connect disconnected graphs.");
    }

    getName() {
      return this._name;
    }

    getParent() {
      return this._parent;
    }

    getChild() {
      return this._child;
    }

    setChild(e) {
      return this._child = e, this;
    }

    getAttributes() {
      return this._attributes;
    }

    dispose() {
      this._disposed || (this._disposed = !0, this.dispatchEvent({
        type: "dispose",
        target: this
      }), super.dispose());
    }

    isDisposed() {
      return this._disposed;
    }

  }

  class Qx extends Jx {
    constructor(...e) {
      super(...e), this._emptySet = new Set(), this._edges = new Set(), this._parentEdges = new Map(), this._childEdges = new Map();
    }

    listEdges() {
      return Array.from(this._edges);
    }

    listParentEdges(e) {
      return Array.from(this._childEdges.get(e) || this._emptySet);
    }

    listParents(e) {
      return this.listParentEdges(e).map(e => e.getParent());
    }

    listChildEdges(e) {
      return Array.from(this._parentEdges.get(e) || this._emptySet);
    }

    listChildren(e) {
      return this.listChildEdges(e).map(e => e.getChild());
    }

    disconnectParents(e, t) {
      let n = this.listParentEdges(e);
      return t && (n = n.filter(e => t(e.getParent()))), n.forEach(e => e.dispose()), this;
    }

    createEdge(e, t, n, r) {
      return this._registerEdge(new $x(e, t, n, r));
    }

    _registerEdge(e) {
      this._edges.add(e);

      const t = e.getParent();
      this._parentEdges.has(t) || this._parentEdges.set(t, new Set()), this._parentEdges.get(t).add(e);
      const n = e.getChild();
      return this._childEdges.has(n) || this._childEdges.set(n, new Set()), this._childEdges.get(n).add(e), e.addEventListener("dispose", () => this._removeEdge(e)), e;
    }

    _removeEdge(e) {
      return this._edges.delete(e), this._parentEdges.get(e.getParent()).delete(e), this._childEdges.get(e.getChild()).delete(e), this;
    }

  }

  function ey() {
    return ey = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }, ey.apply(this, arguments);
  }

  function ty(e) {
    return e instanceof $x;
  }

  function ny(e) {
    return Array.isArray(e) && e[0] instanceof $x;
  }

  function ry(e) {
    return !!(e && "object" == typeof e && Object.values(e)[0] instanceof $x);
  }

  const iy = Symbol("attributes"),
        sy = Symbol("immutableKeys");

  class oy extends Jx {
    constructor(e) {
      super(), this._disposed = !1, this.graph = void 0, this[iy] = void 0, this[sy] = void 0, this.graph = e, this[sy] = new Set(), this[iy] = this._createAttributes();
    }

    getDefaults() {
      return {};
    }

    _createAttributes() {
      const e = this.getDefaults(),
            t = {};

      for (const n in e) {
        const r = e[n];

        if (r instanceof oy) {
          const e = this.graph.createEdge(n, this, r);
          e.addEventListener("dispose", () => r.dispose()), this[sy].add(n), t[n] = e;
        } else t[n] = r;
      }

      return t;
    }

    isOnGraph(e) {
      return this.graph === e.graph;
    }

    isDisposed() {
      return this._disposed;
    }

    dispose() {
      this._disposed || (this.graph.listChildEdges(this).forEach(e => e.dispose()), this.graph.disconnectParents(this), this._disposed = !0, this.dispatchEvent({
        type: "dispose"
      }));
    }

    detach() {
      return this.graph.disconnectParents(this), this;
    }

    swap(e, t) {
      for (const n in this[iy]) {
        const r = this[iy][n];

        if (ty(r)) {
          const i = r;
          i.getChild() === e && this.setRef(n, t, i.getAttributes());
        } else if (ny(r)) {
          const i = r.find(t => t.getChild() === e);

          if (i) {
            const r = i.getAttributes();
            this.removeRef(n, e).addRef(n, t, r);
          }
        } else if (ry(r)) {
          const i = r;

          for (const r in i) {
            const s = i[r];
            s.getChild() === e && this.setRefMap(n, r, t, s.getAttributes());
          }
        }
      }

      return this;
    }

    get(e) {
      return this[iy][e];
    }

    set(e, t) {
      return this[iy][e] = t, this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }

    getRef(e) {
      const t = this[iy][e];
      return t ? t.getChild() : null;
    }

    setRef(e, t, n) {
      if (this[sy].has(e)) throw new Error(`Cannot overwrite immutable attribute, "${e}".`);
      const r = this[iy][e];
      if (r && r.dispose(), !t) return this;
      const i = this.graph.createEdge(e, this, t, n);
      return i.addEventListener("dispose", () => {
        delete this[iy][e], this.dispatchEvent({
          type: "change",
          attribute: e
        });
      }), this[iy][e] = i, this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }

    listRefs(e) {
      return this[iy][e].map(e => e.getChild());
    }

    addRef(e, t, n) {
      const r = this.graph.createEdge(e, this, t, n),
            i = this[iy][e];
      return i.push(r), r.addEventListener("dispose", () => {
        const t = i.filter(e => e !== r);
        i.length = 0;

        for (const e of t) i.push(e);

        this.dispatchEvent({
          type: "change",
          attribute: e
        });
      }), this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }

    removeRef(e, t) {
      return this[iy][e].filter(e => e.getChild() === t).forEach(e => e.dispose()), this;
    }

    listRefMapKeys(e) {
      return Object.keys(this[iy][e]);
    }

    listRefMapValues(e) {
      return Object.values(this[iy][e]).map(e => e.getChild());
    }

    getRefMap(e, t) {
      const n = this[iy][e];
      return n[t] ? n[t].getChild() : null;
    }

    setRefMap(e, t, n, r) {
      const i = this[iy][e],
            s = i[t];
      if (s && s.dispose(), !n) return this;
      r = Object.assign(r || {}, {
        key: t
      });
      const o = this.graph.createEdge(e, this, n, ey({}, r, {
        key: t
      }));
      return o.addEventListener("dispose", () => {
        delete i[t], this.dispatchEvent({
          type: "change",
          attribute: e,
          key: t
        });
      }), i[t] = o, this.dispatchEvent({
        type: "change",
        attribute: e,
        key: t
      });
    }

    dispatchEvent(e) {
      return super.dispatchEvent(ey({}, e, {
        target: this
      })), this.graph.dispatchEvent(ey({}, e, {
        target: this,
        type: `node:${e.type}`
      })), this;
    }

  }

  var ay,
      ly,
      cy,
      uy,
      py,
      hy,
      dy = "undefined" != typeof Float32Array ? Float32Array : Array;

  function fy(e) {
    var t = e[0],
        n = e[1],
        r = e[2];
    return Math.hypot(t, n, r);
  }

  function _y(e, t, n) {
    var r = t[0],
        i = t[1],
        s = t[2],
        o = n[3] * r + n[7] * i + n[11] * s + n[15];
    return o = o || 1, e[0] = (n[0] * r + n[4] * i + n[8] * s + n[12]) / o, e[1] = (n[1] * r + n[5] * i + n[9] * s + n[13]) / o, e[2] = (n[2] * r + n[6] * i + n[10] * s + n[14]) / o, e;
  }

  function my(e, t, n) {
    var r = t[0],
        i = t[1],
        s = t[2],
        o = t[3],
        a = t[4],
        l = t[5],
        c = t[6],
        u = t[7],
        p = t[8],
        h = t[9],
        d = t[10],
        f = t[11],
        _ = t[12],
        m = t[13],
        g = t[14],
        v = t[15],
        b = n[0],
        x = n[1],
        y = n[2],
        w = n[3];
    return e[0] = b * r + x * a + y * p + w * _, e[1] = b * i + x * l + y * h + w * m, e[2] = b * s + x * c + y * d + w * g, e[3] = b * o + x * u + y * f + w * v, b = n[4], x = n[5], y = n[6], w = n[7], e[4] = b * r + x * a + y * p + w * _, e[5] = b * i + x * l + y * h + w * m, e[6] = b * s + x * c + y * d + w * g, e[7] = b * o + x * u + y * f + w * v, b = n[8], x = n[9], y = n[10], w = n[11], e[8] = b * r + x * a + y * p + w * _, e[9] = b * i + x * l + y * h + w * m, e[10] = b * s + x * c + y * d + w * g, e[11] = b * o + x * u + y * f + w * v, b = n[12], x = n[13], y = n[14], w = n[15], e[12] = b * r + x * a + y * p + w * _, e[13] = b * i + x * l + y * h + w * m, e[14] = b * s + x * c + y * d + w * g, e[15] = b * o + x * u + y * f + w * v, e;
  }

  function gy(e, t) {
    const n = {
      min: [1 / 0, 1 / 0, 1 / 0],
      max: [-1 / 0, -1 / 0, -1 / 0]
    };

    for (const r of e.listPrimitives()) {
      const e = r.getAttribute("POSITION");
      if (!e) continue;
      let i = [0, 0, 0],
          s = [0, 0, 0];

      for (let r = 0; r < e.getCount(); r++) i = e.getElement(r, i), s = _y(s, i, t), vy(s, n);
    }

    return n;
  }

  function vy(e, t) {
    for (let n = 0; n < 3; n++) t.min[n] = Math.min(e[n], t.min[n]), t.max[n] = Math.max(e[n], t.max[n]);
  }

  Math.random, Math.PI, Math.hypot || (Math.hypot = function () {
    for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];

    return Math.sqrt(e);
  }), ay = new dy(3), dy != Float32Array && (ay[0] = 0, ay[1] = 0, ay[2] = 0), function (e) {
    e.ACCESSOR = "Accessor", e.ANIMATION = "Animation", e.ANIMATION_CHANNEL = "AnimationChannel", e.ANIMATION_SAMPLER = "AnimationSampler", e.BUFFER = "Buffer", e.CAMERA = "Camera", e.MATERIAL = "Material", e.MESH = "Mesh", e.PRIMITIVE = "Primitive", e.PRIMITIVE_TARGET = "PrimitiveTarget", e.NODE = "Node", e.ROOT = "Root", e.SCENE = "Scene", e.SKIN = "Skin", e.TEXTURE = "Texture", e.TEXTURE_INFO = "TextureInfo";
  }(ly || (ly = {})), function (e) {
    e.INTERLEAVED = "interleaved", e.SEPARATE = "separate";
  }(cy || (cy = {})), function (e) {
    e.ARRAY_BUFFER = "ARRAY_BUFFER", e.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", e.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", e.OTHER = "OTHER";
  }(uy || (uy = {})), function (e) {
    e[e.R = 4096] = "R", e[e.G = 256] = "G", e[e.B = 16] = "B", e[e.A = 1] = "A";
  }(py || (py = {})), function (e) {
    e.GLTF = "GLTF", e.GLB = "GLB";
  }(hy || (hy = {}));

  class by {
    static createBufferFromDataURI(e) {
      if ("undefined" == typeof Buffer) {
        const t = atob(e.split(",")[1]),
              n = new Uint8Array(t.length);

        for (let e = 0; e < t.length; e++) n[e] = t.charCodeAt(e);

        return n;
      }

      {
        const t = e.split(",")[1],
              n = e.indexOf("base64") >= 0;
        return Buffer.from(t, n ? "base64" : "utf8");
      }
    }

    static encodeText(e) {
      return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e) : Buffer.from(e);
    }

    static decodeText(e) {
      return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
    }

    static concat(e) {
      let t = 0;

      for (const n of e) t += n.byteLength;

      const n = new Uint8Array(t);
      let r = 0;

      for (const t of e) n.set(t, r), r += t.byteLength;

      return n;
    }

    static pad(e, t = 0) {
      const n = this.padNumber(e.byteLength);
      if (n === e.byteLength) return e;
      const r = new Uint8Array(n);
      if (r.set(e), 0 !== t) for (let i = e.byteLength; i < n; i++) r[i] = t;
      return r;
    }

    static padNumber(e) {
      return 4 * Math.ceil(e / 4);
    }

    static equals(e, t) {
      if (e === t) return !0;
      if (e.byteLength !== t.byteLength) return !1;
      let n = e.byteLength;

      for (; n--;) if (e[n] !== t[n]) return !1;

      return !0;
    }

    static toView(e, t = 0, n = 1 / 0) {
      return new Uint8Array(e.buffer, e.byteOffset + t, Math.min(e.byteLength, n));
    }

    static assertView(e) {
      if (e && !ArrayBuffer.isView(e)) throw new Error(`Method requires Uint8Array parameter; received "${typeof e}".`);
      return e;
    }

  }

  class xy {
    static hexToFactor(e, t) {
      e = Math.floor(e);
      const n = t;
      return n[0] = (e >> 16 & 255) / 255, n[1] = (e >> 8 & 255) / 255, n[2] = (255 & e) / 255, this.convertSRGBToLinear(t, t);
    }

    static factorToHex(e) {
      const t = [...e],
            [n, r, i] = this.convertLinearToSRGB(e, t);
      return 255 * n << 16 ^ 255 * r << 8 ^ 255 * i << 0;
    }

    static convertSRGBToLinear(e, t) {
      const n = e,
            r = t;

      for (let e = 0; e < 3; e++) r[e] = n[e] < .04045 ? .0773993808 * n[e] : Math.pow(.9478672986 * n[e] + .0521327014, 2.4);

      return t;
    }

    static convertLinearToSRGB(e, t) {
      const n = e,
            r = t;

      for (let e = 0; e < 3; e++) r[e] = n[e] < .0031308 ? 12.92 * n[e] : 1.055 * Math.pow(n[e], .41666) - .055;

      return t;
    }

  }

  class yy {
    match(e) {
      return e.length >= 8 && 137 === e[0] && 80 === e[1] && 78 === e[2] && 71 === e[3] && 13 === e[4] && 10 === e[5] && 26 === e[6] && 10 === e[7];
    }

    getSize(e) {
      const t = new DataView(e.buffer, e.byteOffset);
      return by.decodeText(e.slice(12, 16)) === yy.PNG_FRIED_CHUNK_NAME ? [t.getUint32(32, !1), t.getUint32(36, !1)] : [t.getUint32(16, !1), t.getUint32(20, !1)];
    }

    getChannels(e) {
      return 4;
    }

  }

  yy.PNG_FRIED_CHUNK_NAME = "CgBI";

  class wy {
    static registerFormat(e, t) {
      this.impls[e] = t;
    }

    static getMimeType(e) {
      for (const t in this.impls) if (this.impls[t].match(e)) return t;

      return null;
    }

    static getSize(e, t) {
      return this.impls[t] ? this.impls[t].getSize(e) : null;
    }

    static getChannels(e, t) {
      return this.impls[t] ? this.impls[t].getChannels(e) : null;
    }

    static getMemSize(e, t) {
      if (!this.impls[t]) return null;
      if (this.impls[t].getGPUByteLength) return this.impls[t].getGPUByteLength(e);
      let n = 0;
      const r = this.getSize(e, t);
      if (!r) return null;

      for (; r[0] > 1 || r[1] > 1;) n += r[0] * r[1] * 4, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);

      return n += 4, n;
    }

    static mimeTypeToExtension(e) {
      return "image/jpeg" === e ? "jpg" : e.split("/").pop();
    }

    static extensionToMimeType(e) {
      return "jpg" === e ? "image/jpeg" : `image/${e}`;
    }

  }

  function Sy(e, t) {
    if (t > e.byteLength) throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (255 !== e.getUint8(t)) throw new TypeError("Invalid JPG, marker table corrupted");
    return e;
  }

  wy.impls = {
    "image/jpeg": new class {
      match(e) {
        return e.length >= 3 && 255 === e[0] && 216 === e[1] && 255 === e[2];
      }

      getSize(e) {
        let t,
            n,
            r = new DataView(e.buffer, e.byteOffset + 4);

        for (; r.byteLength;) {
          if (t = r.getUint16(0, !1), Sy(r, t), n = r.getUint8(t + 1), 192 === n || 193 === n || 194 === n) return [r.getUint16(t + 7, !1), r.getUint16(t + 5, !1)];
          r = new DataView(e.buffer, r.byteOffset + t + 2);
        }

        throw new TypeError("Invalid JPG, no size found");
      }

      getChannels(e) {
        return 3;
      }

    }(),
    "image/png": new yy()
  };

  class My {
    static basename(e) {
      const t = e.split(/[\\/]/).pop();
      return t.substring(0, t.lastIndexOf("."));
    }

    static extension(e) {
      if (e.startsWith("data:image/")) {
        const t = e.match(/data:(image\/\w+)/)[1];
        return wy.mimeTypeToExtension(t);
      }

      return e.startsWith("data:model/gltf+json") ? "gltf" : e.startsWith("data:model/gltf-binary") ? "glb" : e.startsWith("data:application/") ? "bin" : e.split(/[\\/]/).pop().split(/[.]/).pop();
    }

  }

  function Ty(e) {
    return "[object Object]" === Object.prototype.toString.call(e);
  }

  function Ey(e) {
    if (!1 === Ty(e)) return !1;
    const t = e.constructor;
    if (void 0 === t) return !0;
    const n = t.prototype;
    return !1 !== Ty(n) && !1 !== Object.prototype.hasOwnProperty.call(n, "isPrototypeOf");
  }

  class Ay {
    constructor(e) {
      this.verbosity = void 0, this.verbosity = e;
    }

    debug(e) {
      this.verbosity <= Ay.Verbosity.DEBUG && console.debug(e);
    }

    info(e) {
      this.verbosity <= Ay.Verbosity.INFO && console.info(e);
    }

    warn(e) {
      this.verbosity <= Ay.Verbosity.WARN && console.warn(e);
    }

    error(e) {
      this.verbosity <= Ay.Verbosity.ERROR && console.error(e);
    }

  }

  Ay.Verbosity = {
    SILENT: 4,
    ERROR: 3,
    WARN: 2,
    INFO: 1,
    DEBUG: 0
  }, Ay.DEFAULT_INSTANCE = new Ay(Ay.Verbosity.INFO);

  class Cy {
    static identity(e) {
      return e;
    }

    static eq(e, t) {
      if (e.length !== t.length) return !1;

      for (let n = 0; n < e.length; n++) if (Math.abs(e[n] - t[n]) > 1e-5) return !1;

      return !0;
    }

    static denormalize(e, t) {
      switch (t) {
        case 5126:
          return e;

        case 5123:
          return e / 65535;

        case 5121:
          return e / 255;

        case 5122:
          return Math.max(e / 32767, -1);

        case 5120:
          return Math.max(e / 127, -1);

        default:
          throw new Error("Invalid component type.");
      }
    }

    static normalize(e, t) {
      switch (t) {
        case 5126:
          return e;

        case 5123:
          return Math.round(65535 * e);

        case 5121:
          return Math.round(255 * e);

        case 5122:
          return Math.round(32767 * e);

        case 5120:
          return Math.round(127 * e);

        default:
          throw new Error("Invalid component type.");
      }
    }

    static decompose(e, t, n, r) {
      let i = fy([e[0], e[1], e[2]]);
      const s = fy([e[4], e[5], e[6]]),
            o = fy([e[8], e[9], e[10]]);
      (function (e) {
        var t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8],
            u = e[9],
            p = e[10],
            h = e[11],
            d = e[12],
            f = e[13],
            _ = e[14],
            m = e[15];
        return (t * o - n * s) * (p * m - h * _) - (t * a - r * s) * (u * m - h * f) + (t * l - i * s) * (u * _ - p * f) + (n * a - r * o) * (c * m - h * d) - (n * l - i * o) * (c * _ - p * d) + (r * l - i * a) * (c * f - u * d);
      })(e) < 0 && (i = -i), t[0] = e[12], t[1] = e[13], t[2] = e[14];
      const a = e.slice(),
            l = 1 / i,
            c = 1 / s,
            u = 1 / o;
      a[0] *= l, a[1] *= l, a[2] *= l, a[4] *= c, a[5] *= c, a[6] *= c, a[8] *= u, a[9] *= u, a[10] *= u, function (e, t) {
        var n = new dy(3);
        !function (e, t) {
          var n = t[0],
              r = t[1],
              i = t[2],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[8],
              c = t[9],
              u = t[10];
          e[0] = Math.hypot(n, r, i), e[1] = Math.hypot(s, o, a), e[2] = Math.hypot(l, c, u);
        }(n, t);

        var r = 1 / n[0],
            i = 1 / n[1],
            s = 1 / n[2],
            o = t[0] * r,
            a = t[1] * i,
            l = t[2] * s,
            c = t[4] * r,
            u = t[5] * i,
            p = t[6] * s,
            h = t[8] * r,
            d = t[9] * i,
            f = t[10] * s,
            _ = o + u + f,
            m = 0;

        _ > 0 ? (m = 2 * Math.sqrt(_ + 1), e[3] = .25 * m, e[0] = (p - d) / m, e[1] = (h - l) / m, e[2] = (a - c) / m) : o > u && o > f ? (m = 2 * Math.sqrt(1 + o - u - f), e[3] = (p - d) / m, e[0] = .25 * m, e[1] = (a + c) / m, e[2] = (h + l) / m) : u > f ? (m = 2 * Math.sqrt(1 + u - o - f), e[3] = (h - l) / m, e[0] = (a + c) / m, e[1] = .25 * m, e[2] = (p + d) / m) : (m = 2 * Math.sqrt(1 + f - o - u), e[3] = (a - c) / m, e[0] = (h + l) / m, e[1] = (p + d) / m, e[2] = .25 * m);
      }(n, a), r[0] = i, r[1] = s, r[2] = o;
    }

    static compose(e, t, n, r) {
      const i = r,
            s = t[0],
            o = t[1],
            a = t[2],
            l = t[3],
            c = s + s,
            u = o + o,
            p = a + a,
            h = s * c,
            d = s * u,
            f = s * p,
            _ = o * u,
            m = o * p,
            g = a * p,
            v = l * c,
            b = l * u,
            x = l * p,
            y = n[0],
            w = n[1],
            S = n[2];

      return i[0] = (1 - (_ + g)) * y, i[1] = (d + x) * y, i[2] = (f - b) * y, i[3] = 0, i[4] = (d - x) * w, i[5] = (1 - (h + g)) * w, i[6] = (m + v) * w, i[7] = 0, i[8] = (f + b) * S, i[9] = (m - v) * S, i[10] = (1 - (h + _)) * S, i[11] = 0, i[12] = e[0], i[13] = e[1], i[14] = e[2], i[15] = 1, i;
    }

  }

  function Ry(e, t) {
    if (!!e != !!t) return !1;
    const n = e.getChild(),
          r = t.getChild();
    return n === r || n.equals(r);
  }

  function ky(e, t) {
    if (!!e != !!t) return !1;
    if (e.length !== t.length) return !1;

    for (let n = 0; n < e.length; n++) {
      const r = e[n],
            i = t[n];
      if (r.getChild() !== i.getChild() && !r.getChild().equals(i.getChild())) return !1;
    }

    return !0;
  }

  function Py(e, t) {
    if (!!e != !!t) return !1;
    const n = Object.keys(e),
          r = Object.keys(t);
    if (n.length !== r.length) return !1;

    for (const n in e) {
      const r = e[n],
            i = t[n];
      if (!!r != !!i) return !1;
      const s = r.getChild(),
            o = i.getChild();
      if (s !== o && !s.equals(o)) return !1;
    }

    return !0;
  }

  function Dy(e, t) {
    if (e === t) return !0;
    if (!!e != !!t || !e || !t) return !1;
    if (e.length !== t.length) return !1;

    for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;

    return !0;
  }

  function Oy(e, t) {
    if (e === t) return !0;
    if (!!e != !!t) return !1;
    if (!Ey(e) || !Ey(t)) return e === t;
    const n = e,
          r = t;
    let i,
        s = 0,
        o = 0;

    for (i in n) s++;

    for (i in r) o++;

    if (s !== o) return !1;

    for (i in n) {
      const e = n[i],
            t = r[i];

      if (Ly(e) && Ly(t)) {
        if (!Dy(e, t)) return !1;
      } else if (Ey(e) && Ey(t)) {
        if (!Oy(e, t)) return !1;
      } else if (e !== t) return !1;
    }

    return !0;
  }

  function Ly(e) {
    return Array.isArray(e) || ArrayBuffer.isView(e);
  }

  const Iy = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ",
        Fy = new Set(),
        Ny = function () {
    let e = "";

    for (let t = 0; t < 6; t++) e += Iy.charAt(Math.floor(Math.random() * Iy.length));

    return e;
  };

  class Uy {
    static dirname(e) {
      const t = e.lastIndexOf("/");
      return -1 === t ? "./" : e.substring(0, t + 1);
    }

    static basename(e) {
      return My.basename(new URL(e, "https://null.example").pathname);
    }

    static extension(e) {
      return My.extension(new URL(e, "https://null.example").pathname);
    }

    static resolve(e, t) {
      if (!this.isRelativePath(t)) return t;
      const n = e.split("/"),
            r = t.split("/");
      n.pop();

      for (let e = 0; e < r.length; e++) "." !== r[e] && (".." === r[e] ? n.pop() : n.push(r[e]));

      return n.join("/");
    }

    static isAbsoluteURL(e) {
      return this.PROTOCOL_REGEXP.test(e);
    }

    static isRelativePath(e) {
      return !/^(?:[a-zA-Z]+:)?\//.test(e);
    }

  }

  Uy.DEFAULT_INIT = {}, Uy.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;

  const By = e => e;

  class jy extends oy {
    constructor(e, t = "") {
      super(e), this[iy].name = t, this.init(), this.dispatchEvent({
        type: "create"
      });
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        name: "",
        extras: {}
      });
    }

    getName() {
      return this.get("name");
    }

    setName(e) {
      return this.set("name", e);
    }

    getExtras() {
      return this.get("extras");
    }

    setExtras(e) {
      return this.set("extras", e);
    }

    clone() {
      return new (0, this.constructor)(this.graph).copy(this, By);
    }

    copy(e, t = By) {
      for (const e in this[iy]) {
        const t = this[iy][e];
        if (t instanceof $x) this[sy].has(e) || t.dispose();else if (Array.isArray(t) && t[0] instanceof $x) for (const e of t) e.dispose();else if (Ey(t) && Object.values(t)[0] instanceof $x) for (const e in t) t[e].dispose();
      }

      for (const n in e[iy]) {
        const r = this[iy][n],
              i = e[iy][n];
        if (i instanceof $x) this[sy].has(n) ? r.getChild().copy(t(i.getChild()), t) : this.setRef(n, t(i.getChild()), i.getAttributes());else if (Array.isArray(i) && i[0] instanceof $x) for (const e of i) this.addRef(n, t(e.getChild()), e.getAttributes());else if (Ey(i) && Object.values(i)[0] instanceof $x) for (const e in i) {
          const r = i[e];
          this.setRefMap(n, e, t(r.getChild()), r.getAttributes());
        } else this[iy][n] = Ey(i) ? JSON.parse(JSON.stringify(i)) : Array.isArray(i) || i instanceof ArrayBuffer || ArrayBuffer.isView(i) ? i.slice() : i;
      }

      return this;
    }

    equals(e) {
      if (this === e) return !0;
      if (this.propertyType !== e.propertyType) return !1;

      for (const t in this[iy]) {
        const n = this[iy][t],
              r = e[iy][t];

        if (ty(n) || ty(r)) {
          if (!Ry(n, r)) return !1;
        } else if (ny(n) || ny(r)) {
          if (!ky(n, r)) return !1;
        } else if (ry(n) || ry(r)) {
          if (!Py(n, r)) return !1;
        } else if (Ey(n) || Ey(r)) {
          if (!Oy(n, r)) return !1;
        } else if (Ly(n) || Ly(r)) {
          if (!Dy(n, r)) return !1;
        } else if (n !== r) return !1;
      }

      return !0;
    }

    detach() {
      return this.graph.disconnectParents(this, e => "Root" !== e.propertyType), this;
    }

    listParents() {
      return this.graph.listParents(this);
    }

  }

  class zy extends jy {
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        extensions: {}
      });
    }

    getExtension(e) {
      return this.getRefMap("extensions", e);
    }

    setExtension(e, t) {
      return t && t.t(this), this.setRefMap("extensions", e, t);
    }

    listExtensions() {
      return this.listRefMapValues("extensions");
    }

  }

  class Vy extends zy {
    constructor(...e) {
      super(...e), this.i = Cy.identity, this.o = Cy.identity;
    }

    init() {
      this.propertyType = ly.ACCESSOR;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        array: null,
        type: Vy.Type.SCALAR,
        componentType: Vy.ComponentType.FLOAT,
        normalized: !1,
        buffer: null
      });
    }

    copy(e, t = By) {
      return super.copy(e, t), this.i = e.i, this.o = e.o, this;
    }

    static getElementSize(e) {
      switch (e) {
        case Vy.Type.SCALAR:
          return 1;

        case Vy.Type.VEC2:
          return 2;

        case Vy.Type.VEC3:
          return 3;

        case Vy.Type.VEC4:
        case Vy.Type.MAT2:
          return 4;

        case Vy.Type.MAT3:
          return 9;

        case Vy.Type.MAT4:
          return 16;

        default:
          throw new Error("Unexpected type: " + e);
      }
    }

    static getComponentSize(e) {
      switch (e) {
        case Vy.ComponentType.BYTE:
        case Vy.ComponentType.UNSIGNED_BYTE:
          return 1;

        case Vy.ComponentType.SHORT:
        case Vy.ComponentType.UNSIGNED_SHORT:
          return 2;

        case Vy.ComponentType.UNSIGNED_INT:
        case Vy.ComponentType.FLOAT:
          return 4;

        default:
          throw new Error("Unexpected component type: " + e);
      }
    }

    getMinNormalized(e) {
      const t = this.getElementSize();
      this.getMin(e);

      for (let n = 0; n < t; n++) e[n] = this.o(e[n]);

      return e;
    }

    getMin(e) {
      const t = this.get("array"),
            n = this.getCount(),
            r = this.getElementSize();

      for (let t = 0; t < r; t++) e[t] = 1 / 0;

      for (let i = 0; i < n * r; i += r) for (let n = 0; n < r; n++) {
        const r = t[i + n];
        Number.isFinite(r) && (e[n] = Math.min(e[n], r));
      }

      return e;
    }

    getMaxNormalized(e) {
      const t = this.getElementSize();
      this.getMax(e);

      for (let n = 0; n < t; n++) e[n] = this.o(e[n]);

      return e;
    }

    getMax(e) {
      const t = this.get("array"),
            n = this.getCount(),
            r = this.getElementSize();

      for (let t = 0; t < r; t++) e[t] = -1 / 0;

      for (let i = 0; i < n * r; i += r) for (let n = 0; n < r; n++) {
        const r = t[i + n];
        Number.isFinite(r) && (e[n] = Math.max(e[n], r));
      }

      return e;
    }

    getCount() {
      const e = this.get("array");
      return e ? e.length / this.getElementSize() : 0;
    }

    getType() {
      return this.get("type");
    }

    setType(e) {
      return this.set("type", e);
    }

    getElementSize() {
      return Vy.getElementSize(this.get("type"));
    }

    getComponentSize() {
      return this.get("array").BYTES_PER_ELEMENT;
    }

    getComponentType() {
      return this.get("componentType");
    }

    getNormalized() {
      return this.get("normalized");
    }

    setNormalized(e) {
      return this.set("normalized", e), e ? (this.o = e => Cy.denormalize(e, this.get("componentType")), this.i = e => Cy.normalize(e, this.get("componentType"))) : (this.o = Cy.identity, this.i = Cy.identity), this;
    }

    getScalar(e) {
      const t = this.getElementSize();
      return this.o(this.get("array")[e * t]);
    }

    setScalar(e, t) {
      return this.get("array")[e * this.getElementSize()] = this.i(t), this;
    }

    getElement(e, t) {
      const n = this.getElementSize(),
            r = this.get("array");

      for (let i = 0; i < n; i++) t[i] = this.o(r[e * n + i]);

      return t;
    }

    setElement(e, t) {
      const n = this.getElementSize(),
            r = this.get("array");

      for (let i = 0; i < n; i++) r[e * n + i] = this.i(t[i]);

      return this;
    }

    getBuffer() {
      return this.getRef("buffer");
    }

    setBuffer(e) {
      return this.setRef("buffer", e);
    }

    getArray() {
      return this.get("array");
    }

    setArray(e) {
      return this.set("componentType", e ? function (e) {
        switch (e.constructor) {
          case Float32Array:
            return Vy.ComponentType.FLOAT;

          case Uint32Array:
            return Vy.ComponentType.UNSIGNED_INT;

          case Uint16Array:
            return Vy.ComponentType.UNSIGNED_SHORT;

          case Uint8Array:
            return Vy.ComponentType.UNSIGNED_BYTE;

          case Int16Array:
            return Vy.ComponentType.SHORT;

          case Int8Array:
            return Vy.ComponentType.BYTE;

          default:
            throw new Error("Unknown accessor componentType.");
        }
      }(e) : Vy.ComponentType.FLOAT), this.set("array", e), this;
    }

    getByteLength() {
      const e = this.get("array");
      return e ? e.byteLength : 0;
    }

  }

  Vy.Type = {
    SCALAR: "SCALAR",
    VEC2: "VEC2",
    VEC3: "VEC3",
    VEC4: "VEC4",
    MAT2: "MAT2",
    MAT3: "MAT3",
    MAT4: "MAT4"
  }, Vy.ComponentType = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_INT: 5125,
    FLOAT: 5126
  };

  class Gy extends zy {
    init() {
      this.propertyType = ly.ANIMATION;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        channels: [],
        samplers: []
      });
    }

    addChannel(e) {
      return this.addRef("channels", e);
    }

    removeChannel(e) {
      return this.removeRef("channels", e);
    }

    listChannels() {
      return this.listRefs("channels");
    }

    addSampler(e) {
      return this.addRef("samplers", e);
    }

    removeSampler(e) {
      return this.removeRef("samplers", e);
    }

    listSamplers() {
      return this.listRefs("samplers");
    }

  }

  class Hy extends zy {
    init() {
      this.propertyType = ly.ANIMATION_CHANNEL;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        targetPath: null,
        targetNode: null,
        sampler: null
      });
    }

    getTargetPath() {
      return this.get("targetPath");
    }

    setTargetPath(e) {
      return this.set("targetPath", e);
    }

    getTargetNode() {
      return this.getRef("targetNode");
    }

    setTargetNode(e) {
      return this.setRef("targetNode", e);
    }

    getSampler() {
      return this.getRef("sampler");
    }

    setSampler(e) {
      return this.setRef("sampler", e);
    }

  }

  Hy.TargetPath = {
    TRANSLATION: "translation",
    ROTATION: "rotation",
    SCALE: "scale",
    WEIGHTS: "weights"
  };

  class Wy extends zy {
    init() {
      this.propertyType = ly.ANIMATION_SAMPLER;
    }

    getDefaultAttributes() {
      return Object.assign(super.getDefaults(), {
        interpolation: Wy.Interpolation.LINEAR,
        input: null,
        output: null
      });
    }

    getInterpolation() {
      return this.get("interpolation");
    }

    setInterpolation(e) {
      return this.set("interpolation", e);
    }

    getInput() {
      return this.getRef("input");
    }

    setInput(e) {
      return this.setRef("input", e, {
        usage: uy.OTHER
      });
    }

    getOutput() {
      return this.getRef("output");
    }

    setOutput(e) {
      return this.setRef("output", e, {
        usage: uy.OTHER
      });
    }

  }

  Wy.Interpolation = {
    LINEAR: "LINEAR",
    STEP: "STEP",
    CUBICSPLINE: "CUBICSPLINE"
  };

  class Ky extends zy {
    init() {
      this.propertyType = ly.BUFFER;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        uri: ""
      });
    }

    getURI() {
      return this.get("uri");
    }

    setURI(e) {
      return this.set("uri", e);
    }

  }

  class Xy extends zy {
    init() {
      this.propertyType = ly.CAMERA;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        type: Xy.Type.PERSPECTIVE,
        znear: .1,
        zfar: 100,
        aspectRatio: null,
        yfov: 2 * Math.PI * 50 / 360,
        xmag: 1,
        ymag: 1
      });
    }

    getType() {
      return this.get("type");
    }

    setType(e) {
      return this.set("type", e);
    }

    getZNear() {
      return this.get("znear");
    }

    setZNear(e) {
      return this.set("znear", e);
    }

    getZFar() {
      return this.get("zfar");
    }

    setZFar(e) {
      return this.set("zfar", e);
    }

    getAspectRatio() {
      return this.get("aspectRatio");
    }

    setAspectRatio(e) {
      return this.set("aspectRatio", e);
    }

    getYFov() {
      return this.get("yfov");
    }

    setYFov(e) {
      return this.set("yfov", e);
    }

    getXMag() {
      return this.get("xmag");
    }

    setXMag(e) {
      return this.set("xmag", e);
    }

    getYMag() {
      return this.get("ymag");
    }

    setYMag(e) {
      return this.set("ymag", e);
    }

  }

  Xy.Type = {
    PERSPECTIVE: "perspective",
    ORTHOGRAPHIC: "orthographic"
  };

  class qy extends jy {
    t(e) {
      if (!this.parentTypes.includes(e.propertyType)) throw new Error(`Parent "${e.propertyType}" invalid for child "${this.propertyType}".`);
    }

  }

  qy.EXTENSION_NAME = void 0;

  class Yy extends zy {
    init() {
      this.propertyType = ly.TEXTURE_INFO;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        texCoord: 0,
        magFilter: null,
        minFilter: null,
        wrapS: Yy.WrapMode.REPEAT,
        wrapT: Yy.WrapMode.REPEAT
      });
    }

    getTexCoord() {
      return this.get("texCoord");
    }

    setTexCoord(e) {
      return this.set("texCoord", e);
    }

    getMagFilter() {
      return this.get("magFilter");
    }

    setMagFilter(e) {
      return this.set("magFilter", e);
    }

    getMinFilter() {
      return this.get("minFilter");
    }

    setMinFilter(e) {
      return this.set("minFilter", e);
    }

    getWrapS() {
      return this.get("wrapS");
    }

    setWrapS(e) {
      return this.set("wrapS", e);
    }

    getWrapT() {
      return this.get("wrapT");
    }

    setWrapT(e) {
      return this.set("wrapT", e);
    }

  }

  Yy.WrapMode = {
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
  }, Yy.MagFilter = {
    NEAREST: 9728,
    LINEAR: 9729
  }, Yy.MinFilter = {
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987
  };
  const {
    R: Zy,
    G: Jy,
    B: $y,
    A: Qy
  } = py;

  class ew extends zy {
    init() {
      this.propertyType = ly.MATERIAL;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        alphaMode: ew.AlphaMode.OPAQUE,
        alphaCutoff: .5,
        doubleSided: !1,
        baseColorFactor: [1, 1, 1, 1],
        baseColorTexture: null,
        baseColorTextureInfo: new Yy(this.graph, "baseColorTextureInfo"),
        emissiveFactor: [0, 0, 0],
        emissiveTexture: null,
        emissiveTextureInfo: new Yy(this.graph, "emissiveTextureInfo"),
        normalScale: 1,
        normalTexture: null,
        normalTextureInfo: new Yy(this.graph, "normalTextureInfo"),
        occlusionStrength: 1,
        occlusionTexture: null,
        occlusionTextureInfo: new Yy(this.graph, "occlusionTextureInfo"),
        roughnessFactor: 1,
        metallicFactor: 1,
        metallicRoughnessTexture: null,
        metallicRoughnessTextureInfo: new Yy(this.graph, "metallicRoughnessTextureInfo")
      });
    }

    getDoubleSided() {
      return this.get("doubleSided");
    }

    setDoubleSided(e) {
      return this.set("doubleSided", e);
    }

    getAlpha() {
      return this.get("baseColorFactor")[3];
    }

    setAlpha(e) {
      const t = this.get("baseColorFactor").slice();
      return t[3] = e, this.set("baseColorFactor", t);
    }

    getAlphaMode() {
      return this.get("alphaMode");
    }

    setAlphaMode(e) {
      return this.set("alphaMode", e);
    }

    getAlphaCutoff() {
      return this.get("alphaCutoff");
    }

    setAlphaCutoff(e) {
      return this.set("alphaCutoff", e);
    }

    getBaseColorFactor() {
      return this.get("baseColorFactor");
    }

    setBaseColorFactor(e) {
      return this.set("baseColorFactor", e);
    }

    getBaseColorHex() {
      return xy.factorToHex(this.get("baseColorFactor"));
    }

    setBaseColorHex(e) {
      const t = this.get("baseColorFactor").slice();
      return this.set("baseColorFactor", xy.hexToFactor(e, t));
    }

    getBaseColorTexture() {
      return this.getRef("baseColorTexture");
    }

    getBaseColorTextureInfo() {
      return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
    }

    setBaseColorTexture(e) {
      return this.setRef("baseColorTexture", e, {
        channels: Zy | Jy | $y | Qy
      });
    }

    getEmissiveFactor() {
      return this.get("emissiveFactor");
    }

    setEmissiveFactor(e) {
      return this.set("emissiveFactor", e);
    }

    getEmissiveHex() {
      return xy.factorToHex(this.get("emissiveFactor"));
    }

    setEmissiveHex(e) {
      const t = this.get("emissiveFactor").slice();
      return this.set("emissiveFactor", xy.hexToFactor(e, t));
    }

    getEmissiveTexture() {
      return this.getRef("emissiveTexture");
    }

    getEmissiveTextureInfo() {
      return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
    }

    setEmissiveTexture(e) {
      return this.setRef("emissiveTexture", e, {
        channels: Zy | Jy | $y
      });
    }

    getNormalScale() {
      return this.get("normalScale");
    }

    setNormalScale(e) {
      return this.set("normalScale", e);
    }

    getNormalTexture() {
      return this.getRef("normalTexture");
    }

    getNormalTextureInfo() {
      return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
    }

    setNormalTexture(e) {
      return this.setRef("normalTexture", e, {
        channels: Zy | Jy | $y
      });
    }

    getOcclusionStrength() {
      return this.get("occlusionStrength");
    }

    setOcclusionStrength(e) {
      return this.set("occlusionStrength", e);
    }

    getOcclusionTexture() {
      return this.getRef("occlusionTexture");
    }

    getOcclusionTextureInfo() {
      return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
    }

    setOcclusionTexture(e) {
      return this.setRef("occlusionTexture", e, {
        channels: Zy
      });
    }

    getRoughnessFactor() {
      return this.get("roughnessFactor");
    }

    setRoughnessFactor(e) {
      return this.set("roughnessFactor", e);
    }

    getMetallicFactor() {
      return this.get("metallicFactor");
    }

    setMetallicFactor(e) {
      return this.set("metallicFactor", e);
    }

    getMetallicRoughnessTexture() {
      return this.getRef("metallicRoughnessTexture");
    }

    getMetallicRoughnessTextureInfo() {
      return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
    }

    setMetallicRoughnessTexture(e) {
      return this.setRef("metallicRoughnessTexture", e, {
        channels: Jy | $y
      });
    }

  }

  ew.AlphaMode = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };

  class tw extends zy {
    init() {
      this.propertyType = ly.MESH;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        weights: [],
        primitives: []
      });
    }

    addPrimitive(e) {
      return this.addRef("primitives", e);
    }

    removePrimitive(e) {
      return this.removeRef("primitives", e);
    }

    listPrimitives() {
      return this.listRefs("primitives");
    }

    getWeights() {
      return this.get("weights");
    }

    setWeights(e) {
      return this.set("weights", e);
    }

  }

  class nw extends zy {
    constructor(...e) {
      super(...e), this.u = null;
    }

    init() {
      this.propertyType = ly.NODE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        translation: [0, 0, 0],
        rotation: [0, 0, 0, 1],
        scale: [1, 1, 1],
        weights: [],
        camera: null,
        mesh: null,
        skin: null,
        children: []
      });
    }

    copy(e, t = By) {
      if (t === By) throw new Error("Node cannot be copied.");
      return super.copy(e, t);
    }

    getTranslation() {
      return this.get("translation");
    }

    getRotation() {
      return this.get("rotation");
    }

    getScale() {
      return this.get("scale");
    }

    setTranslation(e) {
      return this.set("translation", e);
    }

    setRotation(e) {
      return this.set("rotation", e);
    }

    setScale(e) {
      return this.set("scale", e);
    }

    getMatrix() {
      return Cy.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
    }

    setMatrix(e) {
      const t = this.get("translation").slice(),
            n = this.get("rotation").slice(),
            r = this.get("scale").slice();
      return Cy.decompose(e, t, n, r), this.set("translation", t).set("rotation", n).set("scale", r);
    }

    getWorldTranslation() {
      const e = [0, 0, 0];
      return Cy.decompose(this.getWorldMatrix(), e, [0, 0, 0, 1], [1, 1, 1]), e;
    }

    getWorldRotation() {
      const e = [0, 0, 0, 1];
      return Cy.decompose(this.getWorldMatrix(), [0, 0, 0], e, [1, 1, 1]), e;
    }

    getWorldScale() {
      const e = [1, 1, 1];
      return Cy.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], e), e;
    }

    getWorldMatrix() {
      const e = [];

      for (let t = this; t instanceof nw; t = t.u) e.push(t);

      let t;
      const n = e.pop().getMatrix();

      for (; t = e.pop();) my(n, n, t.getMatrix());

      return n;
    }

    addChild(e) {
      e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
      const t = this[iy].children;
      return t[t.length - 1].addEventListener("dispose", () => e.u = null), this;
    }

    removeChild(e) {
      return this.removeRef("children", e);
    }

    listChildren() {
      return this.listRefs("children");
    }

    getParent() {
      return this.u;
    }

    getMesh() {
      return this.getRef("mesh");
    }

    setMesh(e) {
      return this.setRef("mesh", e);
    }

    getCamera() {
      return this.getRef("camera");
    }

    setCamera(e) {
      return this.setRef("camera", e);
    }

    getSkin() {
      return this.getRef("skin");
    }

    setSkin(e) {
      return this.setRef("skin", e);
    }

    getWeights() {
      return this.get("weights");
    }

    setWeights(e) {
      return this.set("weights", e);
    }

    traverse(e) {
      e(this);

      for (const t of this.listChildren()) t.traverse(e);

      return this;
    }

  }

  class rw extends zy {
    init() {
      this.propertyType = ly.PRIMITIVE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        mode: rw.Mode.TRIANGLES,
        material: null,
        indices: null,
        attributes: {},
        targets: []
      });
    }

    getIndices() {
      return this.getRef("indices");
    }

    setIndices(e) {
      return this.setRef("indices", e, {
        usage: uy.ELEMENT_ARRAY_BUFFER
      });
    }

    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }

    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: uy.ARRAY_BUFFER
      });
    }

    listAttributes() {
      return this.listRefMapValues("attributes");
    }

    listSemantics() {
      return this.listRefMapKeys("attributes");
    }

    getMaterial() {
      return this.getRef("material");
    }

    setMaterial(e) {
      return this.setRef("material", e);
    }

    getMode() {
      return this.get("mode");
    }

    setMode(e) {
      return this.set("mode", e);
    }

    listTargets() {
      return this.listRefs("targets");
    }

    addTarget(e) {
      return this.addRef("targets", e);
    }

    removeTarget(e) {
      return this.removeRef("targets", e);
    }

  }

  rw.Mode = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };

  class iw extends jy {
    init() {
      this.propertyType = ly.PRIMITIVE_TARGET;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        attributes: {}
      });
    }

    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }

    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: uy.ARRAY_BUFFER
      });
    }

    listAttributes() {
      return this.listRefMapValues("attributes");
    }

    listSemantics() {
      return this.listRefMapKeys("attributes");
    }

  }

  function sw() {
    return (sw = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }).apply(this, arguments);
  }

  class ow extends zy {
    init() {
      this.propertyType = ly.SCENE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        children: []
      });
    }

    copy(e, t = By) {
      if (t === By) throw new Error("Scene cannot be copied.");
      return super.copy(e, t);
    }

    addChild(e) {
      e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
      const t = this[iy].children;
      return t[t.length - 1].addEventListener("dispose", () => e.u = null), this;
    }

    removeChild(e) {
      return this.removeRef("children", e);
    }

    listChildren() {
      return this.listRefs("children");
    }

    traverse(e) {
      for (const t of this.listChildren()) t.traverse(e);

      return this;
    }

  }

  class aw extends zy {
    init() {
      this.propertyType = ly.SKIN;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        skeleton: null,
        inverseBindMatrices: null,
        joints: []
      });
    }

    getSkeleton() {
      return this.getRef("skeleton");
    }

    setSkeleton(e) {
      return this.setRef("skeleton", e);
    }

    getInverseBindMatrices() {
      return this.getRef("inverseBindMatrices");
    }

    setInverseBindMatrices(e) {
      return this.setRef("inverseBindMatrices", e, {
        usage: uy.INVERSE_BIND_MATRICES
      });
    }

    addJoint(e) {
      return this.addRef("joints", e);
    }

    removeJoint(e) {
      return this.removeRef("joints", e);
    }

    listJoints() {
      return this.listRefs("joints");
    }

  }

  class lw extends zy {
    init() {
      this.propertyType = ly.TEXTURE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        image: null,
        mimeType: "",
        uri: ""
      });
    }

    getMimeType() {
      return this.get("mimeType") || wy.extensionToMimeType(My.extension(this.get("uri")));
    }

    setMimeType(e) {
      return this.set("mimeType", e);
    }

    getURI() {
      return this.get("uri");
    }

    setURI(e) {
      return this.set("uri", e), this.set("mimeType", wy.extensionToMimeType(My.extension(e))), this;
    }

    getImage() {
      return this.get("image");
    }

    setImage(e) {
      return this.set("image", by.assertView(e));
    }

    getSize() {
      const e = this.get("image");
      return e ? wy.getSize(e, this.getMimeType()) : null;
    }

  }

  class cw extends zy {
    init() {
      this.propertyType = ly.ROOT;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        asset: {
          generator: "glTF-Transform v2.2.0",
          version: "2.0"
        },
        defaultScene: null,
        accessors: [],
        animations: [],
        buffers: [],
        cameras: [],
        materials: [],
        meshes: [],
        nodes: [],
        scenes: [],
        skins: [],
        textures: []
      });
    }

    constructor(e) {
      super(e), this.h = new Set(), e.addEventListener("node:create", e => {
        this.l(e.target);
      });
    }

    clone() {
      throw new Error("Root cannot be cloned.");
    }

    copy(e, t = By) {
      if (t === By) throw new Error("Root cannot be copied.");
      this.set("asset", sw({}, e.get("asset"))), this.setName(e.getName()), this.setExtras(sw({}, e.getExtras())), this.setDefaultScene(e.getDefaultScene() ? t(e.getDefaultScene()) : null);

      for (const n of e.listRefMapKeys("extensions")) {
        const r = e.getExtension(n);
        this.setExtension(n, t(r));
      }

      return this;
    }

    l(e) {
      return e instanceof ow ? this.addRef("scenes", e) : e instanceof nw ? this.addRef("nodes", e) : e instanceof Xy ? this.addRef("cameras", e) : e instanceof aw ? this.addRef("skins", e) : e instanceof tw ? this.addRef("meshes", e) : e instanceof ew ? this.addRef("materials", e) : e instanceof lw ? this.addRef("textures", e) : e instanceof Gy ? this.addRef("animations", e) : e instanceof Vy ? this.addRef("accessors", e) : e instanceof Ky && this.addRef("buffers", e), this;
    }

    getAsset() {
      return this.get("asset");
    }

    listExtensionsUsed() {
      return Array.from(this.h);
    }

    listExtensionsRequired() {
      return this.listExtensionsUsed().filter(e => e.isRequired());
    }

    g(e) {
      return this.h.add(e), this;
    }

    p(e) {
      return this.h.delete(e), this;
    }

    listScenes() {
      return this.listRefs("scenes");
    }

    setDefaultScene(e) {
      return this.setRef("defaultScene", e);
    }

    getDefaultScene() {
      return this.getRef("defaultScene");
    }

    listNodes() {
      return this.listRefs("nodes");
    }

    listCameras() {
      return this.listRefs("cameras");
    }

    listSkins() {
      return this.listRefs("skins");
    }

    listMeshes() {
      return this.listRefs("meshes");
    }

    listMaterials() {
      return this.listRefs("materials");
    }

    listTextures() {
      return this.listRefs("textures");
    }

    listAnimations() {
      return this.listRefs("animations");
    }

    listAccessors() {
      return this.listRefs("accessors");
    }

    listBuffers() {
      return this.listRefs("buffers");
    }

  }

  class uw {
    constructor() {
      this.m = new Qx(), this.T = new cw(this.m), this.v = Ay.DEFAULT_INSTANCE;
    }

    getRoot() {
      return this.T;
    }

    getGraph() {
      return this.m;
    }

    getLogger() {
      return this.v;
    }

    setLogger(e) {
      return this.v = e, this;
    }

    clone() {
      return new uw().setLogger(this.v).merge(this);
    }

    merge(e) {
      for (const t of e.getRoot().listExtensionsUsed()) {
        const e = this.createExtension(t.constructor);
        t.isRequired() && e.setRequired(!0);
      }

      const t = new Set(),
            n = new Map();
      t.add(e.T), n.set(e.T, this.T);

      for (const r of e.m.listEdges()) for (const e of [r.getParent(), r.getChild()]) {
        if (t.has(e)) continue;
        let r;
        r = e.propertyType === ly.TEXTURE_INFO ? e : new (0, e.constructor)(this.m), n.set(e, r), t.add(e);
      }

      const r = e => {
        const t = n.get(e);
        if (!t) throw new Error("Could resolve property.");
        return t;
      };

      for (const e of t) {
        const t = n.get(e);
        if (!t) throw new Error("Could resolve property.");
        t.propertyType !== ly.TEXTURE_INFO && t.copy(e, r);
      }

      return this;
    }

    async transform(...e) {
      const t = e.map(e => e.name);

      for (const n of e) await n(this, {
        stack: t
      });

      return this;
    }

    createExtension(e) {
      const t = e.EXTENSION_NAME;
      return this.getRoot().listExtensionsUsed().find(e => e.extensionName === t) || new e(this);
    }

    createScene(e = "") {
      return new ow(this.m, e);
    }

    createNode(e = "") {
      return new nw(this.m, e);
    }

    createCamera(e = "") {
      return new Xy(this.m, e);
    }

    createSkin(e = "") {
      return new aw(this.m, e);
    }

    createMesh(e = "") {
      return new tw(this.m, e);
    }

    createPrimitive() {
      return new rw(this.m);
    }

    createPrimitiveTarget(e = "") {
      return new iw(this.m, e);
    }

    createMaterial(e = "") {
      return new ew(this.m, e);
    }

    createTexture(e = "") {
      return new lw(this.m, e);
    }

    createAnimation(e = "") {
      return new Gy(this.m, e);
    }

    createAnimationChannel(e = "") {
      return new Hy(this.m, e);
    }

    createAnimationSampler(e = "") {
      return new Wy(this.m, e);
    }

    createAccessor(e = "", t = null) {
      return t || (t = this.getRoot().listBuffers()[0]), new Vy(this.m, e).setBuffer(t);
    }

    createBuffer(e = "") {
      return new Ky(this.m, e);
    }

  }

  class pw {
    constructor(e) {
      this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = !1, this.properties = new Set(), this.S = void 0, this.document = e, e.getRoot().g(this), this.S = e => {
        const t = e,
              n = t.target;
        n instanceof qy && n.extensionName === this.extensionName && ("node:create" === t.type && this.M(n), "node:dispose" === t.type && this.I(n));
      };
      const t = e.getGraph();
      t.addEventListener("node:create", this.S), t.addEventListener("node:dispose", this.S);
    }

    dispose() {
      this.document.getRoot().p(this);
      const e = this.document.getGraph();
      e.removeEventListener("node:create", this.S), e.removeEventListener("node:dispose", this.S);

      for (const e of this.properties) e.dispose();
    }

    static register() {}

    isRequired() {
      return this.required;
    }

    setRequired(e) {
      return this.required = e, this;
    }

    M(e) {
      return this.properties.add(e), this;
    }

    I(e) {
      return this.properties.delete(e), this;
    }

    install(e, t) {
      return this;
    }

    preread(e, t) {
      return this;
    }

    prewrite(e, t) {
      return this;
    }

  }

  pw.EXTENSION_NAME = void 0;

  class hw {
    constructor(e) {
      this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = new Map(), this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = e;
    }

    setTextureInfo(e, t) {
      this.textureInfos.set(e, t), void 0 !== t.texCoord && e.setTexCoord(t.texCoord);
      const n = this.jsonDoc.json.textures[t.index];
      if (void 0 === n.sampler) return;
      const r = this.jsonDoc.json.samplers[n.sampler];
      void 0 !== r.magFilter && e.setMagFilter(r.magFilter), void 0 !== r.minFilter && e.setMinFilter(r.minFilter), void 0 !== r.wrapS && e.setWrapS(r.wrapS), void 0 !== r.wrapT && e.setWrapT(r.wrapT);
    }

  }

  const dw = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  },
        fw = {
    logger: Ay.DEFAULT_INSTANCE,
    extensions: [],
    dependencies: {}
  };

  function _w(e, t) {
    const n = t.bufferViews[e.bufferView],
          r = t.jsonDoc.json.bufferViews[e.bufferView],
          i = dw[e.componentType],
          s = Vy.getElementSize(e.type),
          o = i.BYTES_PER_ELEMENT;
    if (void 0 !== r.byteStride && r.byteStride !== s * o) return function (e, t) {
      const n = t.bufferViews[e.bufferView],
            r = t.jsonDoc.json.bufferViews[e.bufferView],
            i = dw[e.componentType],
            s = Vy.getElementSize(e.type),
            o = i.BYTES_PER_ELEMENT,
            a = e.byteOffset || 0,
            l = new i(e.count * s),
            c = new DataView(n.buffer, n.byteOffset, n.byteLength),
            u = r.byteStride;

      for (let t = 0; t < e.count; t++) for (let n = 0; n < s; n++) {
        const r = a + t * u + n * o;
        let i;

        switch (e.componentType) {
          case Vy.ComponentType.FLOAT:
            i = c.getFloat32(r, !0);
            break;

          case Vy.ComponentType.UNSIGNED_INT:
            i = c.getUint32(r, !0);
            break;

          case Vy.ComponentType.UNSIGNED_SHORT:
            i = c.getUint16(r, !0);
            break;

          case Vy.ComponentType.UNSIGNED_BYTE:
            i = c.getUint8(r);
            break;

          case Vy.ComponentType.SHORT:
            i = c.getInt16(r, !0);
            break;

          case Vy.ComponentType.BYTE:
            i = c.getInt8(r);
            break;

          default:
            throw new Error(`Unexpected componentType "${e.componentType}".`);
        }

        l[t * s + n] = i;
      }

      return l;
    }(e, t);
    const a = n.byteOffset + (e.byteOffset || 0);
    return new i(n.buffer.slice(a, a + e.count * s * o));
  }

  var mw;
  !function (e) {
    e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
  }(mw || (mw = {}));

  class gw {
    constructor(e, t, n) {
      this.N = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = new Map(), this.animationIndexMap = new Map(), this.bufferIndexMap = new Map(), this.cameraIndexMap = new Map(), this.skinIndexMap = new Map(), this.materialIndexMap = new Map(), this.meshIndexMap = new Map(), this.nodeIndexMap = new Map(), this.imageIndexMap = new Map(), this.textureDefIndexMap = new Map(), this.textureInfoDefMap = new Map(), this.samplerDefIndexMap = new Map(), this.sceneIndexMap = new Map(), this.imageBufferViews = [], this.otherBufferViews = new Map(), this.otherBufferViewsIndexMap = new Map(), this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.O = new Map(), this.accessorUsageGroupedByParent = new Set(["ARRAY_BUFFER"]), this.accessorParents = new Map(), this.N = e, this.jsonDoc = t, this.options = n;
      const r = e.getRoot(),
            i = r.listBuffers().length,
            s = r.listTextures().length;
      this.bufferURIGenerator = new vw(i > 1, n.basename), this.imageURIGenerator = new vw(s > 1, n.basename), this.logger = e.getLogger();
    }

    createTextureInfoDef(e, t) {
      const n = {
        magFilter: t.getMagFilter() || void 0,
        minFilter: t.getMinFilter() || void 0,
        wrapS: t.getWrapS(),
        wrapT: t.getWrapT()
      },
            r = JSON.stringify(n);
      this.samplerDefIndexMap.has(r) || (this.samplerDefIndexMap.set(r, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(n));
      const i = {
        source: this.imageIndexMap.get(e),
        sampler: this.samplerDefIndexMap.get(r)
      },
            s = JSON.stringify(i);
      this.textureDefIndexMap.has(s) || (this.textureDefIndexMap.set(s, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(i));
      const o = {
        index: this.textureDefIndexMap.get(s)
      };
      return 0 !== t.getTexCoord() && (o.texCoord = t.getTexCoord()), this.textureInfoDefMap.set(t, o), o;
    }

    createPropertyDef(e) {
      const t = {};
      return e.getName() && (t.name = e.getName()), Object.keys(e.getExtras()).length > 0 && (t.extras = e.getExtras()), t;
    }

    createAccessorDef(e) {
      const t = this.createPropertyDef(e);
      return t.type = e.getType(), t.componentType = e.getComponentType(), t.count = e.getCount(), this.N.getGraph().listParentEdges(e).some(e => "attributes" === e.getName() && "POSITION" === e.getAttributes().key || "input" === e.getName()) && (t.max = e.getMax([]).map(Math.fround), t.min = e.getMin([]).map(Math.fround)), e.getNormalized() && (t.normalized = e.getNormalized()), t;
    }

    createImageData(e, t, n) {
      if (this.options.format === hy.GLB) this.imageBufferViews.push(t), e.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({
        buffer: 0,
        byteOffset: -1,
        byteLength: t.byteLength
      });else {
        const r = wy.mimeTypeToExtension(n.getMimeType());
        e.uri = this.imageURIGenerator.createURI(n, r), this.jsonDoc.resources[e.uri] = t;
      }
    }

    getAccessorUsage(e) {
      const t = this.O.get(e);
      if (t) return t;

      for (const t of this.N.getGraph().listParentEdges(e)) {
        const {
          usage: e
        } = t.getAttributes();
        if (e) return e;
        t.getParent().propertyType !== ly.ROOT && this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${t.getName()}".`);
      }

      return gw.BufferViewUsage.OTHER;
    }

    addAccessorToUsageGroup(e, t) {
      const n = this.O.get(e);
      if (n && n !== t) throw new Error(`Accessor with usage "${n}" cannot be reused as "${t}".`);
      return this.O.set(e, t), this;
    }

    listAccessorUsageGroups() {
      const e = {};

      for (const [t, n] of Array.from(this.O.entries())) e[n] = e[n] || [], e[n].push(t);

      return e;
    }

  }

  gw.BufferViewTarget = mw, gw.BufferViewUsage = uy, gw.USAGE_TO_TARGET = {
    [uy.ARRAY_BUFFER]: mw.ARRAY_BUFFER,
    [uy.ELEMENT_ARRAY_BUFFER]: mw.ELEMENT_ARRAY_BUFFER
  };

  class vw {
    constructor(e, t) {
      this.multiple = void 0, this.basename = void 0, this.counter = 1, this.multiple = e, this.basename = t;
    }

    createURI(e, t) {
      return e.getURI() ? e.getURI() : this.multiple ? `${this.basename}_${this.counter++}.${t}` : `${this.basename}.${t}`;
    }

  }

  const {
    BufferViewUsage: bw
  } = gw;
  var xw;
  !function (e) {
    e[e.JSON = 1313821514] = "JSON", e[e.BIN = 5130562] = "BIN";
  }(xw || (xw = {}));

  class yw extends class {
    constructor() {
      this.v = Ay.DEFAULT_INSTANCE, this.h = new Set(), this.C = {}, this.F = cy.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0;
    }

    setLogger(e) {
      return this.v = e, this;
    }

    registerExtensions(e) {
      for (const t of e) this.h.add(t), t.register();

      return this;
    }

    registerDependencies(e) {
      return Object.assign(this.C, e), this;
    }

    setVertexLayout(e) {
      return this.F = e, this;
    }

    async read(e) {
      return await this.readJSON(await this.readAsJSON(e));
    }

    async readAsJSON(e) {
      return e.match(/^data:application\/octet-stream;/) || this.detectFormat(e) === hy.GLB ? this.U(e) : this.P(e);
    }

    async readJSON(e) {
      return e = this.j(e), this.L(e), class {
        static read(e, t = fw) {
          const n = sw({}, fw, t),
                {
            json: r
          } = e,
                i = new uw();
          this.validate(e, n);
          const s = new hw(e),
                o = r.asset,
                a = i.getRoot().getAsset();
          o.copyright && (a.copyright = o.copyright), o.extras && (a.extras = o.extras), void 0 !== r.extras && i.getRoot().setExtras(sw({}, r.extras));
          const l = r.extensionsUsed || [],
                c = r.extensionsRequired || [];

          for (const e of n.extensions) if (l.includes(e.EXTENSION_NAME)) {
            const t = i.createExtension(e).setRequired(c.includes(e.EXTENSION_NAME));

            for (const e of t.readDependencies) t.install(e, n.dependencies[e]);
          }

          const u = r.buffers || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(ly.BUFFER)).forEach(e => e.preread(s, ly.BUFFER)), s.buffers = u.map(e => {
            const t = i.createBuffer(e.name);
            return e.extras && t.setExtras(e.extras), e.uri && 0 !== e.uri.indexOf("__") && t.setURI(e.uri), t;
          }), s.bufferViewBuffers = (r.bufferViews || []).map((t, n) => {
            if (!s.bufferViews[n]) {
              const r = e.json.buffers[t.buffer];
              s.bufferViews[n] = by.toView(r.uri ? e.resources[r.uri] : e.resources["@glb.bin"], t.byteOffset || 0, t.byteLength);
            }

            return s.buffers[t.buffer];
          }), s.accessors = (r.accessors || []).map(e => {
            const t = i.createAccessor(e.name, s.bufferViewBuffers[e.bufferView]).setType(e.type);
            if (e.extras && t.setExtras(e.extras), void 0 !== e.normalized && t.setNormalized(e.normalized), void 0 === e.bufferView && !e.sparse) return t;
            let n;
            return n = void 0 !== e.sparse ? function (e, t) {
              const n = dw[e.componentType],
                    r = Vy.getElementSize(e.type);
              let i;
              i = void 0 !== e.bufferView ? _w(e, t) : new n(e.count * r);

              const s = e.sparse,
                    o = s.count,
                    a = sw({}, e, s.indices, {
                count: o,
                type: "SCALAR"
              }),
                    l = sw({}, e, s.values, {
                count: o
              }),
                    c = _w(a, t),
                    u = _w(l, t);

              for (let e = 0; e < a.count; e++) for (let t = 0; t < r; t++) i[c[e] * r + t] = u[e * r + t];

              return i;
            }(e, s) : _w(e, s), t.setArray(n), t;
          });
          const p = r.images || [],
                h = r.textures || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(ly.TEXTURE)).forEach(e => e.preread(s, ly.TEXTURE)), s.textures = p.map(t => {
            const n = i.createTexture(t.name);

            if (t.extras && n.setExtras(t.extras), void 0 !== t.bufferView) {
              const i = r.bufferViews[t.bufferView],
                    s = e.json.buffers[i.buffer],
                    o = i.byteOffset || 0,
                    a = (s.uri ? e.resources[s.uri] : e.resources["@glb.bin"]).slice(o, o + i.byteLength);
              n.setImage(a);
            } else void 0 !== t.uri && (n.setImage(e.resources[t.uri]), 0 !== t.uri.indexOf("__") && n.setURI(t.uri));

            if (void 0 !== t.mimeType) n.setMimeType(t.mimeType);else if (t.uri) {
              const e = My.extension(t.uri);
              n.setMimeType(wy.extensionToMimeType(e));
            }
            return n;
          }), s.materials = (r.materials || []).map(e => {
            const t = i.createMaterial(e.name);
            e.extras && t.setExtras(e.extras), void 0 !== e.alphaMode && t.setAlphaMode(e.alphaMode), void 0 !== e.alphaCutoff && t.setAlphaCutoff(e.alphaCutoff), void 0 !== e.doubleSided && t.setDoubleSided(e.doubleSided);
            const n = e.pbrMetallicRoughness || {};

            if (void 0 !== n.baseColorFactor && t.setBaseColorFactor(n.baseColorFactor), void 0 !== e.emissiveFactor && t.setEmissiveFactor(e.emissiveFactor), void 0 !== n.metallicFactor && t.setMetallicFactor(n.metallicFactor), void 0 !== n.roughnessFactor && t.setRoughnessFactor(n.roughnessFactor), void 0 !== n.baseColorTexture) {
              const e = n.baseColorTexture;
              t.setBaseColorTexture(s.textures[h[e.index].source]), s.setTextureInfo(t.getBaseColorTextureInfo(), e);
            }

            if (void 0 !== e.emissiveTexture) {
              const n = e.emissiveTexture;
              t.setEmissiveTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getEmissiveTextureInfo(), n);
            }

            if (void 0 !== e.normalTexture) {
              const n = e.normalTexture;
              t.setNormalTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getNormalTextureInfo(), n), void 0 !== e.normalTexture.scale && t.setNormalScale(e.normalTexture.scale);
            }

            if (void 0 !== e.occlusionTexture) {
              const n = e.occlusionTexture;
              t.setOcclusionTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getOcclusionTextureInfo(), n), void 0 !== e.occlusionTexture.strength && t.setOcclusionStrength(e.occlusionTexture.strength);
            }

            if (void 0 !== n.metallicRoughnessTexture) {
              const e = n.metallicRoughnessTexture;
              t.setMetallicRoughnessTexture(s.textures[h[e.index].source]), s.setTextureInfo(t.getMetallicRoughnessTextureInfo(), e);
            }

            return t;
          });
          const d = r.meshes || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(ly.PRIMITIVE)).forEach(e => e.preread(s, ly.PRIMITIVE)), s.meshes = d.map(e => {
            const t = i.createMesh(e.name);
            return e.extras && t.setExtras(e.extras), void 0 !== e.weights && t.setWeights(e.weights), (e.primitives || []).forEach(n => {
              const r = i.createPrimitive();
              n.extras && r.setExtras(n.extras), void 0 !== n.material && r.setMaterial(s.materials[n.material]), void 0 !== n.mode && r.setMode(n.mode);

              for (const [e, t] of Object.entries(n.attributes || {})) r.setAttribute(e, s.accessors[t]);

              void 0 !== n.indices && r.setIndices(s.accessors[n.indices]);
              const o = e.extras && e.extras.targetNames || [];
              (n.targets || []).forEach((e, t) => {
                const n = o[t] || t.toString(),
                      a = i.createPrimitiveTarget(n);

                for (const [t, n] of Object.entries(e)) a.setAttribute(t, s.accessors[n]);

                r.addTarget(a);
              }), t.addPrimitive(r);
            }), t;
          }), s.cameras = (r.cameras || []).map(e => {
            const t = i.createCamera(e.name).setType(e.type);

            if (e.extras && t.setExtras(e.extras), e.type === Xy.Type.PERSPECTIVE) {
              const n = e.perspective;
              t.setYFov(n.yfov), t.setZNear(n.znear), void 0 !== n.zfar && t.setZFar(n.zfar), void 0 !== n.aspectRatio && t.setAspectRatio(n.aspectRatio);
            } else {
              const n = e.orthographic;
              t.setZNear(n.znear).setZFar(n.zfar).setXMag(n.xmag).setYMag(n.ymag);
            }

            return t;
          });
          const f = r.nodes || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(ly.NODE)).forEach(e => e.preread(s, ly.NODE)), s.nodes = f.map(e => {
            const t = i.createNode(e.name);

            if (e.extras && t.setExtras(e.extras), void 0 !== e.translation && t.setTranslation(e.translation), void 0 !== e.rotation && t.setRotation(e.rotation), void 0 !== e.scale && t.setScale(e.scale), void 0 !== e.matrix) {
              const n = [0, 0, 0],
                    r = [0, 0, 0, 1],
                    i = [1, 1, 1];
              Cy.decompose(e.matrix, n, r, i), t.setTranslation(n), t.setRotation(r), t.setScale(i);
            }

            return void 0 !== e.weights && t.setWeights(e.weights), t;
          }), s.skins = (r.skins || []).map(e => {
            const t = i.createSkin(e.name);
            e.extras && t.setExtras(e.extras), void 0 !== e.inverseBindMatrices && t.setInverseBindMatrices(s.accessors[e.inverseBindMatrices]), void 0 !== e.skeleton && t.setSkeleton(s.nodes[e.skeleton]);

            for (const n of e.joints) t.addJoint(s.nodes[n]);

            return t;
          }), f.map((e, t) => {
            const n = s.nodes[t];
            (e.children || []).forEach(e => n.addChild(s.nodes[e])), void 0 !== e.mesh && n.setMesh(s.meshes[e.mesh]), void 0 !== e.camera && n.setCamera(s.cameras[e.camera]), void 0 !== e.skin && n.setSkin(s.skins[e.skin]);
          }), s.animations = (r.animations || []).map(e => {
            const t = i.createAnimation(e.name);
            e.extras && t.setExtras(e.extras);
            const n = (e.samplers || []).map(e => {
              const n = i.createAnimationSampler().setInput(s.accessors[e.input]).setOutput(s.accessors[e.output]).setInterpolation(e.interpolation || Wy.Interpolation.LINEAR);
              return e.extras && n.setExtras(e.extras), t.addSampler(n), n;
            });
            return (e.channels || []).forEach(e => {
              const r = i.createAnimationChannel().setSampler(n[e.sampler]).setTargetPath(e.target.path);
              void 0 !== e.target.node && r.setTargetNode(s.nodes[e.target.node]), e.extras && r.setExtras(e.extras), t.addChannel(r);
            }), t;
          });

          const _ = r.scenes || [];

          return i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(ly.SCENE)).forEach(e => e.preread(s, ly.SCENE)), s.scenes = _.map(e => {
            const t = i.createScene(e.name);
            return e.extras && t.setExtras(e.extras), (e.nodes || []).map(e => s.nodes[e]).forEach(e => t.addChild(e)), t;
          }), void 0 !== r.scene && i.getRoot().setDefaultScene(s.scenes[r.scene]), i.getRoot().listExtensionsUsed().forEach(e => e.read(s)), i;
        }

        static validate(e, t) {
          const n = e.json;
          if ("2.0" !== n.asset.version) throw new Error(`Unsupported glTF version, "${n.asset.version}".`);
          if (n.extensionsRequired) for (const e of n.extensionsRequired) if (!t.extensions.find(t => t.EXTENSION_NAME === e)) throw new Error(`Missing required extension, "${e}".`);
          if (n.extensionsUsed) for (const e of n.extensionsUsed) t.extensions.find(t => t.EXTENSION_NAME === e) || t.logger.warn(`Missing optional extension, "${e}".`);
        }

      }.read(e, {
        extensions: Array.from(this.h),
        dependencies: this.C,
        logger: this.v
      });
    }

    async binaryToJSON(e) {
      const t = this._(by.assertView(e));

      this.L(t);
      const n = t.json;
      if (n.buffers && n.buffers.some(e => function (e, t) {
        return void 0 !== t.uri && !(t.uri in e.resources);
      }(t, e))) throw new Error("Cannot resolve external buffers with binaryToJSON().");
      if (n.images && n.images.some(e => function (e, t) {
        return void 0 !== t.uri && !(t.uri in e.resources) && void 0 === t.bufferView;
      }(t, e))) throw new Error("Cannot resolve external images with binaryToJSON().");
      return t;
    }

    async readBinary(e) {
      return this.readJSON(await this.binaryToJSON(by.assertView(e)));
    }

    async writeJSON(e, t = {}) {
      if (t.format === hy.GLB && e.getRoot().listBuffers().length > 1) throw new Error("GLB must have 0–1 buffers.");
      return class {
        static write(e, t) {
          const n = e.getRoot(),
                r = {
            asset: sw({
              generator: "glTF-Transform v2.2.0"
            }, n.getAsset()),
            extras: sw({}, n.getExtras())
          },
                i = {
            json: r,
            resources: {}
          },
                s = new gw(e, i, t),
                o = t.logger || Ay.DEFAULT_INSTANCE,
                a = new Set(t.extensions.map(e => e.EXTENSION_NAME)),
                l = e.getRoot().listExtensionsUsed().filter(e => a.has(e.extensionName)),
                c = e.getRoot().listExtensionsRequired().filter(e => a.has(e.extensionName));
          l.length < e.getRoot().listExtensionsUsed().length && o.debug("Some extensions were not registered for I/O, and will not be written.");

          for (const e of l) for (const n of e.writeDependencies) e.install(n, t.dependencies[n]);

          function u(e, t, n, i) {
            const o = [];
            let a = 0;

            for (const t of e) {
              const e = s.createAccessorDef(t);
              e.bufferView = r.bufferViews.length;
              const n = t.getArray(),
                    i = by.pad(by.toView(n));
              e.byteOffset = a, a += i.byteLength, o.push(i), s.accessorIndexMap.set(t, r.accessors.length), r.accessors.push(e);
            }

            const l = {
              buffer: t,
              byteOffset: n,
              byteLength: by.concat(o).byteLength
            };
            return i && (l.target = i), r.bufferViews.push(l), {
              buffers: o,
              byteLength: a
            };
          }

          function p(e, t, n) {
            const i = e[0].getCount();
            let o = 0;

            for (const t of e) {
              const e = s.createAccessorDef(t);
              e.bufferView = r.bufferViews.length, e.byteOffset = o;
              const n = t.getElementSize(),
                    i = t.getComponentSize();
              o += by.padNumber(n * i), s.accessorIndexMap.set(t, r.accessors.length), r.accessors.push(e);
            }

            const a = i * o,
                  l = new ArrayBuffer(a),
                  c = new DataView(l);

            for (let t = 0; t < i; t++) {
              let n = 0;

              for (const r of e) {
                const e = r.getElementSize(),
                      i = r.getComponentSize(),
                      s = r.getComponentType(),
                      a = r.getArray();

                for (let r = 0; r < e; r++) {
                  const l = t * o + n + r * i,
                        u = a[t * e + r];

                  switch (s) {
                    case Vy.ComponentType.FLOAT:
                      c.setFloat32(l, u, !0);
                      break;

                    case Vy.ComponentType.BYTE:
                      c.setInt8(l, u);
                      break;

                    case Vy.ComponentType.SHORT:
                      c.setInt16(l, u, !0);
                      break;

                    case Vy.ComponentType.UNSIGNED_BYTE:
                      c.setUint8(l, u);
                      break;

                    case Vy.ComponentType.UNSIGNED_SHORT:
                      c.setUint16(l, u, !0);
                      break;

                    case Vy.ComponentType.UNSIGNED_INT:
                      c.setUint32(l, u, !0);
                      break;

                    default:
                      throw new Error("Unexpected component type: " + s);
                  }
                }

                n += by.padNumber(e * i);
              }
            }

            return r.bufferViews.push({
              buffer: t,
              byteOffset: n,
              byteLength: a,
              byteStride: o,
              target: gw.BufferViewTarget.ARRAY_BUFFER
            }), {
              byteLength: a,
              buffers: [new Uint8Array(l)]
            };
          }

          const h = new Map();

          for (const t of e.getGraph().listEdges()) {
            if (t.getParent() === n) continue;
            const e = t.getChild();

            if (e instanceof Vy) {
              const n = h.get(e) || [];
              n.push(t), h.set(e, n);
            }
          }

          if (r.accessors = [], r.bufferViews = [], r.samplers = [], r.textures = [], r.images = n.listTextures().map((e, t) => {
            const n = s.createPropertyDef(e);
            e.getMimeType() && (n.mimeType = e.getMimeType());
            const r = e.getImage();
            return r && s.createImageData(n, r, e), s.imageIndexMap.set(e, t), n;
          }), l.filter(e => e.prewriteTypes.includes(ly.ACCESSOR)).forEach(e => e.prewrite(s, ly.ACCESSOR)), n.listAccessors().forEach(e => {
            const t = s.accessorUsageGroupedByParent,
                  n = s.accessorParents;
            if (s.accessorIndexMap.has(e)) return;
            const r = h.get(e) || [],
                  i = s.getAccessorUsage(e);

            if (s.addAccessorToUsageGroup(e, i), t.has(i)) {
              const t = r[0].getParent(),
                    i = n.get(t) || new Set();
              i.add(e), n.set(t, i);
            }
          }), l.filter(e => e.prewriteTypes.includes(ly.BUFFER)).forEach(e => e.prewrite(s, ly.BUFFER)), (n.listAccessors().length > 0 || n.listTextures().length > 0 || s.otherBufferViews.size > 0) && 0 === n.listBuffers().length) throw new Error("Buffer required for Document resources, but none was found.");
          r.buffers = [], n.listBuffers().forEach((e, n) => {
            const o = s.createPropertyDef(e),
                  a = s.accessorUsageGroupedByParent,
                  l = s.accessorParents,
                  c = e.listParents().filter(e => e instanceof Vy),
                  h = new Set(c),
                  d = [],
                  f = r.buffers.length;
            let _ = 0;
            const m = s.listAccessorUsageGroups();

            for (const e in m) if (a.has(e)) for (const n of Array.from(l.values())) {
              const r = Array.from(n).filter(e => h.has(e)).filter(t => s.getAccessorUsage(t) === e);
              if (r.length) if (e !== bw.ARRAY_BUFFER || t.vertexLayout === cy.INTERLEAVED) {
                const t = e === bw.ARRAY_BUFFER ? p(r, f, _) : u(r, f, _);
                _ += t.byteLength, d.push(...t.buffers);
              } else for (const e of r) {
                const t = p([e], f, _);
                _ += t.byteLength, d.push(...t.buffers);
              }
            } else {
              const t = m[e].filter(e => h.has(e));
              if (!t.length) continue;
              const n = u(t, f, _, e === bw.ELEMENT_ARRAY_BUFFER ? gw.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0);
              _ += n.byteLength, d.push(...n.buffers);
            }

            if (s.imageBufferViews.length && 0 === n) for (let e = 0; e < s.imageBufferViews.length; e++) if (r.bufferViews[r.images[e].bufferView].byteOffset = _, _ += s.imageBufferViews[e].byteLength, d.push(s.imageBufferViews[e]), _ % 8) {
              const e = 8 - _ % 8;
              _ += e, d.push(new Uint8Array(e));
            }
            if (s.otherBufferViews.has(e)) for (const t of s.otherBufferViews.get(e)) r.bufferViews.push({
              buffer: f,
              byteOffset: _,
              byteLength: t.byteLength
            }), s.otherBufferViewsIndexMap.set(t, r.bufferViews.length - 1), _ += t.byteLength, d.push(t);

            if (_) {
              let n;
              t.format === hy.GLB ? n = "@glb.bin" : (n = s.bufferURIGenerator.createURI(e, "bin"), o.uri = n), o.byteLength = _, i.resources[n] = by.concat(d);
            }

            r.buffers.push(o), s.bufferIndexMap.set(e, n);
          }), n.listAccessors().find(e => !e.getBuffer()) && o.warn("Skipped writing one or more Accessors: no Buffer assigned."), r.materials = n.listMaterials().map((e, t) => {
            const n = s.createPropertyDef(e);

            if (e.getAlphaMode() !== ew.AlphaMode.OPAQUE && (n.alphaMode = e.getAlphaMode()), e.getAlphaMode() === ew.AlphaMode.MASK && (n.alphaCutoff = e.getAlphaCutoff()), e.getDoubleSided() && (n.doubleSided = !0), n.pbrMetallicRoughness = {}, Cy.eq(e.getBaseColorFactor(), [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = e.getBaseColorFactor()), Cy.eq(e.getEmissiveFactor(), [0, 0, 0]) || (n.emissiveFactor = e.getEmissiveFactor()), 1 !== e.getRoughnessFactor() && (n.pbrMetallicRoughness.roughnessFactor = e.getRoughnessFactor()), 1 !== e.getMetallicFactor() && (n.pbrMetallicRoughness.metallicFactor = e.getMetallicFactor()), e.getBaseColorTexture()) {
              const t = e.getBaseColorTexture(),
                    r = e.getBaseColorTextureInfo();
              n.pbrMetallicRoughness.baseColorTexture = s.createTextureInfoDef(t, r);
            }

            if (e.getEmissiveTexture()) {
              const t = e.getEmissiveTexture(),
                    r = e.getEmissiveTextureInfo();
              n.emissiveTexture = s.createTextureInfoDef(t, r);
            }

            if (e.getNormalTexture()) {
              const t = e.getNormalTexture(),
                    r = e.getNormalTextureInfo(),
                    i = s.createTextureInfoDef(t, r);
              1 !== e.getNormalScale() && (i.scale = e.getNormalScale()), n.normalTexture = i;
            }

            if (e.getOcclusionTexture()) {
              const t = e.getOcclusionTexture(),
                    r = e.getOcclusionTextureInfo(),
                    i = s.createTextureInfoDef(t, r);
              1 !== e.getOcclusionStrength() && (i.strength = e.getOcclusionStrength()), n.occlusionTexture = i;
            }

            if (e.getMetallicRoughnessTexture()) {
              const t = e.getMetallicRoughnessTexture(),
                    r = e.getMetallicRoughnessTextureInfo();
              n.pbrMetallicRoughness.metallicRoughnessTexture = s.createTextureInfoDef(t, r);
            }

            return s.materialIndexMap.set(e, t), n;
          }), r.meshes = n.listMeshes().map((e, t) => {
            const n = s.createPropertyDef(e);
            let r = null;
            return n.primitives = e.listPrimitives().map(e => {
              const t = {
                attributes: {}
              };
              t.mode = e.getMode();
              const n = e.getMaterial();
              n && (t.material = s.materialIndexMap.get(n)), Object.keys(e.getExtras()).length && (t.extras = e.getExtras());
              const i = e.getIndices();
              i && (t.indices = s.accessorIndexMap.get(i));

              for (const n of e.listSemantics()) t.attributes[n] = s.accessorIndexMap.get(e.getAttribute(n));

              for (const n of e.listTargets()) {
                const e = {};

                for (const t of n.listSemantics()) e[t] = s.accessorIndexMap.get(n.getAttribute(t));

                t.targets = t.targets || [], t.targets.push(e);
              }

              return e.listTargets().length && !r && (r = e.listTargets().map(e => e.getName())), t;
            }), e.getWeights().length && (n.weights = e.getWeights()), r && (n.extras = n.extras || {}, n.extras.targetNames = r), s.meshIndexMap.set(e, t), n;
          }), r.cameras = n.listCameras().map((e, t) => {
            const n = s.createPropertyDef(e);

            if (n.type = e.getType(), n.type === Xy.Type.PERSPECTIVE) {
              n.perspective = {
                znear: e.getZNear(),
                zfar: e.getZFar(),
                yfov: e.getYFov()
              };
              const t = e.getAspectRatio();
              null !== t && (n.perspective.aspectRatio = t);
            } else n.orthographic = {
              znear: e.getZNear(),
              zfar: e.getZFar(),
              xmag: e.getXMag(),
              ymag: e.getYMag()
            };

            return s.cameraIndexMap.set(e, t), n;
          }), r.nodes = n.listNodes().map((e, t) => {
            const n = s.createPropertyDef(e);
            return Cy.eq(e.getTranslation(), [0, 0, 0]) || (n.translation = e.getTranslation()), Cy.eq(e.getRotation(), [0, 0, 0, 1]) || (n.rotation = e.getRotation()), Cy.eq(e.getScale(), [1, 1, 1]) || (n.scale = e.getScale()), e.getWeights().length && (n.weights = e.getWeights()), s.nodeIndexMap.set(e, t), n;
          }), r.skins = n.listSkins().map((e, t) => {
            const n = s.createPropertyDef(e),
                  r = e.getInverseBindMatrices();
            r && (n.inverseBindMatrices = s.accessorIndexMap.get(r));
            const i = e.getSkeleton();
            return i && (n.skeleton = s.nodeIndexMap.get(i)), n.joints = e.listJoints().map(e => s.nodeIndexMap.get(e)), s.skinIndexMap.set(e, t), n;
          }), n.listNodes().forEach((e, t) => {
            const n = r.nodes[t],
                  i = e.getMesh();
            i && (n.mesh = s.meshIndexMap.get(i));
            const o = e.getCamera();
            o && (n.camera = s.cameraIndexMap.get(o));
            const a = e.getSkin();
            a && (n.skin = s.skinIndexMap.get(a)), e.listChildren().length > 0 && (n.children = e.listChildren().map(e => s.nodeIndexMap.get(e)));
          }), r.animations = n.listAnimations().map((e, t) => {
            const n = s.createPropertyDef(e),
                  r = new Map();
            return n.samplers = e.listSamplers().map((e, t) => {
              const n = s.createPropertyDef(e);
              return n.input = s.accessorIndexMap.get(e.getInput()), n.output = s.accessorIndexMap.get(e.getOutput()), n.interpolation = e.getInterpolation(), r.set(e, t), n;
            }), n.channels = e.listChannels().map(e => {
              const t = s.createPropertyDef(e);
              return t.sampler = r.get(e.getSampler()), t.target = {
                node: s.nodeIndexMap.get(e.getTargetNode()),
                path: e.getTargetPath()
              }, t;
            }), s.animationIndexMap.set(e, t), n;
          }), r.scenes = n.listScenes().map((e, t) => {
            const n = s.createPropertyDef(e);
            return n.nodes = e.listChildren().map(e => s.nodeIndexMap.get(e)), s.sceneIndexMap.set(e, t), n;
          });
          const d = n.getDefaultScene();
          return d && (r.scene = n.listScenes().indexOf(d)), r.extensionsUsed = l.map(e => e.extensionName), r.extensionsRequired = c.map(e => e.extensionName), l.forEach(e => e.write(s)), function (e) {
            const t = [];

            for (const n in e) {
              const r = e[n];
              (Array.isArray(r) && 0 === r.length || null === r || "" === r || r && "object" == typeof r && 0 === Object.keys(r).length) && t.push(n);
            }

            for (const n of t) delete e[n];
          }(r), i;
        }

      }.write(e, {
        format: t.format || hy.GLTF,
        basename: t.basename || "",
        logger: this.v,
        vertexLayout: this.F,
        dependencies: sw({}, this.C),
        extensions: Array.from(this.h)
      });
    }

    async writeBinary(e) {
      const {
        json: t,
        resources: n
      } = await this.writeJSON(e, {
        format: hy.GLB
      }),
            r = new Uint32Array([1179937895, 2, 12]),
            i = JSON.stringify(t),
            s = by.pad(by.encodeText(i), 32),
            o = by.toView(new Uint32Array([s.byteLength, 1313821514])),
            a = by.concat([o, s]);
      r[r.length - 1] += a.byteLength;
      const l = Object.values(n)[0];
      if (!l || !l.byteLength) return by.concat([by.toView(r), a]);
      const c = by.pad(l, 0),
            u = by.toView(new Uint32Array([c.byteLength, 5130562])),
            p = by.concat([u, c]);
      return r[r.length - 1] += p.byteLength, by.concat([by.toView(r), a, p]);
    }

    detectFormat(e) {
      return "glb" === (Uy.isAbsoluteURL(e) ? Uy.extension(e) : My.extension(e)) ? hy.GLB : hy.GLTF;
    }

    async P(e) {
      this.lastReadBytes = 0;
      const t = await this.readURI(e, "text");
      this.lastReadBytes += t.length;
      const n = {
        json: JSON.parse(t),
        resources: {}
      };
      return await this.D(n, this.dirname(e)), this.L(n), n;
    }

    async U(e) {
      const t = await this.readURI(e, "view");
      this.lastReadBytes = t.byteLength;

      const n = this._(t);

      return await this.D(n, this.dirname(e)), this.L(n), n;
    }

    async D(e, t) {
      var n = this;
      const r = [...(e.json.images || []), ...(e.json.buffers || [])].map(async function (r) {
        const i = r.uri;
        if (!i || i.match(/data:/)) return Promise.resolve();
        e.resources[i] = await n.readURI(n.resolve(t, i), "view"), n.lastReadBytes += e.resources[i].byteLength;
      });
      await Promise.all(r);
    }

    L(e) {
      function t(t) {
        if (t.uri) if (t.uri in e.resources) by.assertView(e.resources[t.uri]);else if (t.uri.match(/data:/)) {
          const n = `__${function () {
            for (let e = 0; e < 999; e++) {
              const e = Ny();
              if (!Fy.has(e)) return Fy.add(e), e;
            }

            return "";
          }()}.${My.extension(t.uri)}`;
          e.resources[n] = by.createBufferFromDataURI(t.uri), t.uri = n;
        }
      }

      (e.json.images || []).forEach(e => {
        if (void 0 === e.bufferView && void 0 === e.uri) throw new Error("Missing resource URI or buffer view.");
        t(e);
      }), (e.json.buffers || []).forEach(t);
    }

    j(e) {
      const {
        images: t,
        buffers: n
      } = e.json;
      return e = {
        json: sw({}, e.json),
        resources: sw({}, e.resources)
      }, t && (e.json.images = t.map(e => sw({}, e))), n && (e.json.buffers = n.map(e => sw({}, e))), e;
    }

    _(e) {
      const t = new Uint32Array(e.buffer, e.byteOffset, 3);
      if (1179937895 !== t[0]) throw new Error("Invalid glTF asset.");
      if (2 !== t[1]) throw new Error(`Unsupported glTF binary version, "${t[1]}".`);
      const n = new Uint32Array(e.buffer, e.byteOffset + 12, 2);
      if (n[1] !== xw.JSON) throw new Error("Missing required GLB JSON chunk.");
      const r = n[0],
            i = by.decodeText(by.toView(e, 20, r)),
            s = JSON.parse(i),
            o = 20 + r;
      if (e.byteLength <= o) return {
        json: s,
        resources: {}
      };
      const a = new Uint32Array(e.buffer, e.byteOffset + o, 2);
      if (a[1] !== xw.BIN) throw new Error("Expected GLB BIN in second chunk.");
      return {
        json: s,
        resources: {
          "@glb.bin": by.toView(e, o + 8, a[0])
        }
      };
    }

  } {
    constructor(e = Uy.DEFAULT_INIT) {
      super(), this.V = void 0, this.V = e;
    }

    async readURI(e, t) {
      const n = await fetch(e, this.V);

      switch (t) {
        case "view":
          return new Uint8Array(await n.arrayBuffer());

        case "text":
          return n.text();
      }
    }

    resolve(e, t) {
      return Uy.resolve(e, t);
    }

    dirname(e) {
      return Uy.dirname(e);
    }

    detectFormat(e) {
      return "glb" === Uy.extension(e) ? hy.GLB : hy.GLTF;
    }

  }

  class ww {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
        vendorId: 0,
        descriptorType: 0,
        descriptorBlockSize: 0,
        versionNumber: 2,
        colorModel: 0,
        colorPrimaries: 1,
        transferFunction: 2,
        flags: 0,
        texelBlockDimension: [0, 0, 0, 0],
        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
        samples: []
      }], this.keyValue = {}, this.globalData = null;
    }

  }

  class Sw {
    constructor(e, t, n, r) {
      this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = r, this._offset = 0;
    }

    _nextUint8() {
      const e = this._dataView.getUint8(this._offset);

      return this._offset += 1, e;
    }

    _nextUint16() {
      const e = this._dataView.getUint16(this._offset, this._littleEndian);

      return this._offset += 2, e;
    }

    _nextUint32() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _nextUint64() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);

      return this._offset += 8, e;
    }

    _nextInt32() {
      const e = this._dataView.getInt32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _skip(e) {
      return this._offset += e, this;
    }

    _scan(e, t = 0) {
      const n = this._offset;
      let r = 0;

      for (; this._dataView.getUint8(this._offset) !== t && r < e;) r++, this._offset++;

      return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r);
    }

  }

  new Uint8Array([0]);
  const Mw = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

  function Tw(e) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
  }

  function Ew(e) {
    const t = new Uint8Array(e.buffer, e.byteOffset, Mw.length);
    if (t[0] !== Mw[0] || t[1] !== Mw[1] || t[2] !== Mw[2] || t[3] !== Mw[3] || t[4] !== Mw[4] || t[5] !== Mw[5] || t[6] !== Mw[6] || t[7] !== Mw[7] || t[8] !== Mw[8] || t[9] !== Mw[9] || t[10] !== Mw[10] || t[11] !== Mw[11]) throw new Error("Missing KTX 2.0 identifier.");
    const n = new ww(),
          r = 17 * Uint32Array.BYTES_PER_ELEMENT,
          i = new Sw(e, Mw.length, r, !0);
    n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();

    const s = i._nextUint32();

    n.supercompressionScheme = i._nextUint32();

    const o = i._nextUint32(),
          a = i._nextUint32(),
          l = i._nextUint32(),
          c = i._nextUint32(),
          u = i._nextUint64(),
          p = i._nextUint64(),
          h = new Sw(e, Mw.length + r, 3 * s * 8, !0);

    for (let t = 0; t < s; t++) n.levels.push({
      levelData: new Uint8Array(e.buffer, e.byteOffset + h._nextUint64(), h._nextUint64()),
      uncompressedByteLength: h._nextUint64()
    });

    const d = new Sw(e, o, a, !0),
          f = {
      vendorId: d._skip(4)._nextUint16(),
      descriptorType: d._nextUint16(),
      versionNumber: d._nextUint16(),
      descriptorBlockSize: d._nextUint16(),
      colorModel: d._nextUint8(),
      colorPrimaries: d._nextUint8(),
      transferFunction: d._nextUint8(),
      flags: d._nextUint8(),
      texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      samples: []
    },
          _ = (f.descriptorBlockSize / 4 - 6) / 4;

    for (let e = 0; e < _; e++) {
      const t = {
        bitOffset: d._nextUint16(),
        bitLength: d._nextUint8(),
        channelType: d._nextUint8(),
        samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
        sampleLower: -1 / 0,
        sampleUpper: 1 / 0
      };
      64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t;
    }

    n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f);
    const m = new Sw(e, l, c, !0);

    for (; m._offset < c;) {
      const e = m._nextUint32(),
            t = m._scan(e),
            r = Tw(t),
            i = m._scan(e - t.byteLength);

      n.keyValue[r] = r.match(/^ktx/i) ? Tw(i) : i, m._offset % 4 && m._skip(4 - m._offset % 4);
    }

    if (p <= 0) return n;

    const g = new Sw(e, u, p, !0),
          v = g._nextUint16(),
          b = g._nextUint16(),
          x = g._nextUint32(),
          y = g._nextUint32(),
          w = g._nextUint32(),
          S = g._nextUint32(),
          M = [];

    for (let e = 0; e < s; e++) M.push({
      imageFlags: g._nextUint32(),
      rgbSliceByteOffset: g._nextUint32(),
      rgbSliceByteLength: g._nextUint32(),
      alphaSliceByteOffset: g._nextUint32(),
      alphaSliceByteLength: g._nextUint32()
    });

    const T = u + g._offset,
          E = T + x,
          A = E + y,
          C = A + w,
          R = new Uint8Array(e.buffer, e.byteOffset + T, x),
          k = new Uint8Array(e.buffer, e.byteOffset + E, y),
          P = new Uint8Array(e.buffer, e.byteOffset + A, w),
          D = new Uint8Array(e.buffer, e.byteOffset + C, S);
    return n.globalData = {
      endpointCount: v,
      selectorCount: b,
      imageDescs: M,
      endpointsData: R,
      selectorsData: k,
      tablesData: P,
      extendedData: D
    }, n;
  }

  class Aw extends qy {
    init() {
      this.extensionName = "EXT_mesh_gpu_instancing", this.propertyType = "InstancedMesh", this.parentTypes = [ly.NODE];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        attributes: {}
      });
    }

    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }

    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: "INSTANCE_ATTRIBUTE"
      });
    }

    listAttributes() {
      return this.listRefMapValues("attributes");
    }

    listSemantics() {
      return this.listRefMapKeys("attributes");
    }

  }

  Aw.EXTENSION_NAME = "EXT_mesh_gpu_instancing";
  const Cw = "EXT_mesh_gpu_instancing";

  function Rw() {
    return (Rw = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }).apply(this, arguments);
  }

  var kw, Pw, Dw;
  (class extends pw {
    constructor(...e) {
      super(...e), this.extensionName = Cw, this.provideTypes = [ly.NODE], this.prewriteTypes = [ly.ACCESSOR];
    }

    createInstancedMesh() {
      return new Aw(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.nodes || []).forEach((t, n) => {
        if (!t.extensions || !t.extensions[Cw]) return;
        const r = t.extensions[Cw],
              i = this.createInstancedMesh();

        for (const t in r.attributes) i.setAttribute(t, e.accessors[r.attributes[t]]);

        e.nodes[n].setExtension(Cw, i);
      }), this;
    }

    prewrite(e) {
      e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");

      for (const t of this.properties) for (const n of t.listAttributes()) e.addAccessorToUsageGroup(n, "INSTANCE_ATTRIBUTE");

      return this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listNodes().forEach(n => {
        const r = n.getExtension(Cw);

        if (r) {
          const i = e.nodeIndexMap.get(n),
                s = t.json.nodes[i],
                o = {
            attributes: {}
          };
          r.listSemantics().forEach(t => {
            const n = r.getAttribute(t);
            o.attributes[t] = e.accessorIndexMap.get(n);
          }), s.extensions = s.extensions || {}, s.extensions[Cw] = o;
        }
      }), this;
    }

  }).EXTENSION_NAME = Cw, function (e) {
    e.QUANTIZE = "quantize", e.FILTER = "filter";
  }(kw || (kw = {})), function (e) {
    e.ATTRIBUTES = "ATTRIBUTES", e.TRIANGLES = "TRIANGLES", e.INDICES = "INDICES";
  }(Pw || (Pw = {})), function (e) {
    e.NONE = "NONE", e.OCTAHEDRAL = "OCTAHEDRAL", e.QUATERNION = "QUATERNION", e.EXPONENTIAL = "EXPONENTIAL";
  }(Dw || (Dw = {}));
  const {
    BYTE: Ow,
    SHORT: Lw,
    FLOAT: Iw
  } = Vy.ComponentType,
        {
    normalize: Fw,
    denormalize: Nw
  } = Cy;

  function Uw(e, t, n, r) {
    const {
      filter: i,
      bits: s
    } = r,
          o = {
      array: e.getArray(),
      byteStride: e.getElementSize() * e.getComponentSize(),
      componentType: e.getComponentType(),
      normalized: e.getNormalized()
    };
    if (n !== Pw.ATTRIBUTES) return o;

    if (i !== Dw.NONE) {
      let n = e.getNormalized() ? function (e) {
        const t = e.getComponentType(),
              n = e.getArray(),
              r = new Float32Array(n.length);

        for (let e = 0; e < n.length; e++) r[e] = Nw(n[e], t);

        return r;
      }(e) : new Float32Array(o.array);

      switch (i) {
        case Dw.EXPONENTIAL:
          o.byteStride = 4 * e.getElementSize(), o.componentType = Iw, o.normalized = !1, o.array = t.encodeFilterExp(n, e.getCount(), o.byteStride, s);
          break;

        case Dw.OCTAHEDRAL:
          o.byteStride = s > 8 ? 8 : 4, o.componentType = s > 8 ? Lw : Ow, o.normalized = !0, n = 3 === e.getElementSize() ? function (e) {
            const t = new Float32Array(4 * e.length / 3);

            for (let n = 0, r = e.length / 3; n < r; n++) t[4 * n] = e[3 * n], t[4 * n + 1] = e[3 * n + 1], t[4 * n + 2] = e[3 * n + 2];

            return t;
          }(n) : n, o.array = t.encodeFilterOct(n, e.getCount(), o.byteStride, s);
          break;

        case Dw.QUATERNION:
          o.byteStride = 8, o.componentType = Lw, o.normalized = !0, o.array = t.encodeFilterQuat(n, e.getCount(), o.byteStride, s);
          break;

        default:
          throw new Error("Invalid filter.");
      }

      o.min = e.getMin([]), o.max = e.getMax([]), e.getNormalized() && (o.min = o.min.map(t => Nw(t, e.getComponentType())), o.max = o.max.map(t => Nw(t, e.getComponentType()))), o.normalized && (o.min = o.min.map(e => Fw(e, o.componentType)), o.max = o.max.map(e => Fw(e, o.componentType)));
    } else o.byteStride % 4 && (o.array = function (e, t) {
      const n = by.padNumber(e.BYTES_PER_ELEMENT * t) / e.BYTES_PER_ELEMENT,
            r = new e.constructor(e.length / t * n);

      for (let i = 0; i * t < e.length; i++) for (let s = 0; s < t; s++) r[i * n + s] = e[i * t + s];

      return r;
    }(o.array, e.getElementSize()), o.byteStride = o.array.byteLength / e.getCount());

    return o;
  }

  function Bw(e, t) {
    return t === gw.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? e.listParents().some(e => e instanceof rw && e.getMode() === rw.Mode.TRIANGLES) ? Pw.TRIANGLES : Pw.INDICES : Pw.ATTRIBUTES;
  }

  function jw(e, t) {
    const n = t.getGraph().listParentEdges(e).filter(e => !(e.getParent() instanceof cw));

    for (const t of n) {
      const n = t.getName(),
            r = t.getAttributes().key || "";
      if ("indices" === n) return {
        filter: Dw.NONE
      };

      if ("attributes" === n) {
        if ("POSITION" === r) return {
          filter: Dw.NONE
        };
        if ("TEXCOORD_0" === r) return {
          filter: Dw.NONE
        };
        if ("NORMAL" === r) return {
          filter: Dw.OCTAHEDRAL,
          bits: 8
        };
        if ("TANGENT" === r) return {
          filter: Dw.OCTAHEDRAL,
          bits: 8
        };
        if (r.startsWith("JOINTS_")) return {
          filter: Dw.NONE
        };
        if (r.startsWith("WEIGHTS_")) return {
          filter: Dw.NONE
        };
      }

      if ("output" === n) {
        const t = zw(e);
        return "rotation" === t ? {
          filter: Dw.QUATERNION,
          bits: 16
        } : "translation" === t || "scale" === t ? {
          filter: Dw.EXPONENTIAL,
          bits: 12
        } : {
          filter: Dw.NONE
        };
      }

      if ("input" === n) return {
        filter: Dw.NONE
      };
      if ("inverseBindMatrices" === n) return {
        filter: Dw.NONE
      };
    }

    return {
      filter: Dw.NONE
    };
  }

  function zw(e) {
    for (const t of e.listParents()) if (t instanceof Wy) for (const e of t.listParents()) if (e instanceof Hy) return e.getTargetPath();

    return null;
  }

  const Vw = "EXT_meshopt_compression",
        Gw = {
    method: kw.QUANTIZE
  };

  class Hw extends pw {
    constructor(...e) {
      super(...e), this.extensionName = Vw, this.prereadTypes = [ly.BUFFER, ly.PRIMITIVE], this.prewriteTypes = [ly.BUFFER, ly.ACCESSOR], this.readDependencies = ["meshopt.decoder"], this.writeDependencies = ["meshopt.encoder"], this._decoder = null, this._decoderFallbackBufferMap = new Map(), this._encoder = null, this._encoderOptions = Gw, this._encoderFallbackBuffer = null, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
    }

    install(e, t) {
      return "meshopt.decoder" === e && (this._decoder = t), "meshopt.encoder" === e && (this._encoder = t), this;
    }

    setEncoderOptions(e) {
      return this._encoderOptions = Rw({}, Gw, e), this;
    }

    preread(e, t) {
      if (!this._decoder) {
        if (!this.isRequired()) return this;
        throw new Error(`[${Vw}] Please install extension dependency, "meshopt.decoder".`);
      }

      if (!this._decoder.supported) {
        if (!this.isRequired()) return this;
        throw new Error(`[${Vw}]: Missing WASM support.`);
      }

      return t === ly.BUFFER ? this._prereadBuffers(e) : t === ly.PRIMITIVE && this._prereadPrimitives(e), this;
    }

    _prereadBuffers(e) {
      const t = e.jsonDoc;
      (t.json.bufferViews || []).forEach((n, r) => {
        if (!n.extensions || !n.extensions[Vw]) return;
        const i = n.extensions[Vw],
              s = i.byteOffset || 0,
              o = i.byteLength || 0,
              a = i.count,
              l = i.byteStride,
              c = new Uint8Array(a * l),
              u = t.json.buffers[n.buffer],
              p = by.toView(u.uri ? t.resources[u.uri] : t.resources["@glb.bin"], s, o);
        this._decoder.decodeGltfBuffer(c, a, l, p, i.mode, i.filter), e.bufferViews[r] = c;
      });
    }

    _prereadPrimitives(e) {
      const t = e.jsonDoc;
      (t.json.bufferViews || []).forEach(n => {
        var r;
        n.extensions && n.extensions[Vw] && (r = t.json.buffers[n.buffer]).extensions && r.extensions.EXT_meshopt_compression && r.extensions.EXT_meshopt_compression.fallback && this._decoderFallbackBufferMap.set(e.buffers[n.buffer], e.buffers[n.extensions[Vw].buffer]);
      });
    }

    read(e) {
      if (!this.isRequired()) return this;

      for (const [e, t] of this._decoderFallbackBufferMap) {
        for (const n of e.listParents()) n instanceof Vy && n.swap(e, t);

        e.dispose();
      }

      return this;
    }

    prewrite(e, t) {
      return t === ly.ACCESSOR ? this._prewriteAccessors(e) : t === ly.BUFFER && this._prewriteBuffers(e), this;
    }

    _prewriteAccessors(e) {
      const t = e.jsonDoc.json,
            n = this._encoder,
            r = this._encoderOptions,
            i = this.document.createBuffer(),
            s = this.document.getRoot().listBuffers().indexOf(i);
      this._encoderFallbackBuffer = i, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};

      for (const i of this.document.getRoot().listAccessors()) {
        if ("weights" === zw(i)) continue;
        const o = e.getAccessorUsage(i),
              a = Bw(i, o),
              l = r.method === kw.FILTER ? jw(i, this.document) : {
          filter: Dw.NONE
        },
              c = Uw(i, n, a, l),
              {
          array: u,
          byteStride: p
        } = c,
              h = i.getBuffer();
        if (!h) throw new Error(`${Vw}: Missing buffer for accessor.`);
        const d = this.document.getRoot().listBuffers().indexOf(h),
              f = [o, a, l.filter, p, d].join(":");
        let _ = this._encoderBufferViews[f],
            m = this._encoderBufferViewData[f],
            g = this._encoderBufferViewAccessors[f];
        _ && m || (g = this._encoderBufferViewAccessors[f] = [], m = this._encoderBufferViewData[f] = [], _ = this._encoderBufferViews[f] = {
          buffer: s,
          target: gw.USAGE_TO_TARGET[o],
          byteOffset: 0,
          byteLength: 0,
          byteStride: o === gw.BufferViewUsage.ARRAY_BUFFER ? p : void 0,
          extensions: {
            [Vw]: {
              buffer: d,
              byteOffset: 0,
              byteLength: 0,
              mode: a,
              filter: l.filter !== Dw.NONE ? l.filter : void 0,
              byteStride: p,
              count: 0
            }
          }
        });
        const v = e.createAccessorDef(i);
        v.componentType = c.componentType, v.normalized = c.normalized, v.byteOffset = _.byteLength, v.min && c.min && (v.min = c.min), v.max && c.max && (v.max = c.max), e.accessorIndexMap.set(i, t.accessors.length), t.accessors.push(v), g.push(v), m.push(new Uint8Array(u.buffer, u.byteOffset, u.byteLength)), _.byteLength += u.byteLength, _.extensions.EXT_meshopt_compression.count += i.getCount();
      }
    }

    _prewriteBuffers(e) {
      const t = this._encoder;

      for (const n in this._encoderBufferViews) {
        const r = this._encoderBufferViews[n],
              i = this._encoderBufferViewData[n],
              s = this.document.getRoot().listBuffers()[r.extensions[Vw].buffer],
              o = e.otherBufferViews.get(s) || [],
              {
          count: a,
          byteStride: l,
          mode: c
        } = r.extensions[Vw],
              u = by.concat(i),
              p = t.encodeGltfBuffer(u, a, l, c),
              h = by.pad(p);
        r.extensions[Vw].byteLength = p.byteLength, i.length = 0, i.push(h), o.push(h), e.otherBufferViews.set(s, o);
      }
    }

    write(e) {
      let t = 0;

      for (const n in this._encoderBufferViews) {
        const r = this._encoderBufferViews[n],
              i = e.otherBufferViewsIndexMap.get(this._encoderBufferViewData[n][0]),
              s = this._encoderBufferViewAccessors[n];

        for (const e of s) e.bufferView = i;

        const o = e.jsonDoc.json.bufferViews[i],
              a = o.byteOffset || 0;
        Object.assign(o, r), o.byteOffset = t, o.extensions[Vw].byteOffset = a, t += by.padNumber(r.byteLength);
      }

      const n = this._encoderFallbackBuffer,
            r = e.bufferIndexMap.get(n),
            i = e.jsonDoc.json.buffers[r];
      return i.byteLength = t, i.extensions = {
        [Vw]: {
          fallback: !0
        }
      }, n.dispose(), this;
    }

  }

  Hw.EXTENSION_NAME = Vw, Hw.EncoderMethod = kw;
  const Ww = "EXT_texture_webp";

  class Kw {
    match(e) {
      return e.length >= 12 && 87 === e[8] && 69 === e[9] && 66 === e[10] && 80 === e[11];
    }

    getSize(e) {
      const t = by.decodeText(e.slice(0, 4)),
            n = by.decodeText(e.slice(8, 12));
      if ("RIFF" !== t || "WEBP" !== n) return null;
      const r = new DataView(e.buffer, e.byteOffset);
      let i = 12;

      for (; i < r.byteLength;) {
        const e = by.decodeText(new Uint8Array([r.getUint8(i), r.getUint8(i + 1), r.getUint8(i + 2), r.getUint8(i + 3)])),
              t = r.getUint32(i + 4, !0);
        if ("VP8 " === e) return [16383 & r.getInt16(i + 14, !0), 16383 & r.getInt16(i + 16, !0)];

        if ("VP8L" === e) {
          const e = r.getUint8(i + 9),
                t = r.getUint8(i + 10),
                n = r.getUint8(i + 11);
          return [1 + ((63 & t) << 8 | e), 1 + ((15 & r.getUint8(i + 12)) << 10 | n << 2 | (192 & t) >> 6)];
        }

        i += 8 + t + t % 2;
      }

      return null;
    }

    getChannels(e) {
      return 4;
    }

  }

  (class extends pw {
    constructor(...e) {
      super(...e), this.extensionName = Ww, this.prereadTypes = [ly.TEXTURE];
    }

    static register() {
      wy.registerFormat("image/webp", new Kw());
    }

    preread(e) {
      return (e.jsonDoc.json.textures || []).forEach(e => {
        e.extensions && e.extensions.EXT_texture_webp && (e.source = e.extensions.EXT_texture_webp.source);
      }), this;
    }

    read(e) {
      return this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listTextures().forEach(n => {
        if ("image/webp" === n.getMimeType()) {
          const r = e.imageIndexMap.get(n);
          (t.json.textures || []).forEach(e => {
            e.source === r && (e.extensions = e.extensions || {}, e.extensions.EXT_texture_webp = {
              source: e.source
            }, delete e.source);
          });
        }
      }), this;
    }

  }).EXTENSION_NAME = Ww;
  const Xw = "KHR_draco_mesh_compression";
  let qw, Yw, Zw, Jw;

  function $w(e, t) {
    const n = new qw.DecoderBuffer();

    try {
      if (n.Init(t, t.length), e.GetEncodedGeometryType(n) !== qw.TRIANGULAR_MESH) throw new Error(`[${Xw}] Unknown geometry type.`);
      const r = new qw.Mesh();
      if (!e.DecodeBufferToMesh(n, r).ok() || 0 === r.ptr) throw new Error(`[${Xw}] Decoding failure.`);
      return r;
    } finally {
      qw.destroy(n);
    }
  }

  function Qw(e, t) {
    const n = 3 * t.num_faces();
    let r, i;

    if (t.num_points() <= 65534) {
      const s = n * Uint16Array.BYTES_PER_ELEMENT;
      r = qw._malloc(s), e.GetTrianglesUInt16Array(t, s, r), i = new Uint16Array(qw.HEAPU16.buffer, r, n).slice();
    } else {
      const s = n * Uint32Array.BYTES_PER_ELEMENT;
      r = qw._malloc(s), e.GetTrianglesUInt32Array(t, s, r), i = new Uint32Array(qw.HEAPU32.buffer, r, n).slice();
    }

    return qw._free(r), i;
  }

  function eS(e, t, n, r) {
    const i = Zw[r.componentType],
          s = Yw[r.componentType],
          o = n.num_components(),
          a = t.num_points() * o,
          l = a * s.BYTES_PER_ELEMENT,
          c = qw._malloc(l);

    e.GetAttributeDataArrayForAllPoints(t, n, i, l, c);
    const u = new s(qw.HEAPF32.buffer, c, a).slice();
    return qw._free(c), u;
  }

  var tS, nS;
  !function (e) {
    e[e.EDGEBREAKER = 1] = "EDGEBREAKER", e[e.SEQUENTIAL = 0] = "SEQUENTIAL";
  }(tS || (tS = {})), function (e) {
    e.POSITION = "POSITION", e.NORMAL = "NORMAL", e.COLOR = "COLOR", e.TEX_COORD = "TEX_COORD", e.GENERIC = "GENERIC";
  }(nS || (nS = {}));
  const rS = {
    [nS.POSITION]: 14,
    [nS.NORMAL]: 10,
    [nS.COLOR]: 8,
    [nS.TEX_COORD]: 12,
    [nS.GENERIC]: 12
  },
        iS = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    method: tS.EDGEBREAKER,
    quantizationBits: rS,
    quantizationVolume: "mesh"
  };

  function sS(e, t = iS) {
    const n = Rw({}, iS, t);
    n.quantizationBits = Rw({}, rS, t.quantizationBits);
    const r = new Jw.Encoder(),
          i = new Jw.MeshBuilder(),
          s = new Jw.Mesh(),
          o = {},
          a = new Jw.DracoInt8Array();

    for (const t of e.listSemantics()) {
      const a = e.getAttribute(t),
            l = oS(t),
            c = aS(i, a.getComponentType(), s, Jw[l], a.getCount(), a.getElementSize(), a.getArray());
      if (-1 === c) throw new Error(`Error compressing "${t}" attribute.`);
      if (o[t] = c, "mesh" === n.quantizationVolume || "POSITION" !== t) r.SetAttributeQuantization(Jw[l], n.quantizationBits[l]);else {
        if ("object" != typeof n.quantizationVolume) throw new Error("Invalid quantization volume state.");
        {
          const {
            quantizationVolume: e
          } = n,
                t = Math.max(e.max[0] - e.min[0], e.max[1] - e.min[1], e.max[2] - e.min[2]);
          r.SetAttributeExplicitQuantization(Jw[l], n.quantizationBits[l], a.getElementSize(), e.min, t);
        }
      }
    }

    const l = e.getIndices();
    if (!l) throw new Error("Primitive must have indices.");
    i.AddFacesToMesh(s, l.getCount() / 3, l.getArray()), r.SetSpeedOptions(n.encodeSpeed, n.decodeSpeed), r.SetTrackEncodedProperties(!0), n.method === tS.SEQUENTIAL || e.listTargets().length > 0 ? r.SetEncodingMethod(Jw.MESH_SEQUENTIAL_ENCODING) : r.SetEncodingMethod(Jw.MESH_EDGEBREAKER_ENCODING);
    const c = r.EncodeMeshToDracoBuffer(s, a);
    if (c <= 0) throw new Error("Error applying Draco compression.");
    const u = new Uint8Array(c);

    for (let e = 0; e < c; ++e) u[e] = a.GetValue(e);

    const p = e.getAttribute("POSITION").getCount(),
          h = r.GetNumberOfEncodedPoints(),
          d = 3 * r.GetNumberOfEncodedFaces();
    if (e.listTargets().length > 0 && h !== p) throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');
    return Jw.destroy(a), Jw.destroy(s), Jw.destroy(i), Jw.destroy(r), {
      numVertices: h,
      numIndices: d,
      data: u,
      attributeIDs: o
    };
  }

  function oS(e) {
    return "POSITION" === e ? nS.POSITION : "NORMAL" === e ? nS.NORMAL : e.startsWith("COLOR_") ? nS.COLOR : e.startsWith("TEXCOORD_") ? nS.TEX_COORD : nS.GENERIC;
  }

  function aS(e, t, n, r, i, s, o) {
    switch (t) {
      case Vy.ComponentType.UNSIGNED_BYTE:
        return e.AddUInt8Attribute(n, r, i, s, o);

      case Vy.ComponentType.BYTE:
        return e.AddInt8Attribute(n, r, i, s, o);

      case Vy.ComponentType.UNSIGNED_SHORT:
        return e.AddUInt16Attribute(n, r, i, s, o);

      case Vy.ComponentType.SHORT:
        return e.AddInt16Attribute(n, r, i, s, o);

      case Vy.ComponentType.UNSIGNED_INT:
        return e.AddUInt32Attribute(n, r, i, s, o);

      case Vy.ComponentType.FLOAT:
        return e.AddFloatAttribute(n, r, i, s, o);

      default:
        throw new Error(`Unexpected component type, "${t}".`);
    }
  }

  const lS = "KHR_draco_mesh_compression";

  class cS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = lS, this.prereadTypes = [ly.PRIMITIVE], this.prewriteTypes = [ly.ACCESSOR], this.readDependencies = ["draco3d.decoder"], this.writeDependencies = ["draco3d.encoder"], this._decoderModule = null, this._encoderModule = null, this._encoderOptions = {};
    }

    install(e, t) {
      return "draco3d.decoder" === e && (this._decoderModule = t, qw = this._decoderModule, Yw = {
        [Vy.ComponentType.FLOAT]: Float32Array,
        [Vy.ComponentType.UNSIGNED_INT]: Uint32Array,
        [Vy.ComponentType.UNSIGNED_SHORT]: Uint16Array,
        [Vy.ComponentType.UNSIGNED_BYTE]: Uint8Array,
        [Vy.ComponentType.SHORT]: Int16Array,
        [Vy.ComponentType.BYTE]: Int8Array
      }, Zw = {
        [Vy.ComponentType.FLOAT]: qw.DT_FLOAT32,
        [Vy.ComponentType.UNSIGNED_INT]: qw.DT_UINT32,
        [Vy.ComponentType.UNSIGNED_SHORT]: qw.DT_UINT16,
        [Vy.ComponentType.UNSIGNED_BYTE]: qw.DT_UINT8,
        [Vy.ComponentType.SHORT]: qw.DT_INT16,
        [Vy.ComponentType.BYTE]: qw.DT_INT8
      }), "draco3d.encoder" === e && (this._encoderModule = t, Jw = this._encoderModule), this;
    }

    setEncoderOptions(e) {
      return this._encoderOptions = e, this;
    }

    preread(e) {
      if (!this._decoderModule) throw new Error(`[${lS}] Please install extension dependency, "draco3d.decoder".`);
      const t = this.document.getLogger(),
            n = e.jsonDoc,
            r = new Map();

      try {
        const i = n.json.meshes || [];

        for (const s of i) for (const i of s.primitives) {
          if (!i.extensions || !i.extensions[lS]) continue;
          const s = i.extensions[lS];
          let [o, a] = r.get(s.bufferView) || [];

          if (!a || !o) {
            const e = n.json.bufferViews[s.bufferView],
                  i = n.json.buffers[e.buffer],
                  l = by.toView(i.uri ? n.resources[i.uri] : n.resources["@glb.bin"], e.byteOffset || 0, e.byteLength);
            o = new this._decoderModule.Decoder(), a = $w(o, l), r.set(s.bufferView, [o, a]), t.debug(`[${lS}] Decompressed ${l.byteLength} bytes.`);
          }

          for (const t in i.attributes) {
            const n = e.jsonDoc.json.accessors[i.attributes[t]],
                  r = o.GetAttributeByUniqueId(a, s.attributes[t]),
                  l = eS(o, a, r, n);
            e.accessors[i.attributes[t]].setArray(l);
          }

          void 0 !== i.indices && e.accessors[i.indices].setArray(Qw(o, a));
        }
      } finally {
        for (const [e, t] of Array.from(r.values())) this._decoderModule.destroy(e), this._decoderModule.destroy(t);
      }

      return this;
    }

    read(e) {
      return this;
    }

    prewrite(e, t) {
      if (!this._encoderModule) throw new Error(`[${lS}] Please install extension dependency, "draco3d.encoder".`);
      const n = this.document.getLogger();
      n.debug(`[${lS}] Compression options: ${JSON.stringify(this._encoderOptions)}`);

      const r = function (e) {
        const t = e.getLogger(),
              n = new Set(),
              r = new Set();

        for (const i of e.getRoot().listMeshes()) for (const e of i.listPrimitives()) e.getIndices() ? e.getMode() !== rw.Mode.TRIANGLES ? (r.add(e), t.warn(`[${lS}] Skipping Draco compression on non-TRIANGLES primitive.`)) : n.add(e) : (r.add(e), t.warn(`[${lS}] Skipping Draco compression on non-indexed primitive.`));

        const i = e.getRoot().listAccessors(),
              s = new Map();

        for (let e = 0; e < i.length; e++) s.set(i[e], e);

        const o = new Map(),
              a = new Set(),
              l = new Map();

        for (const t of Array.from(n)) {
          let n = uS(t, s);
          if (a.has(n)) l.set(t, n);else {
            if (o.has(t.getIndices())) {
              const n = t.getIndices(),
                    r = n.clone();
              s.set(r, e.getRoot().listAccessors().length - 1), t.swap(n, r);
            }

            for (const n of t.listAttributes()) if (o.has(n)) {
              const r = n.clone();
              s.set(r, e.getRoot().listAccessors().length - 1), t.swap(n, r);
            }

            n = uS(t, s), a.add(n), l.set(t, n), o.set(t.getIndices(), n);

            for (const e of t.listAttributes()) o.set(e, n);
          }
        }

        for (const e of Array.from(o.keys())) {
          const t = new Set(e.listParents().map(e => e.propertyType));
          if (2 !== t.size || !t.has(ly.PRIMITIVE) || !t.has(ly.ROOT)) throw new Error(`[${lS}] Compressed accessors must only be used as indices or vertex attributes.`);
        }

        for (const e of Array.from(n)) {
          const t = l.get(e),
                n = e.getIndices();
          if (o.get(n) !== t || e.listAttributes().some(e => o.get(e) !== t)) throw new Error(`[${lS}] Draco primitives must share all, or no, accessors.`);
        }

        for (const e of Array.from(r)) {
          const t = e.getIndices();
          if (o.has(t) || e.listAttributes().some(e => o.has(e))) throw new Error(`[${lS}] Accessor cannot be shared by compressed and uncompressed primitives.`);
        }

        return l;
      }(this.document),
            i = new Map();

      let s = "mesh";
      "scene" === this._encoderOptions.quantizationVolume && (1 !== this.document.getRoot().listScenes().length ? n.warn(`[${lS}]: quantizationVolume=scene requires exactly 1 scene.`) : s = function (e) {
        const t = {
          min: [1 / 0, 1 / 0, 1 / 0],
          max: [-1 / 0, -1 / 0, -1 / 0]
        },
              n = e.propertyType === ly.NODE ? [e] : e.listChildren();

        for (const e of n) e.traverse(e => {
          const n = e.getMesh();
          if (!n) return;
          const r = gy(n, e.getWorldMatrix());
          vy(r.min, t), vy(r.max, t);
        });

        return t;
      }(this.document.getRoot().listScenes().pop()));

      for (const t of Array.from(r.keys())) {
        const n = r.get(t);
        if (!n) throw new Error("Unexpected primitive.");

        if (i.has(n)) {
          i.set(n, i.get(n));
          continue;
        }

        const o = t.getIndices(),
              a = e.jsonDoc.json.accessors,
              l = sS(t, Rw({}, this._encoderOptions, {
          quantizationVolume: s
        }));
        i.set(n, l);
        const c = e.createAccessorDef(o);
        c.count = l.numIndices, e.accessorIndexMap.set(o, a.length), a.push(c);

        for (const n of t.listSemantics()) {
          const r = t.getAttribute(n),
                i = e.createAccessorDef(r);
          i.count = l.numVertices, e.accessorIndexMap.set(r, a.length), a.push(i);
        }

        const u = t.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
        e.otherBufferViews.has(u) || e.otherBufferViews.set(u, []), e.otherBufferViews.get(u).push(l.data);
      }

      return n.debug(`[${lS}] Compressed ${r.size} primitives.`), e.extensionData[lS] = {
        primitiveHashMap: r,
        primitiveEncodingMap: i
      }, this;
    }

    write(e) {
      const t = e.extensionData[lS];

      for (const n of this.document.getRoot().listMeshes()) {
        const r = e.jsonDoc.json.meshes[e.meshIndexMap.get(n)];

        for (let i = 0; i < n.listPrimitives().length; i++) {
          const s = n.listPrimitives()[i],
                o = r.primitives[i],
                a = t.primitiveHashMap.get(s);
          if (!a) continue;
          const l = t.primitiveEncodingMap.get(a);
          o.extensions = o.extensions || {}, o.extensions[lS] = {
            bufferView: e.otherBufferViewsIndexMap.get(l.data),
            attributes: l.attributeIDs
          };
        }
      }

      if (!t.primitiveHashMap.size) {
        const t = e.jsonDoc.json;
        t.extensionsUsed = (t.extensionsUsed || []).filter(e => e !== lS), t.extensionsRequired = (t.extensionsRequired || []).filter(e => e !== lS);
      }

      return this;
    }

  }

  function uS(e, t) {
    const n = [],
          r = e.getIndices();
    n.push(t.get(r));

    for (const r of e.listAttributes()) n.push(t.get(r));

    return n.sort().join("|");
  }

  cS.EXTENSION_NAME = lS, cS.EncoderMethod = tS;

  class pS extends qy {
    init() {
      this.extensionName = "KHR_lights_punctual", this.propertyType = "Light", this.parentTypes = [ly.NODE];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        color: [1, 1, 1],
        intensity: 1,
        type: pS.Type.POINT,
        range: null,
        innerConeAngle: 0,
        outerConeAngle: Math.PI / 4
      });
    }

    getColor() {
      return this.get("color");
    }

    setColor(e) {
      return this.set("color", e);
    }

    getColorHex() {
      return xy.factorToHex(this.getColor());
    }

    setColorHex(e) {
      const t = this.getColor().slice();
      return xy.hexToFactor(e, t), this.setColor(t);
    }

    getIntensity() {
      return this.get("intensity");
    }

    setIntensity(e) {
      return this.set("intensity", e);
    }

    getType() {
      return this.get("type");
    }

    setType(e) {
      return this.set("type", e);
    }

    getRange() {
      return this.get("range");
    }

    setRange(e) {
      return this.set("range", e);
    }

    getInnerConeAngle() {
      return this.get("innerConeAngle");
    }

    setInnerConeAngle(e) {
      return this.set("innerConeAngle", e);
    }

    getOuterConeAngle() {
      return this.get("outerConeAngle");
    }

    setOuterConeAngle(e) {
      return this.set("outerConeAngle", e);
    }

  }

  pS.EXTENSION_NAME = "KHR_lights_punctual", pS.Type = {
    POINT: "point",
    SPOT: "spot",
    DIRECTIONAL: "directional"
  };
  const hS = "KHR_lights_punctual";

  class dS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = hS;
    }

    createLight(e = "") {
      return new pS(this.document.getGraph(), e);
    }

    read(e) {
      const t = e.jsonDoc;
      if (!t.json.extensions || !t.json.extensions.KHR_lights_punctual) return this;
      const n = (t.json.extensions.KHR_lights_punctual.lights || []).map(e => {
        var t, n;
        const r = this.createLight().setName(e.name || "").setType(e.type);
        return void 0 !== e.color && r.setColor(e.color), void 0 !== e.intensity && r.setIntensity(e.intensity), void 0 !== e.range && r.setRange(e.range), void 0 !== (null == (t = e.spot) ? void 0 : t.innerConeAngle) && r.setInnerConeAngle(e.spot.innerConeAngle), void 0 !== (null == (n = e.spot) ? void 0 : n.outerConeAngle) && r.setOuterConeAngle(e.spot.outerConeAngle), r;
      });
      return t.json.nodes.forEach((t, r) => {
        t.extensions && t.extensions.KHR_lights_punctual && e.nodes[r].setExtension(hS, n[t.extensions.KHR_lights_punctual.light]);
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      if (0 === this.properties.size) return this;
      const n = [],
            r = new Map();

      for (const e of this.properties) {
        const t = e,
              i = {
          type: t.getType()
        };
        Cy.eq(t.getColor(), [1, 1, 1]) || (i.color = t.getColor()), 1 !== t.getIntensity() && (i.intensity = t.getIntensity()), null != t.getRange() && (i.range = t.getRange()), t.getName() && (i.name = t.getName()), t.getType() === pS.Type.SPOT && (i.spot = {
          innerConeAngle: t.getInnerConeAngle(),
          outerConeAngle: t.getOuterConeAngle()
        }), n.push(i), r.set(t, n.length - 1);
      }

      return this.document.getRoot().listNodes().forEach(n => {
        const i = n.getExtension(hS);

        if (i) {
          const s = e.nodeIndexMap.get(n),
                o = t.json.nodes[s];
          o.extensions = o.extensions || {}, o.extensions.KHR_lights_punctual = {
            light: r.get(i)
          };
        }
      }), t.json.extensions = t.json.extensions || {}, t.json.extensions.KHR_lights_punctual = {
        lights: n
      }, this;
    }

  }

  dS.EXTENSION_NAME = hS;
  const {
    R: fS,
    G: _S,
    B: mS
  } = py;

  class gS extends qy {
    init() {
      this.extensionName = "KHR_materials_clearcoat", this.propertyType = "Clearcoat", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        clearcoatFactor: 0,
        clearcoatTexture: null,
        clearcoatTextureInfo: new Yy(this.graph, "clearcoatTextureInfo"),
        clearcoatRoughnessFactor: 0,
        clearcoatRoughnessTexture: null,
        clearcoatRoughnessTextureInfo: new Yy(this.graph, "clearcoatRoughnessTextureInfo"),
        clearcoatNormalScale: 1,
        clearcoatNormalTexture: null,
        clearcoatNormalTextureInfo: new Yy(this.graph, "clearcoatNormalTextureInfo")
      });
    }

    getClearcoatFactor() {
      return this.get("clearcoatFactor");
    }

    setClearcoatFactor(e) {
      return this.set("clearcoatFactor", e);
    }

    getClearcoatTexture() {
      return this.getRef("clearcoatTexture");
    }

    getClearcoatTextureInfo() {
      return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null;
    }

    setClearcoatTexture(e) {
      return this.setRef("clearcoatTexture", e, {
        channels: fS
      });
    }

    getClearcoatRoughnessFactor() {
      return this.get("clearcoatRoughnessFactor");
    }

    setClearcoatRoughnessFactor(e) {
      return this.set("clearcoatRoughnessFactor", e);
    }

    getClearcoatRoughnessTexture() {
      return this.getRef("clearcoatRoughnessTexture");
    }

    getClearcoatRoughnessTextureInfo() {
      return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null;
    }

    setClearcoatRoughnessTexture(e) {
      return this.setRef("clearcoatRoughnessTexture", e, {
        channels: _S
      });
    }

    getClearcoatNormalScale() {
      return this.get("clearcoatNormalScale");
    }

    setClearcoatNormalScale(e) {
      return this.set("clearcoatNormalScale", e);
    }

    getClearcoatNormalTexture() {
      return this.getRef("clearcoatNormalTexture");
    }

    getClearcoatNormalTextureInfo() {
      return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null;
    }

    setClearcoatNormalTexture(e) {
      return this.setRef("clearcoatNormalTexture", e, {
        channels: fS | _S | mS
      });
    }

  }

  gS.EXTENSION_NAME = "KHR_materials_clearcoat";
  const vS = "KHR_materials_clearcoat";

  class bS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = vS;
    }

    createClearcoat() {
      return new gS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[vS]) {
          const i = this.createClearcoat();
          e.materials[r].setExtension(vS, i);
          const s = t.extensions[vS];

          if (void 0 !== s.clearcoatFactor && i.setClearcoatFactor(s.clearcoatFactor), void 0 !== s.clearcoatRoughnessFactor && i.setClearcoatRoughnessFactor(s.clearcoatRoughnessFactor), void 0 !== s.clearcoatTexture) {
            const t = s.clearcoatTexture;
            i.setClearcoatTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatTextureInfo(), t);
          }

          if (void 0 !== s.clearcoatRoughnessTexture) {
            const t = s.clearcoatRoughnessTexture;
            i.setClearcoatRoughnessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatRoughnessTextureInfo(), t);
          }

          if (void 0 !== s.clearcoatNormalTexture) {
            const t = s.clearcoatNormalTexture;
            i.setClearcoatNormalTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatNormalTextureInfo(), t), void 0 !== t.scale && i.setClearcoatNormalScale(t.scale);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(vS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[vS] = {
            clearcoatFactor: r.getClearcoatFactor(),
            clearcoatRoughnessFactor: r.getClearcoatRoughnessFactor()
          };

          if (r.getClearcoatTexture()) {
            const t = r.getClearcoatTexture(),
                  n = r.getClearcoatTextureInfo();
            o.clearcoatTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getClearcoatRoughnessTexture()) {
            const t = r.getClearcoatRoughnessTexture(),
                  n = r.getClearcoatRoughnessTextureInfo();
            o.clearcoatRoughnessTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getClearcoatNormalTexture()) {
            const t = r.getClearcoatNormalTexture(),
                  n = r.getClearcoatNormalTextureInfo();
            o.clearcoatNormalTexture = e.createTextureInfoDef(t, n), 1 !== r.getClearcoatNormalScale() && (o.clearcoatNormalTexture.scale = r.getClearcoatNormalScale());
          }
        }
      }), this;
    }

  }

  bS.EXTENSION_NAME = vS;

  class xS extends qy {
    init() {
      this.extensionName = "KHR_materials_emissive_strength", this.propertyType = "EmissiveStrength", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        emissiveStrength: 1
      });
    }

    getEmissiveStrength() {
      return this.get("emissiveStrength");
    }

    setEmissiveStrength(e) {
      return this.set("emissiveStrength", e);
    }

  }

  xS.EXTENSION_NAME = "KHR_materials_emissive_strength";
  const yS = "KHR_materials_emissive_strength";

  class wS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = yS;
    }

    createEmissiveStrength() {
      return new xS(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions[yS]) {
          const r = this.createEmissiveStrength();
          e.materials[n].setExtension(yS, r);
          const i = t.extensions[yS];
          void 0 !== i.emissiveStrength && r.setEmissiveStrength(i.emissiveStrength);
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(yS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {}, s.extensions[yS] = {
            emissiveStrength: r.getEmissiveStrength()
          };
        }
      }), this;
    }

  }

  wS.EXTENSION_NAME = yS;

  class SS extends qy {
    init() {
      this.extensionName = "KHR_materials_ior", this.propertyType = "IOR", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        ior: 0
      });
    }

    getIOR() {
      return this.get("ior");
    }

    setIOR(e) {
      return this.set("ior", e);
    }

  }

  SS.EXTENSION_NAME = "KHR_materials_ior";
  const MS = "KHR_materials_ior";

  class TS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = MS;
    }

    createIOR() {
      return new SS(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions.KHR_materials_ior) {
          const r = this.createIOR();
          e.materials[n].setExtension(MS, r);
          const i = t.extensions.KHR_materials_ior;
          void 0 !== i.ior && r.setIOR(i.ior);
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(MS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {}, s.extensions.KHR_materials_ior = {
            ior: r.getIOR()
          };
        }
      }), this;
    }

  }

  TS.EXTENSION_NAME = MS;
  const {
    R: ES,
    G: AS
  } = py;

  class CS extends qy {
    init() {
      this.extensionName = "KHR_materials_iridescence", this.propertyType = "Iridescence", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        iridescenceFactor: 0,
        iridescenceTexture: null,
        iridescenceTextureInfo: new Yy(this.graph, "iridescenceTextureInfo"),
        iridescenceIOR: 1.3,
        iridescenceThicknessMinimum: 100,
        iridescenceThicknessMaximum: 400,
        iridescenceThicknessTexture: null,
        iridescenceThicknessTextureInfo: new Yy(this.graph, "iridescenceThicknessTextureInfo")
      });
    }

    getIridescenceFactor() {
      return this.get("iridescenceFactor");
    }

    setIridescenceFactor(e) {
      return this.set("iridescenceFactor", e);
    }

    getIridescenceTexture() {
      return this.getRef("iridescenceTexture");
    }

    getIridescenceTextureInfo() {
      return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null;
    }

    setIridescenceTexture(e) {
      return this.setRef("iridescenceTexture", e, {
        channels: ES
      });
    }

    getIridescenceIOR() {
      return this.get("iridescenceIOR");
    }

    setIridescenceIOR(e) {
      return this.set("iridescenceIOR", e);
    }

    getIridescenceThicknessMinimum() {
      return this.get("iridescenceThicknessMinimum");
    }

    setIridescenceThicknessMinimum(e) {
      return this.set("iridescenceThicknessMinimum", e);
    }

    getIridescenceThicknessMaximum() {
      return this.get("iridescenceThicknessMaximum");
    }

    setIridescenceThicknessMaximum(e) {
      return this.set("iridescenceThicknessMaximum", e);
    }

    getIridescenceThicknessTexture() {
      return this.getRef("iridescenceThicknessTexture");
    }

    getIridescenceThicknessTextureInfo() {
      return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null;
    }

    setIridescenceThicknessTexture(e) {
      return this.setRef("iridescenceThicknessTexture", e, {
        channels: AS
      });
    }

  }

  CS.EXTENSION_NAME = "KHR_materials_iridescence";
  const RS = "KHR_materials_iridescence";

  class kS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = RS;
    }

    createIridescence() {
      return new CS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[RS]) {
          const i = this.createIridescence();
          e.materials[r].setExtension(RS, i);
          const s = t.extensions[RS];

          if (void 0 !== s.iridescenceFactor && i.setIridescenceFactor(s.iridescenceFactor), void 0 !== s.iridescenceIor && i.setIridescenceIOR(s.iridescenceIor), void 0 !== s.iridescenceThicknessMinimum && i.setIridescenceThicknessMinimum(s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && i.setIridescenceThicknessMaximum(s.iridescenceThicknessMaximum), void 0 !== s.iridescenceTexture) {
            const t = s.iridescenceTexture;
            i.setIridescenceTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getIridescenceTextureInfo(), t);
          }

          if (void 0 !== s.iridescenceThicknessTexture) {
            const t = s.iridescenceThicknessTexture;
            i.setIridescenceThicknessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getIridescenceThicknessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(RS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[RS] = {};

          if (r.getIridescenceFactor() > 0 && (o.iridescenceFactor = r.getIridescenceFactor()), 1.3 !== r.getIridescenceIOR() && (o.iridescenceIor = r.getIridescenceIOR()), 100 !== r.getIridescenceThicknessMinimum() && (o.iridescenceThicknessMinimum = r.getIridescenceThicknessMinimum()), 400 !== r.getIridescenceThicknessMaximum() && (o.iridescenceThicknessMaximum = r.getIridescenceThicknessMaximum()), r.getIridescenceTexture()) {
            const t = r.getIridescenceTexture(),
                  n = r.getIridescenceTextureInfo();
            o.iridescenceTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getIridescenceThicknessTexture()) {
            const t = r.getIridescenceThicknessTexture(),
                  n = r.getIridescenceThicknessTextureInfo();
            o.iridescenceThicknessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  kS.EXTENSION_NAME = RS;
  const {
    R: PS,
    G: DS,
    B: OS,
    A: LS
  } = py;

  class IS extends qy {
    init() {
      this.extensionName = "KHR_materials_pbrSpecularGlossiness", this.propertyType = "PBRSpecularGlossiness", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        diffuseFactor: [1, 1, 1, 1],
        diffuseTexture: null,
        diffuseTextureInfo: new Yy(this.graph, "diffuseTextureInfo"),
        specularFactor: [1, 1, 1],
        glossinessFactor: 1,
        specularGlossinessTexture: null,
        specularGlossinessTextureInfo: new Yy(this.graph, "specularGlossinessTextureInfo")
      });
    }

    getDiffuseFactor() {
      return this.get("diffuseFactor");
    }

    setDiffuseFactor(e) {
      return this.set("diffuseFactor", e);
    }

    getDiffuseHex() {
      return xy.factorToHex(this.getDiffuseFactor());
    }

    setDiffuseHex(e) {
      const t = this.getDiffuseFactor().slice();
      return this.setDiffuseFactor(xy.hexToFactor(e, t));
    }

    getDiffuseTexture() {
      return this.getRef("diffuseTexture");
    }

    getDiffuseTextureInfo() {
      return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null;
    }

    setDiffuseTexture(e) {
      return this.setRef("diffuseTexture", e, {
        channels: PS | DS | OS | LS
      });
    }

    getSpecularFactor() {
      return this.get("specularFactor");
    }

    setSpecularFactor(e) {
      return this.set("specularFactor", e);
    }

    getGlossinessFactor() {
      return this.get("glossinessFactor");
    }

    setGlossinessFactor(e) {
      return this.set("glossinessFactor", e);
    }

    getSpecularGlossinessTexture() {
      return this.getRef("specularGlossinessTexture");
    }

    getSpecularGlossinessTextureInfo() {
      return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null;
    }

    setSpecularGlossinessTexture(e) {
      return this.setRef("specularGlossinessTexture", e, {
        channels: PS | DS | OS | LS
      });
    }

  }

  IS.EXTENSION_NAME = "KHR_materials_pbrSpecularGlossiness";
  const FS = "KHR_materials_pbrSpecularGlossiness";

  class NS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = FS;
    }

    createPBRSpecularGlossiness() {
      return new IS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[FS]) {
          const i = this.createPBRSpecularGlossiness();
          e.materials[r].setExtension(FS, i);
          const s = t.extensions[FS];

          if (void 0 !== s.diffuseFactor && i.setDiffuseFactor(s.diffuseFactor), void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.glossinessFactor && i.setGlossinessFactor(s.glossinessFactor), void 0 !== s.diffuseTexture) {
            const t = s.diffuseTexture;
            i.setDiffuseTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getDiffuseTextureInfo(), t);
          }

          if (void 0 !== s.specularGlossinessTexture) {
            const t = s.specularGlossinessTexture;
            i.setSpecularGlossinessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularGlossinessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(FS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[FS] = {
            diffuseFactor: r.getDiffuseFactor(),
            specularFactor: r.getSpecularFactor(),
            glossinessFactor: r.getGlossinessFactor()
          };

          if (r.getDiffuseTexture()) {
            const t = r.getDiffuseTexture(),
                  n = r.getDiffuseTextureInfo();
            o.diffuseTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getSpecularGlossinessTexture()) {
            const t = r.getSpecularGlossinessTexture(),
                  n = r.getSpecularGlossinessTextureInfo();
            o.specularGlossinessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  NS.EXTENSION_NAME = FS;
  const {
    R: US,
    G: BS,
    B: jS,
    A: zS
  } = py;

  class VS extends qy {
    init() {
      this.extensionName = "KHR_materials_sheen", this.propertyType = "Sheen", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        sheenColorFactor: [0, 0, 0],
        sheenColorTexture: null,
        sheenColorTextureInfo: new Yy(this.graph, "sheenColorTextureInfo"),
        sheenRoughnessFactor: 0,
        sheenRoughnessTexture: null,
        sheenRoughnessTextureInfo: new Yy(this.graph, "sheenRoughnessTextureInfo")
      });
    }

    getSheenColorFactor() {
      return this.get("sheenColorFactor");
    }

    getSheenColorHex() {
      return xy.factorToHex(this.getSheenColorFactor());
    }

    setSheenColorFactor(e) {
      return this.set("sheenColorFactor", e);
    }

    setSheenColorHex(e) {
      const t = this.getSheenColorFactor().slice();
      return this.set("sheenColorFactor", xy.hexToFactor(e, t));
    }

    getSheenColorTexture() {
      return this.getRef("sheenColorTexture");
    }

    getSheenColorTextureInfo() {
      return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null;
    }

    setSheenColorTexture(e) {
      return this.setRef("sheenColorTexture", e, {
        channels: US | BS | jS
      });
    }

    getSheenRoughnessFactor() {
      return this.get("sheenRoughnessFactor");
    }

    setSheenRoughnessFactor(e) {
      return this.set("sheenRoughnessFactor", e);
    }

    getSheenRoughnessTexture() {
      return this.getRef("sheenRoughnessTexture");
    }

    getSheenRoughnessTextureInfo() {
      return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null;
    }

    setSheenRoughnessTexture(e) {
      return this.setRef("sheenRoughnessTexture", e, {
        channels: zS
      });
    }

  }

  VS.EXTENSION_NAME = "KHR_materials_sheen";
  const GS = "KHR_materials_sheen";

  class HS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = GS;
    }

    createSheen() {
      return new VS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions.KHR_materials_sheen) {
          const i = this.createSheen();
          e.materials[r].setExtension(GS, i);
          const s = t.extensions.KHR_materials_sheen;

          if (void 0 !== s.sheenColorFactor && i.setSheenColorFactor(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && i.setSheenRoughnessFactor(s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture) {
            const t = s.sheenColorTexture;
            i.setSheenColorTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSheenColorTextureInfo(), t);
          }

          if (void 0 !== s.sheenRoughnessTexture) {
            const t = s.sheenRoughnessTexture;
            i.setSheenRoughnessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSheenRoughnessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(GS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions.KHR_materials_sheen = {
            sheenColorFactor: r.getSheenColorFactor(),
            sheenRoughnessFactor: r.getSheenRoughnessFactor()
          };

          if (r.getSheenColorTexture()) {
            const t = r.getSheenColorTexture(),
                  n = r.getSheenColorTextureInfo();
            o.sheenColorTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getSheenRoughnessTexture()) {
            const t = r.getSheenRoughnessTexture(),
                  n = r.getSheenRoughnessTextureInfo();
            o.sheenRoughnessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  HS.EXTENSION_NAME = GS;
  const {
    R: WS,
    G: KS,
    B: XS,
    A: qS
  } = py;

  class YS extends qy {
    init() {
      this.extensionName = "KHR_materials_specular", this.propertyType = "Specular", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        specularFactor: 1,
        specularTexture: null,
        specularTextureInfo: new Yy(this.graph, "specularTextureInfo"),
        specularColorFactor: [1, 1, 1],
        specularColorTexture: null,
        specularColorTextureInfo: new Yy(this.graph, "specularColorTextureInfo")
      });
    }

    getSpecularFactor() {
      return this.get("specularFactor");
    }

    setSpecularFactor(e) {
      return this.set("specularFactor", e);
    }

    getSpecularColorFactor() {
      return this.get("specularColorFactor");
    }

    setSpecularColorFactor(e) {
      return this.set("specularColorFactor", e);
    }

    getSpecularColorHex() {
      return xy.factorToHex(this.getSpecularColorFactor());
    }

    setSpecularColorHex(e) {
      const t = this.getSpecularColorFactor().slice();
      return this.set("specularColorFactor", xy.hexToFactor(e, t));
    }

    getSpecularTexture() {
      return this.getRef("specularTexture");
    }

    getSpecularTextureInfo() {
      return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null;
    }

    setSpecularTexture(e) {
      return this.setRef("specularTexture", e, {
        channels: qS
      });
    }

    getSpecularColorTexture() {
      return this.getRef("specularColorTexture");
    }

    getSpecularColorTextureInfo() {
      return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null;
    }

    setSpecularColorTexture(e) {
      return this.setRef("specularColorTexture", e, {
        channels: WS | KS | XS
      });
    }

  }

  YS.EXTENSION_NAME = "KHR_materials_specular";
  const ZS = "KHR_materials_specular";

  class JS extends pw {
    constructor(...e) {
      super(...e), this.extensionName = ZS;
    }

    createSpecular() {
      return new YS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[ZS]) {
          const i = this.createSpecular();
          e.materials[r].setExtension(ZS, i);
          const s = t.extensions[ZS];

          if (void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.specularColorFactor && i.setSpecularColorFactor(s.specularColorFactor), void 0 !== s.specularTexture) {
            const t = s.specularTexture;
            i.setSpecularTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularTextureInfo(), t);
          }

          if (void 0 !== s.specularColorTexture) {
            const t = s.specularColorTexture;
            i.setSpecularColorTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularColorTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(ZS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[ZS] = {};

          if (1 !== r.getSpecularFactor() && (o.specularFactor = r.getSpecularFactor()), Cy.eq(r.getSpecularColorFactor(), [1, 1, 1]) || (o.specularColorFactor = r.getSpecularColorFactor()), r.getSpecularTexture()) {
            const t = r.getSpecularTexture(),
                  n = r.getSpecularTextureInfo();
            o.specularTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getSpecularColorTexture()) {
            const t = r.getSpecularColorTexture(),
                  n = r.getSpecularColorTextureInfo();
            o.specularColorTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  JS.EXTENSION_NAME = ZS;
  const {
    R: $S
  } = py;

  class QS extends qy {
    init() {
      this.extensionName = "KHR_materials_transmission", this.propertyType = "Transmission", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        transmissionFactor: 0,
        transmissionTexture: null,
        transmissionTextureInfo: new Yy(this.graph, "transmissionTextureInfo")
      });
    }

    getTransmissionFactor() {
      return this.get("transmissionFactor");
    }

    setTransmissionFactor(e) {
      return this.set("transmissionFactor", e);
    }

    getTransmissionTexture() {
      return this.getRef("transmissionTexture");
    }

    getTransmissionTextureInfo() {
      return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null;
    }

    setTransmissionTexture(e) {
      return this.setRef("transmissionTexture", e, {
        channels: $S
      });
    }

  }

  QS.EXTENSION_NAME = "KHR_materials_transmission";
  const eM = "KHR_materials_transmission";

  class tM extends pw {
    constructor(...e) {
      super(...e), this.extensionName = eM;
    }

    createTransmission() {
      return new QS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[eM]) {
          const i = this.createTransmission();
          e.materials[r].setExtension(eM, i);
          const s = t.extensions[eM];

          if (void 0 !== s.transmissionFactor && i.setTransmissionFactor(s.transmissionFactor), void 0 !== s.transmissionTexture) {
            const t = s.transmissionTexture;
            i.setTransmissionTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getTransmissionTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(eM);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[eM] = {
            transmissionFactor: r.getTransmissionFactor()
          };

          if (r.getTransmissionTexture()) {
            const t = r.getTransmissionTexture(),
                  n = r.getTransmissionTextureInfo();
            o.transmissionTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  tM.EXTENSION_NAME = eM;

  class nM extends qy {
    init() {
      this.extensionName = "KHR_materials_unlit", this.propertyType = "Unlit", this.parentTypes = [ly.MATERIAL];
    }

  }

  nM.EXTENSION_NAME = "KHR_materials_unlit";
  const rM = "KHR_materials_unlit";

  class iM extends pw {
    constructor(...e) {
      super(...e), this.extensionName = rM;
    }

    createUnlit() {
      return new nM(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, n) => {
        t.extensions && t.extensions.KHR_materials_unlit && e.materials[n].setExtension(rM, this.createUnlit());
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        if (n.getExtension(rM)) {
          const r = e.materialIndexMap.get(n),
                i = t.json.materials[r];
          i.extensions = i.extensions || {}, i.extensions.KHR_materials_unlit = {};
        }
      }), this;
    }

  }

  iM.EXTENSION_NAME = rM;

  class sM extends qy {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Mapping", this.parentTypes = ["MappingList"];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        material: null,
        variants: []
      });
    }

    getMaterial() {
      return this.getRef("material");
    }

    setMaterial(e) {
      return this.setRef("material", e);
    }

    addVariant(e) {
      return this.addRef("variants", e);
    }

    removeVariant(e) {
      return this.removeRef("variants", e);
    }

    listVariants() {
      return this.listRefs("variants");
    }

  }

  sM.EXTENSION_NAME = "KHR_materials_variants";

  class oM extends qy {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "MappingList", this.parentTypes = [ly.PRIMITIVE];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        mappings: []
      });
    }

    addMapping(e) {
      return this.addRef("mappings", e);
    }

    removeMapping(e) {
      return this.removeRef("mappings", e);
    }

    listMappings() {
      return this.listRefs("mappings");
    }

  }

  oM.EXTENSION_NAME = "KHR_materials_variants";

  class aM extends qy {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Variant", this.parentTypes = ["MappingList"];
    }

  }

  aM.EXTENSION_NAME = "KHR_materials_variants";
  const lM = "KHR_materials_variants";

  class cM extends pw {
    constructor(...e) {
      super(...e), this.extensionName = lM;
    }

    createMappingList() {
      return new oM(this.document.getGraph());
    }

    createVariant(e = "") {
      return new aM(this.document.getGraph(), e);
    }

    createMapping() {
      return new sM(this.document.getGraph());
    }

    listVariants() {
      return Array.from(this.properties).filter(e => e instanceof aM);
    }

    read(e) {
      const t = e.jsonDoc;
      if (!t.json.extensions || !t.json.extensions[lM]) return this;
      const n = (t.json.extensions[lM].variants || []).map(e => this.createVariant().setName(e.name || ""));
      return (t.json.meshes || []).forEach((t, r) => {
        const i = e.meshes[r];
        (t.primitives || []).forEach((t, r) => {
          if (!t.extensions || !t.extensions[lM]) return;
          const s = this.createMappingList(),
                o = t.extensions[lM];

          for (const t of o.mappings) {
            const r = this.createMapping();
            void 0 !== t.material && r.setMaterial(e.materials[t.material]);

            for (const e of t.variants || []) r.addVariant(n[e]);

            s.addMapping(r);
          }

          i.listPrimitives()[r].setExtension(lM, s);
        });
      }), this;
    }

    write(e) {
      const t = e.jsonDoc,
            n = this.listVariants();
      if (!n.length) return this;
      const r = [],
            i = new Map();

      for (const t of n) i.set(t, r.length), r.push(e.createPropertyDef(t));

      for (const t of this.document.getRoot().listMeshes()) {
        const n = e.meshIndexMap.get(t);
        t.listPrimitives().forEach((t, r) => {
          const s = t.getExtension(lM);
          if (!s) return;
          const o = e.jsonDoc.json.meshes[n].primitives[r],
                a = s.listMappings().map(t => {
            const n = e.createPropertyDef(t),
                  r = t.getMaterial();
            return r && (n.material = e.materialIndexMap.get(r)), n.variants = t.listVariants().map(e => i.get(e)), n;
          });
          o.extensions = o.extensions || {}, o.extensions[lM] = {
            mappings: a
          };
        });
      }

      return t.json.extensions = t.json.extensions || {}, t.json.extensions[lM] = {
        variants: r
      }, this;
    }

  }

  cM.EXTENSION_NAME = lM;
  const {
    G: uM
  } = py;

  class pM extends qy {
    init() {
      this.extensionName = "KHR_materials_volume", this.propertyType = "Volume", this.parentTypes = [ly.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        thicknessFactor: 0,
        thicknessTexture: null,
        thicknessTextureInfo: new Yy(this.graph, "thicknessTexture"),
        attenuationDistance: 1 / 0,
        attenuationColor: [1, 1, 1]
      });
    }

    getThicknessFactor() {
      return this.get("thicknessFactor");
    }

    setThicknessFactor(e) {
      return this.set("thicknessFactor", e);
    }

    getThicknessTexture() {
      return this.getRef("thicknessTexture");
    }

    getThicknessTextureInfo() {
      return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null;
    }

    setThicknessTexture(e) {
      return this.setRef("thicknessTexture", e, {
        channels: uM
      });
    }

    getAttenuationDistance() {
      return this.get("attenuationDistance");
    }

    setAttenuationDistance(e) {
      return this.set("attenuationDistance", e);
    }

    getAttenuationColor() {
      return this.get("attenuationColor");
    }

    setAttenuationColor(e) {
      return this.set("attenuationColor", e);
    }

    getAttenuationColorHex() {
      return xy.factorToHex(this.getAttenuationColor());
    }

    setAttenuationColorHex(e) {
      const t = this.getAttenuationColor().slice();
      return this.set("attenuationColor", xy.hexToFactor(e, t));
    }

  }

  pM.EXTENSION_NAME = "KHR_materials_volume";
  const hM = "KHR_materials_volume";

  class dM extends pw {
    constructor(...e) {
      super(...e), this.extensionName = hM;
    }

    createVolume() {
      return new pM(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions.KHR_materials_volume) {
          const i = this.createVolume();
          e.materials[r].setExtension(hM, i);
          const s = t.extensions.KHR_materials_volume;

          if (void 0 !== s.thicknessFactor && i.setThicknessFactor(s.thicknessFactor), void 0 !== s.attenuationDistance && i.setAttenuationDistance(s.attenuationDistance), void 0 !== s.attenuationColor && i.setAttenuationColor(s.attenuationColor), void 0 !== s.thicknessTexture) {
            const t = s.thicknessTexture;
            i.setThicknessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getThicknessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(hM);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions.KHR_materials_volume = {};

          if (r.getThicknessFactor() > 0 && (o.thicknessFactor = r.getThicknessFactor()), Number.isFinite(r.getAttenuationDistance()) && (o.attenuationDistance = r.getAttenuationDistance()), Cy.eq(r.getAttenuationColor(), [1, 1, 1]) || (o.attenuationColor = r.getAttenuationColor()), r.getThicknessTexture()) {
            const t = r.getThicknessTexture(),
                  n = r.getThicknessTextureInfo();
            o.thicknessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  dM.EXTENSION_NAME = hM;
  const fM = "KHR_mesh_quantization";

  class _M extends pw {
    constructor(...e) {
      super(...e), this.extensionName = fM;
    }

    read(e) {
      return this;
    }

    write(e) {
      return this;
    }

  }

  _M.EXTENSION_NAME = fM;
  const mM = "KHR_texture_basisu";

  class gM {
    match(e) {
      return 171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 50 === e[5] && 48 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11];
    }

    getSize(e) {
      const t = Ew(e);
      return [t.pixelWidth, t.pixelHeight];
    }

    getChannels(e) {
      const t = Ew(e).dataFormatDescriptor[0];
      if (163 === t.colorModel) return 2 === t.samples.length && 15 == (15 & t.samples[1].channelType) ? 4 : 3;
      if (166 === t.colorModel) return 3 == (15 & t.samples[0].channelType) ? 4 : 3;
      throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`);
    }

    getGPUByteLength(e) {
      const t = Ew(e),
            n = this.getChannels(e) > 3;
      let r = 0;

      for (let e = 0; e < t.levels.length; e++) {
        const i = t.levels[e];
        r += i.uncompressedByteLength ? i.uncompressedByteLength : Math.max(1, Math.floor(t.pixelWidth / Math.pow(2, e))) / 4 * (Math.max(1, Math.floor(t.pixelHeight / Math.pow(2, e))) / 4) * (n ? 16 : 8);
      }

      return r;
    }

  }

  class vM extends pw {
    constructor(...e) {
      super(...e), this.extensionName = mM, this.prereadTypes = [ly.TEXTURE];
    }

    static register() {
      wy.registerFormat("image/ktx2", new gM());
    }

    preread(e) {
      return e.jsonDoc.json.textures.forEach(e => {
        e.extensions && e.extensions.KHR_texture_basisu && (e.source = e.extensions.KHR_texture_basisu.source);
      }), this;
    }

    read(e) {
      return this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listTextures().forEach(n => {
        if ("image/ktx2" === n.getMimeType()) {
          const r = e.imageIndexMap.get(n);
          t.json.textures.forEach(e => {
            e.source === r && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_basisu = {
              source: e.source
            }, delete e.source);
          });
        }
      }), this;
    }

  }

  vM.EXTENSION_NAME = mM;

  class bM extends qy {
    init() {
      this.extensionName = "KHR_texture_transform", this.propertyType = "Transform", this.parentTypes = [ly.TEXTURE_INFO];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        offset: [0, 0],
        rotation: 0,
        scale: [1, 1],
        texCoord: null
      });
    }

    getOffset() {
      return this.get("offset");
    }

    setOffset(e) {
      return this.set("offset", e);
    }

    getRotation() {
      return this.get("rotation");
    }

    setRotation(e) {
      return this.set("rotation", e);
    }

    getScale() {
      return this.get("scale");
    }

    setScale(e) {
      return this.set("scale", e);
    }

    getTexCoord() {
      return this.get("texCoord");
    }

    setTexCoord(e) {
      return this.set("texCoord", e);
    }

  }

  bM.EXTENSION_NAME = "KHR_texture_transform";
  const xM = "KHR_texture_transform";

  class yM extends pw {
    constructor(...e) {
      super(...e), this.extensionName = xM;
    }

    createTransform() {
      return new bM(this.document.getGraph());
    }

    read(e) {
      for (const [t, n] of Array.from(e.textureInfos.entries())) {
        if (!n.extensions || !n.extensions.KHR_texture_transform) continue;
        const e = this.createTransform(),
              r = n.extensions.KHR_texture_transform;
        void 0 !== r.offset && e.setOffset(r.offset), void 0 !== r.rotation && e.setRotation(r.rotation), void 0 !== r.scale && e.setScale(r.scale), void 0 !== r.texCoord && e.setTexCoord(r.texCoord), t.setExtension(xM, e);
      }

      return this;
    }

    write(e) {
      const t = Array.from(e.textureInfoDefMap.entries());

      for (const [e, n] of t) {
        const t = e.getExtension(xM);
        if (!t) continue;
        n.extensions = n.extensions || {};
        const r = {},
              i = Cy.eq;
        i(t.getOffset(), [0, 0]) || (r.offset = t.getOffset()), 0 !== t.getRotation() && (r.rotation = t.getRotation()), i(t.getScale(), [1, 1]) || (r.scale = t.getScale()), null != t.getTexCoord() && (r.texCoord = t.getTexCoord()), n.extensions.KHR_texture_transform = r;
      }

      return this;
    }

  }

  yM.EXTENSION_NAME = xM;
  const wM = [ly.ROOT, ly.SCENE, ly.NODE, ly.MESH, ly.MATERIAL, ly.TEXTURE, ly.ANIMATION];

  class SM extends qy {
    init() {
      this.extensionName = "KHR_xmp_json_ld", this.propertyType = "Packet", this.parentTypes = wM;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        context: {},
        properties: {}
      });
    }

    getContext() {
      return this.get("context");
    }

    setContext(e) {
      return this.set("context", Rw({}, e));
    }

    listProperties() {
      return Object.keys(this.get("properties"));
    }

    getProperty(e) {
      const t = this.get("properties");
      return e in t ? t[e] : null;
    }

    setProperty(e, t) {
      this._assertContext(e);

      const n = Rw({}, this.get("properties"));
      return t ? n[e] = t : delete n[e], this.set("properties", n);
    }

    toJSONLD() {
      return Rw({
        "@context": MM(this.get("context"))
      }, MM(this.get("properties")));
    }

    fromJSONLD(e) {
      const t = (e = MM(e))["@context"];
      return t && this.set("context", t), delete e["@context"], this.set("properties", e);
    }

    _assertContext(e) {
      if (!(e.split(":")[0] in this.get("context"))) throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`);
    }

  }

  function MM(e) {
    return JSON.parse(JSON.stringify(e));
  }

  SM.EXTENSION_NAME = "KHR_xmp_json_ld";
  const TM = "KHR_xmp_json_ld";

  class EM extends pw {
    constructor(...e) {
      super(...e), this.extensionName = TM;
    }

    createPacket() {
      return new SM(this.document.getGraph());
    }

    listPackets() {
      return Array.from(this.properties);
    }

    read(e) {
      var t;
      const n = null == (t = e.jsonDoc.json.extensions) ? void 0 : t.KHR_xmp_json_ld;
      if (!n || !n.packets) return this;
      const r = e.jsonDoc.json,
            i = this.document.getRoot(),
            s = n.packets.map(e => this.createPacket().fromJSONLD(e)),
            o = [[r.asset], r.scenes, r.nodes, r.meshes, r.materials, r.images, r.animations],
            a = [[i], i.listScenes(), i.listNodes(), i.listMeshes(), i.listMaterials(), i.listTextures(), i.listAnimations()];

      for (let e = 0; e < o.length; e++) {
        const t = o[e] || [];

        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          r.extensions && r.extensions.KHR_xmp_json_ld && a[e][n].setExtension(TM, s[r.extensions.KHR_xmp_json_ld.packet]);
        }
      }

      return this;
    }

    write(e) {
      const {
        json: t
      } = e.jsonDoc,
            n = [];

      for (const r of this.properties) {
        n.push(r.toJSONLD());

        for (const i of r.listParents()) {
          let r;

          switch (i.propertyType) {
            case ly.ROOT:
              r = t.asset;
              break;

            case ly.SCENE:
              r = t.scenes[e.sceneIndexMap.get(i)];
              break;

            case ly.NODE:
              r = t.nodes[e.nodeIndexMap.get(i)];
              break;

            case ly.MESH:
              r = t.meshes[e.meshIndexMap.get(i)];
              break;

            case ly.MATERIAL:
              r = t.materials[e.materialIndexMap.get(i)];
              break;

            case ly.TEXTURE:
              r = t.images[e.imageIndexMap.get(i)];
              break;

            case ly.ANIMATION:
              r = t.animations[e.animationIndexMap.get(i)];
              break;

            default:
              r = null, this.document.getLogger().warn(`[KHR_xmp_json_ld]: Unsupported parent property, "${i.propertyType}"`);
          }

          r && (r.extensions = r.extensions || {}, r.extensions.KHR_xmp_json_ld = {
            packet: n.length - 1
          });
        }
      }

      return n.length > 0 && (t.extensions = t.extensions || {}, t.extensions.KHR_xmp_json_ld = {
        packets: n
      }), this;
    }

  }

  EM.EXTENSION_NAME = TM;
  const AM = [cS, dS, bS, wS, TS, kS, NS, JS, HS, tM, iM, cM, dM, _M, vM, yM, EM];

  class CM extends zx {
    constructor(e) {
      super(), this._loadedLibs = !1, e = e || {
        method: cS.EncoderMethod.EDGEBREAKER,
        encodeSpeed: 5
      }, this._io = new yw().registerExtensions(AM).registerExtensions([PM, NM, LM, IM, FM, UM, BM, jM, zM, VM, GM, HM, WM, KM]), this._encoderOptions = e;
    }

    preload() {
      return this._loadLibs(), this;
    }

    async _loadLibs() {
      if (this._loadedLibs || !this.loader) return;
      const e = await Promise.all([this.loader.initEncoder(), this.loader.initDecoder()]);
      this._io.registerDependencies({
        "draco3d.encoder": e[0],
        "draco3d.decoder": e[1]
      }), this._loadedLibs = !0;
    }

    async parseAsync(e, t) {
      if (!this.loader) return console.error("GLTFDracoExporter: No DRACOLoader2 instance provided"), super.parseAsync(e, t);
      await this._loadLibs();
      const n = { ...t
      };
      n.compress && (n.externalImagesInExtras = !0);
      const r = await new Promise((t, r) => this.parse(e, t, r, n)),
            i = await super.parseAsync(r, n);
      if (!1 === n.compress) return i;
      if (!r) throw new Error("GLTFDracoExporter: gltf is null");
      let s = r;
      const o = s.byteLength || 1 / 0,
            a = await ("object" != typeof s || s.byteLength ? this._io.readBinary(new Uint8Array(s)) : this._io.readJSON({
        json: s,
        resources: {}
      }));
      if (a.createExtension(cS).setRequired(!0).setEncoderOptions(this._encoderOptions), "glb" === n.exportExt) s = await this._io.writeBinary(a), isFinite(o) && console.log("DRACO Compression ratio: " + (s.byteLength / o).toFixed(5));else {
        const e = await this._io.writeJSON(a);
        s = e.json, Object.values(e.resources).filter(e => e).length > 0 && (console.warn("DRACOExporter: extra resources in resources not supported properly"), s.resources = e.resources);
      }
      s.__isGLTFOutput = !0;
      const l = await super.parseAsync(s, n);
      return l.__uncompressed = i, l;
    }

  }

  class RM extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this.dependencies = [js, Zx];
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = e.getManager().importer;
      if (!t) throw new Error("GLTFDracoExportPlugin: AssetImporter not found");
      !function (e, t) {
        Gx(e, CM, e => {
          const n = Be() + ".drc",
                r = e;
          r.loader = t.registerFile(n), r.loader.setDecoderConfig({
            type: "js"
          }), r.loader.preload(!0, !0);
        });
      }(e, t);
    }

  }

  RM.PluginType = "GLTFDracoExportPlugin";

  class kM extends qy {
    constructor() {
      super(...arguments), this.extensionName = Yn, this.parentTypes = [ly.SCENE], this.propertyType = "ViewerJSON";
    }

    init() {}

  }

  class PM extends pw {
    constructor() {
      super(...arguments), this.extensionName = Yn, this._viewerConfig = {}, this._texturesRef = [], this.required = !0;
    }

    read(e) {
      var t;
      return this._viewerConfig = {}, null === (t = e.jsonDoc.json.scenes) || void 0 === t || t.forEach((t, n) => {
        if (t.extensions && t.extensions[Yn]) {
          const r = new kM(this.document.getGraph());
          e.scenes[n].setExtension(Yn, r);
          const i = t.extensions[Yn];
          this._viewerConfig = i;
        }
      }), this;
    }

    write(e) {
      return this.document.getRoot().listScenes().forEach(t => {
        var n;

        if (t.getExtension(Yn)) {
          const t = null === (n = e.jsonDoc.json.scenes) || void 0 === n ? void 0 : n[e.jsonDoc.json.scene || 0];
          t && this._viewerConfig !== {} && (t.extensions = t.extensions || {}, t.extensions[Yn] = this._viewerConfig, this._texturesRef = [], this._viewerConfig = {});
        }
      }), this;
    }

  }

  PM.EXTENSION_NAME = Yn;

  class DM extends qy {
    constructor(e, t, n) {
      super(e, t), this.parentTypes = [ly.MATERIAL, ly.MESH, ly.NODE, ly.SCENE], this.propertyType = "GenericExtension", this.textures = {}, this.extensionName = n;
    }

    addTexture(e, t, n, r = 4369) {
      this.setRef(e, n, {
        channels: r
      }), this.textures[e] = [t, n];
    }

    copy(e, t = By) {
      return super.copy(e, t), this;
    }

    dispose() {
      Object.values(this.textures).forEach(([e, t]) => {
        null == e || e.dispose();
      }), super.dispose();
    }

    init() {}

  }

  class OM extends pw {
    constructor() {
      super(...arguments), this.textureChannels = {};
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
      return n.forEach((t, n) => {
        var i, s;

        if (t.extensions && t.extensions[this.extensionName]) {
          const o = new DM(this.document.getGraph(), "", this.extensionName);
          e.materials[n].setExtension(this.extensionName, o);
          const a = { ...t.extensions[this.extensionName]
          };

          for (const [t, n] of Object.entries(a)) if ("number" == typeof (null == n ? void 0 : n.index)) {
            const l = n,
                  c = null === (i = r[l.index]) || void 0 === i ? void 0 : i.source;

            if ("number" != typeof c) {
              console.warn("GLTF Pipeline: source texture not found for texture info", l);
              continue;
            }

            const u = e.textures[c],
                  p = new Yy(this.document.getGraph()),
                  h = null !== (s = this.textureChannels[t]) && void 0 !== s ? s : 4369;
            o.addTexture(t, p, u, h), e.setTextureInfo(p, l), delete a[t];
          }

          o.setExtras(a);
        }
      }), (t.json.meshes || []).forEach((t, n) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const r = new DM(this.document.getGraph(), "", this.extensionName);
          e.meshes[n].setExtension(this.extensionName, r);
          const i = t.extensions[this.extensionName];
          r.setExtras(i);
        }
      }), (t.json.nodes || []).forEach((t, n) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const r = new DM(this.document.getGraph(), "", this.extensionName);
          e.nodes[n].setExtension(this.extensionName, r);
          const i = t.extensions[this.extensionName];
          r.setExtras(i);
        }
      }), (t.json.scenes || []).forEach((t, n) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const r = new DM(this.document.getGraph(), "", this.extensionName);
          e.scenes[n].setExtension(this.extensionName, r);
          const i = t.extensions[this.extensionName];
          r.setExtras(i);
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = { ...r.getExtras()
          };

          for (const [t, n] of Object.entries(r.textures)) {
            const r = n[0],
                  i = n[1];
            i && (o[t] = e.createTextureInfoDef(i, r));
          }

          s.extensions[this.extensionName] = o;
        }
      }), this.document.getRoot().listMeshes().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const i = e.meshIndexMap.get(n),
                s = t.json.meshes[i];
          s.extensions = s.extensions || {}, s.extensions[this.extensionName] = r.getExtras();
        }
      }), this.document.getRoot().listNodes().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const i = e.nodeIndexMap.get(n),
                s = t.json.nodes[i];
          s.extensions = s.extensions || {}, s.extensions[this.extensionName] = r.getExtras();
        }
      }), this.document.getRoot().listScenes().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const n = e.jsonDoc.json.scene || 0,
                i = t.json.scenes[n];
          if (!i) return;
          i.extensions = i.extensions || {}, i.extensions[this.extensionName] = r.getExtras();
        }
      }), this;
    }

  }

  class LM extends OM {
    constructor() {
      super(...arguments), this.extensionName = LM.EXTENSION_NAME, this.textureChannels = {
        bumpTexture: py.R
      };
    }

  }

  LM.EXTENSION_NAME = ir;

  class IM extends OM {
    constructor() {
      super(...arguments), this.extensionName = IM.EXTENSION_NAME, this.textureChannels = {
        lightMapTexture: py.R | py.G | py.B
      };
    }

  }

  IM.EXTENSION_NAME = or;

  class FM extends OM {
    constructor() {
      super(...arguments), this.extensionName = FM.EXTENSION_NAME, this.textureChannels = {
        alphaTexture: py.G
      };
    }

  }

  FM.EXTENSION_NAME = sr;

  class NM extends OM {
    constructor() {
      super(...arguments), this.extensionName = NM.EXTENSION_NAME;
    }

  }

  NM.EXTENSION_NAME = xc.DIAMOND_GLTF_EXTENSION;

  class UM extends OM {
    constructor() {
      super(...arguments), this.extensionName = UM.EXTENSION_NAME;
    }

  }

  UM.EXTENSION_NAME = Mc.AnimationMarkersExtension;

  class BM extends OM {
    constructor() {
      super(...arguments), this.extensionName = BM.EXTENSION_NAME, this.textureChannels = {
        anisotropyDirection: py.R | py.G | py.B
      };
    }

  }

  BM.EXTENSION_NAME = tu.ANISOTROPY_GLTF_EXTENSION;

  class jM extends OM {
    constructor() {
      super(...arguments), this.extensionName = jM.EXTENSION_NAME, this.textureChannels = {
        anisotropyDirection: py.R | py.G | py.B
      };
    }

  }

  jM.EXTENSION_NAME = mu.CUSTOM_BUMP_MAP_GLTF_EXTENSION;

  class zM extends OM {
    constructor() {
      super(...arguments), this.extensionName = zM.EXTENSION_NAME;
    }

  }

  zM.EXTENSION_NAME = Jn;

  class VM extends OM {
    constructor() {
      super(...arguments), this.extensionName = VM.EXTENSION_NAME;
    }

  }

  VM.EXTENSION_NAME = $n;

  class GM extends OM {
    constructor() {
      super(...arguments), this.extensionName = GM.EXTENSION_NAME;
    }

  }

  GM.EXTENSION_NAME = Qn;

  class HM extends OM {
    constructor() {
      super(...arguments), this.extensionName = HM.EXTENSION_NAME;
    }

  }

  HM.EXTENSION_NAME = xu.CLEARCOAT_TINT_GLTF_EXTENSION;

  class WM extends OM {
    constructor() {
      super(...arguments), this.extensionName = WM.EXTENSION_NAME;
    }

  }

  WM.EXTENSION_NAME = su.THIN_FILM_LAYER_GLTF_EXTENSION;

  class KM extends OM {
    constructor() {
      super(...arguments), this.extensionName = KM.EXTENSION_NAME;
    }

  }

  KM.EXTENSION_NAME = uu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;

  class XM extends r {
    constructor() {
      super(...arguments), this.processor = {
        forAssetType: "texture",
        process: (e, t) => e
      };
    }

    async onAdded(e) {}

    async onDispose(e) {}

    async onRemove(e) {
      this._pmrem = void 0;
    }

  }

  XM.PluginType = "PMREMGenerator";
  const qM = 1e4,
        YM = 50;

  class ZM {
    constructor(e = YM) {
      this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e);
    }

    setDecayTime(e) {
      this.naturalFrequency = 1 / Math.max(.001, e);
    }

    update(e, t, n, r) {
      const i = 2e-4 * this.naturalFrequency;
      if (null == e || 0 === r) return t;
      if (e === t && 0 === this.velocity) return t;
      if (n < 0) return e;
      const s = e - t,
            o = this.velocity + this.naturalFrequency * s,
            a = s + n * o,
            l = Math.exp(-this.naturalFrequency * n),
            c = (o - this.naturalFrequency * a) * l,
            u = -this.naturalFrequency * (c + o * l);
      return Math.abs(c) < i * Math.abs(r) && u * s >= 0 ? (this.velocity = 0, t) : (this.velocity = c, t + a * l);
    }

  }

  const JM = new i.Pa4();

  class $M {
    constructor() {
      this.inputSource = null, this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.lastDragPosition = new i.Pa4(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new i.Pa4(), this.goalYaw = 0, this.goalScale = 1, this.presentedScene = null, this.placementBox = null, this.placeOnWall = !1, this.placementComplete = !1, this.xr = null, this.session = null, this._hitPosition = new i.Pa4(), this._hitMatrix = new i.yGw(), this.xDamper = new ZM(), this.yDamper = new ZM(), this.zDamper = new ZM(), this.yawDamper = new ZM(), this.scaleDamper = new ZM(), this.onSelectStart = e => {
        const t = this.transientHitTestSource;
        if (null == t) return;
        const n = this.frame.getHitTestResultsForTransientInput(t),
              r = this.presentedScene,
              i = this.placementBox;

        if (1 === n.length) {
          this.inputSource = e.inputSource;
          const {
            axes: t
          } = this.inputSource.gamepad || {
            axes: [0, 0]
          },
                n = i.getHit(r, t[0], t[1]);
          i.show = !0, null != n ? (this.isTranslating = !0, this.lastDragPosition.copy(n)) : this.placeOnWall || (this.isRotating = !0, this.lastAngle = 1.5 * t[0]);
        } else if (2 === n.length) {
          i.show = !0, this.isTwoFingering = !0;
          const {
            separation: e
          } = this.fingerPolar(n);
          this.firstRatio = e / r.scale.x;
        }
      }, this.onSelectEnd = () => {
        this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = !1;
      };
    }

    async setSession(e, t, n, r) {
      var i;
      this.transientHitTestSource = await (null === (i = e.requestHitTestSourceForTransientInput) || void 0 === i ? void 0 : i.call(e, {
        profile: "generic-touchscreen"
      })), this.presentedScene = t, this.placementBox = r, this.xr = n, this.session = e, this.placementComplete = !1, this.goalPosition.copy(t.position), this.goalYaw = t.rotation.y, this.goalScale = t.scale.x, e.addEventListener("selectstart", this.onSelectStart), e.addEventListener("selectend", this.onSelectEnd);
    }

    cancel() {
      this.transientHitTestSource && (this.transientHitTestSource.cancel(), this.transientHitTestSource = void 0), this.presentedScene = null, this.placeOnWall = !1, this.frame = void 0, this.xr = null, this.placementBox && (this.placementBox.show = !1, this.placementBox = null), this.session && (this.session.removeEventListener("selectstart", this.onSelectStart), this.session.removeEventListener("selectend", this.onSelectEnd), this.session = null);
    }

    getHitPoint(e) {
      var t;
      const n = null === (t = this.xr) || void 0 === t ? void 0 : t.getReferenceSpace(),
            r = n ? e.getPose(n) : null;
      return r ? (this._hitMatrix.fromArray(r.transform.matrix), this.placeOnWall && (this.goalYaw = Math.atan2(this._hitMatrix.elements[4], this._hitMatrix.elements[6])), this._hitMatrix.elements[5] > .75 !== this.placeOnWall ? this._hitPosition.setFromMatrixPosition(this._hitMatrix) : null) : null;
    }

    moveScene(e) {
      if (!this.session) return;
      const t = this.presentedScene,
            n = t.position,
            r = t.rotation.y,
            i = this.placementBox,
            s = Math.max(i.boundingSize.x, i.boundingSize.y, i.boundingSize.z) / 2,
            o = this.goalPosition,
            a = t.scale.x;

      if (!o.equals(n) || this.goalScale !== a) {
        let {
          x: r,
          y: l,
          z: c
        } = n;
        r = this.xDamper.update(r, o.x, e, s), l = this.yDamper.update(l, o.y, e, s), c = this.zDamper.update(c, o.z, e, s), n.set(r, l, c);
        const u = this.scaleDamper.update(a, this.goalScale, e, 1);

        if (t.scale.set(u, u, u), !this.isTranslating) {
          const e = o.y - l;
          this.placementComplete && !this.placeOnWall ? i.offsetHeight = e / u : 0 === e && (this.placementComplete = !0, i.show = !1);
        }
      }

      i.updateOpacity(e), t.rotation.y = this.yawDamper.update(r, this.goalYaw, e, Math.PI);
    }

    processInput(e) {
      var t;
      this.frame = e;
      const n = this.transientHitTestSource;
      if (!n) return;
      if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
      const r = e.getHitTestResultsForTransientInput(n),
            i = this.presentedScene,
            s = i.scale.x;
      if (this.isTwoFingering) {
        if (r.length < 2) this.isTwoFingering = !1;else {
          const {
            separation: e,
            deltaYaw: t
          } = this.fingerPolar(r);

          if (this.placeOnWall || (this.goalYaw += t), !i.userData.__scaleDisabled) {
            const t = e / this.firstRatio;
            this.goalScale = t < 1.3 && t > .7692307692307692 ? 1 : t;
          }
        }
      } else if (2 !== r.length) {
        if (this.isRotating && (null === (t = this.inputSource) || void 0 === t ? void 0 : t.gamepad)) {
          const e = 1.5 * this.inputSource.gamepad.axes[0];
          this.goalYaw += e - this.lastAngle, this.lastAngle = e;
        } else this.isTranslating && (console.log("translating"), r.forEach(e => {
          if (e.inputSource !== this.inputSource) return;
          let t = null;

          if (e.results.length > 0 && (t = this.getHitPoint(e.results[0])), null == t && (t = this.getTouchLocation()), null != t) {
            if (this.goalPosition.sub(this.lastDragPosition), !this.placeOnWall) {
              const e = t.y - this.lastDragPosition.y;

              if (e < 0) {
                this.placementBox.offsetHeight = e / s;
                const n = JM.copy(this.xr.getCamera().position),
                      r = -e / (n.y - t.y);
                n.multiplyScalar(r), t.multiplyScalar(1 - r).add(n);
              }
            }

            this.goalPosition.add(t), this.lastDragPosition.copy(t);
          }
        }));
      } else {
        this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;
        const {
          separation: e
        } = this.fingerPolar(r);
        this.firstRatio = e / s;
      }
    }

    getTouchLocation() {
      var e, t;
      const {
        axes: n
      } = null !== (e = this.inputSource.gamepad) && void 0 !== e ? e : {
        axes: [0, 0]
      },
            r = this.placementBox.getExpandedHit(this.presentedScene, n[0], n[1]);
      return null != r && (JM.copy(r).sub(null === (t = this.xr) || void 0 === t ? void 0 : t.getCamera().position), JM.length() > 10) ? null : r;
    }

    fingerPolar(e) {
      var t, n, r, i, s, o;
      const a = null !== (r = null === (n = null === (t = e[0].inputSource) || void 0 === t ? void 0 : t.gamepad) || void 0 === n ? void 0 : n.axes) && void 0 !== r ? r : [0, 0],
            l = null !== (o = null === (s = null === (i = e[1].inputSource) || void 0 === i ? void 0 : i.gamepad) || void 0 === s ? void 0 : s.axes) && void 0 !== o ? o : [0, 0],
            c = l[0] - a[0],
            u = l[1] - a[1],
            p = Math.atan2(u, c);
      let h = this.lastAngle - p;
      return h > Math.PI ? h -= 2 * Math.PI : h < -Math.PI && (h += 2 * Math.PI), this.lastAngle = p, {
        separation: Math.sqrt(c * c + u * u),
        deltaYaw: h
      };
    }

  }

  const QM = .2,
        eT = Math.PI / 24,
        tT = new i.FM8(),
        nT = (e, t, n) => {
    let r = t > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI;

    for (let i = 0; i <= 12; ++i) e.push(t + .17 * Math.cos(r), n + .17 * Math.sin(r), 0, t + QM * Math.cos(r), n + QM * Math.sin(r), 0), r += eT;
  };

  class rT extends i.Kj0 {
    constructor(e, t, n = !1) {
      super(((e, t) => {
        const n = new i.u9r(),
              r = [],
              s = [],
              o = e.getSize(new i.Pa4()),
              a = o.x / 2,
              l = (t ? o.y : o.z) / 2;
        nT(s, a, l), nT(s, -a, l), nT(s, -a, -l), nT(s, a, -l);
        const c = s.length / 3;

        for (let e = 0; e < c - 2; e += 2) r.push(e, e + 1, e + 3, e, e + 3, e + 2);

        const u = c - 2;
        return r.push(u, u + 1, 1, u, 1, 0), n.setAttribute("position", new i.a$l(s, 3)), n.setIndex(r), n;
      })(e, n)), this.boundingSize = new i.Pa4(), this._raycaster = new i.iMs(), this._camera = t, this._placeOnWall = n;
      const r = this.material;
      r.side = i.Wl3, r.color = new ve(16711935), r.opacity = 0, this.userData.bboxVisible = !1;
      const s = e.getSize(this.boundingSize);
      console.log(e, n, s, this);
      const o = s.x / 2,
            a = (n ? s.y : s.z) / 2;
      this.hitPlane = new i.Kj0(new i.BKK(2 * (o + QM), 2 * (a + QM))), this.hitPlane.visible = !1, this.add(this.hitPlane), e.getCenter(this.position), n ? (this.shadowHeight = e.min.z, this.position.z = this.shadowHeight) : (this.rotateX(-Math.PI / 2), this.shadowHeight = e.min.y, this.position.y = this.shadowHeight), this.offsetHeight = 0;
    }

    getHit(e, t, n) {
      tT.set(t, -n), this.hitPlane.visible = !0;

      const r = this._positionAndNormalFromPoint(tT, this.hitPlane);

      return this.hitPlane.visible = !1, null == r ? null : r.position;
    }

    getExpandedHit(e, t, n) {
      this.hitPlane.scale.set(1e3, 1e3, 1e3);
      const r = this.getHit(e, t, n);
      return this.hitPlane.scale.set(1, 1, 1), r;
    }

    set offsetHeight(e) {
      e -= .001, this._placeOnWall ? this.position.z = this.shadowHeight + e : this.position.y = this.shadowHeight + e;
    }

    get offsetHeight() {
      return this._placeOnWall ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    }

    set show(e) {
      this.material.opacity = e ? .75 : 0;
    }

    get show() {
      return this.material.opacity > .01;
    }

    updateOpacity(e) {
      const t = this.material;
      this.visible = t.opacity > 0;
    }

    dispose() {
      var e;
      const {
        geometry: t,
        material: n
      } = this.hitPlane;
      t.dispose(), n.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e = this.parent) || void 0 === e || e.remove(this);
    }

    _positionAndNormalFromPoint(e, t) {
      if (!this._camera) return null;

      this._raycaster.setFromCamera(e, this._camera);

      const n = this._raycaster.intersectObject(t, !0);

      if (0 === n.length) return null;
      const r = n[0];
      return null == r.face ? null : null == r.uv ? {
        position: r.point,
        normal: r.face.normal,
        uv: null
      } : (r.face.normal.applyNormalMatrix(new i.Vkp().getNormalMatrix(r.object.matrixWorld)), {
        position: r.point,
        normal: r.face.normal,
        uv: r.uv
      });
    }

  }

  class iT extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this._touchInputHelper = new $M(), this._preRender = () => {
        if (!(this._dirty && this._viewer && this._xrManager && this._xrSession)) return;
        this._viewer.renderer.composer.renderToScreen = !1, this._xrManager.enabled = !1;

        const e = this._xrManager.getCamera(),
              t = e.cameras[0] || e,
              n = this._viewer.scene.activeCamera;

        n.cameraObject.projectionMatrix.copy(t.projectionMatrix), n.cameraObject.projectionMatrixInverse.copy(n.cameraObject.projectionMatrix).invert();
      }, this._postRender = () => {
        var e, t;
        if (!this._dirty || !this._viewer || !this._xrSession) return;

        this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();

        const n = this._viewer.renderer,
              r = null === (t = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera()) || void 0 === t ? void 0 : t.cameras[0].viewport;
        r ? n.rendererObject.setViewport(r) : console.warn("no viewport for ar camera"), K(n.rendererObject, {
          sceneRender: !0,
          opaqueRender: !0,
          shadowMapRender: !1,
          backgroundRender: !1,
          transparentRender: !1,
          transmissionRender: !1,
          screenSpaceRendering: !1
        }, () => {
          sT.render(n.rendererObject, null, n.composer.readBuffer, 0, !1);
        }), this._xrManager.enabled = !0, this._viewer.renderer.composer.renderToScreen = !0;
      }, this._frameCount = 0, this._lastTime = 0, this._preFrame = ({
        xrFrame: e,
        deltaTime: t
      }) => {
        var n, r;
        if (this.dirty = !!e && (null === (n = this._xrManager) || void 0 === n ? void 0 : n.isPresenting) || !1, this._viewer.scene.activeCamera.interactionsEnabled = !this._dirty, this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty, !this._dirty || !e) return void (this._xrSession && this._xrSessionEnd());
        if (!this._xrSession && !this._xrManager.getSession()) return console.error("no xr session found, shouldn't happen"), void (this.dirty = !1);
        this._xrSession || console.log("webxr: AR session init"), this._frameCount++;

        const i = this._xrManager.getReferenceSpace(),
              s = e.getViewerPose(i);

        if (null == s && this._frameCount, null == s || 0 === (null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.modelRoot.children.length)) return this.dirty = !1, void console.log("no pose or no model");

        if (!this._xrSession) {
          if (this._xrSession = this._xrManager.getSession() || void 0, !this._xrSession) return;
          this._frameCount = 0, this._cancelHitSources(), this._savePreXRState(), this._preSetupModel(), this._xrSessionStart();
        }

        const o = this._viewer.scene.activeCamera;
        this._xrManager.updateCamera(o.cameraObject), o.setDirty(), this.moveToFloor(e), this._touchInputHelper.processInput(e), this._touchInputHelper.moveScene(t), this._updateShadow();
      }, this.placeOnWall = !1, this._preXRState = {
        viewerBg: null,
        modelScale: new i.Pa4(1, 1, 1),
        modelPosition: new i.Pa4(),
        modelRotation: new i._fP(),
        cameraPosition: new i.Pa4(0, 0, 5),
        cameraTarget: new i.Pa4(),
        cameraUp: new i.Pa4(0, 1, 0),
        cameraAspect: 1,
        cameraFov: 50,
        cameraZoom: 1,
        cameraNear: .01,
        cameraFar: 100,
        groundOffset: new i.Pa4(),
        groundScale: 1
      }, this._savePreXRState = () => {
        if (!this._viewer) return;
        this._preXRState.viewerBg = this._viewer.getBackground(!0);
        const e = this._viewer.scene.modelRoot,
              t = this._viewer.scene.activeCamera;
        e.updateMatrix(), e.updateMatrixWorld(!0), this._preXRState.modelScale.copy(e.scale), this._preXRState.modelPosition.copy(e.position), this._preXRState.modelRotation.copy(e.quaternion), this._preXRState.cameraPosition.copy(t.position), this._preXRState.cameraTarget.copy(t.target), this._preXRState.cameraUp.copy(t.cameraObject.up), t.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = t.cameraObject.fov, this._preXRState.cameraAspect = t.cameraObject.aspect), this._preXRState.cameraZoom = t.cameraObject.zoom, this._preXRState.cameraNear = t.cameraObject.near, this._preXRState.cameraFar = t.cameraObject.far;

        const n = this._viewer.getPluginByType("Ground");

        (null == n ? void 0 : n.mesh) && (this._preXRState.groundOffset.subVectors(e.position, n.mesh.modelObject.position), this._preXRState.groundScale = n.mesh.modelObject.scale.x, console.log("ground offset", this._preXRState.groundOffset, this._preXRState.groundScale), n.shadowBaker.enabled = !1);
      }, this._xrSessionStart = () => {
        if (!this._xrSession || !this._viewer) return;
        console.log("webxr: AR session start");
        const e = 20 * Math.PI / 180,
              t = this.placeOnWall ? void 0 : new window.XRRay(new DOMPoint(0, 0, 0), {
          x: 0,
          y: -Math.sin(e),
          z: -Math.cos(e)
        });
        this._touchInputHelper.placeOnWall = this.placeOnWall, this._viewer.resize(), (async () => {
          var e, n;

          if (this._xrSession) {
            const r = await this._xrSession.requestReferenceSpace("viewer");
            this._hitTestSource = await (null === (n = (e = this._xrSession).requestHitTestSource) || void 0 === n ? void 0 : n.call(e, {
              space: r,
              offsetRay: t
            }));
          }

          this._xrSession && (await this._touchInputHelper.setSession(this._xrSession, this._viewer.scene.modelRoot, this._xrManager, this._placementBox));
        })();
      }, this._xrSessionEnd = () => {
        var e;
        console.log("webxr: AR session end"), this._frameCount = 0, null === (e = this._xrSession) || void 0 === e || e.removeEventListener("end", this._xrSessionEnd), this._xrSession = void 0, this._cancelHitSources(), this._viewer && (this._restorePreXRState(), this._viewer.resize());
      };
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = e.renderer.rendererObject.xr;
      t.enabled = !0, t.cameraAutoUpdate = !1, this._xrManager = t;
      const n = document.getElementById("tweakpaneUiContainer"),
            r = n ? {
        root: n
      } : void 0;
      document.body.appendChild(class {
        static createButton(e, t = {}) {
          const n = document.createElement("button");

          function r() {
            n.style.display = "", n.style.cursor = "auto", n.style.left = "calc(50% - 75px)", n.style.width = "150px", n.onmouseenter = null, n.onmouseleave = null, n.onclick = null;
          }

          function i(e) {
            e.style.position = "absolute", e.style.bottom = "20px", e.style.padding = "12px 6px", e.style.border = "1px solid #fff", e.style.borderRadius = "4px", e.style.background = "rgba(0,0,0,0.1)", e.style.color = "#fff", e.style.font = "normal 13px sans-serif", e.style.textAlign = "center", e.style.opacity = "0.5", e.style.outline = "none", e.style.zIndex = "999";
          }

          if ("xr" in navigator) return n.id = "ARButton", n.style.display = "none", i(n), navigator.xr.isSessionSupported("immersive-ar").then(function (i) {
            i ? function () {
              if (void 0 === t.domOverlay) {
                const e = document.createElement("div");
                e.style.display = "none", document.body.appendChild(e);
                const n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                n.setAttribute("width", 38), n.setAttribute("height", 38), n.style.position = "absolute", n.style.right = "20px", n.style.top = "20px", n.addEventListener("click", function () {
                  r.end();
                }), e.appendChild(n);
                const i = document.createElementNS("http://www.w3.org/2000/svg", "path");
                i.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), i.setAttribute("stroke", "#fff"), i.setAttribute("stroke-width", 2), n.appendChild(i), void 0 === t.optionalFeatures && (t.optionalFeatures = []), t.optionalFeatures.push("dom-overlay"), t.domOverlay = {
                  root: e
                };
              }

              let r = null;

              async function i(i) {
                i.addEventListener("end", s), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(i), n.textContent = "STOP AR", t.domOverlay.root.style.display = "", r = i;
              }

              function s() {
                r.removeEventListener("end", s), n.textContent = "START AR", t.domOverlay.root.style.display = "none", r = null;
              }

              n.style.display = "", n.style.cursor = "pointer", n.style.left = "calc(50% - 50px)", n.style.width = "100px", n.textContent = "START AR", n.onmouseenter = function () {
                n.style.opacity = "1.0";
              }, n.onmouseleave = function () {
                n.style.opacity = "0.5";
              }, n.onclick = function () {
                null === r ? navigator.xr.requestSession("immersive-ar", t).then(i) : r.end();
              };
            }() : (r(), n.textContent = "AR NOT SUPPORTED");
          }).catch(function (e) {
            r(), console.warn("Exception when trying to call xr.isSessionSupported", e), n.textContent = "AR NOT ALLOWED";
          }), n;
          {
            const e = document.createElement("a");
            return !1 === window.isSecureContext ? (e.href = document.location.href.replace(/^http:/, "https:"), e.innerHTML = "WEBXR NEEDS HTTPS") : (e.href = "https://immersiveweb.dev/", e.innerHTML = "WEBXR NOT AVAILABLE"), e.style.left = "calc(50% - 90px)", e.style.width = "180px", e.style.textDecoration = "none", i(e), e;
          }
        }

      }.createButton(e.renderer.rendererObject, {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: r
      })), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame);
    }

    _updateShadow() {
      if (!this._viewer) return;

      const e = this._viewer.scene.modelRoot,
            t = this._viewer.getPluginByType("Ground");

      t && (t.groundReflection = !1, t.mesh.modelObject.position.copy(this._preXRState.groundOffset).multiplyScalar(e.modelObject.scale.x).sub(e.modelObject.position).negate(), t.mesh.modelObject.scale.setScalar(e.modelObject.scale.x * this._preXRState.groundScale));
    }

    moveToFloor(e) {
      if (!this._dirty || !this._hitTestSource || !this._xrManager) return;
      const t = e.getHitTestResults(this._hitTestSource);
      if (!t.length) return;

      const n = t[0],
            r = this._touchInputHelper.getHitPoint(n);

      r && (this._placementBox.show = !0, this._viewer.scene.modelRoot, this.placeOnWall ? this._touchInputHelper.goalPosition.copy(r) : this._touchInputHelper.goalPosition.y = r.y, this._hitTestSource.cancel(), this._hitTestSource = void 0, console.log("move to initial hit point", r));
    }

    _removePlacementBox() {
      this._placementBox && (this._placementBox.dispose(), this._placementBox = void 0);
    }

    _preSetupModel() {
      var e;
      const t = this._viewer.scene.modelRoot,
            n = this._viewer.scene.activeCamera,
            r = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera(),
            s = r.cameras[0] || r;

      this._removePlacementBox();

      const o = this._viewer.scene.getBounds(!0, !0);

      o.getSize(new i.Pa4()).length() > .01 && (this._placementBox = new rT(o, r, this.placeOnWall), t.add(this._placementBox), this._placementBox.show = !1);
      const a = r.getWorldDirection(new i.Pa4());
      t.rotation.y = Math.atan2(-a.x, -a.z) - 0, n.cameraObject.zoom = s.zoom, n.cameraObject.near = s.near, n.cameraObject.far = s.far, n.cameraObject.isPerspectiveCamera ? (n.cameraObject.fov = s.fov, n.cameraObject.aspect = s.viewport.width / s.viewport.height) : console.warn("Perspective camera required."), n.cameraObject.updateProjectionMatrix(), t.position.set(0, 0, 0);
      const l = t.userData.arScale || 1;
      t.scale.set(l, l, l), t.position.copy(r.position).add(a.multiplyScalar(5)), t.visible = !0, this._viewer.setBackground(null);
    }

    _restorePreXRState() {
      if (!this._viewer) return;
      this._viewer.setBackground(this._preXRState.viewerBg), this._preXRState.viewerBg = null;
      const e = this._viewer.scene.modelRoot;
      e.scale.copy(this._preXRState.modelScale), e.position.copy(this._preXRState.modelPosition), e.quaternion.copy(this._preXRState.modelRotation), e.updateMatrix(), e.updateMatrixWorld(!0), e.visible = !0;
      const t = this._viewer.scene.activeCamera;
      t.position.copy(this._preXRState.cameraPosition), t.target.copy(this._preXRState.cameraTarget), t.cameraObject.up.copy(this._preXRState.cameraUp), t.cameraObject.near = this._preXRState.cameraNear, t.cameraObject.far = this._preXRState.cameraFar, t.cameraObject.isPerspectiveCamera && (void 0 !== this._preXRState.cameraFov && (t.cameraObject.fov = this._preXRState.cameraFov), void 0 !== this._preXRState.cameraAspect && (t.cameraObject.aspect = this._preXRState.cameraAspect)), t.positionUpdated(!1), t.targetUpdated(!0), t.cameraObject.updateMatrixWorld(!0), t.cameraObject.updateProjectionMatrix();
    }

    _cancelHitSources() {
      this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0), this._touchInputHelper.cancel();
    }

  }

  iT.PluginType = "WEBXR_ARPlugin";
  const sT = new u({
    vertexShader: s.vertexShader,
    fragmentShader: "\n    uniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\t// gl_FragColor = vec4(1,0,1,1);\n\t\t\tgl_FragColor = texel;\n\n\t\t}\n\t\t",
    uniforms: s.uniforms
  });

  async function oT(e, t) {
    if (e.createWriter) {
      const n = await e.createWriter();
      return await n.write(0, t), void (await n.close());
    }

    const n = await e.createWritable();
    await n.write(t), await n.close();
  }

  async function aT(e, t) {
    const n = {};
    return t && (n.writable = !0, n.mode = "readwrite"), "granted" === (await e.queryPermission(n)) || "granted" === (await e.requestPermission(n));
  }

  sT.renderToScreen = !1, sT.useExistingRenderTarget = !0, sT.clear = !1;

  class lT extends r {
    constructor(e, t) {
      super(), this._state = "stopped", this._console = console, this._currentRecording = [], this._currentImages = [], this.stepMode = !1, this._resumeSyncTime = 0, this._frameCount = 0, this._onstop = e => {
        var t;

        if (this._state = "stopped", this._recorder && this._currentRecording.length > 0) {
          const e = new Blob(this._currentRecording, {
            type: this._options.mimeType
          });
          null === (t = this._recordingCallback) || void 0 === t || t.call(this, e);
        } else this._currentImages.length > 0 && (this._writeImages([...this._currentImages]), this._currentImages = []);

        this._recorder = void 0, this.dispatchEvent({
          type: "stop"
        });
      }, this._onstart = e => {
        var t;
        this._state = "recording", this._frameCount = 0, this.dispatchEvent({
          type: "start"
        }), this.stepMode && (null === (t = this._recorder) || void 0 === t || t.pause());
      }, this._onresume = e => {
        if (!this.stepMode) return;

        const t = () => {
          var e;
          "recording" === this._state && (null === (e = this._recorder) || void 0 === e || e.pause());
        },
              n = Math.min(this._resumeSyncTime - At(), 0) + 1e3 / this._options.frameRate;

        n > 0 ? uc(n).then(t) : t();
      }, this._onpause = e => {}, this._ondataavailable = e => {
        e.data && e.data.size > 0 && this._currentRecording.push(e.data);
      }, this._onerror = e => {
        this._state = "error", this._console.error(e), this.dispatchEvent({
          type: "error",
          error: e
        }), this._recorder = void 0;
      }, this._canvas = e;
      const n = null == t ? void 0 : t.mimeType;
      this._options = {
        mimeType: n || "auto",
        frameRate: 30
      }, this._setOptions(t || this._options);
    }

    _setOptions(e) {
      var t, n;
      Object.assign(this._options, e), this._options.mimeType && "auto" !== this._options.mimeType || (this._options.mimeType = null !== (t = lT.GetSupportedMimeTypes([], ["h264"], !0)) && void 0 !== t ? t : lT.GetSupportedMimeTypes(void 0, void 0, !0)), this._options.mimeType && !(null === (n = this._options.mimeType) || void 0 === n ? void 0 : n.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"), this._options.mimeType = "image/png"), this._options.mimeType || console.warn(new Error("No supported mimetype found"));
    }

    setOptions(e) {
      this._setOptions(e);
    }

    isRecording() {
      return "recording" === this._state;
    }

    start() {
      var e, t, n;
      if ("recording" === this._state) return void this._console.log("Already recording canvas");
      if ("error" === this._state && (this._recorder = void 0, this._console.warn("Resetting from error state.")), this._recorder) return "paused" === this._state ? (this.dispatchEvent({
        type: "starting"
      }), void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this._state);
      if ("paused" === this._state) return this.dispatchEvent({
        type: "starting"
      }), void (this._state = "recording");
      const r = {
        mimeType: this._options.mimeType,
        videoBitsPerSecond: this._options.videoBitsPerSecond
      };

      if (this._currentRecording = [], this._currentImages = [], this._frameCount = 0, null === (e = r.mimeType) || void 0 === e ? void 0 : e.startsWith("video")) {
        if (!window.MediaRecorder) return this._console.error("MediaRecorder not supported, use image sequence"), void (this._state = "error");
        {
          const e = this._canvas.captureStream(this.stepMode ? 0 : this._options.frameRate),
                n = null === (t = e.getVideoTracks()) || void 0 === t ? void 0 : t[0];

          this._track = n, this._recorder = new window.MediaRecorder(e, r), this._recorder.onstop = this._onstop, this._recorder.ondataavailable = this._ondataavailable, this._recorder.onerror = this._onerror, this._recorder.onresume = this._onresume, this._recorder.onstart = this._onstart;
        }
      }

      this.dispatchEvent({
        type: "starting"
      }), this._recorder ? (this._state = "recording", null === (n = this._recorder) || void 0 === n || n.start()) : window.showDirectoryPicker && window.showDirectoryPicker().then(async e => {
        const t = await (null == e ? void 0 : e.getDirectoryHandle("i-" + Math.floor(Date.now()), {
          create: !0
        }));
        this._imgDirectory = t, this._state = "recording", this._onstart({});
      }).catch(e => {
        this._onerror({
          detail: e
        });
      });
    }

    async requestFrame() {
      if ("recording" !== this._state) return;
      this._frameCount++;
      const e = this._options.mimeType;

      if (!this._recorder && e.startsWith("image/")) {
        const t = this._canvas.toDataURL(e, 90);

        this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (e.includes("png") ? ".png" : ".jpg"), t]), this._currentImages.length > 60 && (this._writeImages([...this._currentImages]), this._currentImages = []);
      }

      this._recorder && this._track && this.stepMode && (this._resumeSyncTime = At(), this._track.requestFrame(), this._recorder.resume());
    }

    pause() {
      "paused" !== this._state && "stopped" !== this._state && (this._recorder ? this._recorder.pause() : this._state = "paused");
    }

    stop(e) {
      "stopped" !== this._state && ("error" !== this._state ? (this._recordingCallback = e, this.dispatchEvent({
        type: "stopping"
      }), this._recorder ? this._recorder.stop() : this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."));
    }

    get state() {
      return this._state;
    }

    dispose() {
      this._recorder && "error" !== this._state ? this.stop(e => {
        this._console.warn("disposed with blob", e), this.dispose();
      }) : this._recorder = void 0;
    }

    async _writeImages(e) {
      if (!this._imgDirectory) return;
      const t = await Promise.all(e.map(async ([e, t]) => await (await fetch(t)).blob())),
            n = [];

      for (let r = 0; r < e.length; r++) {
        const i = await this._imgDirectory.getFileHandle(e[r][0], {
          create: !0
        });
        n.push(oT(i, t[r]));
      }

      await Promise.all(n);
    }

    static GetSupportedMimeTypes(e, t, n = !1) {
      if (!window.MediaRecorder) return n ? void 0 : [];
      const r = ["webm", "ogg", "mp4", "x-matroska"].filter(t => !e || e.length < 1 || e.includes(t)),
            i = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter(e => !t || t.length < 1 || t.includes(e)),
            s = [];
      return r.forEach(e => {
        const t = `video/${e}`;
        i.forEach(e => {
          [`${t};codecs=${e}`, `${t};codecs:${e}`, `${t};codecs=${e.toUpperCase()}`, `${t};codecs:${e.toUpperCase()}`, `${t}`].forEach(e => {
            MediaRecorder.isTypeSupported(e) && s.push(e);
          });
        });
      }), n ? s.length > 0 ? s[0] : void 0 : s;
    }

  }

  var cT = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class uT extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this.convergeMode = !1, this.mimeType = "auto", this.videoFrameRate = 30, this._renderToScreenDisabled = !1, this._preRender = () => {
        var e, t, n;

        if (this.convergeMode && (null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording())) {
          const e = this._viewer.renderer.composer.renderToScreen;
          this._viewer.renderer.composer.renderToScreen = (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(po)) || void 0 === n ? void 0 : n.isConverged()) || !1, e && !this._viewer.renderer.composer.renderToScreen && (this._renderToScreenDisabled = !0);
        }
      }, this._postRender = () => {
        var e, t, n;

        if ((null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && (!this.convergeMode || (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(po)) || void 0 === n ? void 0 : n.isConverged(!0)))) {
          const e = () => {
            var e;
            return null === (e = this._recorder) || void 0 === e ? void 0 : e.requestFrame();
          };

          this.convergeMode ? uc(1).then(e) : e();
        }

        this._renderToScreenDisabled && (this._viewer.renderer.composer.renderToScreen = !0);
      };
    }

    get recorder() {
      return this._recorder;
    }

    isRecording() {
      var e, t;
      return null !== (t = null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && void 0 !== t && t;
    }

    refreshRecorderOptions() {
      this._recorder && (this._recorder.setOptions({
        frameRate: this.videoFrameRate,
        mimeType: this.mimeType
      }), this._recorder.stepMode = this.convergeMode);
    }

    async onAdded(e) {
      await super.onAdded(e), this._recorder = new lT(e.canvas, {
        frameRate: this.videoFrameRate,
        mimeType: this.mimeType
      }), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), this._recorder.addEventListener("starting", () => this._stateChange(!1)), this._recorder.addEventListener("start", () => {
        this.dispatchEvent({
          type: "start"
        }), this._stateChange(!this.convergeMode);
      }), this._recorder.addEventListener("error", () => {
        this.dispatchEvent({
          type: "error"
        });
      }), this._recorder.addEventListener("pause", () => this._stateChange(!1)), this._recorder.addEventListener("resume", () => this._stateChange(!this.convergeMode)), this._recorder.addEventListener("stop", () => {
        this.dispatchEvent({
          type: "stop"
        }), this._stateChange(!1);
      });
    }

    _stateChange(e) {
      var t, n, r;
      this.dirty = e, null === (t = this._viewer) || void 0 === t || t.setDirty(), null === (r = null === (n = this._uiConfig) || void 0 === n ? void 0 : n.children) || void 0 === r || r.map(e => x(e)).flat(2).forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e);
      });
    }

    async onRemove(e) {
      var t;
      return e.removeEventListener("preRender", this._preRender), e.removeEventListener("preRender", this._postRender), null === (t = this._recorder) || void 0 === t || t.dispose(), super.onRemove(e);
    }

    startRecording() {
      var e;
      return !!this.enabled && !1 === (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) && (this.recorder.stepMode = this.convergeMode, this.recorder.start(), !0);
    }

    async stopRecording() {
      var e;
      if (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) return new Promise((e, t) => {
        var n;
        return null === (n = this.recorder) || void 0 === n ? void 0 : n.stop(e);
      });
    }

    get uiConfig() {
      var e;
      if (this._uiConfig) return this._uiConfig;
      const t = this;
      return this._uiConfig = {
        type: "folder",
        label: "Recorder",
        children: [{
          label: "Quality",
          type: "slider",
          bounds: [.1, 4],
          stepSize: .5,
          limitedUi: !0,
          property: [null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer, "displayCanvasScaling"]
        }, {
          type: "slider",
          label: "Frame Rate",
          bounds: [1, 60],
          stepSize: 1,
          property: [this, "videoFrameRate"]
        }, {
          type: "checkbox",
          limitedUi: !0,
          property: [this, "convergeMode"]
        }, {
          type: "dropdown",
          label: "Mime type",
          limitedUi: !0,
          property: [this, "mimeType"],
          children: [["Auto Video (x264)", "auto"], ["PNG sequence", "image/png"], ["JPEG sequence", "image/jpeg"]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "input",
          disabled: !0,
          label: "State",
          limitedUi: !0,

          get value() {
            var e, n;
            return null !== (n = null === (e = t.recorder) || void 0 === e ? void 0 : e.state) && void 0 !== n ? n : "not initialized";
          },

          set value(e) {}

        }, {
          type: "button",

          get label() {
            var e;
            return (null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) ? "Stop" : "Start";
          },

          value: () => {
            var e;
            (null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) ? this.stopRecording().then(e => {
              if (e) {
                console.log(e);
                const t = e.type.split(";")[0].split("/").pop() || "mp4";
                gt(e, "test." + t);
              }
            }) : this.startRecording();
          }
        }, {
          type: "button",
          limitedUi: !0,
          label: "Record Camera Views",
          hidden: () => {
            var e, n;
            return !!(null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) || !(null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews"));
          },
          value: () => {
            var e, t;
            null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("CameraViews")) || void 0 === t || t.recordAllViews();
          }
        }, {
          type: "button",
          limitedUi: !0,
          label: "Record Camera Views + GLTF Anim",
          hidden: () => {
            var e, n, r, i;
            return !!(null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) || !(null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews")) || !(null === (i = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("GLTFAnimation")) || void 0 === i ? void 0 : i.animations.length);
          },
          value: () => {
            var e, t, n, r;
            const i = "playing" === (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t ? void 0 : t.animationState);
            null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews")) || void 0 === r || r.recordAllViews(() => {
              var e, t;
              null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.playAnimation();
            }).then(() => {
              var e, t;
              i || null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.stopAnimation();
            });
          }
        }]
      };
    }

  }

  uT.PluginType = "CanvasRecorder", cT([C(uT.prototype.refreshRecorderOptions)], uT.prototype, "convergeMode", void 0), cT([C(uT.prototype.refreshRecorderOptions)], uT.prototype, "mimeType", void 0), cT([C(uT.prototype.refreshRecorderOptions)], uT.prototype, "videoFrameRate", void 0);

  var pT = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const hT = new i.jyz({
    uniforms: {
      tDiffuse: {
        value: null
      },
      h: {
        value: 1 / 512
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float h;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
  });
  hT.depthTest = !1;
  const dT = new i.jyz({
    uniforms: {
      tDiffuse: {
        value: null
      },
      v: {
        value: 1 / 512
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float v;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
  });
  dT.depthTest = !1;

  class fT extends Xc {
    constructor(e = {}, t = !1) {
      super(e), this.contactShadows = !0, this.blurAmount = 1, this.shadowScale = 1, this.shadowHeight = 5, this.shadowCamera = new i.iKG(-1, 1, 1, -1, .001, this.shadowHeight), this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._showDebug = t, t && this.dependencies.push(Ac);
    }

    async onAdded(e) {
      const t = e.renderer.createTarget({
        type: i.ywz,
        format: i.wk1,
        encoding: i.rnI,
        size: {
          width: 512,
          height: 512
        },
        generateMipmaps: !1,
        depthBuffer: !0,
        minFilter: i.wem,
        magFilter: i.wem,
        isAntialiased: !1
      });
      t.texture.name = "groundContactDepthTexture";
      const n = new i.lRF({
        depthPacking: i.z81
      });

      n.onBeforeCompile = function (e) {
        e.uniforms.opacity.value = 1, e.fragmentShader = `\n\t\t\t\t\t\t${e.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );")}\n\t\t\t\t\t`;
      };

      const r = new Ks(t, n, new ve(0, 0, 0), 0);
      this._depthPass = r, await super.onAdded(e);
    }

    _postFrame() {
      super._postFrame(), this._viewer;
    }

    _preRender() {
      if (super._preRender(), !this._viewer) return;
      if (!this._depthPass) return;
      this._depthPass.scene = this._viewer.scene.modelObject, this._depthPass.camera = this.shadowCamera, this._depthPass.render(this._viewer.renderer.rendererObject);

      const e = this._viewer.renderer.getTempTarget({
        type: i.ywz,
        format: i.wk1,
        encoding: i.rnI,
        size: {
          width: 1024,
          height: 1024
        },
        generateMipmaps: !1,
        depthBuffer: !1,
        minFilter: i.wem,
        magFilter: i.wem,
        isAntialiased: !1
      });

      this._blurShadow(e), this._blurShadow(e, .4), this._viewer.renderer.releaseTempTarget(e);
    }

    _blurShadow(e, t = 1) {
      this._viewer && this._depthPass && (hT.uniforms.h.value = t * this.blurAmount / 256, dT.uniforms.v.value = t * this.blurAmount / 256, this._viewer.renderer.blit(this._depthPass.target.texture, e, {
        material: hT,
        clear: !0
      }), this._viewer.renderer.blit(e.texture, this._depthPass.target, {
        material: dT,
        clear: !0
      }));
    }

    async onDispose(e) {
      return super.onDispose(e);
    }

    async onRemove(e) {
      return super.onRemove(e);
    }

    _refreshTransform() {
      super._refreshTransform(), this._mesh && this._viewer && (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new i.Pa4())), this.shadowCamera.setRotationFromEuler(new i.USm(Math.PI / 2, 0, 0)), this.shadowCamera.updateMatrixWorld(), this._refreshShadowCameraFrustum(), this._mesh.scale.y = -this.size);
    }

    _refreshShadowCameraFrustum() {
      this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale), this.shadowCamera.right = this.size / (2 * this.shadowScale), this.shadowCamera.top = this.size / (2 * this.shadowScale), this.shadowCamera.bottom = -this.size / (2 * this.shadowScale), this.shadowCamera.far = this.shadowHeight, this.shadowCamera.updateProjectionMatrix(), this._setDirty());
    }

    _setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    _removeMaterial() {
      this._material && super._removeMaterial();
    }

    refreshOptions() {
      this._viewer && super.refreshOptions();
    }

    _refreshMaterial() {
      var e;
      if (!this._viewer) return !1;

      const t = super._refreshMaterial();

      return this._material ? (this._material.alphaMap = (null === (e = this._depthPass) || void 0 === e ? void 0 : e.target.texture) || null, t && (this._material.roughness = 1, this._material.metalness = 0, this._material.color.set(1118481), this._material.transparent = !0, this._material.materialObject.userData.ssreflDisabled = !0, this._material.materialObject.userData.ssreflNonPhysical = !1), t) : t;
    }

    _extraUiConfig() {
      return [{
        label: "Contact Shadows",
        type: "checkbox",
        property: [this, "contactShadows"]
      }, {
        label: "Shadow Scale",
        type: "slider",
        bounds: [0, 2],
        property: [this, "shadowScale"]
      }, {
        label: "Shadow Height",
        type: "slider",
        bounds: [0, 20],
        property: [this, "shadowHeight"]
      }, {
        label: "Blur Amount",
        type: "slider",
        bounds: [0, 10],
        property: [this, "blurAmount"]
      }, ...super._extraUiConfig()];
    }

  }

  fT.PluginType = "ContactShadowGroundPlugin", pT([C(fT.prototype.refreshOptions), xe()], fT.prototype, "contactShadows", void 0), pT([xe(), C(fT.prototype._setDirty)], fT.prototype, "blurAmount", void 0), pT([xe(), C(fT.prototype._refreshShadowCameraFrustum)], fT.prototype, "shadowScale", void 0), pT([xe(), C(fT.prototype._refreshShadowCameraFrustum)], fT.prototype, "shadowHeight", void 0);

  const _T = new i.cPb(45, 1, .1, 1e3);

  function mT(e, t, n, r = 7, s = new i.Pa4(0, 0, 1.5)) {
    n = null != n ? n : e.scene;
    const o = new P().expandByObject(null != n ? n : t, !0, !0),
          a = o.getCenter(new i.Pa4()),
          l = o.getSize(new i.Pa4());
    _T.position.copy(a).add(s.clone().multiplyScalar(Math.max(l.x, l.y, l.z))), _T.lookAt(a), t && t.traverseVisible(e => {
      e.layers.enable(r);
    }), r > 0 ? _T.layers.set(r) : _T.layers.enableAll();
    const c = null == t ? void 0 : t.visible;
    t && (t.visible = !0), e.renderer.rendererObject.setRenderTarget(null), e.renderer.rendererObject.render(n, _T);
    const u = e.renderer.rendererObject.domElement.toDataURL("image/png");
    return t && (t.visible = c, t.traverseVisible(e => {
      e.layers.disable(r);
    }), _T.layers.enableAll()), e.setDirty(), u;
  }

  class gT {
    constructor(e) {
      this.viewer = e, this._lights = [], this.shapes = {
        sphere: new i.Kj0(new i.xo$(1)),
        cube: new i.Kj0(new i.DvJ(1, 1, 1)),
        cylinder: new i.Kj0(new i.fHI(.5, .5, 1))
      };
      const t = new i.xsS();
      this._channel = 7;
      const n = new i.vmT(16777215, 4473924, 1);
      n.position.set(0, 10, 0), n.layers.set(this._channel), t.add(n), this._lights.push(n), this._scene = t;
    }

    dispose() {
      this._lights.forEach(e => e.dispose()), Object.values(this.shapes).forEach(e => {
        e.geometry && e.geometry.dispose();
      });
    }

    generate(e, t = "sphere") {
      const n = this.shapes[t] || new i.Kj0(new i.xo$(1));
      n.material = e.materialObject, this._scene.add(n), this._scene.environment = this.viewer.scene.getEnvironment();
      const r = n.material.envMapIntensity;
      "number" == typeof r && (n.material.envMapIntensity = Math.max(r, 2));
      const s = mT(this.viewer, n, this._scene, this._channel, new i.Pa4(0, 0, 1.5));
      return "number" == typeof r && (n.material.envMapIntensity = r), this._scene.remove(n), n.material = void 0, s;
    }

  }

  class vT extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
        var e, t;
        this.enabled && (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e));
      }, this.dependencies = [js], this.variations = [], this._selectedMaterial = () => {
        var e, t;
        return (null === (t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0 === t ? void 0 : t.material) || void 0;
      }, this.uiConfig = {
        label: "Material Configurator",
        type: "folder",
        children: [() => {
          var e;
          return [{
            type: "input",
            label: "uuid",
            property: [this._selectedMaterial(), "uuid"],
            hidden: () => !this._selectedMaterial(),
            disabled: !0
          }, {
            type: "input",
            label: "title",
            hidden: () => !this._selectedMaterial(),
            property: () => [this.getSelectedVariation(), "title"],
            onChange: async () => this.refreshUi()
          }, {
            type: "dropdown",
            label: "Preview Type",
            hidden: () => !this._selectedMaterial(),
            property: () => [this.getSelectedVariation(), "preview"],
            onChange: async () => this.refreshUi(),
            children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(Vt).filter(e => e.endsWith("Map"))].map(e => ({
              label: e,
              value: e
            }))
          }, ...((null === (e = this.getSelectedVariation()) || void 0 === e ? void 0 : e.materials.map(e => Object.assign(e.uiConfig, {
            expanded: !1
          }))) || []), {
            type: "button",
            label: "Remove All",
            hidden: () => !this._selectedMaterial(),
            value: () => {
              const e = this.getSelectedVariation();
              e && confirm("Remove all for this material?") && (e.materials = []), this.refreshUi();
            }
          }, {
            type: "button",
            label: "Remove Variation",
            hidden: () => !this._selectedMaterial(),
            value: () => {
              const e = this.getSelectedVariation();
              e && confirm("Remove this variation?") && this.removeVariation(e);
            }
          }, {
            type: "button",
            label: "Add Variation",
            hidden: () => !this._selectedMaterial(),
            value: () => this.addVariation(this._selectedMaterial())
          }, {
            type: "button",
            label: "Refresh Ui",
            value: () => this.refreshUi()
          }];
        }]
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new gT(this._viewer), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }

    fromJSON(e, t) {
      return this.variations = [], super.fromJSON(e, t);
    }

    async onRemove(e) {
      var t, n;
      return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (n = this._picking) || void 0 === n || n.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e);
    }

    findVariation(e) {
      return e ? this.variations.find(t => t.uuid === e) : void 0;
    }

    getSelectedVariation() {
      var e, t;
      return this.findVariation(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid) || this.findVariation(null === (t = this._selectedMaterial()) || void 0 === t ? void 0 : t.name);
    }

    applyVariation(e, t) {
      var n, r;
      const i = e.materials.find(e => e.uuid === t);

      if (i) {
        const t = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getManager()) || void 0 === r ? void 0 : r.materials;
        let s = null == t ? void 0 : t.findMaterialsByName(e.uuid);
        (!s || s.length < 1) && (s = [null == t ? void 0 : t.findMaterial(e.uuid)]), s.forEach(e => {
          if (!e) return;
          const t = e.name;
          e.copyProps(i), e.name = t;
        });
      }
    }

    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }

    async _refreshUi() {
      return !(!this.enabled || !this._viewer || !this._uiNeedRefresh || (this._uiNeedRefresh = !1, this._refreshUiConfig(), 0));
    }

    removeVariationForMaterial(e) {
      let t = this.findVariation(e.uuid);
      !t && e.name.length > 0 && (t = this.findVariation(e.name)), t && this.removeVariation(t);
    }

    removeVariation(e) {
      e && (this.variations.splice(this.variations.indexOf(e), 1), this.refreshUi());
    }

    addVariation(e) {
      var t;
      const n = null === (t = null == e ? void 0 : e.clone) || void 0 === t ? void 0 : t.call(e);

      if (e && n) {
        let t = this.findVariation(e.uuid);
        !t && e.name.length > 0 && (t = this.findVariation(e.name)), t || this.variations.push(t = {
          uuid: e.name.length > 0 ? e.name : e.uuid,
          title: "Name",
          preview: "generate:sphere",
          materials: []
        }), t.materials.push(n), this.refreshUi();
      }
    }

  }

  vT.PluginType = "MaterialConfiguratorBasePlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe()], vT.prototype, "variations", void 0);

  const bT = (e, t = !0) => {
    const n = new ve().set(e);
    return t && n.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${n.getHexString()}'/%3E%3C/svg%3E%0A`;
  },
        xT = (e, t = !0) => {
    const n = new ve().set(e);
    return t && n.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${n.getHexString()}'/%3E%3C/svg%3E%0A`;
  },
        yT = e => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${e}%3C/text%3E%3C/svg%3E%0A`,
        wT = async (e, t) => Dt(await wt(e), t),
        ST = async (e, t) => await wT(e, t).then(e => e.toDataURL("image/png"));

  class MT {
    static _initialize() {
      this._inited = !0, St(T`
  .customContextGrid {
    background: #28223C;
    //backdrop-filter: blur(8px);
    border: 0.5px solid rgba(220, 220, 220, 0.3);
    width: auto;
    height: auto;
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    z-index: 200;
    padding: 0.35rem 0.35rem;
    border-radius: 0.375rem;
    min-width: 5rem;
    pointer-events: auto;
    box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);

    color: white;
    font-size: 0.65rem;
    font-family: Inter, "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
  }
  .customContextGridItems {
    background-color: transparent;
    cursor: pointer;
    border-radius: 0.25rem;
    line-height: 1rem;
    font-weight: 500;
    overflow: hidden;
    margin: 0.12rem;
  }
  .customContextGridItems:hover {
    color: white;
    background-color: #017AFF;
  }
  .customContextGridItemImage{
    width: 100%;
    height: 100%;
  }
  .customContextGridHeading{
    width: 100%;
    padding: 0.12rem;
    font-size: 0.85rem;
  }

        `);
    }

    static Create(e, t, n, r, i, s, o) {
      var a;
      this._inited || this._initialize();
      const l = Ct(),
            c = l ? .15 : .25,
            u = l ? 1.5 : 2.5,
            p = yt({
        classList: ["customContextGrid"],
        addToBody: !1,
        innerHTML: `\n            <div class="customContextGridHeading"> ${t} </div>\n            `
      });
      p.style.top = i + "px", p.style.left = r + "px", p.style.gap = c + "rem", p.style.width = (u + c) * n - c + "rem", p.dataset.tag = e;

      for (const e of s) {
        const t = yt({
          classList: ["customContextGridItems"],
          addToBody: !1,
          innerHTML: `\n            <img src="${e.image}" class="customContextGridItemImage">\n            `
        });
        t.style.width = u + "rem", t.style.height = u + "rem", p.appendChild(t), t.onclick = () => {
          var t;
          return null === (t = e.onClick) || void 0 === t ? void 0 : t.call(e, e.id);
        }, o(t, e);
      }

      return null === (a = this.Elements) || void 0 === a || a.push(p), p;
    }

    static RemoveAll(e) {
      if (e) {
        const t = this.Elements.filter(t => t.dataset.tag === e);

        for (const e of t) e.remove();

        this.Elements = this.Elements.filter(t => t.dataset.tag !== e);
      } else {
        for (const e of this.Elements) e.remove();

        this.Elements = [];
      }
    }

    static RebuildUi(e) {
      if (0 === this.Elements.length) return;
      e || (e = document.body);

      for (const e of this.Elements) e.remove();

      let t = 20;

      for (const n of this.Elements) n.style.top = t + "px", e.appendChild(n), t += n.clientHeight + 20;
    }

  }

  function TT(e) {
    if (null == e) return window;

    if ("[object Window]" !== e.toString()) {
      var t = e.ownerDocument;
      return t && t.defaultView || window;
    }

    return e;
  }

  function ET(e) {
    return e instanceof TT(e).Element || e instanceof Element;
  }

  function AT(e) {
    return e instanceof TT(e).HTMLElement || e instanceof HTMLElement;
  }

  function CT(e) {
    return "undefined" != typeof ShadowRoot && (e instanceof TT(e).ShadowRoot || e instanceof ShadowRoot);
  }

  MT.Elements = [], MT._inited = !1;
  var RT = Math.max,
      kT = Math.min,
      PT = Math.round;

  function DT(e, t) {
    void 0 === t && (t = !1);
    var n = e.getBoundingClientRect(),
        r = 1,
        i = 1;

    if (AT(e) && t) {
      var s = e.offsetHeight,
          o = e.offsetWidth;
      o > 0 && (r = PT(n.width) / o || 1), s > 0 && (i = PT(n.height) / s || 1);
    }

    return {
      width: n.width / r,
      height: n.height / i,
      top: n.top / i,
      right: n.right / r,
      bottom: n.bottom / i,
      left: n.left / r,
      x: n.left / r,
      y: n.top / i
    };
  }

  function OT(e) {
    var t = TT(e);
    return {
      scrollLeft: t.pageXOffset,
      scrollTop: t.pageYOffset
    };
  }

  function LT(e) {
    return e ? (e.nodeName || "").toLowerCase() : null;
  }

  function IT(e) {
    return ((ET(e) ? e.ownerDocument : e.document) || window.document).documentElement;
  }

  function FT(e) {
    return DT(IT(e)).left + OT(e).scrollLeft;
  }

  function NT(e) {
    return TT(e).getComputedStyle(e);
  }

  function UT(e) {
    var t = NT(e),
        n = t.overflow,
        r = t.overflowX,
        i = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r);
  }

  function BT(e, t, n) {
    void 0 === n && (n = !1);

    var r,
        i,
        s = AT(t),
        o = AT(t) && function (e) {
      var t = e.getBoundingClientRect(),
          n = PT(t.width) / e.offsetWidth || 1,
          r = PT(t.height) / e.offsetHeight || 1;
      return 1 !== n || 1 !== r;
    }(t),
        a = IT(t),
        l = DT(e, o),
        c = {
      scrollLeft: 0,
      scrollTop: 0
    },
        u = {
      x: 0,
      y: 0
    };

    return (s || !s && !n) && (("body" !== LT(t) || UT(a)) && (c = (r = t) !== TT(r) && AT(r) ? {
      scrollLeft: (i = r).scrollLeft,
      scrollTop: i.scrollTop
    } : OT(r)), AT(t) ? ((u = DT(t, !0)).x += t.clientLeft, u.y += t.clientTop) : a && (u.x = FT(a))), {
      x: l.left + c.scrollLeft - u.x,
      y: l.top + c.scrollTop - u.y,
      width: l.width,
      height: l.height
    };
  }

  function jT(e) {
    var t = DT(e),
        n = e.offsetWidth,
        r = e.offsetHeight;
    return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
      x: e.offsetLeft,
      y: e.offsetTop,
      width: n,
      height: r
    };
  }

  function zT(e) {
    return "html" === LT(e) ? e : e.assignedSlot || e.parentNode || (CT(e) ? e.host : null) || IT(e);
  }

  function VT(e) {
    return ["html", "body", "#document"].indexOf(LT(e)) >= 0 ? e.ownerDocument.body : AT(e) && UT(e) ? e : VT(zT(e));
  }

  function GT(e, t) {
    var n;
    void 0 === t && (t = []);
    var r = VT(e),
        i = r === (null == (n = e.ownerDocument) ? void 0 : n.body),
        s = TT(r),
        o = i ? [s].concat(s.visualViewport || [], UT(r) ? r : []) : r,
        a = t.concat(o);
    return i ? a : a.concat(GT(zT(o)));
  }

  function HT(e) {
    return ["table", "td", "th"].indexOf(LT(e)) >= 0;
  }

  function WT(e) {
    return AT(e) && "fixed" !== NT(e).position ? e.offsetParent : null;
  }

  function KT(e) {
    for (var t = TT(e), n = WT(e); n && HT(n) && "static" === NT(n).position;) n = WT(n);

    return n && ("html" === LT(n) || "body" === LT(n) && "static" === NT(n).position) ? t : n || function (e) {
      var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
      if (-1 !== navigator.userAgent.indexOf("Trident") && AT(e) && "fixed" === NT(e).position) return null;
      var n = zT(e);

      for (CT(n) && (n = n.host); AT(n) && ["html", "body"].indexOf(LT(n)) < 0;) {
        var r = NT(n);
        if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n;
        n = n.parentNode;
      }

      return null;
    }(e) || t;
  }

  var XT = "top",
      qT = "bottom",
      YT = "right",
      ZT = "left",
      JT = "auto",
      $T = [XT, qT, YT, ZT],
      QT = "start",
      eE = "end",
      tE = "clippingParents",
      nE = "viewport",
      rE = "popper",
      iE = "reference",
      sE = $T.reduce(function (e, t) {
    return e.concat([t + "-" + QT, t + "-" + eE]);
  }, []),
      oE = [].concat($T, [JT]).reduce(function (e, t) {
    return e.concat([t, t + "-" + QT, t + "-" + eE]);
  }, []),
      aE = "beforeRead",
      lE = "read",
      cE = "afterRead",
      uE = "beforeMain",
      pE = "main",
      hE = "afterMain",
      dE = "beforeWrite",
      fE = "write",
      _E = "afterWrite",
      mE = [aE, lE, cE, uE, pE, hE, dE, fE, _E];

  function gE(e) {
    var t = new Map(),
        n = new Set(),
        r = [];

    function i(e) {
      n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
        if (!n.has(e)) {
          var r = t.get(e);
          r && i(r);
        }
      }), r.push(e);
    }

    return e.forEach(function (e) {
      t.set(e.name, e);
    }), e.forEach(function (e) {
      n.has(e.name) || i(e);
    }), r;
  }

  function vE(e) {
    var t;
    return function () {
      return t || (t = new Promise(function (n) {
        Promise.resolve().then(function () {
          t = void 0, n(e());
        });
      })), t;
    };
  }

  var bE = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };

  function xE() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];

    return !t.some(function (e) {
      return !(e && "function" == typeof e.getBoundingClientRect);
    });
  }

  function yE(e) {
    void 0 === e && (e = {});
    var t = e,
        n = t.defaultModifiers,
        r = void 0 === n ? [] : n,
        i = t.defaultOptions,
        s = void 0 === i ? bE : i;
    return function (e, t, n) {
      void 0 === n && (n = s);
      var i = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, bE, s),
        modifiersData: {},
        elements: {
          reference: e,
          popper: t
        },
        attributes: {},
        styles: {}
      },
          o = [],
          a = !1,
          l = {
        state: i,
        setOptions: function (n) {
          var a = "function" == typeof n ? n(i.options) : n;
          c(), i.options = Object.assign({}, s, i.options, a), i.scrollParents = {
            reference: ET(e) ? GT(e) : e.contextElement ? GT(e.contextElement) : [],
            popper: GT(t)
          };

          var u,
              p,
              h = function (e) {
            var t = gE(e);
            return mE.reduce(function (e, n) {
              return e.concat(t.filter(function (e) {
                return e.phase === n;
              }));
            }, []);
          }((u = [].concat(r, i.options.modifiers), p = u.reduce(function (e, t) {
            var n = e[t.name];
            return e[t.name] = n ? Object.assign({}, n, t, {
              options: Object.assign({}, n.options, t.options),
              data: Object.assign({}, n.data, t.data)
            }) : t, e;
          }, {}), Object.keys(p).map(function (e) {
            return p[e];
          })));

          return i.orderedModifiers = h.filter(function (e) {
            return e.enabled;
          }), i.orderedModifiers.forEach(function (e) {
            var t = e.name,
                n = e.options,
                r = void 0 === n ? {} : n,
                s = e.effect;

            if ("function" == typeof s) {
              var a = s({
                state: i,
                name: t,
                instance: l,
                options: r
              });
              o.push(a || function () {});
            }
          }), l.update();
        },
        forceUpdate: function () {
          if (!a) {
            var e = i.elements,
                t = e.reference,
                n = e.popper;

            if (xE(t, n)) {
              i.rects = {
                reference: BT(t, KT(n), "fixed" === i.options.strategy),
                popper: jT(n)
              }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach(function (e) {
                return i.modifiersData[e.name] = Object.assign({}, e.data);
              });

              for (var r = 0; r < i.orderedModifiers.length; r++) if (!0 !== i.reset) {
                var s = i.orderedModifiers[r],
                    o = s.fn,
                    c = s.options,
                    u = void 0 === c ? {} : c,
                    p = s.name;
                "function" == typeof o && (i = o({
                  state: i,
                  options: u,
                  name: p,
                  instance: l
                }) || i);
              } else i.reset = !1, r = -1;
            }
          }
        },
        update: vE(function () {
          return new Promise(function (e) {
            l.forceUpdate(), e(i);
          });
        }),
        destroy: function () {
          c(), a = !0;
        }
      };
      if (!xE(e, t)) return l;

      function c() {
        o.forEach(function (e) {
          return e();
        }), o = [];
      }

      return l.setOptions(n).then(function (e) {
        !a && n.onFirstUpdate && n.onFirstUpdate(e);
      }), l;
    };
  }

  var wE = yE(),
      SE = {
    passive: !0
  },
      ME = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (e) {
      var t = e.state,
          n = e.instance,
          r = e.options,
          i = r.scroll,
          s = void 0 === i || i,
          o = r.resize,
          a = void 0 === o || o,
          l = TT(t.elements.popper),
          c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
      return s && c.forEach(function (e) {
        e.addEventListener("scroll", n.update, SE);
      }), a && l.addEventListener("resize", n.update, SE), function () {
        s && c.forEach(function (e) {
          e.removeEventListener("scroll", n.update, SE);
        }), a && l.removeEventListener("resize", n.update, SE);
      };
    },
    data: {}
  };

  function TE(e) {
    return e.split("-")[0];
  }

  function EE(e) {
    return e.split("-")[1];
  }

  function AE(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
  }

  function CE(e) {
    var t,
        n = e.reference,
        r = e.element,
        i = e.placement,
        s = i ? TE(i) : null,
        o = i ? EE(i) : null,
        a = n.x + n.width / 2 - r.width / 2,
        l = n.y + n.height / 2 - r.height / 2;

    switch (s) {
      case XT:
        t = {
          x: a,
          y: n.y - r.height
        };
        break;

      case qT:
        t = {
          x: a,
          y: n.y + n.height
        };
        break;

      case YT:
        t = {
          x: n.x + n.width,
          y: l
        };
        break;

      case ZT:
        t = {
          x: n.x - r.width,
          y: l
        };
        break;

      default:
        t = {
          x: n.x,
          y: n.y
        };
    }

    var c = s ? AE(s) : null;

    if (null != c) {
      var u = "y" === c ? "height" : "width";

      switch (o) {
        case QT:
          t[c] = t[c] - (n[u] / 2 - r[u] / 2);
          break;

        case eE:
          t[c] = t[c] + (n[u] / 2 - r[u] / 2);
      }
    }

    return t;
  }

  var RE = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: function (e) {
      var t = e.state,
          n = e.name;
      t.modifiersData[n] = CE({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
      });
    },
    data: {}
  },
      kE = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };

  function PE(e) {
    var t,
        n = e.popper,
        r = e.popperRect,
        i = e.placement,
        s = e.variation,
        o = e.offsets,
        a = e.position,
        l = e.gpuAcceleration,
        c = e.adaptive,
        u = e.roundOffsets,
        p = e.isFixed,
        h = o.x,
        d = void 0 === h ? 0 : h,
        f = o.y,
        _ = void 0 === f ? 0 : f,
        m = "function" == typeof u ? u({
      x: d,
      y: _
    }) : {
      x: d,
      y: _
    };

    d = m.x, _ = m.y;
    var g = o.hasOwnProperty("x"),
        v = o.hasOwnProperty("y"),
        b = ZT,
        x = XT,
        y = window;

    if (c) {
      var w = KT(n),
          S = "clientHeight",
          M = "clientWidth";
      w === TT(n) && "static" !== NT(w = IT(n)).position && "absolute" === a && (S = "scrollHeight", M = "scrollWidth"), (i === XT || (i === ZT || i === YT) && s === eE) && (x = qT, _ -= (p && w === y && y.visualViewport ? y.visualViewport.height : w[S]) - r.height, _ *= l ? 1 : -1), i !== ZT && (i !== XT && i !== qT || s !== eE) || (b = YT, d -= (p && w === y && y.visualViewport ? y.visualViewport.width : w[M]) - r.width, d *= l ? 1 : -1);
    }

    var T,
        E = Object.assign({
      position: a
    }, c && kE),
        A = !0 === u ? function (e) {
      var t = e.x,
          n = e.y,
          r = window.devicePixelRatio || 1;
      return {
        x: PT(t * r) / r || 0,
        y: PT(n * r) / r || 0
      };
    }({
      x: d,
      y: _
    }) : {
      x: d,
      y: _
    };
    return d = A.x, _ = A.y, l ? Object.assign({}, E, ((T = {})[x] = v ? "0" : "", T[b] = g ? "0" : "", T.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + _ + "px)" : "translate3d(" + d + "px, " + _ + "px, 0)", T)) : Object.assign({}, E, ((t = {})[x] = v ? _ + "px" : "", t[b] = g ? d + "px" : "", t.transform = "", t));
  }

  var DE = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = n.gpuAcceleration,
          i = void 0 === r || r,
          s = n.adaptive,
          o = void 0 === s || s,
          a = n.roundOffsets,
          l = void 0 === a || a,
          c = {
        placement: TE(t.placement),
        variation: EE(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: i,
        isFixed: "fixed" === t.options.strategy
      };
      null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, PE(Object.assign({}, c, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: o,
        roundOffsets: l
      })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, PE(Object.assign({}, c, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
      })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
      });
    },
    data: {}
  },
      OE = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (e) {
      var t = e.state;
      Object.keys(t.elements).forEach(function (e) {
        var n = t.styles[e] || {},
            r = t.attributes[e] || {},
            i = t.elements[e];
        AT(i) && LT(i) && (Object.assign(i.style, n), Object.keys(r).forEach(function (e) {
          var t = r[e];
          !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t);
        }));
      });
    },
    effect: function (e) {
      var t = e.state,
          n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () {
        Object.keys(t.elements).forEach(function (e) {
          var r = t.elements[e],
              i = t.attributes[e] || {},
              s = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) {
            return e[t] = "", e;
          }, {});
          AT(r) && LT(r) && (Object.assign(r.style, s), Object.keys(i).forEach(function (e) {
            r.removeAttribute(e);
          }));
        });
      };
    },
    requires: ["computeStyles"]
  },
      LE = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = e.name,
          i = n.offset,
          s = void 0 === i ? [0, 0] : i,
          o = oE.reduce(function (e, n) {
        return e[n] = function (e, t, n) {
          var r = TE(e),
              i = [ZT, XT].indexOf(r) >= 0 ? -1 : 1,
              s = "function" == typeof n ? n(Object.assign({}, t, {
            placement: e
          })) : n,
              o = s[0],
              a = s[1];
          return o = o || 0, a = (a || 0) * i, [ZT, YT].indexOf(r) >= 0 ? {
            x: a,
            y: o
          } : {
            x: o,
            y: a
          };
        }(n, t.rects, s), e;
      }, {}),
          a = o[t.placement],
          l = a.x,
          c = a.y;
      null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = o;
    }
  },
      IE = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };

  function FE(e) {
    return e.replace(/left|right|bottom|top/g, function (e) {
      return IE[e];
    });
  }

  var NE = {
    start: "end",
    end: "start"
  };

  function UE(e) {
    return e.replace(/start|end/g, function (e) {
      return NE[e];
    });
  }

  function BE(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;

    if (n && CT(n)) {
      var r = t;

      do {
        if (r && e.isSameNode(r)) return !0;
        r = r.parentNode || r.host;
      } while (r);
    }

    return !1;
  }

  function jE(e) {
    return Object.assign({}, e, {
      left: e.x,
      top: e.y,
      right: e.x + e.width,
      bottom: e.y + e.height
    });
  }

  function zE(e, t) {
    return t === nE ? jE(function (e) {
      var t = TT(e),
          n = IT(e),
          r = t.visualViewport,
          i = n.clientWidth,
          s = n.clientHeight,
          o = 0,
          a = 0;
      return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), {
        width: i,
        height: s,
        x: o + FT(e),
        y: a
      };
    }(e)) : ET(t) ? function (e) {
      var t = DT(e);
      return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
    }(t) : jE(function (e) {
      var t,
          n = IT(e),
          r = OT(e),
          i = null == (t = e.ownerDocument) ? void 0 : t.body,
          s = RT(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
          o = RT(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
          a = -r.scrollLeft + FT(e),
          l = -r.scrollTop;
      return "rtl" === NT(i || n).direction && (a += RT(n.clientWidth, i ? i.clientWidth : 0) - s), {
        width: s,
        height: o,
        x: a,
        y: l
      };
    }(IT(e)));
  }

  function VE(e) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, e);
  }

  function GE(e, t) {
    return t.reduce(function (t, n) {
      return t[n] = e, t;
    }, {});
  }

  function HE(e, t) {
    void 0 === t && (t = {});

    var n = t,
        r = n.placement,
        i = void 0 === r ? e.placement : r,
        s = n.boundary,
        o = void 0 === s ? tE : s,
        a = n.rootBoundary,
        l = void 0 === a ? nE : a,
        c = n.elementContext,
        u = void 0 === c ? rE : c,
        p = n.altBoundary,
        h = void 0 !== p && p,
        d = n.padding,
        f = void 0 === d ? 0 : d,
        _ = VE("number" != typeof f ? f : GE(f, $T)),
        m = u === rE ? iE : rE,
        g = e.rects.popper,
        v = e.elements[h ? m : u],
        b = function (e, t, n) {
      var r = "clippingParents" === t ? function (e) {
        var t = GT(zT(e)),
            n = ["absolute", "fixed"].indexOf(NT(e).position) >= 0 && AT(e) ? KT(e) : e;
        return ET(n) ? t.filter(function (e) {
          return ET(e) && BE(e, n) && "body" !== LT(e);
        }) : [];
      }(e) : [].concat(t),
          i = [].concat(r, [n]),
          s = i[0],
          o = i.reduce(function (t, n) {
        var r = zE(e, n);
        return t.top = RT(r.top, t.top), t.right = kT(r.right, t.right), t.bottom = kT(r.bottom, t.bottom), t.left = RT(r.left, t.left), t;
      }, zE(e, s));
      return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
    }(ET(v) ? v : v.contextElement || IT(e.elements.popper), o, l),
        x = DT(e.elements.reference),
        y = CE({
      reference: x,
      element: g,
      strategy: "absolute",
      placement: i
    }),
        w = jE(Object.assign({}, g, y)),
        S = u === rE ? w : x,
        M = {
      top: b.top - S.top + _.top,
      bottom: S.bottom - b.bottom + _.bottom,
      left: b.left - S.left + _.left,
      right: S.right - b.right + _.right
    },
        T = e.modifiersData.offset;

    if (u === rE && T) {
      var E = T[i];
      Object.keys(M).forEach(function (e) {
        var t = [YT, qT].indexOf(e) >= 0 ? 1 : -1,
            n = [XT, qT].indexOf(e) >= 0 ? "y" : "x";
        M[e] += E[n] * t;
      });
    }

    return M;
  }

  var WE = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = e.name;

      if (!t.modifiersData[r]._skip) {
        for (var i = n.mainAxis, s = void 0 === i || i, o = n.altAxis, a = void 0 === o || o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, p = n.rootBoundary, h = n.altBoundary, d = n.flipVariations, f = void 0 === d || d, _ = n.allowedAutoPlacements, m = t.options.placement, g = TE(m), v = l || (g !== m && f ? function (e) {
          if (TE(e) === JT) return [];
          var t = FE(e);
          return [UE(e), t, UE(t)];
        }(m) : [FE(m)]), b = [m].concat(v).reduce(function (e, n) {
          return e.concat(TE(n) === JT ? function (e, t) {
            void 0 === t && (t = {});
            var n = t,
                r = n.placement,
                i = n.boundary,
                s = n.rootBoundary,
                o = n.padding,
                a = n.flipVariations,
                l = n.allowedAutoPlacements,
                c = void 0 === l ? oE : l,
                u = EE(r),
                p = u ? a ? sE : sE.filter(function (e) {
              return EE(e) === u;
            }) : $T,
                h = p.filter(function (e) {
              return c.indexOf(e) >= 0;
            });
            0 === h.length && (h = p);
            var d = h.reduce(function (t, n) {
              return t[n] = HE(e, {
                placement: n,
                boundary: i,
                rootBoundary: s,
                padding: o
              })[TE(n)], t;
            }, {});
            return Object.keys(d).sort(function (e, t) {
              return d[e] - d[t];
            });
          }(t, {
            placement: n,
            boundary: u,
            rootBoundary: p,
            padding: c,
            flipVariations: f,
            allowedAutoPlacements: _
          }) : n);
        }, []), x = t.rects.reference, y = t.rects.popper, w = new Map(), S = !0, M = b[0], T = 0; T < b.length; T++) {
          var E = b[T],
              A = TE(E),
              C = EE(E) === QT,
              R = [XT, qT].indexOf(A) >= 0,
              k = R ? "width" : "height",
              P = HE(t, {
            placement: E,
            boundary: u,
            rootBoundary: p,
            altBoundary: h,
            padding: c
          }),
              D = R ? C ? YT : ZT : C ? qT : XT;
          x[k] > y[k] && (D = FE(D));
          var O = FE(D),
              L = [];

          if (s && L.push(P[A] <= 0), a && L.push(P[D] <= 0, P[O] <= 0), L.every(function (e) {
            return e;
          })) {
            M = E, S = !1;
            break;
          }

          w.set(E, L);
        }

        if (S) for (var I = function (e) {
          var t = b.find(function (t) {
            var n = w.get(t);
            if (n) return n.slice(0, e).every(function (e) {
              return e;
            });
          });
          if (t) return M = t, "break";
        }, F = f ? 3 : 1; F > 0 && "break" !== I(F); F--);
        t.placement !== M && (t.modifiersData[r]._skip = !0, t.placement = M, t.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };

  function KE(e, t, n) {
    return RT(e, kT(t, n));
  }

  var XE = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = e.name,
          i = n.mainAxis,
          s = void 0 === i || i,
          o = n.altAxis,
          a = void 0 !== o && o,
          l = n.boundary,
          c = n.rootBoundary,
          u = n.altBoundary,
          p = n.padding,
          h = n.tether,
          d = void 0 === h || h,
          f = n.tetherOffset,
          _ = void 0 === f ? 0 : f,
          m = HE(t, {
        boundary: l,
        rootBoundary: c,
        padding: p,
        altBoundary: u
      }),
          g = TE(t.placement),
          v = EE(t.placement),
          b = !v,
          x = AE(g),
          y = "x" === x ? "y" : "x",
          w = t.modifiersData.popperOffsets,
          S = t.rects.reference,
          M = t.rects.popper,
          T = "function" == typeof _ ? _(Object.assign({}, t.rects, {
        placement: t.placement
      })) : _,
          E = "number" == typeof T ? {
        mainAxis: T,
        altAxis: T
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, T),
          A = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
          C = {
        x: 0,
        y: 0
      };

      if (w) {
        if (s) {
          var R,
              k = "y" === x ? XT : ZT,
              P = "y" === x ? qT : YT,
              D = "y" === x ? "height" : "width",
              O = w[x],
              L = O + m[k],
              I = O - m[P],
              F = d ? -M[D] / 2 : 0,
              N = v === QT ? S[D] : M[D],
              U = v === QT ? -M[D] : -S[D],
              B = t.elements.arrow,
              j = d && B ? jT(B) : {
            width: 0,
            height: 0
          },
              z = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          },
              V = z[k],
              G = z[P],
              H = KE(0, S[D], j[D]),
              W = b ? S[D] / 2 - F - H - V - E.mainAxis : N - H - V - E.mainAxis,
              K = b ? -S[D] / 2 + F + H + G + E.mainAxis : U + H + G + E.mainAxis,
              X = t.elements.arrow && KT(t.elements.arrow),
              q = X ? "y" === x ? X.clientTop || 0 : X.clientLeft || 0 : 0,
              Y = null != (R = null == A ? void 0 : A[x]) ? R : 0,
              Z = O + K - Y,
              J = KE(d ? kT(L, O + W - Y - q) : L, O, d ? RT(I, Z) : I);
          w[x] = J, C[x] = J - O;
        }

        if (a) {
          var $,
              Q = "x" === x ? XT : ZT,
              ee = "x" === x ? qT : YT,
              te = w[y],
              ne = "y" === y ? "height" : "width",
              re = te + m[Q],
              ie = te - m[ee],
              se = -1 !== [XT, ZT].indexOf(g),
              oe = null != ($ = null == A ? void 0 : A[y]) ? $ : 0,
              ae = se ? re : te - S[ne] - M[ne] - oe + E.altAxis,
              le = se ? te + S[ne] + M[ne] - oe - E.altAxis : ie,
              ce = d && se ? function (e, t, n) {
            var r = KE(e, t, n);
            return r > n ? n : r;
          }(ae, te, le) : KE(d ? ae : re, te, d ? le : ie);
          w[y] = ce, C[y] = ce - te;
        }

        t.modifiersData[r] = C;
      }
    },
    requiresIfExists: ["offset"]
  },
      qE = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t,
          n = e.state,
          r = e.name,
          i = e.options,
          s = n.elements.arrow,
          o = n.modifiersData.popperOffsets,
          a = TE(n.placement),
          l = AE(a),
          c = [ZT, YT].indexOf(a) >= 0 ? "height" : "width";

      if (s && o) {
        var u = function (e, t) {
          return VE("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, {
            placement: t.placement
          })) : e) ? e : GE(e, $T));
        }(i.padding, n),
            p = jT(s),
            h = "y" === l ? XT : ZT,
            d = "y" === l ? qT : YT,
            f = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c],
            _ = o[l] - n.rects.reference[l],
            m = KT(s),
            g = m ? "y" === l ? m.clientHeight || 0 : m.clientWidth || 0 : 0,
            v = f / 2 - _ / 2,
            b = u[h],
            x = g - p[c] - u[d],
            y = g / 2 - p[c] / 2 + v,
            w = KE(b, y, x),
            S = l;

        n.modifiersData[r] = ((t = {})[S] = w, t.centerOffset = w - y, t);
      }
    },
    effect: function (e) {
      var t = e.state,
          n = e.options.element,
          r = void 0 === n ? "[data-popper-arrow]" : n;
      null != r && ("string" != typeof r || (r = t.elements.popper.querySelector(r))) && BE(t.elements.popper, r) && (t.elements.arrow = r);
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  function YE(e, t, n) {
    return void 0 === n && (n = {
      x: 0,
      y: 0
    }), {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x
    };
  }

  function ZE(e) {
    return [XT, YT, qT, ZT].some(function (t) {
      return e[t] >= 0;
    });
  }

  var JE = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: function (e) {
      var t = e.state,
          n = e.name,
          r = t.rects.reference,
          i = t.rects.popper,
          s = t.modifiersData.preventOverflow,
          o = HE(t, {
        elementContext: "reference"
      }),
          a = HE(t, {
        altBoundary: !0
      }),
          l = YE(o, r),
          c = YE(a, i, s),
          u = ZE(l),
          p = ZE(c);
      t.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: u,
        hasPopperEscaped: p
      }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": p
      });
    }
  },
      $E = yE({
    defaultModifiers: [ME, RE, DE, OE, LE, WE, XE, qE, JE]
  }),
      QE = "tippy-content",
      eA = "tippy-arrow",
      tA = "tippy-svg-arrow",
      nA = {
    passive: !0,
    capture: !0
  },
      rA = function () {
    return document.body;
  };

  function iA(e, t, n) {
    if (Array.isArray(e)) {
      var r = e[t];
      return null == r ? Array.isArray(n) ? n[t] : n : r;
    }

    return e;
  }

  function sA(e, t) {
    var n = {}.toString.call(e);
    return 0 === n.indexOf("[object") && n.indexOf(t + "]") > -1;
  }

  function oA(e, t) {
    return "function" == typeof e ? e.apply(void 0, t) : e;
  }

  function aA(e, t) {
    return 0 === t ? e : function (r) {
      clearTimeout(n), n = setTimeout(function () {
        e(r);
      }, t);
    };
    var n;
  }

  function lA(e) {
    return [].concat(e);
  }

  function cA(e, t) {
    -1 === e.indexOf(t) && e.push(t);
  }

  function uA(e) {
    return [].slice.call(e);
  }

  function pA(e) {
    return Object.keys(e).reduce(function (t, n) {
      return void 0 !== e[n] && (t[n] = e[n]), t;
    }, {});
  }

  function hA() {
    return document.createElement("div");
  }

  function dA(e) {
    return ["Element", "Fragment"].some(function (t) {
      return sA(e, t);
    });
  }

  function fA(e, t) {
    e.forEach(function (e) {
      e && (e.style.transitionDuration = t + "ms");
    });
  }

  function _A(e, t) {
    e.forEach(function (e) {
      e && e.setAttribute("data-state", t);
    });
  }

  function mA(e, t, n) {
    var r = t + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function (t) {
      e[r](t, n);
    });
  }

  function gA(e, t) {
    for (var n = t; n;) {
      var r;
      if (e.contains(n)) return !0;
      n = null == n.getRootNode || null == (r = n.getRootNode()) ? void 0 : r.host;
    }

    return !1;
  }

  var vA = {
    isTouch: !1
  },
      bA = 0;

  function xA() {
    vA.isTouch || (vA.isTouch = !0, window.performance && document.addEventListener("mousemove", yA));
  }

  function yA() {
    var e = performance.now();
    e - bA < 20 && (vA.isTouch = !1, document.removeEventListener("mousemove", yA)), bA = e;
  }

  function wA() {
    var e,
        t = document.activeElement;

    if ((e = t) && e._tippy && e._tippy.reference === e) {
      var n = t._tippy;
      t.blur && !n.state.isVisible && t.blur();
    }
  }

  var SA = !("undefined" == typeof window || "undefined" == typeof document || !window.msCrypto),
      MA = Object.assign({
    appendTo: rA,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: !0,
    ignoreAttributes: !1,
    interactive: !1,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function () {},
    onBeforeUpdate: function () {},
    onCreate: function () {},
    onDestroy: function () {},
    onHidden: function () {},
    onHide: function () {},
    onMount: function () {},
    onShow: function () {},
    onShown: function () {},
    onTrigger: function () {},
    onUntrigger: function () {},
    onClickOutside: function () {},
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: !1,
    touch: !0,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, {
    animateFill: !1,
    followCursor: !1,
    inlinePositioning: !1,
    sticky: !1
  }, {
    allowHTML: !1,
    animation: "fade",
    arrow: !0,
    content: "",
    inertia: !1,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  }),
      TA = Object.keys(MA);

  function EA(e) {
    var t = (e.plugins || []).reduce(function (t, n) {
      var r,
          i = n.name,
          s = n.defaultValue;
      return i && (t[i] = void 0 !== e[i] ? e[i] : null != (r = MA[i]) ? r : s), t;
    }, {});
    return Object.assign({}, e, t);
  }

  function AA(e, t) {
    var n = Object.assign({}, t, {
      content: oA(t.content, [e])
    }, t.ignoreAttributes ? {} : function (e, t) {
      return (t ? Object.keys(EA(Object.assign({}, MA, {
        plugins: t
      }))) : TA).reduce(function (t, n) {
        var r = (e.getAttribute("data-tippy-" + n) || "").trim();
        if (!r) return t;
        if ("content" === n) t[n] = r;else try {
          t[n] = JSON.parse(r);
        } catch (e) {
          t[n] = r;
        }
        return t;
      }, {});
    }(e, t.plugins));
    return n.aria = Object.assign({}, MA.aria, n.aria), n.aria = {
      expanded: "auto" === n.aria.expanded ? t.interactive : n.aria.expanded,
      content: "auto" === n.aria.content ? t.interactive ? null : "describedby" : n.aria.content
    }, n;
  }

  function CA(e, t) {
    e.innerHTML = t;
  }

  function RA(e) {
    var t = hA();
    return !0 === e ? t.className = eA : (t.className = tA, dA(e) ? t.appendChild(e) : CA(t, e)), t;
  }

  function kA(e, t) {
    dA(t.content) ? (CA(e, ""), e.appendChild(t.content)) : "function" != typeof t.content && (t.allowHTML ? CA(e, t.content) : e.textContent = t.content);
  }

  function PA(e) {
    var t = e.firstElementChild,
        n = uA(t.children);
    return {
      box: t,
      content: n.find(function (e) {
        return e.classList.contains(QE);
      }),
      arrow: n.find(function (e) {
        return e.classList.contains(eA) || e.classList.contains(tA);
      }),
      backdrop: n.find(function (e) {
        return e.classList.contains("tippy-backdrop");
      })
    };
  }

  function DA(e) {
    var t = hA(),
        n = hA();
    n.className = "tippy-box", n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
    var r = hA();

    function i(n, r) {
      var i = PA(t),
          s = i.box,
          o = i.content,
          a = i.arrow;
      r.theme ? s.setAttribute("data-theme", r.theme) : s.removeAttribute("data-theme"), "string" == typeof r.animation ? s.setAttribute("data-animation", r.animation) : s.removeAttribute("data-animation"), r.inertia ? s.setAttribute("data-inertia", "") : s.removeAttribute("data-inertia"), s.style.maxWidth = "number" == typeof r.maxWidth ? r.maxWidth + "px" : r.maxWidth, r.role ? s.setAttribute("role", r.role) : s.removeAttribute("role"), n.content === r.content && n.allowHTML === r.allowHTML || kA(o, e.props), r.arrow ? a ? n.arrow !== r.arrow && (s.removeChild(a), s.appendChild(RA(r.arrow))) : s.appendChild(RA(r.arrow)) : a && s.removeChild(a);
    }

    return r.className = QE, r.setAttribute("data-state", "hidden"), kA(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props), {
      popper: t,
      onUpdate: i
    };
  }

  DA.$$tippy = !0;
  var OA = 1,
      LA = [],
      IA = [];

  function FA(e, t) {
    var n,
        r,
        i,
        s,
        o,
        a,
        l,
        c,
        u = AA(e, Object.assign({}, MA, EA(pA(t)))),
        p = !1,
        h = !1,
        d = !1,
        f = !1,
        _ = [],
        m = aA(X, u.interactiveDebounce),
        g = OA++,
        v = (c = u.plugins).filter(function (e, t) {
      return c.indexOf(e) === t;
    }),
        b = {
      id: g,
      reference: e,
      popper: hA(),
      popperInstance: null,
      props: u,
      state: {
        isEnabled: !0,
        isVisible: !1,
        isDestroyed: !1,
        isMounted: !1,
        isShown: !1
      },
      plugins: v,
      clearDelayTimeouts: function () {
        clearTimeout(n), clearTimeout(r), cancelAnimationFrame(i);
      },
      setProps: function (t) {
        if (!b.state.isDestroyed) {
          O("onBeforeUpdate", [b, t]), W();
          var n = b.props,
              r = AA(e, Object.assign({}, n, pA(t), {
            ignoreAttributes: !0
          }));
          b.props = r, H(), n.interactiveDebounce !== r.interactiveDebounce && (F(), m = aA(X, r.interactiveDebounce)), n.triggerTarget && !r.triggerTarget ? lA(n.triggerTarget).forEach(function (e) {
            e.removeAttribute("aria-expanded");
          }) : r.triggerTarget && e.removeAttribute("aria-expanded"), I(), D(), w && w(n, r), b.popperInstance && (J(), Q().forEach(function (e) {
            requestAnimationFrame(e._tippy.popperInstance.forceUpdate);
          })), O("onAfterUpdate", [b, t]);
        }
      },
      setContent: function (e) {
        b.setProps({
          content: e
        });
      },
      show: function () {
        var e = b.state.isVisible,
            t = b.state.isDestroyed,
            n = !b.state.isEnabled,
            r = vA.isTouch && !b.props.touch,
            i = iA(b.props.duration, 0, MA.duration);

        if (!(e || t || n || r || C().hasAttribute("disabled") || (O("onShow", [b], !1), !1 === b.props.onShow(b)))) {
          if (b.state.isVisible = !0, A() && (y.style.visibility = "visible"), D(), j(), b.state.isMounted || (y.style.transition = "none"), A()) {
            var s = k();
            fA([s.box, s.content], 0);
          }

          var o, l, c;
          a = function () {
            var e;

            if (b.state.isVisible && !f) {
              if (f = !0, y.offsetHeight, y.style.transition = b.props.moveTransition, A() && b.props.animation) {
                var t = k(),
                    n = t.box,
                    r = t.content;
                fA([n, r], i), _A([n, r], "visible");
              }

              L(), I(), cA(IA, b), null == (e = b.popperInstance) || e.forceUpdate(), O("onMount", [b]), b.props.animation && A() && function (e, t) {
                V(e, function () {
                  b.state.isShown = !0, O("onShown", [b]);
                });
              }(i);
            }
          }, l = b.props.appendTo, c = C(), (o = b.props.interactive && l === rA || "parent" === l ? c.parentNode : oA(l, [c])).contains(y) || o.appendChild(y), b.state.isMounted = !0, J();
        }
      },
      hide: function () {
        var e = !b.state.isVisible,
            t = b.state.isDestroyed,
            n = !b.state.isEnabled,
            r = iA(b.props.duration, 1, MA.duration);

        if (!(e || t || n) && (O("onHide", [b], !1), !1 !== b.props.onHide(b))) {
          if (b.state.isVisible = !1, b.state.isShown = !1, f = !1, p = !1, A() && (y.style.visibility = "hidden"), F(), z(), D(!0), A()) {
            var i = k(),
                s = i.box,
                o = i.content;
            b.props.animation && (fA([s, o], r), _A([s, o], "hidden"));
          }

          L(), I(), b.props.animation ? A() && function (e, t) {
            V(e, function () {
              !b.state.isVisible && y.parentNode && y.parentNode.contains(y) && t();
            });
          }(r, b.unmount) : b.unmount();
        }
      },
      hideWithInteractivity: function (e) {
        R().addEventListener("mousemove", m), cA(LA, m), m(e);
      },
      enable: function () {
        b.state.isEnabled = !0;
      },
      disable: function () {
        b.hide(), b.state.isEnabled = !1;
      },
      unmount: function () {
        b.state.isVisible && b.hide(), b.state.isMounted && ($(), Q().forEach(function (e) {
          e._tippy.unmount();
        }), y.parentNode && y.parentNode.removeChild(y), IA = IA.filter(function (e) {
          return e !== b;
        }), b.state.isMounted = !1, O("onHidden", [b]));
      },
      destroy: function () {
        b.state.isDestroyed || (b.clearDelayTimeouts(), b.unmount(), W(), delete e._tippy, b.state.isDestroyed = !0, O("onDestroy", [b]));
      }
    };
    if (!u.render) return b;
    var x = u.render(b),
        y = x.popper,
        w = x.onUpdate;
    y.setAttribute("data-tippy-root", ""), y.id = "tippy-" + b.id, b.popper = y, e._tippy = b, y._tippy = b;
    var S = v.map(function (e) {
      return e.fn(b);
    }),
        M = e.hasAttribute("aria-expanded");
    return H(), I(), D(), O("onCreate", [b]), u.showOnCreate && ee(), y.addEventListener("mouseenter", function () {
      b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
    }), y.addEventListener("mouseleave", function () {
      b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && R().addEventListener("mousemove", m);
    }), b;

    function T() {
      var e = b.props.touch;
      return Array.isArray(e) ? e : [e, 0];
    }

    function E() {
      return "hold" === T()[0];
    }

    function A() {
      var e;
      return !(null == (e = b.props.render) || !e.$$tippy);
    }

    function C() {
      return l || e;
    }

    function R() {
      var e,
          t,
          n = C().parentNode;
      return n ? null != (t = lA(n)[0]) && null != (e = t.ownerDocument) && e.body ? t.ownerDocument : document : document;
    }

    function k() {
      return PA(y);
    }

    function P(e) {
      return b.state.isMounted && !b.state.isVisible || vA.isTouch || s && "focus" === s.type ? 0 : iA(b.props.delay, e ? 0 : 1, MA.delay);
    }

    function D(e) {
      void 0 === e && (e = !1), y.style.pointerEvents = b.props.interactive && !e ? "" : "none", y.style.zIndex = "" + b.props.zIndex;
    }

    function O(e, t, n) {
      var r;
      void 0 === n && (n = !0), S.forEach(function (n) {
        n[e] && n[e].apply(n, t);
      }), n && (r = b.props)[e].apply(r, t);
    }

    function L() {
      var t = b.props.aria;

      if (t.content) {
        var n = "aria-" + t.content,
            r = y.id;
        lA(b.props.triggerTarget || e).forEach(function (e) {
          var t = e.getAttribute(n);
          if (b.state.isVisible) e.setAttribute(n, t ? t + " " + r : r);else {
            var i = t && t.replace(r, "").trim();
            i ? e.setAttribute(n, i) : e.removeAttribute(n);
          }
        });
      }
    }

    function I() {
      !M && b.props.aria.expanded && lA(b.props.triggerTarget || e).forEach(function (e) {
        b.props.interactive ? e.setAttribute("aria-expanded", b.state.isVisible && e === C() ? "true" : "false") : e.removeAttribute("aria-expanded");
      });
    }

    function F() {
      R().removeEventListener("mousemove", m), LA = LA.filter(function (e) {
        return e !== m;
      });
    }

    function N(t) {
      if (!vA.isTouch || !d && "mousedown" !== t.type) {
        var n = t.composedPath && t.composedPath()[0] || t.target;

        if (!b.props.interactive || !gA(y, n)) {
          if (lA(b.props.triggerTarget || e).some(function (e) {
            return gA(e, n);
          })) {
            if (vA.isTouch) return;
            if (b.state.isVisible && b.props.trigger.indexOf("click") >= 0) return;
          } else O("onClickOutside", [b, t]);

          !0 === b.props.hideOnClick && (b.clearDelayTimeouts(), b.hide(), h = !0, setTimeout(function () {
            h = !1;
          }), b.state.isMounted || z());
        }
      }
    }

    function U() {
      d = !0;
    }

    function B() {
      d = !1;
    }

    function j() {
      var e = R();
      e.addEventListener("mousedown", N, !0), e.addEventListener("touchend", N, nA), e.addEventListener("touchstart", B, nA), e.addEventListener("touchmove", U, nA);
    }

    function z() {
      var e = R();
      e.removeEventListener("mousedown", N, !0), e.removeEventListener("touchend", N, nA), e.removeEventListener("touchstart", B, nA), e.removeEventListener("touchmove", U, nA);
    }

    function V(e, t) {
      var n = k().box;

      function r(e) {
        e.target === n && (mA(n, "remove", r), t());
      }

      if (0 === e) return t();
      mA(n, "remove", o), mA(n, "add", r), o = r;
    }

    function G(t, n, r) {
      void 0 === r && (r = !1), lA(b.props.triggerTarget || e).forEach(function (e) {
        e.addEventListener(t, n, r), _.push({
          node: e,
          eventType: t,
          handler: n,
          options: r
        });
      });
    }

    function H() {
      var e;
      E() && (G("touchstart", K, {
        passive: !0
      }), G("touchend", q, {
        passive: !0
      })), (e = b.props.trigger, e.split(/\s+/).filter(Boolean)).forEach(function (e) {
        if ("manual" !== e) switch (G(e, K), e) {
          case "mouseenter":
            G("mouseleave", q);
            break;

          case "focus":
            G(SA ? "focusout" : "blur", Y);
            break;

          case "focusin":
            G("focusout", Y);
        }
      });
    }

    function W() {
      _.forEach(function (e) {
        var t = e.node,
            n = e.eventType,
            r = e.handler,
            i = e.options;
        t.removeEventListener(n, r, i);
      }), _ = [];
    }

    function K(e) {
      var t,
          n = !1;

      if (b.state.isEnabled && !Z(e) && !h) {
        var r = "focus" === (null == (t = s) ? void 0 : t.type);
        s = e, l = e.currentTarget, I(), !b.state.isVisible && sA(e, "MouseEvent") && LA.forEach(function (t) {
          return t(e);
        }), "click" === e.type && (b.props.trigger.indexOf("mouseenter") < 0 || p) && !1 !== b.props.hideOnClick && b.state.isVisible ? n = !0 : ee(e), "click" === e.type && (p = !n), n && !r && te(e);
      }
    }

    function X(e) {
      var t = e.target,
          n = C().contains(t) || y.contains(t);

      if ("mousemove" !== e.type || !n) {
        var r = Q().concat(y).map(function (e) {
          var t,
              n = null == (t = e._tippy.popperInstance) ? void 0 : t.state;
          return n ? {
            popperRect: e.getBoundingClientRect(),
            popperState: n,
            props: u
          } : null;
        }).filter(Boolean);
        (function (e, t) {
          var n = t.clientX,
              r = t.clientY;
          return e.every(function (e) {
            var t = e.popperRect,
                i = e.popperState,
                s = e.props.interactiveBorder,
                o = i.placement.split("-")[0],
                a = i.modifiersData.offset;
            if (!a) return !0;

            var l = "bottom" === o ? a.top.y : 0,
                c = "top" === o ? a.bottom.y : 0,
                u = "right" === o ? a.left.x : 0,
                p = "left" === o ? a.right.x : 0,
                h = t.top - r + l > s,
                d = r - t.bottom - c > s,
                f = t.left - n + u > s,
                _ = n - t.right - p > s;

            return h || d || f || _;
          });
        })(r, e) && (F(), te(e));
      }
    }

    function q(e) {
      Z(e) || b.props.trigger.indexOf("click") >= 0 && p || (b.props.interactive ? b.hideWithInteractivity(e) : te(e));
    }

    function Y(e) {
      b.props.trigger.indexOf("focusin") < 0 && e.target !== C() || b.props.interactive && e.relatedTarget && y.contains(e.relatedTarget) || te(e);
    }

    function Z(e) {
      return !!vA.isTouch && E() !== e.type.indexOf("touch") >= 0;
    }

    function J() {
      $();
      var t = b.props,
          n = t.popperOptions,
          r = t.placement,
          i = t.offset,
          s = t.getReferenceClientRect,
          o = t.moveTransition,
          l = A() ? PA(y).arrow : null,
          c = s ? {
        getBoundingClientRect: s,
        contextElement: s.contextElement || C()
      } : e,
          u = [{
        name: "offset",
        options: {
          offset: i
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !o
        }
      }, {
        name: "$$tippy",
        enabled: !0,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function (e) {
          var t = e.state;

          if (A()) {
            var n = k().box;
            ["placement", "reference-hidden", "escaped"].forEach(function (e) {
              "placement" === e ? n.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? n.setAttribute("data-" + e, "") : n.removeAttribute("data-" + e);
            }), t.attributes.popper = {};
          }
        }
      }];
      A() && l && u.push({
        name: "arrow",
        options: {
          element: l,
          padding: 3
        }
      }), u.push.apply(u, (null == n ? void 0 : n.modifiers) || []), b.popperInstance = $E(c, y, Object.assign({}, n, {
        placement: r,
        onFirstUpdate: a,
        modifiers: u
      }));
    }

    function $() {
      b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
    }

    function Q() {
      return uA(y.querySelectorAll("[data-tippy-root]"));
    }

    function ee(e) {
      b.clearDelayTimeouts(), e && O("onTrigger", [b, e]), j();
      var t = P(!0),
          r = T(),
          i = r[0],
          s = r[1];
      vA.isTouch && "hold" === i && s && (t = s), t ? n = setTimeout(function () {
        b.show();
      }, t) : b.show();
    }

    function te(e) {
      if (b.clearDelayTimeouts(), O("onUntrigger", [b, e]), b.state.isVisible) {
        if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && p)) {
          var t = P(!1);
          t ? r = setTimeout(function () {
            b.state.isVisible && b.hide();
          }, t) : i = requestAnimationFrame(function () {
            b.hide();
          });
        }
      } else z();
    }
  }

  function NA(e, t) {
    void 0 === t && (t = {});
    var n = MA.plugins.concat(t.plugins || []);
    document.addEventListener("touchstart", xA, nA), window.addEventListener("blur", wA);
    var r,
        i = Object.assign({}, t, {
      plugins: n
    }),
        s = (r = e, dA(r) ? [r] : function (e) {
      return sA(e, "NodeList");
    }(r) ? uA(r) : Array.isArray(r) ? r : uA(document.querySelectorAll(r))).reduce(function (e, t) {
      var n = t && FA(t, i);
      return n && e.push(n), e;
    }, []);
    return dA(e) ? s[0] : s;
  }

  NA.defaultProps = MA, NA.setDefaultProps = function (e) {
    Object.keys(e).forEach(function (t) {
      MA[t] = e[t];
    });
  }, NA.currentInput = vA, Object.assign({}, OE, {
    effect: function (e) {
      var t = e.state,
          n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow);
    }
  }), NA.setDefaultProps({
    render: DA
  });
  var UA = NA;

  class BA extends vT {
    async _refreshUi() {
      var e;
      if (!(await super._refreshUi())) return !1;
      MT.RemoveAll(BA.PluginType);

      for (const e of this.variations) MT.Create(BA.PluginType, e.title, 5, 20, 0, e.materials.map(t => {
        let n;
        if (e.preview.startsWith("generate:")) n = this._previewGenerator.generate(t, e.preview.split(":")[1]);else {
          const r = t[e.preview] || "#ff00ff";
          n = r.image ? Tt(r.image, 100) : void 0, n || (n = xT(r, !0));
        }
        return {
          id: t.uuid,
          image: n,
          onClick: t => this.applyVariation(e, t),
          tooltip: t.name || t.uuid
        };
      }), (e, t) => UA(e, {
        placement: "bottom",
        content: t.tooltip
      }));

      return MT.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), !0;
    }

  }

  BA.PluginType = "MaterialConfiguratorPlugin";

  class jA extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
        var e, t;
        this.enabled && (null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
      }, this.dependencies = [js], this._selectedObject = () => {
        var e;
        return (null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0;
      }, this._selectedMaterial = () => {
        var e, t;
        return (null === (t = null === (e = this._selectedObject()) || void 0 === e ? void 0 : e.modelObject) || void 0 === t ? void 0 : t.material) || void 0;
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new gT(this._viewer), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }

    async onRemove(e) {
      var t, n;
      return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (n = this._picking) || void 0 === n || n.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e);
    }

    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }

    async _refreshUi() {
      return this._uiNeedRefresh && this.enabled && this._refreshUiConfig(), this._uiNeedRefresh = !1, !1;
    }

  }

  jA.PluginType = "MaterialLibraryBasePlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([Ve("Enabled")], jA.prototype, "enabled", void 0);

  class zA extends jA {
    constructor() {
      super(...arguments), this.replaceMaterial = !1, this.uiConfig = {
        type: "folder",
        label: "Material Library",
        uuid: Be(),
        children: [...Je(this), () => {
          var e;
          return {
            type: "dropdown",
            label: "Apply Material",
            limitedUi: !0,
            hidden: () => !this._selectedObject(),
            children: [{
              label: "select one",
              value: ""
            }, [...(this._viewer.getPlugin(js).materials.getMaterialsOfType(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.typeSlug).map(e => ({
              label: e.name || e.uuid,
              value: e.uuid
            })) || [])]],
            getValue: () => {
              var e;
              return null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid;
            },
            setValue: e => {
              var t, n, r, i, s;
              const o = null === (r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(js)) || void 0 === n ? void 0 : n.materials) || void 0 === r ? void 0 : r.findMaterial(e);
              if (o) if (this.replaceMaterial) null === (s = null === (i = this._selectedObject()) || void 0 === i ? void 0 : i.modelObject) || void 0 === s || s.userData.setMaterial(o);else {
                const e = this._selectedMaterial();

                if (e) {
                  const t = e.name,
                        n = e.uuid;
                  e.copyProps(o), e.name = t, e.uuid = n, e.userData.uuid && (e.userData.uuid = n);
                }
              }

              this._refreshUi();
            }
          };
        }]
      };
    }

    async _refreshUi() {
      var e, t, n, r;
      if (!(await super._refreshUi())) return !1;
      const i = [Ht.TypeSlug, Uo.TypeSlug],
            s = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(js)) || void 0 === t ? void 0 : t.materials,
            o = i.map(e => [e, null == s ? void 0 : s.getMaterialsOfType(e)]);
      MT.RemoveAll(zA.PluginType);

      for (const [e, t] of o) MT.Create(zA.PluginType, e, 5, 20, 0, null === (n = t) || void 0 === n ? void 0 : n.filter(e => !e.userData.__runtimeMaterial).map(e => {
        let t;
        const n = "generate:sphere";
        if (n.startsWith("generate:")) t = this._previewGenerator.generate(e, n.split(":")[1]);else {
          const r = e[n] || "#ff00ff";
          t = r.image ? Tt(r.image, 100) : void 0, t || (t = bT(r, !0));
        }
        return {
          id: e.uuid,
          image: t,
          onClick: e => {
            const t = null == s ? void 0 : s.findMaterial(e);

            if (console.log(null == t ? void 0 : t.name), t) {
              const e = t.userData.appliedMeshes;

              if (null == e ? void 0 : e.size) {
                const t = e.keys().next().value;
                t.dispatchEvent({
                  type: "select",
                  value: t
                });
              }
            }
          },
          tooltip: e.name || e.uuid
        };
      }), (e, t) => UA(e, {
        placement: "bottom",
        content: t.tooltip
      }));

      return MT.RebuildUi(null === (r = this._viewer) || void 0 === r ? void 0 : r.container), !0;
    }

  }

  function VA(e, t, n, r) {
    e.traverse(e => {
      e && (e.userData.cloneRotI = t, e.userData.rotationCount = n, e.userData.rotationAxis = r, e.addEventListener("beforeRender", t => function (e, t) {
        var n;
        t && (null === (n = t.map) || void 0 === n ? void 0 : n.isTexture) && (t.extraUniformsToUpload || (t.extraUniformsToUpload = {}), t.extraUniformsToUpload.uvTransform || (t.extraUniformsToUpload.uvTransform = {
          value: new i.Vkp()
        }), t.extraUniformsToUpload.uvTransform.value.setUvTransform(t.map.offset.x * t.map.repeat.x * e.userData.cloneRotI / (e.userData.rotationCount || 1), t.map.offset.y * t.map.repeat.y * e.userData.cloneRotI / (e.userData.rotationCount || 1), t.map.repeat.x, t.map.repeat.y, t.map.rotation, t.map.center.x, t.map.center.y));
      }(e, t.material)));
    });
  }

  function GA(e, t, n, r = "x") {
    var i;
    if (e.userData.rotationCount > 1 && !e.userData.rotationRoot) return e;
    const s = e.parent;
    if (!s) throw new Error("No parent");

    if (e.userData.cloneParent) {
      const t = e.userData.cloneParent;
      if (e = s.children.find(e => t === e.uuid), !e) return console.error("Couldn't find clone root, cannot rotate. maybe a serialization issue?", t, s), e;
    }

    let o = s.children.filter(t => {
      var n;
      return (null === (n = t.userData) || void 0 === n ? void 0 : n.cloneParent) === e.uuid;
    }).sort((e, t) => e.userData.cloneRotI - t.userData.cloneRotI);
    if (e.userData.rotationCount === t && t === o.length && void 0 === n && e.userData.rotationAxis === r) return e;

    if (null == n && (n = null !== (i = e.userData.rotationSkips) && void 0 !== i ? i : []), n !== e.userData.rotationSkips && (e.userData.rotationSkips = [...n]), VA(e, 0, t, r), e.userData.rotationRoot = !0, e.visible = !0, t <= o.length) {
      for (let e = t - 1; e < o.length; e++) s.remove(o[e]), o[e].traverse(e => e.userData = {
        __disposed: !0
      });

      o = o.slice(0, t);
    }

    for (let i = 1; i < t; i++) {
      const a = i <= o.length ? o[i - 1] : e.clone();
      a.rotation.copy(e.rotation), a.rotation[r] += i / t * Math.PI * 2, VA(a, i, t, r), i > o.length && s.add(a), a.visible = !n.includes(i);
    }

    return e.visible = !n.includes(0), e;
  }

  zA.PluginType = "MaterialLibraryPlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([Ve("Replace Material")], zA.prototype, "replaceMaterial", void 0);

  var HA,
      WA = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let KA = HA = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.rotations = 1, this.axis = "x", this.skips = "", this._selectedObjectChanged = this._selectedObjectChanged.bind(this);
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }

    _selectedObjectChanged() {
      var e, t, n, r, i, s, o, a, l;
      if (!this.enabled) return;
      const c = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
      if (!c) return void (null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
      const u = c.userData.rotationRoot && null !== (i = c.userData.rotationCount) && void 0 !== i ? i : 1;
      this.rotations = u, this.skips = null !== (o = null === (s = c.userData.rotationSkips) || void 0 === s ? void 0 : s.join(",")) && void 0 !== o ? o : "", this.axis = c.userData.rotationAxis || "x", null === (l = (a = this.uiConfig).uiRefresh) || void 0 === l || l.call(a, "postFrame", !0);
    }

    _paramsChanged() {
      var e, t, n, r, s, o;
      if (!this.enabled) return;
      const a = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();

      if (a) {
        if (this.rotations > 1 || a.userData.rotationCount) {
          const e = a.userData.rotationCount,
                t = GA(a, this.rotations, this.skips.split(",").map(e => parseInt(e)).filter(e => isFinite(e)), this.axis),
                o = null == t ? void 0 : t.userData.rotationCount;

          if (o && o !== e) {
            const e = [];
            null == t || t.traverseAncestors(t => {
              e.push(t);
            });

            for (const t of e) if (t.userData.autoScaled) {
              X(t), null === (n = this._viewer) || void 0 === n || n.resetCamera({
                rootObject: t,
                centerOffset: new i.Pa4(4, 4, 4)
              });
              break;
            }
          }

          a.parent && !a.userData.__disposed || null === (s = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("Picking")) || void 0 === s || s.setSelectedObject(t, !0);
        }

        null === (o = this._viewer) || void 0 === o || o.scene.setDirty({
          frameFade: !1,
          sceneUpdate: !0
        });
      }
    }

  };
  KA.PluginType = "ObjectRotationPlugin", WA([xe(), Ve("Enabled"), C(HA.prototype._paramsChanged)], KA.prototype, "enabled", void 0), WA([He("Rotation Count", [1, 100], 1, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations;
    }
  })), C(HA.prototype._paramsChanged)], KA.prototype, "rotations", void 0), WA([Ke("Axis", ["x", "y", "z"].map(e => ({
    label: e
  })), e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations;
    }
  })), C(HA.prototype._paramsChanged)], KA.prototype, "axis", void 0), WA([qe("Rotation Skips", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations;
    }
  })), C(HA.prototype._paramsChanged)], KA.prototype, "skips", void 0), KA = HA = WA([Qe("Object Rotations")], KA);

  var XA,
      qA = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let YA = XA = class extends zs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.debugNormals = !1, this.debugHitHeight = !1, this._defines = {
        PARALLAX_NORMAL_MAP_QUALITY: 0
      }, this.stepCount = 12, this.binaryStepCount = 3, this._bumpMapExtension = {
        shaderExtender: (e, t, n) => {
          if (t.materialObject.bumpMap && this.enabled) {
            e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_begin>", ""), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", ""), e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", "#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <map_fragment>");

            for (const t of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"]) e.fragmentShader = e.fragmentShader.replace(`#include <${t}>`, i.WdD[t].replace("vUv", "parallaxUv.xy"));

            (this.debugNormals || this.debugHitHeight) && (e.fragmentShader = e.fragmentShader.replace("texture2D( map, parallaxUv.xy )", this.debugNormals ? "vec4(normal, 1.); normal = geometryNormal" : "vec4(parallaxUv.z,0., 0., 1.)")), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", i.WdD.normal_fragment_maps.replace("#elif defined( TANGENTSPACE_NORMALMAP )", "#elif defined( TANGENTSPACE_NORMALMAP ) && !defined( USE_BUMPMAP )").replace("normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );", "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"));
          }
        },
        parsFragmentSnippet: () => this.enabled ? "#ifdef USE_BUMPMAP\nmat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.,1.);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){\n#if defined( TANGENTSPACE_NORMALMAP ) && 0 \nvec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);\n#else\nvec2 texOffs=1./bumpMapSize;\n#if PARALLAX_NORMAL_MAP_QUALITY > 0\nfloat hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,-1.)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,-1.)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,1.)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,1.)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.*(hx[1]-hx[7])+hx[2]-hx[8]);\n#else\nfloat h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);\n#endif\nreturn normalize(vec3(deltaH/texOffs,1.));\n#endif\n}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.;float bumpHeightStep=1./float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}\n#pragma unroll_loop_end\nbestBumpHeight+=bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)?bumpHeightStep:0.;}\n#pragma unroll_loop_end\nbestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.,1.);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vUv,0.);float parallaxHeight;vec2 texCoords=vUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vUv);vec2 duv2=dFdy(vUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\nreturn parallaxUv;}\n#endif \n\n".replaceAll("PARALLAX_MAP_STEPS", this._defines.PARALLAX_MAP_STEPS).replaceAll("PARALLAX_MAP_B_STEPS", this._defines.PARALLAX_MAP_B_STEPS) : "",
        isCompatible: e => e.isMeshStandardMaterial2,
        computeCacheKey: e => {
          var t;
          return this.enabled + " " + (null === (t = e.materialObject.bumpMap) || void 0 === t ? void 0 : t.uuid) + " " + this.debugNormals + " " + this.debugHitHeight + "  ";
        },
        onObjectRender: (e, {
          materialObject: t
        }, n) => {
          for (const [e, n] of Object.entries(this._defines)) {
            const r = "number" == typeof n ? n : n ? 1 : 0;
            t.defines[e] !== r && (t.defines[e] = r, t.needsUpdate = !0);
          }
        }
      }, this.dependencies = [js], this.enabled = e, this._updateExtension = this._updateExtension.bind(this);
    }

    _updateExtension() {
      var e, t, n;
      null === (t = null === (e = this._bumpMapExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty();
    }

    async onAdded(e) {
      var t, n;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.registerMaterialExtension(this._bumpMapExtension), super.onAdded(e);
    }

    async onRemove(e) {
      var t, n;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this._bumpMapExtension), super.onRemove(e);
    }

  };
  YA.PluginType = "ReliefParallaxMapping", qA([C(XA.prototype._updateExtension), Ve("Enabled")], YA.prototype, "enabled", void 0), qA([C(XA.prototype._updateExtension), Ve("Debug Normals")], YA.prototype, "debugNormals", void 0), qA([C(XA.prototype._updateExtension), Ve("Debug Hit Height")], YA.prototype, "debugHitHeight", void 0), qA([G("PARALLAX_MAP_STEPS", void 0, !0, XA.prototype._updateExtension), He("Step count", [1, 32], 1), xe()], YA.prototype, "stepCount", void 0), qA([G("PARALLAX_MAP_B_STEPS", void 0, !0, XA.prototype._updateExtension), He("Binary search steps", [1, 8], 1), xe()], YA.prototype, "binaryStepCount", void 0), YA = XA = qA([Qe("Parallax Mapping")], YA);

  class ZA extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this.dependencies = [js], this.variations = [], this._selectedSwitchNode = () => {
        var e;
        const t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject();
        if (!t) return;
        const n = this.variations.map(e => e.name);
        let r;
        return t.traverseAncestors(e => {
          r || n.includes(e.name) && (r = e);
        }), r;
      }, this.uiConfig = {
        label: "Switch Node",
        type: "folder",
        children: [() => [{
          type: "folder",
          label: "All nodes",
          expanded: !0,
          children: [this.variations.map(e => ({
            type: "input",
            label: e.title,
            property: [e, "name"],
            onChange: () => this.refreshUi()
          }))]
        }, {
          type: "button",
          label: "Add Node",
          value: () => {
            this.variations.push({
              name: "switch_node",
              selected: "",
              title: "Switch Node",
              camView: "front",
              camDistance: 1
            }), this.refreshUi();
          }
        }, {
          type: "button",
          label: "Refresh UI",
          value: () => this.refreshUi()
        }, {
          type: "input",
          label: "Selected node title",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();

            return e ? [this.variations.find(t => t.name === e.name), "title"] : [];
          },
          onChange: () => this.refreshUi()
        }, {
          type: "slider",
          bounds: [.01, 2],
          stepSize: .01,
          label: "Cam Distance",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();

            return e ? [this.variations.find(t => t.name === e.name), "camDistance"] : [];
          }
        }, {
          type: "dropdown",
          label: "Cam View",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();

            return e ? [this.variations.find(t => t.name === e.name), "camView"] : [];
          },
          onChange: () => this.refreshUi(),
          children: ["top", "bottom", "front", "back", "left", "right"].map(e => ({
            label: e,
            value: e
          }))
        }]]
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", () => {
        var e, t;
        null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e);
      }), e.addEventListener("postFrame", () => {
        this._uiNeedRefresh && this._refreshUi();
      }), e.addEventListener("preRender", () => {
        if (this._viewer) for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);

          if (!t || t.children.length < 1) return;
          e.selected || (e.selected = t.children[0].name || t.children[0].uuid);

          for (const n of t.children) n.visible = (n.name || n.uuid) === e.selected;
        }
      }), e.addEventListener("postRender", () => {
        if (this._viewer) for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);

          if (!t || t.children.length < 1) return;

          for (const e of t.children) e.visible = !0;
        }
      }), this.addEventListener("deserialize", async () => {
        await uc(200), this.refreshUi();
      });
    }

    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }

    _refreshUi() {
      var e, t, n;

      if (this.enabled && this._viewer) {
        this._uiNeedRefresh = !1, MT.RemoveAll(ZA.PluginType);

        for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);

          t ? (t.children.length < 1 && console.warn("SwitchNode does not have enough children", e), MT.Create(ZA.PluginType, e.title, Math.min(5, t.children.length), 20, 0, t.children.map(t => {
            const n = e.camView,
                  r = new i.Pa4((n.includes("right") ? 1 : 0) - (n.includes("left") ? 1 : 0), (n.includes("top") ? 1 : 0) - (n.includes("bottom") ? 1 : 0), (n.includes("front") ? 1 : 0) - (n.includes("back") ? 1 : 0));
            e.camDistance || (e.camDistance = 1);
            const s = mT(this._viewer, t, void 0, 7, r.multiplyScalar(.5 * e.camDistance));
            return {
              id: t.uuid,
              image: s,
              onClick: () => {
                var n;
                e.selected = t.name || t.uuid, null === (n = this._viewer) || void 0 === n || n.scene.setDirty({
                  sceneUpdate: !0,
                  frameFade: !0
                });
              },
              tooltip: t.name || t.uuid
            };
          }), (e, t) => UA(e, {
            placement: "bottom",
            content: t.tooltip
          }))) : console.warn("no object found for variation, skipping", e);
        }

        MT.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t);
      }
    }

  }

  ZA.PluginType = "SwitchNodePlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe()], ZA.prototype, "variations", void 0);

  class JA extends i.u9r {
    constructor(e, t, n = 32, r = 64, s = !1, o = new i.FM8(1, 1), a = "shape") {
      super(), this.type = "TubeShapeGeometry", this.parameters = {
        path: t,
        shape: e,
        shapeSegments: n,
        tubularSegments: r,
        closed: s,
        primary: a,
        shapeScale: o.clone()
      };
      const l = t.computeFrenetFrames(r, s);
      this.frames = l;
      const c = new i.Pa4(),
            u = new i.Pa4(),
            p = new i.Pa4(),
            h = new i.FM8();
      let d = new i.Pa4();
      const f = [],
            _ = [],
            m = [],
            g = e.getSpacedPoints(n);

      for (const e of g) e.multiply(o);

      !function () {
        for (let e = 0; e < r; e++) b(e);

        b(!1 === s ? r : 0), function () {
          for (let e = 0; e <= r; e++) for (let t = 0; t <= n; t++) h.x = e / r, h.y = t / n, _.push(h.x, h.y);
        }(), function () {
          const e = "shape" === a,
                t = e ? n : r,
                i = e ? r : n;

          for (let r = 1; r <= t; r++) for (let t = 1; t <= i; t++) {
            const [i, s] = e ? [t, r] : [r, t],
                  o = (n + 1) * (i - 1) + (s - 1),
                  a = (n + 1) * i + (s - 1),
                  l = (n + 1) * i + s,
                  c = (n + 1) * (i - 1) + s;
            m.push(o, a, c), m.push(a, l, c);
          }
        }();
      }(), this.setIndex(m), this.setAttribute("position", new i.a$l(f, 3)), this.setAttribute("uv", new i.a$l(_, 2)), this.computeVertexNormals();
      const v = this.attributes.normal;

      function b(e) {
        d = t.getPointAt(e / r, d);
        const i = l.normals[e],
              s = l.binormals[e];

        for (let e = 0; e <= n; e++) {
          const t = g[e % n];
          u.set(0, 0, 0).addScaledVector(i, t.x).addScaledVector(s, t.y), c.copy(d).add(u), f.push(c.x, c.y, c.z);
        }
      }

      !function () {
        for (let e = 1; e < n; e++) {
          const t = e + r * (n + 1);
          u.fromBufferAttribute(v, e), p.fromBufferAttribute(v, t), u.add(p).normalize(), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(t, u.x, u.y, u.z);
        }

        for (let e = 1; e < r; e++) {
          const t = e * (n + 1),
                r = t + n;
          u.fromBufferAttribute(v, t), p.fromBufferAttribute(v, r), u.add(p).normalize(), v.setXYZ(t, u.x, u.y, u.z), v.setXYZ(r, u.x, u.y, u.z);
        }

        u.fromBufferAttribute(v, 0), p.fromBufferAttribute(v, n), u.add(p);
        const e = r * (n + 1);
        p.fromBufferAttribute(v, e), u.add(p), p.fromBufferAttribute(v, e + n), u.add(p), u.normalize(), v.setXYZ(0, u.x, u.y, u.z), v.setXYZ(n, u.x, u.y, u.z), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(e + n, u.x, u.y, u.z), v.needsUpdate = !0;
      }();
    }

    createSplits(e) {
      this.clearGroups();
      const t = "shape" === this.parameters.primary ? this.parameters.shapeSegments : this.parameters.tubularSegments,
            n = this.index.count,
            r = [...e, 1].sort();
      let i = 0,
          s = 0;

      for (const e of r) {
        const r = Math.round(t * e) * n / t;
        this.addGroup(i, r - i, s++), i = r;
      }

      return this.groups.length;
    }

    toJSON() {
      const e = super.toJSON();
      return e.path = this.parameters.path.toJSON(), e.shape = this.parameters.shape.toJSON(), e;
    }

  }

  var $A,
      QA = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let eC = $A = class extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this.shapeSegments = 32, this.tubularSegments = 32, this.shapeScale = new i.FM8(1, 1), this.materialSplits = "0.3, 0.6", this.horizontalSplits = !0, this.extrudeCirceTube = async () => {
        var e, t;
        const n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(gc)) || void 0 === t ? void 0 : t.getSelectedObject();
        if (!n) return;
        let r = prompt("Radius", "1");
        if (!r) return;
        r = parseFloat(r);
        const i = new tC(0, 0, r, r, 0, 2 * Math.PI, !0, 0);
        await this.extrudeObject(n, i);
      };
    }

    async onAdded(e) {
      await super.onAdded(e);
    }

    static CreateCurve(e, t) {
      var n, r;
      if ("circle" === e) return new tC(0, 0, null !== (n = t.radius) && void 0 !== n ? n : 1, null !== (r = t.radius) && void 0 !== r ? r : 1, 0, 2 * Math.PI, !0, 0);
      throw new Error("Unknown curve type");
    }

    async extrudeObject(e, t, n = this.shapeSegments, r = this.tubularSegments, s = this.shapeScale, o = this.materialSplits.split(",").map(e => parseFloat(e.trim())), a = this.horizontalSplits) {
      var l, c, u, p, h, d;

      if (e.userData.isExtrudedTube, e.userData._extrudeSource) {
        const t = e.userData._extrudeSource;
        if (e = null === (l = e.parent) || void 0 === l ? void 0 : l.children.find(e => t === e.uuid), !e) return void console.warn("Could not find extrude source with uuid", t);
      }

      if (e.userData.extrudedObject) {
        const t = e.userData.extrudedObject,
              n = null === (c = e.parent) || void 0 === c ? void 0 : c.children.find(e => t === e.uuid);
        n && (n.removeFromParent(), n.geometry.dispose(), n.geometry = null, n.material = null), delete e.userData.extrudedObject;
      }

      const f = e.geometry;
      if (!f) return void alert("no geometry to extrude");
      const _ = [e.material];
      let m;

      try {
        const e = $A.ConvertGeometryToFlatShape(f);
        m = new JA(e, t, n, r, !0, s, a ? "shape" : "path"), m.computeBoundingBox(), m.createSplits(o);
      } catch (e) {
        return void alert("string" == typeof e ? e : null == e ? void 0 : e.message);
      }

      _[0].color.set(16777215);

      for (let e = _.length; e < m.groups.length; e++) {
        const e = _[0].clone();

        _.push(e), e.color.set(16777215 * Math.random());
      }

      const g = new i.Kj0(m, _);
      g.userData._extrudeSource = e.uuid, g.userData.isExtrudedTube = !0, e.visible = !1, e.userData.bboxVisible = !1, g.name = e.name + "_extruded";
      const v = at(g),
            b = await (null === (h = null === (p = null === (u = this._viewer) || void 0 === u ? void 0 : u.getManager()) || void 0 === p ? void 0 : p.importer) || void 0 === h ? void 0 : h.processImportedSingle(v, {
        pseudoCenter: !1,
        autoScale: !1
      }));
      b && (null === (d = e.parent) || void 0 === d || d.add(b.modelObject), e.userData.extrudedObject = b.modelObject.uuid, b.dispatchEvent({
        type: "select",
        ui: !0,
        value: b
      }));
    }

    static ExtrudeShape(e, t, n, r, s, o, a, l) {
      const c = new JA(e, r, t, n, !0, new i.FM8(s, o), l ? "shape" : "path");
      c.computeBoundingBox(), c.createSplits(a);
      const u = at(new i.Kj0(c, []));
      return u.userData.isExtrudedTube = !0, u;
    }

    static ConvertGeometryToFlatShape(e, t = !0) {
      if (e.userData.__planarShape) return e.userData.__planarShape;
      let n = e.attributes.position;
      if (!n) throw "no position attribute";
      if (n.count > 500) throw "too large to extrude";
      const r = e;
      n = r.attributes.position, r.boundingBox || r.computeBoundingBox();
      const s = r.boundingBox.getSize(new i.Pa4()),
            o = s.x < .001 ? "x" : s.y < .001 ? "y" : s.z < .001 ? "z" : null;
      if (!o) throw "geometry is not axis aligned not planar";
      let a = [];

      for (let e = 0; e < n.count; e++) {
        const t = new i.FM8();
        "x" === o ? t.set(n.getY(e), n.getZ(e)) : "y" === o ? t.set(n.getX(e), n.getZ(e)) : t.set(n.getX(e), n.getY(e)), a.push(t);
      }

      if (t) {
        let e = 0;

        for (let t = 0; t < a.length; t++) (a[t].x < a[e].x || a[t].x === a[e].x && a[t].y < a[e].y) && (e = t);

        0 !== e && (a = a.slice(e).concat(a.slice(0, e)));
      }

      const l = new i.bnF(a);
      return e.userData.__planarShape = l, l;
    }

  };
  eC.PluginType = "ShapeTubeExtrudePlugin", QA([Ve("Enabled")], eC.prototype, "enabled", void 0), QA([He("Shape Segments (X)", [1, 100], 1, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], eC.prototype, "shapeSegments", void 0), QA([He("Tube Segments (Y)", [1, 100], 1, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], eC.prototype, "tubularSegments", void 0), QA([We("Shape scale", [.01, 10], .01, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], eC.prototype, "shapeScale", void 0), QA([qe("Material Splits", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], eC.prototype, "materialSplits", void 0), QA([Ve("Horizontal Splits", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], eC.prototype, "horizontalSplits", void 0), QA([Xe("Extrude Circle Tube", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(gc)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], eC.prototype, "extrudeCirceTube", void 0), eC = $A = QA([Qe("Extrude Tube Shapes")], eC);

  class tC extends i.Ny0 {
    getPoint(e, t) {
      return super.getPoint(e, t || new i.Pa4());
    }

  }

  class nC extends zs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.toJSON = void 0, this.fromJSON = void 0, this._lastFrameTime = 0, this._updaters = [], this.dependencies = [], this._fadeDisabled = !1, this.disableFrameFade = !0, this._postFrame = () => {
        var e, t;
        if (!this._viewer) return;
        if (!this.enabled || Object.keys(this.animations).length < 1) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(nC.PluginType), this._fadeDisabled = !1));
        const n = At() / 1e3;
        this._lastFrameTime < 1 && (this._lastFrameTime = n - 1 / 60);
        let r = n - this._lastFrameTime;
        this._lastFrameTime = n;
        const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();

        if (i && i > 0 && (r = i), 0 !== i && (r *= 1e3, !(r <= .001) && (this._updaters.forEach(e => {
          let t = r;
          e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t);
        }), !this._fadeDisabled && this.disableFrameFade))) {
          const e = this._viewer.getPluginByType("FrameFade");

          e && (e.disable(nC.PluginType), this._fadeDisabled = !0);
        }
      }, this.defaultDriver = e => ({
        start: () => this._updaters.push({
          u: e,
          time: 0
        }),
        stop: () => this._updaters.splice(this._updaters.findIndex(t => t.u === e), 1)
      }), this.animations = {}, this.enabled = e, this._postFrame = this._postFrame.bind(this);
    }

    async onAdded(e) {
      await super.onAdded(e), e.addEventListener("postFrame", this._postFrame);
    }

    async onRemove(e) {
      return e.removeEventListener("postFrame", this._postFrame), super.onRemove(e);
    }

    animate(e) {
      const t = Be(),
            n = {
        id: t,
        options: e,
        stop: () => {
          var e, n, r;
          (null === (e = this.animations[t]) || void 0 === e ? void 0 : e._stop) ? null === (r = null === (n = this.animations[t]) || void 0 === n ? void 0 : n._stop) || void 0 === r || r.call(n) : console.warn("Animation not started");
        }
      };
      return this.animations[t] = n, n.promise = new Promise((n, r) => {
        const i = {
          driver: this.defaultDriver,
          onComplete: () => {
            var t;
            null === (t = e.onComplete) || void 0 === t || t.call(e), n();
          },
          onStop: () => {
            var t;
            null === (t = e.onStop) || void 0 === t || t.call(e), n();
          },
          ...e
        },
              s = lc(i);
        this.animations[t]._stop = s.stop, this.animations[t].options = i;
      }).then(() => (delete this.animations[t], t)), this.animations[t];
    }

    async animateAsync(e) {
      return this.animate(e).promise;
    }

  }

  nC.PluginType = "PopmotionPlugin";

  const rC = async e => vt(await (await fetch(e)).blob());

  async function iC(e, t = rC) {
    const n = e.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
    if (n) for (const r of n) {
      const n = await t(r);
      e = e.replace(r, n);
    }
    return e;
  }

  function sC(e, t, {
    width: n,
    height: r
  }, i = !0) {
    const s = `\n<svg viewBox="0 0 ${n} ${r}" xmlns="http://www.w3.org/2000/svg">\n    <style>\n    ${t}\n    </style>\n    <foreignObject x="0" y="0" width="100%" height="100%">\n        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">\n            ${e}\n        </div>\n    </foreignObject>\n</svg>\n    `;
    return i ? A(s) : s;
  }

  async function oC(e, t, n) {
    const r = sC(e, t, n);
    return await wT(r, n);
  }

  async function aC(e, t, n) {
    const r = sC(e, t, n);
    return await ST(r, n);
  }

  var lC,
      cC,
      uC = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const pC = e => ({
    onChange: t => {
      t.last && e.onChange();
    }
  });

  let hC = lC = class {
    constructor() {
      this.text = "Custom Text", this.fontSize = 100, this.width = 1024, this.height = 1024, this.xOffset = 0, this.yOffset = 0, this.boxWidth = 1024, this.boxHeight = 1024, this.fontFamily = "", this.fontPath = "", this.maskText = !1, this.innerShadow = !1, this.textColor = "#000000", this.bgFillColor = "#ffffff", this.svgBackground = "#ffffff", this.onChange = () => {};
    }

    set(e) {
      Object.assign(this, e);
    }

    reset() {
      const e = this.onChange;
      Object.assign(this, new lC()), this.onChange = e;
    }

    toJSON() {
      return {
        text: this.text,
        fontFamily: this.fontFamily,
        fontPath: this.fontPath,
        svgBackground: this.svgBackground,
        width: this.width,
        height: this.height,
        xOffset: this.xOffset,
        yOffset: this.yOffset,
        boxWidth: this.boxWidth,
        boxHeight: this.boxHeight,
        fontSize: this.fontSize,
        maskText: this.maskText,
        innerShadow: this.innerShadow,
        bgFillColor: this.bgFillColor,
        textColor: this.textColor
      };
    }

  };
  uC([qe("Text", pC)], hC.prototype, "text", void 0), uC([He("Font Size", [2, 400], 1, pC)], hC.prototype, "fontSize", void 0), uC([He("Width", [2, 4096], 1, pC)], hC.prototype, "width", void 0), uC([He("Height", [2, 4096], 1, pC)], hC.prototype, "height", void 0), uC([He("X Offset", [-1024, 1024], 1, pC)], hC.prototype, "xOffset", void 0), uC([He("Y Offset", [-1024, 1024], 1, pC)], hC.prototype, "yOffset", void 0), uC([He("V-Width", [2, 4096], 1, pC)], hC.prototype, "boxWidth", void 0), uC([He("V-Height", [2, 4096], 1, pC)], hC.prototype, "boxHeight", void 0), uC([qe("Font", pC)], hC.prototype, "fontFamily", void 0), uC([qe("Font Url", pC)], hC.prototype, "fontPath", void 0), uC([Ve("Mask Text", pC)], hC.prototype, "maskText", void 0), uC([Ve("Inner Shadow", pC)], hC.prototype, "innerShadow", void 0), uC([Ye("Text Color", pC)], hC.prototype, "textColor", void 0), uC([Ye("BG Fill", pC)], hC.prototype, "bgFillColor", void 0), uC([Ye("SVG BG", pC)], hC.prototype, "svgBackground", void 0), hC = lC = uC([Qe("Text SVG Options")], hC);

  const dC = {
    woff: "woff",
    woff2: "woff2",
    ttf: "truetype",
    otf: "opentype",
    eot: "embedded-opentype"
  },
        fC = e => ({
    hidden: () => {
      const t = e.getSelected();
      return !t || !t.userData[_C.PluginType];
    }
  });

  let _C = cC = class extends zs {
    constructor() {
      super(), this.enabled = !0, this.getSelected = () => {
        var e, t;
        return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
      }, this.options = new hC(), this.applyToMap = !0, this.applyToBumpMap = !1, this.applyToAlphaMap = !0, this.inverseAlphaMap = !1, this._lastMeta = void 0, this.fonts = {
        roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2"
      }, this._assetLoadOptions = void 0, this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this.addTextToSelected = this.addTextToSelected.bind(this), this._paramsChanged = this._paramsChanged.bind(this), this.options.onChange = this._paramsChanged;
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }

    _selectedObjectChanged() {
      var e, t, n, r, i, s;
      if (!this.enabled) return;
      const o = this.getSelected();
      if (!o) return void (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
      const a = o.userData[cC.PluginType];
      if (!a) return this.options.reset(), this._lastMeta = void 0, void (null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
      this._lastMeta !== a && (this.options.set(a), this._lastMeta = a), null === (s = (i = this.uiConfig).uiRefresh) || void 0 === s || s.call(i, "postFrame", !0);
    }

    _paramsChanged() {
      if (!this.enabled) return;
      const e = this.getSelected();
      e && e.isMesh && e.userData[cC.PluginType] && this.updateText(e, this.options.toJSON());
    }

    addTextToSelected() {
      const e = this.getSelected();
      if (e && e.isMesh) {
        if (e.material) {
          if (e.userData[cC.PluginType] || !e.material.map || confirm("This mesh already has a texture. Adding text will replace the texture. Continue?")) return this.addText(e);
        } else console.error("no material on mesh");
      } else console.error("no mesh is selected");
    }

    async addText(e, t) {
      return this.updateText(e, Object.assign(this.options.toJSON(), t));
    }

    async updateText(e, t) {
      var n, r;
      if (!e.isMesh) return;
      if (!e.material) return void console.error("updateText: no material on mesh");
      let i = e.userData[cC.PluginType];
      i || (e.userData[cC.PluginType] = i = {}), Object.assign(i, t);
      const s = e.material;
      s.map && (s.map._isSimpleTextTexture && s.map.dispose(), s.map = void 0), s.alphaMap && (s.alphaMap._isSimpleTextTexture && s.alphaMap.dispose(), s.alphaMap = void 0), s.bumpMap && (s.bumpMap._isSimpleTextTexture && s.bumpMap.dispose(), s.bumpMap = void 0);
      const o = await this.makeTextSvg(i);
      this.applyToMap && (s.map = o), this.applyToAlphaMap && (s.alphaMap = o, s.transparent = !0), this.applyToBumpMap && (s.bumpMap = o), s.userData.inverseAlphaMap = this.inverseAlphaMap, s.userData.setDirty(), s.needsUpdate = !0, null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0);
    }

    async makeTextSvg(e) {
      const t = e.fontFamily || "Arial",
            n = e.fontPath || this.fonts[t] || "";
      let r = e.style;

      if (n.length > 0) {
        const e = n.split("?")[0].split(".").pop() || "woff";
        r += "\n" + (n.length > 0 ? `\n            @font-face {\n                font-family: ${t};\n                src: url(${n}) format(${dC[e] || e});\n            }` : "");
      }

      let s = function ({
        text: e = "Custom Text",
        svgBackground: t = "#ffffff",
        xOffset: n = 0,
        yOffset: r = 0,
        width: i = 1024,
        height: s = 1024,
        boxWidth: o = 1024,
        boxHeight: a = 1024,
        fontFamily: l = "",
        fontSize: c = 32,
        maskText: u = !0,
        innerShadow: p = !0,
        bgFillColor: h = "#000000",
        textColor: d = "#ffffff",
        style: f = ""
      }) {
        return `\n<svg style="background-color:${t}" width="${i}" height="${s}" viewBox="0 0 ${o} ${a}"\n xmlns="http://www.w3.org/2000/svg"\n xmlns:xlink="http://www.w3.org/1999/xlink">\n     <defs>\n        <style>\n        ${f}\n        </style>\n    </defs>\n\n    <g style="overflow:hidden; text-anchor: middle; font-size: ${c}px; font-family: ${l || "Arial"}">\n        <defs>\n\n` + (u ? `\n<mask id="textMask">\n<text style="fill:white; font-size: ${c}px;" x="${n + o / 2}" y="${a / 2 + r + c / 4}" > ${e} </text>\n</mask>\n` : "") + "\n\n" + (p ? '\n<filter id="innerShadow" x="-20%" y="-20%" width="140%" height="140%">\n<feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>\n<feOffset in="blur" dx="1.5" dy="1.5"/>\n</filter>\n' : "") + "\n\n        </defs>\n\n" + (u ? '\n        <g mask="url(#textMask)">\n' : "") + `\n\n        <rect x="0" y="0" width="${o}" height="${a}" style="fill:${h}"/>\n        <text style="${p ? "filter: url(#innerShadow);" : ""} fill:${d};" x="${n + o / 2}" y="${a / 2 + r + c / 4}"> ${e} </text>\n\n` + (u ? "\n        </g>\n" : "") + "\n\n    </g>\n</svg>\n";
      }({ ...e,
        fontFamily: t,
        style: r
      });

      s = await iC(s, async e => this._getAssetData(e)), s = A(s);
      const o = await this._viewer.getManager().importer.importSinglePath(s, {
        generateMipmaps: !1,
        minFilter: i.wem
      });
      return o._isSimpleTextTexture = !0, o.flipY = !1, o.needsUpdate = !0, o;
    }

    async _getAssetData(e) {
      var t, n;
      if (e.startsWith("http://www.w3.org")) return e;
      const r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getManager()) || void 0 === n ? void 0 : n.importer;
      if (!r) throw new Error("no importer");
      this._assetLoadOptions = this._assetLoadOptions || {
        fileHandler: new mx(r.loadingManager),
        processImported: !1
      };

      try {
        return await r.importPath(e, this._assetLoadOptions);
      } catch (e) {
        return console.error(e), "";
      }
    }

  };

  _C.PluginType = "SimpleTextPlugin", uC([ze(void 0, {
    params: fC
  })], _C.prototype, "options", void 0), uC([Ve("Apply Map", fC), C(cC.prototype._paramsChanged)], _C.prototype, "applyToMap", void 0), uC([Ve("Apply Bump Map", fC), C(cC.prototype._paramsChanged)], _C.prototype, "applyToBumpMap", void 0), uC([Ve("Apply Alpha Map", fC), C(cC.prototype._paramsChanged)], _C.prototype, "applyToAlphaMap", void 0), uC([Ve("Invert Alpha Map", fC), C(cC.prototype._paramsChanged)], _C.prototype, "inverseAlphaMap", void 0), uC([Xe("Add Text", e => ({
    hidden: () => !e.getSelected()
  }))], _C.prototype, "addTextToSelected", null), _C = cC = uC([Qe("Simple Text")], _C);

  var mC = __webpackgi_require__(819);

  class gC {
    static _initialize() {
      this._inited = !0, St(T`
          #customContextMenu {
            background: #2c2c2e99;
            backdrop-filter: blur(8px);
            border: 0.5px solid rgba(20, 20, 20, 0.3);
            width: auto;
            height: auto;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 9999;
            padding: 0.35rem 0.20rem;
            border-radius: 0.375rem;
            min-width: 6rem;
            pointer-events: auto;
            box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);
          }

          .customContextMenuItems {
            color: white;
            font-size: 0.65rem;
            font-family: "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
            background-color: transparent;
            cursor: pointer;
            padding: 0.12rem 0.35rem;
            border-radius: 0.25rem;
            line-height: 1rem;
            font-weight: 500;
          }

          .customContextMenuItems:hover {
            color: white;
            background-color: #017AFF;
          }
        `), document.addEventListener("mouseup", e => {
        this.Element && !this.Element.contains(e.target) && this.Remove();
      });
    }

    static Create(e, t, n) {
      this._inited || this._initialize(), this.Element && this.Remove();
      const r = yt({
        id: "customContextMenu",
        addToBody: !1
      });
      r.style.top = n + "px", r.style.left = t + "px";

      for (const [t, n] of Object.entries(e)) {
        const e = yt({
          classList: ["customContextMenuItems"],
          addToBody: !1,
          innerHTML: t
        });
        r.appendChild(e), e.onclick = n;
      }

      return this.Element = r, r;
    }

    static Remove() {
      var e;
      null === (e = this.Element) || void 0 === e || e.remove(), this.Element = void 0;
    }

  }

  gC.Element = void 0, gC._inited = !1;

  var vC = __webpackgi_require__(665);

  const bC = (e, t, n) => {
    var r, i, s;

    const o = e.controller_,
          a = null === (i = null === (r = o.parent) || void 0 === r ? void 0 : r.children) || void 0 === i ? void 0 : i.indexOf(o),
          l = ((e, t) => t.controller_.rackController.rack === e.controller_.parent)(e, t);

    return !(l && a === n || (void 0 !== a && a >= 0 && (null === (s = o.parent) || void 0 === s || s.remove(e)), t.add(e, n), 0));
  },
        xC = (e, t, n, r) => {
    var i, s, o, a, l;
    let c = t.uiRef;
    const u = null == c ? void 0 : c.expanded;
    if (c || (c = e.addFolder({
      title: ""
    }), c.on("fold", e => {
      var n, r, i;
      let s = c.expanded;
      g(t, "expanded", s, !0), s = null !== (n = x(t.expanded)) && void 0 !== n ? n : s, s !== c.expanded && (c.expanded = s), null === (r = t.uiRefresh) || void 0 === r || r.call(t, "postFrame", !0), s && (null === (i = t.onExpand) || void 0 === i || i.call(t, t));
    })), !c) return c;
    c.expanded = null !== (s = null !== (i = x(t.expanded)) && void 0 !== i ? i : u) && void 0 !== s && s;
    const p = (null !== (o = t.children) && void 0 !== o ? o : []).map(e => e && x(e)).flat(2).filter(e => e);
    let h = 0;

    for (const e of p) {
      let t = e.uiRef;
      t && t.controller_.viewProps.get("disposed") && (e.uiRef = void 0), t = e.uiRef, t || (n.appendUiObject({
        uiConfig: e
      }, c), t = e.uiRef), t && bC(t, c, h++) && n.appendUiObject({
        uiConfig: e
      }, c);
    }

    let d = c.children;

    for (; d.length > h;) {
      const e = d[d.length - 1];
      c.remove(e), d = c.children;
    }

    c.controller_.props.set("title", null !== (a = x(t.label)) && void 0 !== a ? a : "");

    const f = c.controller_.view.containerElement,
          _ = x(t.domChildren, []);

    if (void 0 !== (null == _ ? void 0 : _.length)) {
      const e = [];

      for (let t = 0; t < f.children.length; t++) {
        const n = f.children[t];
        (null === (l = n.dataset) || void 0 === l ? void 0 : l.tpCustomDOM) && e.push(n);
      }

      for (const t of e) f.removeChild(t);

      for (const e of _) e.parentElement !== f && (f.appendChild(e), e.dataset.tpCustomDOM = "true");

      c.controller_.foldable.cleanUpTransition();
    }

    return c;
  },
        yC = (e, t, n, r) => {
    var i, s;
    const [o, a] = null !== (i = t.property) && void 0 !== i ? i : [void 0, void 0],
          l = null !== (s = x(t.label)) && void 0 !== s ? s : a;
    let c = t.uiRef;
    return c || (c = e.addButton({
      title: ""
    }), c.on("click", () => {
      var e;
      const r = null !== (e = o && a ? o[a] : void 0) && void 0 !== e ? e : t.value;

      if ("function" == typeof r) {
        const e = () => {
          n.removeEventListener("postFrame", e), r();
        };

        n.addEventListener("postFrame", e);
      } else console.warn("Invalid action type for button");
    })), c && (c.title = null != l ? l : "click me"), c;
  },
        wC = (e, t, n, r) => {
    var i;
    const s = Object.fromEntries((null !== (i = x(t.children)) && void 0 !== i ? i : []).map(e => x(e)).flat(2).filter(e => e).map(e => {
      var t;
      const n = x(e.label);
      return [n, null !== (t = e.value) && void 0 !== t ? t : n];
    }));
    return EC(e, t, n, {
      options: s,
      ...(null != r ? r : {})
    });
  },
        SC = (e, t, n, r) => {
    var i, s, o, a;
    const l = (null !== (s = null === (i = t.bounds) || void 0 === i ? void 0 : i.length) && void 0 !== s ? s : 0) >= 2 ? t.bounds[1] : 1,
          c = (null !== (a = null === (o = t.bounds) || void 0 === o ? void 0 : o.length) && void 0 !== a ? a : 0) >= 1 ? t.bounds[0] : 0,
          u = t.stepSize || void 0;
    return EC(e, t, n, {
      min: c,
      max: l,
      step: u,
      ...(null != r ? r : {})
    });
  },
        MC = (e, t, n, r) => {
    var s, o, a;
    if (!t.bounds || t.bounds.length < 1) return EC(e, t, n, { ...(null != r ? r : {})
    });
    const l = (null !== (s = t.bounds.length) && void 0 !== s ? s : 0) >= 2 ? t.bounds[1] : 1,
          c = (null !== (o = t.bounds.length) && void 0 !== o ? o : 0) >= 1 ? t.bounds[0] : 0,
          u = {
      min: c,
      max: l,
      step: null !== (a = t.stepSize) && void 0 !== a ? a : (l - c) / 100
    },
          p = {
      x: u,
      y: u
    };
    "vec3" !== t.type && "vec4" !== t.type || (p.z = u), "vec4" === t.type && (p.w = u);
    const h = t.property;

    if (void 0 === t.value && h && h[0] && "object" == typeof h[0] && h[0][h[1]] && Array.isArray(h[0][h[1]])) {
      const [e, n] = h,
            r = e[n],
            s = r.length,
            o = new (2 === s ? i.FM8 : 3 === s ? i.Pa4 : i.Ltg)().fromArray(r);
      t.value = o, t.property = void 0, t.onChange = [() => {
        e[n] = o.toArray();
      }, ...(Array.isArray(t.onChange) ? t.onChange : [t.onChange])].filter(e => e), void 0 === t.label && (t.label = n);
    }

    return EC(e, t, n, { ...p,
      ...(null != r ? r : {})
    });
  },
        TC = (e, t, n, r) => {
    var i;
    const s = t.property;

    if (void 0 === t.value && s && "object" == typeof s[0] && (null === (i = s[0][s[1]]) || void 0 === i ? void 0 : i.isColor)) {
      const [e, n] = s,
            r = new ve().set(e[n]).convertSRGBToLinear();
      Object.defineProperty(t, "value", {
        get: () => {
          const t = e[n];
          return t ? r.set(t).convertLinearToSRGB().getHex() : 0;
        },
        set: t => {
          var i;
          const s = e[n];
          r.setHex(t).convertSRGBToLinear(), s.isColor ? s.copy(r) : "number" == typeof s ? e[n] = r.getHex() : "string" == typeof s && (e[n] = "#" + r.getHexString()), "function" == typeof (null === (i = null == e ? void 0 : e.userData) || void 0 === i ? void 0 : i.setDirty) && e.userData.setDirty();
        }
      }), t.property = void 0, t.onChange = [...(Array.isArray(t.onChange) ? t.onChange : [t.onChange])].filter(e => e), void 0 === t.label && (t.label = n);
    }

    return (r = null != r ? r : {}).view = "color", x(t.inlinePicker) && (r.picker = "inline"), EC(e, t, n, r);
  },
        EC = (e, t, n, r) => {
    var i;
    let s = x(t.property);
    if ((t.getValue || t.setValue) && s && console.error("specify either property or value, or getValue and setValue", t), s) t.value && console.warn("Both property and value are defined, value will be ignored", t);else if (void 0 === t.value && (t.getValue || t.setValue) && (Object.defineProperty(t, "value", {
      get: () => {
        var e;
        return null === (e = t.getValue) || void 0 === e ? void 0 : e.call(t);
      },
      set: e => {
        var n;
        return null === (n = t.setValue) || void 0 === n ? void 0 : n.call(t, e);
      }
    }), s = [t, "value"]), s || void 0 === t.value || (s = [t, "value"]), !s) return void console.error("cannot determine property", t);
    r = null != r ? r : {};
    const o = {
      label: null !== (i = x(t.label)) && void 0 !== i ? i : s[1],
      ...r
    };
    let a = t.uiRef;

    if (!a && "object" == typeof s[0] && s[0]) {
      const [n, r] = s;

      try {
        a = t.isMonitor ? e.addMonitor(n, r, o) : e.addInput(n, r, o).on("change", e => {
          var r;
          [t.onChange].flat().forEach(t => "function" == typeof t && (null == t ? void 0 : t(e))), "function" == typeof (null === (r = null == n ? void 0 : n.userData) || void 0 === r ? void 0 : r.setDirty) && n.userData.setDirty(e);
        });
      } catch (e) {
        if (!e.message.startsWith("No matching controller for")) throw e;
        a = void 0;
      }
    }

    if (a) {
      for (const [e, t] of Object.entries(o)) {
        const n = a.controller_.props.value(e);
        void 0 !== n && n.rawValue !== t && a.controller_.props.set(e, t);
      }

      a.refresh();
    }

    return a;
  };

  class AC extends r {
    constructor(e = !1, t = !1, n = !1, r = !0, i = document.body) {
      super(), this._refreshQueue = {
        preRender: [],
        postRender: [],
        preFrame: [],
        postFrame: []
      }, this._typeGenerators = {
        folder: xC,
        input: EC,
        slider: SC,
        dropdown: wC,
        checkbox: EC,
        color: TC,
        vec: MC,
        vec2: MC,
        vec3: MC,
        vec4: MC,
        button: yC,
        monitor: (e, t, n, r) => (t.isMonitor = !0, EC(e, t, n, r)),
        dummy: (e, t, n, r) => EC(e, t, n, r)
      }, this._expand = e, this._limitedOptions = n;

      const s = this._createUiContainer();

      i.appendChild(s), this._pane = new vC.Pane({
        title: "Configuration",
        container: s
      }), this._pane.expanded = this._expand, r && (this.addEventListener("postFrame", () => this.refreshQueue("postFrame")), setTimeout(() => {
        this.dispatchEvent({
          type: "postFrame"
        });
      }, 32));
    }

    refreshQueue(e) {
      const t = this._refreshQueue[e];
      this._refreshQueue[e] = [], t.forEach(e => this._refreshUiObject(e[0], e[1], e[2]));
    }

    addToRefreshQueue(e, t) {
      var n;
      const r = null === (n = t[0]) || void 0 === n ? void 0 : n.uiConfig,
            i = null == r ? void 0 : r.uuid,
            s = this._refreshQueue[e];
      s.findIndex(e => e[3] === i) < 0 && s.push([...t, i]), this._refreshQueue[e] = s;
    }

    dispose() {
      var e;
      null === (e = this._pane) || void 0 === e || e.dispose(), this._pane = void 0;
    }

    appendUiObject(e, t) {
      e && this._appendUiObject(e, t);
    }

    _appendUiObject(e, t) {
      var n, r, i, s;
      const {
        uiConfig: o
      } = null != e ? e : {};

      if (o && (!this._limitedOptions || o.limitedUi) && (t = null != t ? t : this._pane, o.type)) {
        o.uuid || (o.uuid = Be()), o.uiRef && o.uiRefType !== o.type && (console.log("Removing UI object because of type mismatch", o.uiRef), this.removeUiConfig(o));
        const a = null === (r = (n = this._typeGenerators)[o.type]) || void 0 === r ? void 0 : r.call(n, t, o, this);
        a && (a.hidden = null !== (i = x(o.hidden)) && void 0 !== i && i, a.disabled = null !== (s = x(o.disabled)) && void 0 !== s && s), o.uiRef = a, o.uiRefType = a ? o.type : void 0, o.uiRefresh = (n = "postFrame", r = !1, i = 0) => {
          var s;
          return this._uiObjectRefresh(n, null !== (s = null == e ? void 0 : e.uiConfig) && void 0 !== s ? s : o, t, r, i);
        };
      }
    }

    removeUiObject(e) {
      this.removeUiConfig(null == e ? void 0 : e.uiConfig);
    }

    removeUiConfig(e) {
      var t, n;
      e && e.uiRef && e.uiRefType !== e.type && (null === (n = (t = e.uiRef).dispose) || void 0 === n || n.call(t), e.uiRefType = void 0, e.uiRefresh = void 0);
    }

    _uiObjectRefresh(e, t, n, r, i) {
      (r ? CC(t, n) : [{
        uiConfig: t,
        parentFolder: n
      }]).forEach(t => {
        const n = [{
          uiConfig: t.uiConfig
        }, t.parentFolder, i];
        "immediate" === e ? this._refreshUiObject(...n) : this.addToRefreshQueue(e, n);
      });
    }

    _refreshUiObject(e, t, n = 0) {
      this._appendUiObject(e, t), n > 1e-4 && console.error("no support for immediate delay");
    }

    _createUiContainer() {
      const e = yt({
        id: "tweakpaneUiContainer",
        addToBody: !1
      });
      return St(T`
          #tweakpaneUiContainer {
            position: fixed;
            top: 0px;
            padding-right: 4px;
            padding-bottom: 10px;
            right: 10px;
            width: max(20%, 300px);
            height: auto;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: auto;
            max-height: calc(100% - 6rem);
            border-radius: 0.5rem;
          }
        `), e;
    }

  }

  function CC(e, t, n) {
    var r;
    return n = null != n ? n : [], e ? (n.push({
      uiConfig: e,
      parentFolder: t
    }), null === (r = e.children) || void 0 === r || r.forEach(t => n = CC(t, e.uiRef, n)), n) : n;
  }

  class RC {
    constructor() {
      RC.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }

    set(e, t, n, r, i, s, o, a, l) {
      const c = this.elements;
      return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this;
    }

    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }

    copy(e) {
      const t = this.elements,
            n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
    }

    extractBasis(e, t, n) {
      return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }

    setFromMatrix4(e) {
      const t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }

    multiply(e) {
      return this.multiplyMatrices(this, e);
    }

    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }

    multiplyMatrices(e, t) {
      const n = e.elements,
            r = t.elements,
            i = this.elements,
            s = n[0],
            o = n[3],
            a = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            p = n[2],
            h = n[5],
            d = n[8],
            f = r[0],
            _ = r[3],
            m = r[6],
            g = r[1],
            v = r[4],
            b = r[7],
            x = r[2],
            y = r[5],
            w = r[8];
      return i[0] = s * f + o * g + a * x, i[3] = s * _ + o * v + a * y, i[6] = s * m + o * b + a * w, i[1] = l * f + c * g + u * x, i[4] = l * _ + c * v + u * y, i[7] = l * m + c * b + u * w, i[2] = p * f + h * g + d * x, i[5] = p * _ + h * v + d * y, i[8] = p * m + h * b + d * w, this;
    }

    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
    }

    determinant() {
      const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8];
      return t * s * c - t * o * l - n * i * c + n * o * a + r * i * l - r * s * a;
    }

    invert() {
      const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8],
            u = c * s - o * l,
            p = o * a - c * i,
            h = l * i - s * a,
            d = t * u + n * p + r * h;
      if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / d;
      return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (o * n - r * s) * f, e[3] = p * f, e[4] = (c * t - r * a) * f, e[5] = (r * i - o * t) * f, e[6] = h * f, e[7] = (n * a - l * t) * f, e[8] = (s * t - n * i) * f, this;
    }

    transpose() {
      let e;
      const t = this.elements;
      return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    }

    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }

    transposeIntoArray(e) {
      const t = this.elements;
      return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
    }

    setUvTransform(e, t, n, r, i, s, o) {
      const a = Math.cos(i),
            l = Math.sin(i);
      return this.set(n * a, n * l, -n * (a * s + l * o) + s + e, -r * l, r * a, -r * (-l * s + a * o) + o + t, 0, 0, 1), this;
    }

    scale(e, t) {
      const n = this.elements;
      return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this;
    }

    rotate(e) {
      const t = Math.cos(e),
            n = Math.sin(e),
            r = this.elements,
            i = r[0],
            s = r[3],
            o = r[6],
            a = r[1],
            l = r[4],
            c = r[7];
      return r[0] = t * i + n * a, r[3] = t * s + n * l, r[6] = t * o + n * c, r[1] = -n * i + t * a, r[4] = -n * s + t * l, r[7] = -n * o + t * c, this;
    }

    translate(e, t) {
      const n = this.elements;
      return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this;
    }

    equals(e) {
      const t = this.elements,
            n = e.elements;

      for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;

      return !0;
    }

    fromArray(e, t = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];

      return this;
    }

    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
    }

    clone() {
      return new this.constructor().fromArray(this.elements);
    }

  }

  function kC(e) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e);
  }

  let PC;
  Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

  class DC {
    constructor(e = null) {
      this.isSource = !0, this.uuid = $(), this.data = e, this.version = 0;
    }

    set needsUpdate(e) {
      !0 === e && this.version++;
    }

    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
      const n = {
        uuid: this.uuid,
        url: ""
      },
            r = this.data;

      if (null !== r) {
        let e;

        if (Array.isArray(r)) {
          e = [];

          for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(OC(r[t].image)) : e.push(OC(r[t]));
        } else e = OC(r);

        n.url = e;
      }

      return t || (e.images[this.uuid] = n), n;
    }

  }

  function OC(e) {
    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? class {
      static getDataURL(e) {
        if (/^data:/i.test(e.src)) return e.src;
        if ("undefined" == typeof HTMLCanvasElement) return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;else {
          void 0 === PC && (PC = kC("canvas")), PC.width = e.width, PC.height = e.height;
          const n = PC.getContext("2d");
          e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = PC;
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png");
      }

      static sRGBToLinear(e) {
        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
          const t = kC("canvas");
          t.width = e.width, t.height = e.height;
          const n = t.getContext("2d");
          n.drawImage(e, 0, 0, e.width, e.height);
          const r = n.getImageData(0, 0, e.width, e.height),
                i = r.data;

          for (let e = 0; e < i.length; e++) i[e] = 255 * le(i[e] / 255);

          return n.putImageData(r, 0, 0), t;
        }

        if (e.data) {
          const t = e.data.slice(0);

          for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * le(t[e] / 255)) : t[e] = le(t[e]);

          return {
            data: t,
            width: e.width,
            height: e.height
          };
        }

        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
      }

    }.getDataURL(e) : e.data ? {
      data: Array.from(e.data),
      width: e.width,
      height: e.height,
      type: e.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }

  let LC = 0;

  class IC extends class {
    addEventListener(e, t) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
    }

    hasEventListener(e, t) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[e] && -1 !== n[e].indexOf(t);
    }

    removeEventListener(e, t) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[e];

      if (void 0 !== n) {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      }
    }

    dispatchEvent(e) {
      if (void 0 === this._listeners) return;
      const t = this._listeners[e.type];

      if (void 0 !== t) {
        e.target = this;
        const n = t.slice(0);

        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);

        e.target = null;
      }
    }

  } {
    constructor(e = IC.DEFAULT_IMAGE, t = IC.DEFAULT_MAPPING, n = 1001, r = 1001, i = se, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) {
      super(), this.isTexture = !0, Object.defineProperty(this, "id", {
        value: LC++
      }), this.uuid = $(), this.name = "", this.source = new DC(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new k(0, 0), this.repeat = new k(1, 1), this.center = new k(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new RC(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
    }

    get image() {
      return this.source.data;
    }

    set image(e) {
      this.source.data = e;
    }

    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }

    clone() {
      return new this.constructor().copy(this);
    }

    copy(e) {
      return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
    }

    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
    }

    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }

    transformUv(e) {
      if (300 !== this.mapping) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
        case 1e3:
          e.x = e.x - Math.floor(e.x);
          break;

        case 1001:
          e.x = e.x < 0 ? 0 : 1;
          break;

        case 1002:
          1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
      }
      if (e.y < 0 || e.y > 1) switch (this.wrapT) {
        case 1e3:
          e.y = e.y - Math.floor(e.y);
          break;

        case 1001:
          e.y = e.y < 0 ? 0 : 1;
          break;

        case 1002:
          1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
      }
      return this.flipY && (e.y = 1 - e.y), e;
    }

    set needsUpdate(e) {
      !0 === e && (this.version++, this.source.needsUpdate = !0);
    }

  }

  IC.DEFAULT_IMAGE = null, IC.DEFAULT_MAPPING = 300;

  var FC = __webpackgi_require__(898),
      NC = {};

  FC.Z && FC.Z.locals && (NC.locals = FC.Z.locals);
  var UC,
      BC = 0,
      jC = {};
  jC.styleTagTransform = Om(), jC.setAttributes = Rm(), jC.insert = function (e, t) {
    (t.target || document.head).appendChild(e);
  }, jC.domAPI = Am(), jC.insertStyleElement = Pm(), NC.use = function (e) {
    return jC.options = e || {}, BC++ || (UC = Tm()(FC.Z, jC)), NC;
  }, NC.unuse = function () {
    BC > 0 && ! --BC && (UC(), UC = null);
  };
  var zC = NC;

  class VC extends AC {
    constructor(e = !1, t = !1, n = !1, r = document.body) {
      super(e, t, n, !1), this.dependencies = [js], this._preRender = () => this.refreshQueue("preRender"), this._postRender = () => this.refreshQueue("postRender"), this._postFrame = e => {
        this.dispatchEvent(e), this.refreshQueue("postFrame");
      }, this._preFrame = () => this.refreshQueue("preFrame"), this._plugins = [], this._pane.registerPlugin(mC), zC.use({
        target: r
      });
    }

    async onAdded(e) {
      this._viewer = e, this._typeGenerators.image = (e => (t, n, r, s) => {
        const o = n.property,
              a = "placeholder";

        if (void 0 === n.value && o && "object" == typeof o[0]) {
          const [t, r] = o,
                s = yT("Render Target"),
                l = yT("Data Texture"),
                c = yT("Compressed Texture"),
                u = {},
                p = {};
          Object.defineProperty(n, "value", {
            get: () => {
              var e;
              let n,
                  i = t[r];
              if ((null == i ? void 0 : i.get) && (i = i.get()), !i) return a;

              if (i.isRenderTargetTexture && !i.image.tp_src && (i.image.tp_src = s), i.isDataTexture && !i.image.tp_src && (i.image.tp_src = l), i.isCompressedTexture && !i.image.tp_src && (i.image.tp_src = c), i.isTexture ? (i.image && (i.image instanceof ImageBitmap || i.image instanceof HTMLImageElement || i.image instanceof HTMLVideoElement) && !i.image.tp_src && (i.image.tp_src = Tt(i.image, 160)), i.image && (n = i.image.tp_src_uuid, n = n ? u[n] : void 0, n || (n = i.image.tp_src || i.image.src))) : "string" == typeof i ? n = i : i && console.error("unknown value", i), n || (n = a), i.image && !i.image.tp_src_uuid) {
                const e = Be();
                i.image.tp_src_uuid = e, p[n] = e;
              }

              return "string" == typeof n && (n = null !== (e = u[n]) && void 0 !== e ? e : n), n;
            },
            set: s => {
              var o, l, c, h, d, f, _, m, g, v, b, x, y;

              const w = t[r],
                    S = e => {
                var n;
                t[r] = e, (null == e ? void 0 : e.isTexture) && (e.flipY = e.isDataTexture ? e.flipY : null === (n = null == w ? void 0 : w.flipY) || void 0 === n || n);
              };

              if ("string" == typeof s) return void ("string" == typeof w && S(s));
              let M = s.tp_src_uuid;
              if (M || (M = null !== (o = s.src) && void 0 !== o ? o : s.tp_src, M = null !== (l = p[M]) && void 0 !== l ? l : M, delete p[M], s.tp_src_uuid = M), M && (u[M] = s), s) {
                if (s.isPlaceholder) w && (S("string" == typeof w ? "" : null), "function" == typeof (null === (c = null == t ? void 0 : t.userData) || void 0 === c ? void 0 : c.setDirty) && t.userData.setDirty());else if ("string" != typeof w) {
                  if (!((null == w ? void 0 : w.image) === s || (null === (h = null == w ? void 0 : w.image) || void 0 === h ? void 0 : h.src) === s.src || (null === (d = null == w ? void 0 : w.image) || void 0 === d ? void 0 : d.tp_src) === s.tp_src && null != s.tp_src || (null === (f = null == w ? void 0 : w.image) || void 0 === f ? void 0 : f.tp_src) === s.src && null != s.src || (null === (_ = null == w ? void 0 : w.image) || void 0 === _ ? void 0 : _.src) === s.tp_src && null != s.tp_src)) if (s instanceof File) {
                    const r = null == e ? void 0 : e.getPlugin(js);
                    if (!r) throw "Viewer or AssetManagerPlugin not found";
                    null === (m = r.importer) || void 0 === m || m.importSingle({
                      file: s,
                      path: s.src
                    }).then(e => {
                      var r, i, o, a, l;

                      if (e) {
                        e.isDataTexture && (e.needsUpdate = !0);
                        const c = null === (o = null === (i = null === (r = s.src) || void 0 === r ? void 0 : r.split("?")) || void 0 === i ? void 0 : i[0]) || void 0 === o ? void 0 : o.split(".").pop();
                        e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(c) ? "jpeg" : "png")), S(e), [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (a = null == t ? void 0 : t.userData) || void 0 === a ? void 0 : a.setDirty) && t.userData.setDirty(), null === (l = n.uiRefresh) || void 0 === l || l.call(n, "postFrame", !1);
                      }
                    });
                  } else {
                    const e = new IC(s);
                    e.assetType = "texture", e.needsUpdate = !0;
                    const o = null === (b = null === (v = null === (g = s.src) || void 0 === g ? void 0 : g.split("?")) || void 0 === v ? void 0 : v[0]) || void 0 === b ? void 0 : b.split(".").pop();
                    e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(o) ? "jpeg" : "png")), S(e);
                    const a = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(r);
                    e.encoding = a ? i.rnI : i.knz, e.wrapS = i.rpg, e.wrapT = i.rpg, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (x = null == t ? void 0 : t.userData) || void 0 === x ? void 0 : x.setDirty) && t.userData.setDirty(), null === (y = n.uiRefresh) || void 0 === y || y.call(n, "postFrame", !1);
                  }
                } else S(M);
              } else n.value = a;
            }
          }), n.property = void 0, void 0 === n.label && (n.label = r);
        }

        return (s = null != s ? s : {}).extensions = [".jpg", ".png", ".svg", ".hdr", ".exr", ".jpeg", ".bmp", ".gif", ".webp"], void 0 === s.imageFit && (s.imageFit = "contain"), void 0 === s.clickCallback && (s.clickCallback = (t, r) => {
          var s;
          const l = null == t ? void 0 : t.target,
                c = null == l ? void 0 : l.getBoundingClientRect();
          if (!c) return void r.click();
          const u = n.uiRef.controller_.valueController.value.rawValue;
          if (u === a || (null == u ? void 0 : u.isPlaceholder)) r.click();else {
            const t = gC.Create({
              "remove image": () => {
                var e, t;
                n.uiRef.controller_.valueController.value.setRawValue("");
                const [r, i] = o || [n, "value"],
                      s = "string" == typeof r[i];
                r[i] = s ? "" : null, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (e = null == r ? void 0 : r.userData) || void 0 === e ? void 0 : e.setDirty) && r.userData.setDirty(), null === (t = n.uiRefresh) || void 0 === t || t.call(n, "postFrame", !1), gC.Remove();
              },
              "replace image": () => {
                r.click(), gC.Remove();
              },
              "download image": () => {
                var e, t, r;
                const [i, s] = o || [n, "value"];
                let a = null !== (t = null === (e = i[s]) || void 0 === e ? void 0 : e.image) && void 0 !== t ? t : n.uiRef.controller_.valueController.value.rawValue;
                a && (a instanceof ImageBitmap || a instanceof HTMLImageElement || a instanceof HTMLVideoElement) && !a.src && (a = Tt(a));
                const l = document.createElement("a");
                document.body.appendChild(l), l.style.display = "none", l.href = null !== (r = null == a ? void 0 : a.src) && void 0 !== r ? r : a, l.download = "image.png", l.click(), document.body.removeChild(l), gC.Remove();
              },
              "from url": async () => {
                var t, r, s;
                let a = "";
                if (a && (a.startsWith("http") || a.startsWith("data:image")) || (a = ""), a = prompt("enter image url", a), !a || !a.startsWith("http") && !a.startsWith("data:image")) return null !== a && alert("invalid url"), void gC.Remove();
                const [l, c] = o || [n, "value"],
                      u = l[c];
                if ("string" == typeof u) l[c] = a, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (t = null == l ? void 0 : l.userData) || void 0 === t ? void 0 : t.setDirty) && l.userData.setDirty(), null === (r = n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !1);else {
                  const t = null == e ? void 0 : e.getPlugin(js);
                  if (!t) throw "Viewer or AssetManagerPlugin not found";
                  null === (s = t.importer) || void 0 === s || s.importSinglePath(a).then(e => {
                    var t, r;

                    if (e) {
                      e.isDataTexture ? e.needsUpdate = !0 : e && void 0 !== (null == u ? void 0 : u.flipY) && (e.flipY = u.flipY), l[c] = e;
                      const s = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(c);
                      e.encoding = s ? i.rnI : i.knz, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (t = null == l ? void 0 : l.userData) || void 0 === t ? void 0 : t.setDirty) && l.userData.setDirty(), null === (r = n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !1);
                    }
                  });
                }
                gC.Remove();
              },
              cancel: () => {
                gC.Remove();
              }
            }, 2, c.height + 8);
            null === (s = l.parentElement) || void 0 === s || s.appendChild(t), c.y > .7 * document.body.clientHeight && (t.style.top = "auto", t.style.bottom = c.height + 8 + "px");
          }
        }), s.view = "input-image", EC(t, n, r, s);
      })(this._viewer), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame), e.addEventListener("postFrame", this._postFrame);
    }

    async onDispose(e) {
      this.dispose();
    }

    async onRemove(e) {
      this._viewer = void 0, e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), e.removeEventListener("preFrame", this._preFrame), e.removeEventListener("postFrame", this._postFrame), this.dispose();
    }

    setupPluginUi(e) {
      var t;
      const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(e);
      if (!n) return void console.warn("plugin not found:", e);
      this._plugins.push(n), n.uiConfig && (n.uiConfig.limitedUi = !0), n.uiConfig && void 0 === n.uiConfig.hidden && (n.uiConfig.hidden = !1), this._appendUiObject(n);
      const r = n.uiConfig;

      if ((null == r ? void 0 : r.uiRef) && n.toJSON) {
        const e = r.uiRef.controller_.view.element,
              t = yt({
          innerHTML: "&#8942;",
          classList: ["pluginOptionsButton"],
          elementTag: "button"
        });
        t.onclick = t => {
          const r = {};
          "function" == typeof n.toJSON && (r["download preset"] = async () => {
            var e, t;
            const r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(js)) || void 0 === t ? void 0 : t.exportPluginPreset(n);
            await gt(new Blob([JSON.stringify(r, null, 2)], {
              type: "application/json"
            }), "preset." + n.constructor.PluginType + ".json"), gC.Remove();
          }), "function" == typeof n.fromJSON && (r["upload preset"] = async () => {
            var e, t;
            gC.Remove();
            const r = await xt(!1, !1);
            if (0 === r.length) return;
            const i = r[0],
                  s = await i.text(),
                  o = JSON.parse(s);
            await (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(js)) || void 0 === t ? void 0 : t.importPluginPreset(o, n));
          });
          const i = gC.Create(r, e.clientWidth - 120, 12);
          e.append(i), t.preventDefault();
        }, e.appendChild(t);
      }

      return r;
    }

    setupPlugins(...e) {
      e.forEach(e => this.setupPluginUi(e));
    }

    refreshPluginsEnabled() {
      this._plugins.forEach(e => {
        var t;
        const n = e.uiConfig;
        n && (!0 !== x(n.hidden) ? null === (t = n.uiRefresh) || void 0 === t || t.call(n, "postFrame", !0) : n.uiRef && (n.uiRef.hidden = !0));
      });
    }

  }

  VC.PluginType = "TweakpaneUi";

  class GC extends zs {
    constructor() {
      super(...arguments), this.enabled = !0, this.toJSON = void 0, this.bgUIConfig = {
        label: "Color",
        type: "color",
        inlinePicker: !0,
        onChange: () => {
          if (!this._viewer) return;
          const e = new ve(this.bgUIConfig.value || 16777215).convertSRGBToLinear();

          this._viewer.setBackground(e.getHex());
        },
        expanded: !0,
        limitedUi: !0
      }, this.uiConfig = {
        label: "Background / Environment",
        type: "folder",
        expanded: !1,
        limitedUi: !0,
        children: [this.bgUIConfig, {
          label: "Image",
          property: [this, "sceneBackground"],
          type: "image",
          limitedUi: !0
        }, {
          label: "EnvMap BG",
          type: "checkbox",
          property: [this, "envmapBg"]
        }, () => ({
          type: "slider",
          label: "BG Intensity",
          property: [this._viewer, "backgroundIntensity"],
          bounds: [0, 16]
        }), {
          label: "Set Transparent BG",
          type: "button",
          hidden: () => !this._viewer || this._viewer.useRgbm,
          value: () => {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setBackground(null);
          }
        }, {
          label: "Environment",
          property: [this, "sceneEnvironment"],
          type: "image",
          limitedUi: !0
        }, {
          type: "slider",
          label: "Env Rotation",
          property: [this, "sceneEnvironmentRotation"],
          bounds: [0, 2 * Math.PI],
          limitedUi: !0
        }, {
          type: "slider",
          label: "Env Intensity",
          property: [this, "sceneEnvironmentIntensity"],
          bounds: [0, 4],
          limitedUi: !0
        }]
      };
    }

    get sceneBackground() {
      var e;
      const t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground();
      return t && (t.isTexture || "texture" === t.assetType) ? t : null;
    }

    set sceneBackground(e) {
      var t, n;
      e ? null === (t = this._viewer) || void 0 === t || t.setBackground(e) : null === (n = this._viewer) || void 0 === n || n.setBackground(this.bgUIConfig.value);
    }

    get sceneEnvironment() {
      var e;
      return null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment();
    }

    set sceneEnvironment(e) {
      var t;
      null === (t = this._viewer) || void 0 === t || t.scene.setEnvironment(e);
    }

    get sceneEnvironmentRotation() {
      var e, t, n;
      return null !== (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || void 0 === t ? void 0 : t.rotation) && void 0 !== n ? n : 0;
    }

    set sceneEnvironmentRotation(e) {
      var t, n;
      const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.getEnvironment();
      r && (r.rotation = e, null === (n = this._viewer) || void 0 === n || n.scene.setDirty());
    }

    get sceneEnvironmentIntensity() {
      var e, t;
      return null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.envMapIntensity) && void 0 !== t ? t : 1;
    }

    set sceneEnvironmentIntensity(e) {
      var t;
      (null === (t = this._viewer) || void 0 === t ? void 0 : t.scene) && (this._viewer.scene.envMapIntensity = e);
    }

    get envmapBg() {
      var e;
      return (null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0)) === no;
    }

    set envmapBg(e) {
      if (this._viewer) if (e) {
        const e = this._viewer.getBackground(!0);

        e && e !== no && (this.lastBgVal = e), this._viewer.setBackground(no);
      } else this._viewer.getBackground() === this._viewer.scene.getEnvironment() && this._viewer.setBackground(this.lastBgVal || this.bgUIConfig.value);
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e);
      const n = e.getBackground();
      this.bgUIConfig.value = "string" == typeof n && n !== no || "number" == typeof n || (null === (t = n) || void 0 === t ? void 0 : t.isColor) ? "#" + new ve(n).getHexString() : "#000000", this.lastBgVal = n;
    }

  }

  GC.PluginType = "SimpleBackgroundEnvUiPlugin1";

  class HC extends zs {
    constructor() {
      super(), this.enabled = !0, this.toJSON = void 0, this._uiConfig = {
        type: "folder",
        label: "Scene",
        children: [],
        onExpand: () => {
          var e, t;
          null === (t = (e = this._uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
        }
      }, this._clearSceneButton = {
        type: "button",
        label: "Clear Scene",
        value: () => {
          var e;
          null === (e = this._viewer) || void 0 === e || e.scene.disposeSceneModels();
        }
      }, this._sceneUpdate = this._sceneUpdate.bind(this);
    }

    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }

    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get uiConfig() {
      var e, t, n;
      return this._viewer ? (this._uiConfig.children = [this._clearSceneButton], this._uiConfig.children.push(this._viewer.scene.activeCamera.uiConfig), this._uiConfig.children.push(...(null !== (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.modelRoot.modelObject.children) || void 0 === t ? void 0 : t.map(e => "light" === e.assetType ? null : e.uiConfig).filter(e => null != e)) && void 0 !== n ? n : [])), this._uiConfig) : this._uiConfig;
    }

    _sceneUpdate() {
      var e, t;
      null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
    }

  }

  HC.PluginType = "SimpleUi";

  var WC = __webpackgi_require__(1),
      KC = __webpackgi_require__.n(WC)();

  class XC extends zs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.toJSON = void 0, this.treeView = void 0, this.hierarchyDiv = yt({
        innerHTML: "",
        id: "tpHierarchyContainer",
        addToBody: !1
      }), this._uiConfig = {
        type: "folder",
        label: "Hierarchy",
        children: []
      }, this._buildData = (e, t) => (e.push({
        text: t.name || "unnamed",
        id: t.uuid,
        children: t.children.reduce(this._buildData, [])
      }), e), this._findVisible = (e, t) => t.visible ? (t.children.length < 1 ? e.push(t.uuid) : e.push(...t.children.reduce(this._findVisible, [])), e) : e, this._setVisible = e => {
        var t, n, r;
        const i = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
        if (!i || null == e) return;
        const s = new Set();
        i.traverse(t => {
          t !== i && (t.visible = e.includes(t.uuid), t.visible && t.traverseAncestors(e => s.add(e)));
        }), s.forEach(e => e.visible = !0), null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.scene) || void 0 === r || r.setDirty({
          sceneUpdate: !0,
          fromHierarchyPlugin: !0,
          updateGround: !1
        });
      }, this.enabled = e, this.reset = this.reset.bind(this), St(T`
#tpHierarchyContainer{
  width: 100%;
  height: auto;
  background-color: transparent;
  color: #e9e9ed;
  margin-top: 0;
}
`);
    }

    reset(e) {
      var t;
      if (null == e ? void 0 : e.fromHierarchyPlugin) return;

      for (; this.hierarchyDiv.firstChild;) this.hierarchyDiv.firstChild.remove();

      const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
      if (!n) return;
      const r = n.children.reduce(this._buildData, []),
            i = n.children.reduce(this._findVisible, []);
      let s = !1;
      return new Promise((e, t) => {
        this.treeView = new KC(this.hierarchyDiv, {
          closeDepth: 1,
          data: r,
          loaded: function () {
            this.values = i, e();
          },
          onChange: () => {
            s ? uc(200).then(() => {
              this.treeView && this._setVisible(this.treeView.values);
            }) : s = !0;
          },
          onItemLabelClick: e => {
            var t;
            const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot.modelObject.getObjectByProperty("uuid", e);
            r && n.visible && r.dispatchEvent({
              type: "select",
              value: r
            });
          }
        });
      });
    }

    async onAdded(e) {
      await super.onAdded(e), this.reset(), e.scene.addEventListener("sceneUpdate", this.reset);
    }

    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this.reset), super.onRemove(e);
    }

    async onDispose(e) {
      return super.onDispose(e);
    }

    get uiConfig() {
      return this._uiConfig.domChildren || (this._uiConfig.domChildren = [this.hierarchyDiv]), this._uiConfig;
    }

  }

  XC.PluginType = "HierarchyUiPlugin";

  var qC = yE({
    defaultModifiers: [ME, RE, DE, OE]
  }),
      YC = __webpackgi_require__(388),
      ZC = __webpackgi_require__.n(YC);

  function JC(e) {
    const t = [];
    e.traverse(e => {
      e.geometry && t.push(e);
    });
    const n = {},
          r = {};
    t.forEach(e => {
      var t;

      if (!n[e.geometry.uuid]) {
        const t = e.geometry.toJSON().data,
              r = t ? ZC()({
          a: t.attributes || {},
          b: t.index || []
        }) : "";
        n[e.geometry.uuid] = r;
      }

      const i = n[e.geometry.uuid],
            s = null !== (t = r[i]) && void 0 !== t ? t : r[i] = [];
      s.includes(e) || s.push(e);
    }), Object.values(r).forEach(e => {
      if (e.length < 2) return;
      const t = e[0].geometry;
      e.forEach((e, n) => {
        n < 1 || (e.geometry.dispose(), e.geometry = t);
      });
    });
  }

  const $C = new i.Pa4(),
        QC = new i.Pa4(),
        eR = new i.Pa4(),
        tR = new i.Pa4(),
        nR = new i.Pa4(),
        rR = new i.Pa4();
  let iR = 1;
  const sR = new i.Pa4(0, 1, 0);

  class oR extends Pe {
    constructor(e, t) {
      super(e, t), this.targetOffset = new i.Pa4(0, 0, 0);
      const n = this.update;

      this.update = () => this._update(n);
    }

    _update(e) {
      this.target.add(this.targetOffset), $C.copy(this.object.position).sub(this.target), iR = $C.length(), rR.copy(this.target);
      const t = e();
      return rR.sub(this.target), $C.copy(this.object.position).sub(this.target), iR /= $C.length(), this.target.add(rR), this.object.position.copy(this.target).add($C), $C.normalize(), QC.crossVectors(sR, $C).normalize(), eR.crossVectors($C, QC).normalize(), tR.crossVectors(QC, eR).normalize().negate(), QC.length() > .1 && this.object.up.crossVectors($C.clone().normalize(), QC), this.enablePan && (nR.set(0, 0, 0).addScaledVector(QC, rR.x).addScaledVector(eR, rR.y).addScaledVector(tR, rR.z), this.targetOffset.add(nR), this.targetOffset.multiplyScalar(1 / iR)), nR.set(0, 0, 0).addScaledVector(QC, -this.targetOffset.x).addScaledVector(eR, -this.targetOffset.y).addScaledVector(tR, -this.targetOffset.z), this.object.lookAt(nR.add(this.target)), this.object.updateMatrixWorld(), this.object.isCamera && this.object.updateProjectionMatrix(), this.target.sub(this.targetOffset), t;
    }

  }

  class aR extends Ea {
    constructor(e) {
      super(e), this.boundingScaleMultiplier = 1.2, this._initGeometry(new i.cJO(1, 0));
    }

  }

  function lR(e, t) {
    var n, r;
    const i = Array.from((null !== (n = e.access) && void 0 !== n ? n : "").split(".")),
          s = i.pop();
    let o = null !== (r = e.targetObject) && void 0 !== r ? r : t;
    if (!s || 0 === s.length) return {
      key: void 0,
      tar: o
    };
    if (o = v(i, o), o && !(s in o)) throw console.error("invalid key", s, o, t, e), "";
    return {
      key: s,
      tar: o
    };
  }

  function cR(e, t, n, r) {
    const {
      key: i,
      tar: s
    } = lR(e, t);
    return i && s ? pc(s, i, () => {
      var t;
      n && (null === (t = e.updater) || void 0 === t ? void 0 : t.length) && e.updater.forEach(e => n[e]()), null == r || r();
    }) : n => console.warn("Unable to set ", n, i, s, e, t);
  }

  async function uR(e, t, n) {
    var r, i, s, o;
    const {
      key: a,
      tar: l
    } = lR(t, e),
          c = t.animSet ? [pR(l, t.animSet, n, null !== (r = t.animSetParallel) && void 0 !== r && r)] : [];

    if (a && l) {
      const e = null !== (o = t.updater) && void 0 !== o ? o : [],
            r = async () => dc(l, a, { ...t,
        onUpdate: r => {
          var i;
          null === (i = t.onUpdate) || void 0 === i || i.call(t, r), e.forEach(e => {
            var t;
            return null === (t = n[e]) || void 0 === t ? void 0 : t.call(n);
          });
        }
      });

      t.delay ? c.push(uc(t.delay).then(r)) : c.push(r());
    } else (t.duration || t.delay) && c.push(uc((null !== (i = t.delay) && void 0 !== i ? i : 0) + (null !== (s = t.duration) && void 0 !== s ? s : 0)));

    return 1 === c.length ? c[0] : Promise.all(c);
  }

  async function pR(e, t, n, r = !1) {
    if (r) return Promise.all(t.map(async t => uR(e, t, n)));

    for (const r of t) await uR(e, r, n);
  }

  function hR(e, t, n, r) {
    var i, s, o, a, l, c, u;
    if (!e) return;
    t || (t = []);
    const p = null != r ? r : {},
          h = e;

    for (let e = 0, d = t.length; e < d; e++) {
      const d = t[e];

      if (d.uiRef) {
        const t = null !== (l = null == h ? void 0 : h.indexOf(d.uiRef)) && void 0 !== l ? l : -1;
        t !== e && (t >= 0 && (null == h || h.splice(t, 1)), null == h || h.splice(e, 0, d.uiRef));
      } else {
        d.uiRef = {
          type: "folder",
          label: null !== (i = d.name) && void 0 !== i ? i : "Animation " + e,
          children: []
        };
        const t = [{
          type: "button",
          label: "animate",
          value: () => {
            uR(n, d, p).then(() => {
              var e;
              return console.log((null === (e = d.uiRef) || void 0 === e ? void 0 : e.label) + " finished");
            });
          }
        }];
        void 0 !== d.access && t.push({
          type: "input",
          property: [d, "access"]
        }), void 0 !== d.from && t.push({
          type: null !== (s = d.uiObjectType) && void 0 !== s ? s : "input",
          property: [d, "from"],
          onChange: () => {
            var e;
            cR(d, n)(d.from), null === (e = d.updater) || void 0 === e || e.forEach(e => e in p && p[e]());
          }
        }), void 0 !== d.to && t.push({
          type: null !== (o = d.uiObjectType) && void 0 !== o ? o : "input",
          property: [d, "to"],
          onChange: () => {
            var e;
            cR(d, n)(d.to), null === (e = d.updater) || void 0 === e || e.forEach(e => e in p && p[e]());
          }
        }), void 0 !== d.duration && t.push({
          type: "input",
          property: [d, "duration"]
        }), d.animSet && (d.animSetParallel || (d.animSetParallel = !1), t.push({
          type: "input",
          label: "run parallel",
          property: [d, "animSetParallel"]
        })), d.animSet && t.push({
          type: "folder",
          label: "AnimSet",
          expanded: !1,
          children: [],
          animSetContainer: !0
        }), null === (a = d.uiRef.children) || void 0 === a || a.push(...t), null == h || h.splice(e, 0, d.uiRef);
      }

      const f = null === (c = d.uiRef.children) || void 0 === c ? void 0 : c.map(e => x(e)).flat(2).find(e => null == e ? void 0 : e.animSetContainer);
      d.animSet && f && hR(f.children, d.animSet, null !== (u = d.targetObject) && void 0 !== u ? u : n, r);
    }
  }

  class dR extends zs {
    constructor() {
      super(), this.enabled = !0, this.uiConfig = {
        type: "folder",
        label: "Lights",
        children: [{
          type: "button",
          label: "Add Directional Light",
          value: () => {
            if (!this._viewer) return;
            const e = new Os();
            e.position.set(0, 0, 0), e.target.position.set(0, 0, -1).normalize(), e.intensity = 2, e.shadow.mapSize.set(1024, 1024), this._viewer.scene.addLight(e), this._processor(e, {});
          }
        }],
        limitedUi: !0
      }, this.dependencies = [js], this._processor = (e, t) => {
        const n = e;
        return e.modelObject.traverse(e => {
          var t, n, r;
          if (!e.lightObject) return;
          const i = e.uiConfig;
          i && !(null === (t = this.uiConfig.children) || void 0 === t ? void 0 : t.includes(i)) && (this.uiConfig.children.push(i), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
        }), n;
      };
    }

    async onAdded(e) {
      var t, n, r, i;
      await super.onAdded(e), null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.processors.add("model", {
        forAssetType: "model",
        process: this._processor
      }), null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.processors.add("light", {
        forAssetType: "light",
        process: this._processor
      });
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(js)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.processors.remove("model", {
        forAssetType: "model",
        process: this._processor
      }), null === (i = null === (r = e.getPlugin(js)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.processors.remove("light", {
        forAssetType: "light",
        process: this._processor
      }), super.onRemove(e);
    }

  }

  dR.PluginType = "SimpleLightsUi";

  var fR = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class _R extends It {
    constructor(e, t, n, r = !1) {
      super({
        vertexShader: go,
        fragmentShader: `\n\n${bo}\n${vo}\n${xo}\n${yo}\n${n}\n\n${wo}\n\nvarying vec2 vUv;uniform float intensity;uniform float objectRadius;uniform float rayCount;uniform float power;uniform float bias;uniform float falloff;uniform float tolerance;uniform bool autoRadius;uniform vec2 screenSize;vec3 ComputeUniformL(vec3 N,vec2 E){vec3 L;L.xy=E;L.z=interleavedGradientNoise(gl_FragCoord.xy,frameCount*5.);L=L*2.-1.;return L;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=random3(vec3(gl_FragCoord.xy,frameCount+seed));rand_e.y=random3(vec3(gl_FragCoord.yx,rand_e.x+(frameCount)*7.));return rand_e;}vec4 calculateGI(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeUniformL(normal,E);L=normalize(L);L*=sign(dot(L,normal));float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?length(viewPos-screenToView(screenPos.xy+objectRadius/10.,screenPos.z)):mix((cameraNearFar.y)+viewPos.z,-viewPos.z-cameraNearFar.x,L.z*0.5+0.5)*objectRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount*14.+seed)+0.05;rayLen=max(rayLen,0.001);vec3 state=vec3(1.,(r+0.5)/float(RTAO_STEP_COUNT),2.);viewPos+=normal*max(-0.01*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,RTAO_STEP_COUNT);vec3 viewHitP=screenToView(screenHitP.xy,screenHitP.z);vec3 LRes=viewHitP-viewPos;if(state.z>1.)LRes=vec3(9999999.);float dist=length(LRes)*falloff;float EPS=0.01;float zBias=(viewPos.z)*bias;float ao=(max(dot(normal,L)+zBias,0.))/(dist*dist+EPS);\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 hitColor=tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy)).rgb;vec3 hitNormal=getViewNormal(screenHitP.xy);float giWeight=1.;giWeight=saturate2(giWeight/(dist+EPS),1.);giWeight*=saturate2((dot(normal,L)),1.);giWeight*=saturate2((dot(hitNormal,-L)),1.);return vec4(hitColor*giWeight,ao);\n#endif\nreturn vec4(0,0,0,ao);}float normpdf(in float x,in float sigma){return exp(-0.5*x*x/(sigma*sigma));}vec4 getLastThis(sampler2D tex,float depth,vec3 normal){vec2 direction=vec2(1,1);vec4 color=clamp(tLastThisTexelToLinear(texture2D(tex,vUv.xy)),0.,5.);return color;}void main(){float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>0.99){discard;gl_FragColor=getLastThis(tLastThis,depth,normal);return;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec4 gi=vec4(0.);gi+=calculateGI(8.,screenPos,normal,1.);if(rayCount>1.5)gi=max(gi,calculateGI(2.,screenPos,normal,0.4));if(rayCount>2.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.5));if(rayCount>3.5)gi=max(gi,calculateGI(1.,screenPos,normal,0.6));if(rayCount>4.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.));gi.a=min(1.,gi.a);gi.a=max(0.,gi.a);gi.rgb=min(vec3(3.),gi.rgb);gi.rgb=max(vec3(0.),gi.rgb);if(frameCount<3.){gl_FragColor=gi;return;}gl_FragColor=(texture2D(tLastThis,vUv));gl_FragColor=((gi+(gl_FragColor)*frameCount)/(frameCount+1.));}\n\n            `,
        uniforms: {
          tLastThis: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tLastFrame: {
            value: null
          },
          opacity: {
            value: 1
          },
          intensity: {
            value: 2.14
          },
          rayCount: {
            value: .1
          },
          objectRadius: {
            value: 1
          },
          autoRadius: {
            value: !r
          },
          power: {
            value: 1.1
          },
          bias: {
            value: .015
          },
          falloff: {
            value: .7
          },
          tolerance: {
            value: 1.5
          },
          frameCount: {
            value: 0
          },
          projection: {
            value: new i.yGw()
          },
          screenSize: {
            value: new i.FM8()
          },
          cameraPositionWorld: {
            value: new i.Pa4()
          },
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          }
        },
        defines: {
          PERSPECTIVE_CAMERA: 1,
          SSGI_ENABLED: r ? 1 : 0
        }
      }, "tDiffuse", "tLastFrame", "tLastThis"), this.materialExtension = {
        shaderExtender: (e, t, n) => {
          if (!e.defines.SSRTAO_ENABLED) return;
          const r = "vec3 totalDiffuse =";
          e.fragmentShader = e.fragmentShader.replace(r, `\n\n            \n            #if defined(SSRTAO_ENABLED) && SSRTAO_ENABLED > 0\nvec4 ssgi=tSSGIMapTexelToLinear(texture2D(tSSGIMap,viewToScreen(vViewPosition.xyz).xy));float ambientOcclusion=1.-ssgi.a;ambientOcclusion=max(0.,ambientOcclusion);ambientOcclusion=pow(ambientOcclusion,ssaoPower);ambientOcclusion=min(1.,ambientOcclusion);reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 ssgiColor=ssgi.rgb*ssgiIntensity;reflectedLight.indirectDiffuse+=ssgiColor*(material.diffuseColor.rgb);\n#endif\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));float specularOcclusion=saturate(pow(dotNV+ambientOcclusion,exp2(-16.*material.roughness-1.))-1.+ambientOcclusion);reflectedLight.indirectSpecular*=specularOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\n#if !defined(SSR_ENABLED) || SSR_ENABLED < 1\nreflectedLight.indirectSpecular+=ssgiColor*material.specularColor;\n#endif\n#endif\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${r}`), e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", ""), e.vertexUvs = !0;
        },
        onObjectRender: (e, t, n) => {
          var r, i, s;
          this.materialExtension.extraUniforms.tSSGIMap.value = null === (r = this._target) || void 0 === r ? void 0 : r.texture;
          const o = t.materialObject,
                a = !o.transparent && o.transmission < .001;
          let l = this.enabled && a && (this.renderWithCamera || this._renderer.frameCount > 1) && !1 !== n.userData.screenSpaceRendering && !(null === (i = o.userData) || void 0 === i ? void 0 : i.ssrtaoDisabled) && !(null === (s = o.userData) || void 0 === s ? void 0 : s.ssaoDisabled) ? 1 : 0;
          o.defines.SSRTAO_ENABLED !== l && (o.defines.SSRTAO_ENABLED = l, o.needsUpdate = !0), l = this.material.defines.SSGI_ENABLED, o.defines.SSGI_ENABLED !== l && (o.defines.SSGI_ENABLED = l, o.needsUpdate = !0), l = this._target.texture, this.materialExtension.extraUniforms.tSSGIMap.value !== l && (this.materialExtension.extraUniforms.tSSGIMap.value = l, o.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return M`
            uniform float ssaoPower;
            uniform float ssgiIntensity;
            uniform sampler2D tSSGIMap;
            ${U("tSSGIMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2)}

            ${Mo}

        `;
        },
        extraUniforms: {
          tSSGIMap: {
            value: null
          },
          ssaoPower: this.material.uniforms.power,
          ssgiIntensity: this.material.uniforms.intensity
        },
        computeCacheKey: e => {
          var t, n;
          return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2;
        }
      }, this.intensity = 2, this.power = 1.1, this.autoRadius = !0, this.objectRadius = 2, this.tolerance = 1, this.bias = .15, this.falloff = .7, this.rayCount = 2, this.stepCount = 4, this.smoothEnabled = !0, this.renderWithCamera = !0, this.uiConfig = {
        type: "folder",
        label: "SS Global illumination (Dev)",
        children: [...Je(this), {
          type: "checkbox",
          label: "GI Enabled",
          hidden: () => !this._giActivated,
          property: [this, "ssgiEnabled"]
        }]
      }, this._renderer = e, this._target = t, this.needsSwap = !0, this._giActivated = r, this.ssgiEnabled = r, this.bilateralPass = new Ro(this._target, n, "rgba");
    }

    get ssgiEnabled() {
      return parseInt(this.material.defines.SSGI_ENABLED) > .5;
    }

    set ssgiEnabled(e) {
      e = e && this._giActivated, this.material.defines.SSGI_ENABLED = e ? 1 : 0, this.material.needsUpdate = !0;
    }

    render(e, t, n, r, i) {
      this.needsSwap = !1, !this.renderWithCamera && this._renderer.frameCount < 2 || (this._renderer.blit(this._target.texture, t), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this.smoothEnabled && this.bilateralPass.render(e, t, n, r, i));
    }

  }

  fR([xe()], _R.prototype, "bilateralPass", void 0), fR([He("Intensity", [0, 4]), xe(), V()], _R.prototype, "intensity", void 0), fR([He("Power", [0, 3]), xe(), V()], _R.prototype, "power", void 0), fR([Ve("Auto radius"), xe(), V()], _R.prototype, "autoRadius", void 0), fR([He("Object Radius", [.01, 10]), xe(), V()], _R.prototype, "objectRadius", void 0), fR([He("Tolerance", [.1, 5]), xe(), V()], _R.prototype, "tolerance", void 0), fR([He("Bias", [-.3, .3]), xe(), V()], _R.prototype, "bias", void 0), fR([He("Falloff", [1e-4, 4]), xe(), V()], _R.prototype, "falloff", void 0), fR([He("Ray Count", [1, 5], 1), xe(), V()], _R.prototype, "rayCount", void 0), fR([He("Step count", [1, 16], 1), xe(), G("RTAO_STEP_COUNT")], _R.prototype, "stepCount", void 0), fR([Ve("Smooth Enabled"), xe()], _R.prototype, "smoothEnabled", void 0), fR([Ve("Render with Camera")], _R.prototype, "renderWithCamera", void 0);

  class mR extends lo {
    constructor(e = !0) {
      super(), this.dependencies = [js, Xs, po], this._initEnabled = !1, this.setDirty = this.setDirty.bind(this), this._initEnabled = e;
    }

    get rtgiTarget() {
      return this._rtgiTarget;
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.enabled = this._initEnabled, null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }

    set enabled(e) {
      var t;
      (null === (t = this.passes.ssrtgi) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssrtgi.passObject.enabled = e);
    }

    createPasses(e) {
      var t, n, r;
      this._rtgiTarget = e.renderer.createTarget({
        sizeMultiplier: 1
      });
      let i = !1;
      const s = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("debug");
      return s && s.addTexture("SSRTGI", () => {
        var e;
        return null === (e = this._rtgiTarget) || void 0 === e ? void 0 : e.texture;
      }, [40, 100, 400, 200]), [Vs(e, {
        passId: "ssrtgi",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer", "progressive"],
        passObject: new _R(e.renderer, this._rtgiTarget, null !== (r = null === (n = e.getPlugin(Xs)) || void 0 === n ? void 0 : n.getUnpackSnippet()) && void 0 !== r ? r : "", !0),
        update: () => {
          var t;
          let n = this.enabled;

          if (n && !i) {
            const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SSAO");
            (null == e ? void 0 : e.enabled) && (confirm("SSAO Plugin needs to be disabled to enable SSRTGI or SSRTAO. Disable now?") ? e.enabled = !1 : (this.enabled = !1, n = !1));
          }

          i = n, n && this.passes.ssrtgi.passObject.bilateralPass.updateShaderProperties([e.getPlugin(Xs)]);
        }
      }, () => [e.getPlugin(Xs), e.getPlugin(po), e.scene.activeCamera, e.renderer])];
    }

    async onRemove(e) {
      return e.renderer.disposeTarget(this._rtgiTarget), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get uiConfig() {
      var e, t, n, r, i;
      const s = null !== (n = null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
      return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map(e => x(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this.setDirty)), s;
    }

  }

  async function gR(e, {
    debug: t = !1,
    ground: n = !0,
    bloom: r = !0,
    depthTonemap: i = !1,
    importPopup: s = !0
  }) {
    const o = new to(e);
    o.enabled = !1, t && (await o.addPlugin(Ac)), await o.addPlugin(js, void 0, void 0, {
      storage: caches ? await caches.open("webgi-cache-storage") : void 0
    }), await o.addPlugin(Zx), await o.addPlugin(RM), s && (await o.addPlugin(Vm)), await o.addPlugin(px), await o.addPlugin(Gb), await o.addPlugin(qb), await o.addPlugin(Jb), await o.addPlugin(gb), await o.addPlugin(fx), await o.addPlugin(Yb), await o.addPlugin(oo), await o.addPlugin(gc, Aa, !1, !0), await Gm(o, {
      ground: n,
      bloom: r,
      depthTonemap: i
    }), await o.addPlugin(mR, !1), await o.addPlugin(YA, !1), await o.addPlugin(KA), await o.addPlugin(eC), await o.addPlugin(_C), await o.addPlugin(BA), await o.addPlugin(ZA), await o.addPlugin(zA), await o.addPlugin(uT), await o.addPlugin(Du), await o.addPlugin(XC), await o.addPlugin(HC), await o.addPlugin(dR), await o.addPlugin(GC);
    const a = await o.addPlugin(new VC(!Ct()));
    return o.renderer.refreshPipeline(), o.scene.addEventListener("textureAdded", e => {
      e.texture && o.scene.setEnvironment(e.texture);
    }), a.setupPluginUi(io), a.setupPluginUi(oo), a.setupPluginUi(GC), a.setupPluginUi(Zx), a.setupPluginUi(Mc), a.setupPluginUi(Hu), a.setupPluginUi(ZA), a.setupPluginUi(BA), a.setupPluginUi(XC), a.setupPluginUi(zA), a.setupPluginUi(xc), a.setupPluginUi(gc), n && a.setupPluginUi(Yc), a.setupPluginUi(Ao), a.setupPluginUi(Fu), a.setupPluginUi(uT), a.setupPluginUi(mo), a.setupPluginUi(Qu), a.setupPluginUi(Do), a.setupPluginUi(HC), a.setupPluginUi(KA), a.setupPluginUi(eC), a.setupPluginUi(po), a.setupPluginUi(dR), a.setupPluginUi(su), a.setupPluginUi(uu), r && a.setupPluginUi(Qc), a.setupPluginUi(Du), a.setupPluginUi(tu), a.setupPluginUi(Ru), a.setupPluginUi(Xu), a.setupPluginUi(mR), a.setupPluginUi(_C), a.setupPluginUi(_c), a.setupPluginUi(Au), a.setupPluginUi(ym), a.setupPluginUi(mu), a.setupPluginUi(YA), a.setupPluginUi(Vm), a.setupPluginUi(Sm), o.enabled = !0, o;
  }

  mR.PluginType = "SSGI";
}();
var __webpackgi_exports__ACESFilmicToneMapping = __webpackgi_exports__.LY2,
    __webpackgi_exports__AMaterialManager = __webpackgi_exports__.HRj,
    __webpackgi_exports__ARPlacementBox = __webpackgi_exports__.li4,
    __webpackgi_exports__ARPlugin = __webpackgi_exports__.FO5,
    __webpackgi_exports__ARTouchInputHelper = __webpackgi_exports__.Nlh,
    __webpackgi_exports__AViewerPlugin = __webpackgi_exports__.QvI,
    __webpackgi_exports__AddBlendPass = __webpackgi_exports__.JHp,
    __webpackgi_exports__AddEquation = __webpackgi_exports__.bGH,
    __webpackgi_exports__AddOperation = __webpackgi_exports__.NDo,
    __webpackgi_exports__AdditiveAnimationBlendMode = __webpackgi_exports__.gSk,
    __webpackgi_exports__AdditiveBlending = __webpackgi_exports__.WMw,
    __webpackgi_exports__AlphaFormat = __webpackgi_exports__.OTo,
    __webpackgi_exports__AlwaysDepth = __webpackgi_exports__.Se2,
    __webpackgi_exports__AlwaysStencilFunc = __webpackgi_exports__.cum,
    __webpackgi_exports__AmbientLight = __webpackgi_exports__.Mig,
    __webpackgi_exports__AmbientLight2 = __webpackgi_exports__.B$7,
    __webpackgi_exports__AmbientLightProbe = __webpackgi_exports__.i_9,
    __webpackgi_exports__AnimationClip = __webpackgi_exports__.m7l,
    __webpackgi_exports__AnimationLoader = __webpackgi_exports__.sYA,
    __webpackgi_exports__AnimationMixer = __webpackgi_exports__.Xcj,
    __webpackgi_exports__AnimationObjectGroup = __webpackgi_exports__.mzJ,
    __webpackgi_exports__AnimationUtils = __webpackgi_exports__.ZZA,
    __webpackgi_exports__AnisotropyPlugin = __webpackgi_exports__.$Ph,
    __webpackgi_exports__ArcCurve = __webpackgi_exports__.T__,
    __webpackgi_exports__ArrayCamera = __webpackgi_exports__.HkE,
    __webpackgi_exports__ArrowHelper = __webpackgi_exports__.tGC,
    __webpackgi_exports__AssetExporter = __webpackgi_exports__.g1S,
    __webpackgi_exports__AssetExporterPlugin = __webpackgi_exports__.I$C,
    __webpackgi_exports__AssetImporter = __webpackgi_exports__.QIH,
    __webpackgi_exports__AssetManagerBasicPopupPlugin = __webpackgi_exports__._JE,
    __webpackgi_exports__AssetManagerPlugin = __webpackgi_exports__.ksm,
    __webpackgi_exports__AsyncCompress = __webpackgi_exports__.jl_,
    __webpackgi_exports__AsyncDecompress = __webpackgi_exports__.b7R,
    __webpackgi_exports__AsyncDeflate = __webpackgi_exports__.BDV,
    __webpackgi_exports__AsyncGunzip = __webpackgi_exports__.Ea_,
    __webpackgi_exports__AsyncGzip = __webpackgi_exports__.qff,
    __webpackgi_exports__AsyncInflate = __webpackgi_exports__.tmC,
    __webpackgi_exports__AsyncUnzipInflate = __webpackgi_exports__.BON,
    __webpackgi_exports__AsyncUnzlib = __webpackgi_exports__.P40,
    __webpackgi_exports__AsyncZipDeflate = __webpackgi_exports__.wLL,
    __webpackgi_exports__AsyncZlib = __webpackgi_exports__.iHO,
    __webpackgi_exports__Audio = __webpackgi_exports__.BbS,
    __webpackgi_exports__AudioAnalyser = __webpackgi_exports__.kqm,
    __webpackgi_exports__AudioContext = __webpackgi_exports__.Hmr,
    __webpackgi_exports__AudioListener = __webpackgi_exports__.SJI,
    __webpackgi_exports__AudioLoader = __webpackgi_exports__.mTL,
    __webpackgi_exports__AxesHelper = __webpackgi_exports__.y8_,
    __webpackgi_exports__BackSide = __webpackgi_exports__._Li,
    __webpackgi_exports__BaseGroundPlugin = __webpackgi_exports__.g56,
    __webpackgi_exports__BaseRenderer = __webpackgi_exports__.bj3,
    __webpackgi_exports__BasicDepthPacking = __webpackgi_exports__.z81,
    __webpackgi_exports__BasicShadowMap = __webpackgi_exports__._MY,
    __webpackgi_exports__BlobLoader = __webpackgi_exports__.yEv,
    __webpackgi_exports__BloomPlugin = __webpackgi_exports__.dFZ,
    __webpackgi_exports__Bone = __webpackgi_exports__.N$j,
    __webpackgi_exports__BooleanKeyframeTrack = __webpackgi_exports__._YM,
    __webpackgi_exports__Box2 = __webpackgi_exports__.TUj,
    __webpackgi_exports__Box3 = __webpackgi_exports__.ZzF,
    __webpackgi_exports__Box3B = __webpackgi_exports__.qzb,
    __webpackgi_exports__Box3Helper = __webpackgi_exports__.GQ,
    __webpackgi_exports__BoxBufferGeometry = __webpackgi_exports__.nvb,
    __webpackgi_exports__BoxGeometry = __webpackgi_exports__.DvJ,
    __webpackgi_exports__BoxHelper = __webpackgi_exports__.fQA,
    __webpackgi_exports__BoxSelectionWidget = __webpackgi_exports__.cPz,
    __webpackgi_exports__BufferAttribute = __webpackgi_exports__.TlE,
    __webpackgi_exports__BufferGeometry = __webpackgi_exports__.u9r,
    __webpackgi_exports__BufferGeometryLoader = __webpackgi_exports__.s4_,
    __webpackgi_exports__ByteType = __webpackgi_exports__.T95,
    __webpackgi_exports__Cache = __webpackgi_exports__.CtF,
    __webpackgi_exports__Camera = __webpackgi_exports__.V1s,
    __webpackgi_exports__CameraController = __webpackgi_exports__.jOv,
    __webpackgi_exports__CameraHelper = __webpackgi_exports__.Rki,
    __webpackgi_exports__CameraView = __webpackgi_exports__.itZ,
    __webpackgi_exports__CameraViewPlugin = __webpackgi_exports__.qKx,
    __webpackgi_exports__CanvasRecorder = __webpackgi_exports__.vlJ,
    __webpackgi_exports__CanvasRecorderPlugin = __webpackgi_exports__.nPO,
    __webpackgi_exports__CanvasSnipper = __webpackgi_exports__.zcQ,
    __webpackgi_exports__CanvasSnipperPlugin = __webpackgi_exports__.GH1,
    __webpackgi_exports__CanvasTexture = __webpackgi_exports__.ROQ,
    __webpackgi_exports__CapsuleBufferGeometry = __webpackgi_exports__.YN5,
    __webpackgi_exports__CapsuleGeometry = __webpackgi_exports__.BVQ,
    __webpackgi_exports__CatmullRomCurve3 = __webpackgi_exports__.YT8,
    __webpackgi_exports__CineonToneMapping = __webpackgi_exports__.YGz,
    __webpackgi_exports__CircleBufferGeometry = __webpackgi_exports__.trn,
    __webpackgi_exports__CircleGeometry = __webpackgi_exports__.zf8,
    __webpackgi_exports__ClampToEdgeWrapping = __webpackgi_exports__.uWy,
    __webpackgi_exports__Clock = __webpackgi_exports__.SUY,
    __webpackgi_exports__Color = __webpackgi_exports__.Ilk,
    __webpackgi_exports__ColorKeyframeTrack = __webpackgi_exports__.R2R,
    __webpackgi_exports__ColorManagement = __webpackgi_exports__.epp,
    __webpackgi_exports__Compress = __webpackgi_exports__.GD$,
    __webpackgi_exports__CompressedTexture = __webpackgi_exports__.EB7,
    __webpackgi_exports__CompressedTextureLoader = __webpackgi_exports__.DqL,
    __webpackgi_exports__ConeBufferGeometry = __webpackgi_exports__._3,
    __webpackgi_exports__ConeGeometry = __webpackgi_exports__.b_z,
    __webpackgi_exports__ContactShadowGroundPlugin = __webpackgi_exports__.OCn,
    __webpackgi_exports__CubeCamera = __webpackgi_exports__._am,
    __webpackgi_exports__CubeNormalsCaptureHelper = __webpackgi_exports__.kB7,
    __webpackgi_exports__CubeReflectionMapping = __webpackgi_exports__.fY$,
    __webpackgi_exports__CubeRefractionMapping = __webpackgi_exports__.vxC,
    __webpackgi_exports__CubeTexture = __webpackgi_exports__.BtG,
    __webpackgi_exports__CubeTextureLoader = __webpackgi_exports__.cBK,
    __webpackgi_exports__CubeUVReflectionMapping = __webpackgi_exports__.g8_,
    __webpackgi_exports__CubicBezierCurve = __webpackgi_exports__.AXT,
    __webpackgi_exports__CubicBezierCurve3 = __webpackgi_exports__.yj7,
    __webpackgi_exports__CubicInterpolant = __webpackgi_exports__.dYG,
    __webpackgi_exports__CullFaceBack = __webpackgi_exports__.tm_,
    __webpackgi_exports__CullFaceFront = __webpackgi_exports__.S2y,
    __webpackgi_exports__CullFaceFrontBack = __webpackgi_exports__.B02,
    __webpackgi_exports__CullFaceNone = __webpackgi_exports__.PeU,
    __webpackgi_exports__Curve = __webpackgi_exports__.Hyl,
    __webpackgi_exports__CurvePath = __webpackgi_exports__.Wqd,
    __webpackgi_exports__CustomBlending = __webpackgi_exports__.Xaj,
    __webpackgi_exports__CustomBumpMapPlugin = __webpackgi_exports__.DUb,
    __webpackgi_exports__CustomToneMapping = __webpackgi_exports__.dZ3,
    __webpackgi_exports__CylinderBufferGeometry = __webpackgi_exports__.m_w,
    __webpackgi_exports__CylinderGeometry = __webpackgi_exports__.fHI,
    __webpackgi_exports__Cylindrical = __webpackgi_exports__.LBq,
    __webpackgi_exports__DECAY_MILLISECONDS = __webpackgi_exports__.dHf,
    __webpackgi_exports__DRACOLoader2 = __webpackgi_exports__.Qww,
    __webpackgi_exports__Damper = __webpackgi_exports__.CGV,
    __webpackgi_exports__Data3DTexture = __webpackgi_exports__.JUT,
    __webpackgi_exports__DataArrayTexture = __webpackgi_exports__.p3g,
    __webpackgi_exports__DataTexture = __webpackgi_exports__.IEO,
    __webpackgi_exports__DataTexture2DArray = __webpackgi_exports__.CN8,
    __webpackgi_exports__DataTexture3D = __webpackgi_exports__.zob,
    __webpackgi_exports__DataTextureLoader = __webpackgi_exports__.yxD,
    __webpackgi_exports__DataUrlLoader = __webpackgi_exports__.CUS,
    __webpackgi_exports__DataUtils = __webpackgi_exports__.A5E,
    __webpackgi_exports__DebugPlugin = __webpackgi_exports__.zqG,
    __webpackgi_exports__DecodeUTF8 = __webpackgi_exports__.PfX,
    __webpackgi_exports__Decompress = __webpackgi_exports__.Q1o,
    __webpackgi_exports__DecrementStencilOp = __webpackgi_exports__.jfJ,
    __webpackgi_exports__DecrementWrapStencilOp = __webpackgi_exports__.T_J,
    __webpackgi_exports__DefaultLoadingManager = __webpackgi_exports__.tEQ,
    __webpackgi_exports__Deflate = __webpackgi_exports__.gb4,
    __webpackgi_exports__DepthFormat = __webpackgi_exports__.qkB,
    __webpackgi_exports__DepthOfFieldPass = __webpackgi_exports__.cvk,
    __webpackgi_exports__DepthOfFieldPlugin = __webpackgi_exports__.HWo,
    __webpackgi_exports__DepthStencilFormat = __webpackgi_exports__.brP,
    __webpackgi_exports__DepthTexture = __webpackgi_exports__.$YQ,
    __webpackgi_exports__DiamondMaterial = __webpackgi_exports__.yNB,
    __webpackgi_exports__DiamondPlugin = __webpackgi_exports__.h7x,
    __webpackgi_exports__DirectionalLight = __webpackgi_exports__.Ox3,
    __webpackgi_exports__DirectionalLight2 = __webpackgi_exports__.qtn,
    __webpackgi_exports__DirectionalLightHelper = __webpackgi_exports__.cBI,
    __webpackgi_exports__DiscreteInterpolant = __webpackgi_exports__.cU9,
    __webpackgi_exports__DodecahedronBufferGeometry = __webpackgi_exports__.DT1,
    __webpackgi_exports__DodecahedronGeometry = __webpackgi_exports__.Kgo,
    __webpackgi_exports__DoubleSide = __webpackgi_exports__.ehD,
    __webpackgi_exports__Dropzone = __webpackgi_exports__.fhJ,
    __webpackgi_exports__DropzonePlugin = __webpackgi_exports__.y1s,
    __webpackgi_exports__DstAlphaFactor = __webpackgi_exports__.fSK,
    __webpackgi_exports__DstColorFactor = __webpackgi_exports__.Vdb,
    __webpackgi_exports__DynamicCopyUsage = __webpackgi_exports__.l8J,
    __webpackgi_exports__DynamicDrawUsage = __webpackgi_exports__.dj0,
    __webpackgi_exports__DynamicReadUsage = __webpackgi_exports__.QM0,
    __webpackgi_exports__EXRLoadPlugin = __webpackgi_exports__.OIS,
    __webpackgi_exports__EasingFunctions = __webpackgi_exports__.q8b,
    __webpackgi_exports__EdgesGeometry = __webpackgi_exports__.TOt,
    __webpackgi_exports__EffectComposer2 = __webpackgi_exports__.xaN,
    __webpackgi_exports__EllipseCurve = __webpackgi_exports__.Ny0,
    __webpackgi_exports__EncodeUTF8 = __webpackgi_exports__.Zof,
    __webpackgi_exports__EqualDepth = __webpackgi_exports__.eD,
    __webpackgi_exports__EqualStencilFunc = __webpackgi_exports__.jwo,
    __webpackgi_exports__EquirectangularReflectionMapping = __webpackgi_exports__.dSO,
    __webpackgi_exports__EquirectangularRefractionMapping = __webpackgi_exports__.Bf4,
    __webpackgi_exports__Euler = __webpackgi_exports__.USm,
    __webpackgi_exports__EventDispatcher = __webpackgi_exports__.pBf,
    __webpackgi_exports__ExtrudeBufferGeometry = __webpackgi_exports__.$Vf,
    __webpackgi_exports__ExtrudeGeometry = __webpackgi_exports__.O7d,
    __webpackgi_exports__FBXLoadPlugin = __webpackgi_exports__.ksq,
    __webpackgi_exports__FSShadowMaterial = __webpackgi_exports__.gXf,
    __webpackgi_exports__FileLoader = __webpackgi_exports__.hH6,
    __webpackgi_exports__FlatShading = __webpackgi_exports__.esl,
    __webpackgi_exports__Float16BufferAttribute = __webpackgi_exports__.e62,
    __webpackgi_exports__Float32BufferAttribute = __webpackgi_exports__.a$l,
    __webpackgi_exports__Float64BufferAttribute = __webpackgi_exports__.OM3,
    __webpackgi_exports__FloatType = __webpackgi_exports__.VzW,
    __webpackgi_exports__Fog = __webpackgi_exports__.ybr,
    __webpackgi_exports__FogExp2 = __webpackgi_exports__.yo9,
    __webpackgi_exports__Font = __webpackgi_exports__.Zxw,
    __webpackgi_exports__FontLoader = __webpackgi_exports__.JfN,
    __webpackgi_exports__FrameFadePlugin = __webpackgi_exports__.$Bt,
    __webpackgi_exports__FramebufferTexture = __webpackgi_exports__.Wzm,
    __webpackgi_exports__FrontSide = __webpackgi_exports__.Wl3,
    __webpackgi_exports__Frustum = __webpackgi_exports__.iWj,
    __webpackgi_exports__FullScreenPlugin = __webpackgi_exports__.DNz,
    __webpackgi_exports__GBufferPlugin = __webpackgi_exports__.m1M,
    __webpackgi_exports__GLBufferAttribute = __webpackgi_exports__.ylh,
    __webpackgi_exports__GLSL1 = __webpackgi_exports__.v9Y,
    __webpackgi_exports__GLSL3 = __webpackgi_exports__.LSk,
    __webpackgi_exports__GLTFAnimationPlugin = __webpackgi_exports__.LHE,
    __webpackgi_exports__GLTFDracoExportPlugin = __webpackgi_exports__.KE0,
    __webpackgi_exports__GLTFDracoExporter = __webpackgi_exports__.KCF,
    __webpackgi_exports__GLTFExporter2 = __webpackgi_exports__.a4n,
    __webpackgi_exports__GLTFLoader2 = __webpackgi_exports__.zIH,
    __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__.Hfk,
    __webpackgi_exports__GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__.png,
    __webpackgi_exports__GLTFMaterialsLightMapExtensionName = __webpackgi_exports__.Eb_,
    __webpackgi_exports__GLTFMeshOptPlugin = __webpackgi_exports__.BT2,
    __webpackgi_exports__GLTFWriter2 = __webpackgi_exports__._8p,
    __webpackgi_exports__GenericBlendTexturePass = __webpackgi_exports__.hkn,
    __webpackgi_exports__GenericFilterPlugin = __webpackgi_exports__.GFY,
    __webpackgi_exports__GreaterDepth = __webpackgi_exports__.w$m,
    __webpackgi_exports__GreaterEqualDepth = __webpackgi_exports__.ksN,
    __webpackgi_exports__GreaterEqualStencilFunc = __webpackgi_exports__.j4z,
    __webpackgi_exports__GreaterStencilFunc = __webpackgi_exports__.OAl,
    __webpackgi_exports__GridHelper = __webpackgi_exports__.VLJ,
    __webpackgi_exports__GroundPlugin = __webpackgi_exports__.C73,
    __webpackgi_exports__Group = __webpackgi_exports__.ZAu,
    __webpackgi_exports__Gunzip = __webpackgi_exports__.ibP,
    __webpackgi_exports__Gzip = __webpackgi_exports__._fI,
    __webpackgi_exports__HDRiGroundPlugin = __webpackgi_exports__.hUN,
    __webpackgi_exports__HalfFloatType = __webpackgi_exports__.cLu,
    __webpackgi_exports__HemisphereLight = __webpackgi_exports__.vmT,
    __webpackgi_exports__HemisphereLightHelper = __webpackgi_exports__.Qpg,
    __webpackgi_exports__HemisphereLightProbe = __webpackgi_exports__.So8,
    __webpackgi_exports__HierarchyUiPlugin = __webpackgi_exports__.eOv,
    __webpackgi_exports__IcosahedronBufferGeometry = __webpackgi_exports__.Wjw,
    __webpackgi_exports__IcosahedronGeometry = __webpackgi_exports__.cJO,
    __webpackgi_exports__ImageBitmapLoader = __webpackgi_exports__.QRU,
    __webpackgi_exports__ImageLoader = __webpackgi_exports__.S3k,
    __webpackgi_exports__ImageUtils = __webpackgi_exports__.PpQ,
    __webpackgi_exports__ImmediateRenderObject = __webpackgi_exports__.AHu,
    __webpackgi_exports__Importer = __webpackgi_exports__.q_9,
    __webpackgi_exports__IncrementStencilOp = __webpackgi_exports__.ZRs,
    __webpackgi_exports__IncrementWrapStencilOp = __webpackgi_exports__.oqc,
    __webpackgi_exports__Inflate = __webpackgi_exports__.T_x,
    __webpackgi_exports__InstancedBufferAttribute = __webpackgi_exports__.lb7,
    __webpackgi_exports__InstancedBufferGeometry = __webpackgi_exports__.L5s,
    __webpackgi_exports__InstancedInterleavedBuffer = __webpackgi_exports__.$TI,
    __webpackgi_exports__InstancedMesh = __webpackgi_exports__.SPe,
    __webpackgi_exports__Int16BufferAttribute = __webpackgi_exports__.aVm,
    __webpackgi_exports__Int32BufferAttribute = __webpackgi_exports__.j87,
    __webpackgi_exports__Int8BufferAttribute = __webpackgi_exports__.RNb,
    __webpackgi_exports__IntType = __webpackgi_exports__.Kz5,
    __webpackgi_exports__InterleavedBuffer = __webpackgi_exports__.vpT,
    __webpackgi_exports__InterleavedBufferAttribute = __webpackgi_exports__.kB5,
    __webpackgi_exports__Interpolant = __webpackgi_exports__._C8,
    __webpackgi_exports__InterpolateDiscrete = __webpackgi_exports__.Syv,
    __webpackgi_exports__InterpolateLinear = __webpackgi_exports__.NMF,
    __webpackgi_exports__InterpolateSmooth = __webpackgi_exports__.pIN,
    __webpackgi_exports__InvertStencilOp = __webpackgi_exports__.eMJ,
    __webpackgi_exports__KHR_TEXTURE_BASISU = __webpackgi_exports__.rN7,
    __webpackgi_exports__KTX2LoadPlugin = __webpackgi_exports__.iUp,
    __webpackgi_exports__KTXLoadPlugin = __webpackgi_exports__.GFd,
    __webpackgi_exports__KeepStencilOp = __webpackgi_exports__.x5V,
    __webpackgi_exports__KeyframeTrack = __webpackgi_exports__.tUh,
    __webpackgi_exports__LOD = __webpackgi_exports__.z8B,
    __webpackgi_exports__LatheBufferGeometry = __webpackgi_exports__.GZb,
    __webpackgi_exports__LatheGeometry = __webpackgi_exports__.p7y,
    __webpackgi_exports__Layers = __webpackgi_exports__.S9g,
    __webpackgi_exports__LessDepth = __webpackgi_exports__.Zr5,
    __webpackgi_exports__LessEqualDepth = __webpackgi_exports__.vCF,
    __webpackgi_exports__LessEqualStencilFunc = __webpackgi_exports__.yt0,
    __webpackgi_exports__LessStencilFunc = __webpackgi_exports__.uXU,
    __webpackgi_exports__Light = __webpackgi_exports__._kC,
    __webpackgi_exports__LightProbe = __webpackgi_exports__.lk7,
    __webpackgi_exports__Line = __webpackgi_exports__.x12,
    __webpackgi_exports__Line3 = __webpackgi_exports__.Zzh,
    __webpackgi_exports__LineBasicMaterial = __webpackgi_exports__.nls,
    __webpackgi_exports__LineCurve = __webpackgi_exports__.g_z,
    __webpackgi_exports__LineCurve3 = __webpackgi_exports__.U7,
    __webpackgi_exports__LineDashedMaterial = __webpackgi_exports__.FT0,
    __webpackgi_exports__LineLoop = __webpackgi_exports__.blk,
    __webpackgi_exports__LineSegments = __webpackgi_exports__.ejS,
    __webpackgi_exports__LinearEncoding = __webpackgi_exports__.rnI,
    __webpackgi_exports__LinearFilter = __webpackgi_exports__.wem,
    __webpackgi_exports__LinearInterpolant = __webpackgi_exports__.lfu,
    __webpackgi_exports__LinearMipMapLinearFilter = __webpackgi_exports__.FDw,
    __webpackgi_exports__LinearMipMapNearestFilter = __webpackgi_exports__.lRj,
    __webpackgi_exports__LinearMipmapLinearFilter = __webpackgi_exports__.D1R,
    __webpackgi_exports__LinearMipmapNearestFilter = __webpackgi_exports__.qyh,
    __webpackgi_exports__LinearSRGBColorSpace = __webpackgi_exports__.GUF,
    __webpackgi_exports__LinearToneMapping = __webpackgi_exports__.EoG,
    __webpackgi_exports__Loader = __webpackgi_exports__.aNw,
    __webpackgi_exports__LoaderUtils = __webpackgi_exports__.Zp0,
    __webpackgi_exports__LoadingManager = __webpackgi_exports__.lLk,
    __webpackgi_exports__LoopOnce = __webpackgi_exports__.jAl,
    __webpackgi_exports__LoopPingPong = __webpackgi_exports__.uEv,
    __webpackgi_exports__LoopRepeat = __webpackgi_exports__.YKA,
    __webpackgi_exports__LuminanceAlphaFormat = __webpackgi_exports__.cRx,
    __webpackgi_exports__LuminanceFormat = __webpackgi_exports__.Y8D,
    __webpackgi_exports__MOUSE = __webpackgi_exports__.RsA,
    __webpackgi_exports__MTLLoader2 = __webpackgi_exports__.Y0m,
    __webpackgi_exports__Material = __webpackgi_exports__.F5T,
    __webpackgi_exports__MaterialConfiguratorBasePlugin = __webpackgi_exports__.EDU,
    __webpackgi_exports__MaterialConfiguratorPlugin = __webpackgi_exports__.z$Q,
    __webpackgi_exports__MaterialExtender = __webpackgi_exports__.KA8,
    __webpackgi_exports__MaterialLibraryBasePlugin = __webpackgi_exports__.XUj,
    __webpackgi_exports__MaterialLibraryPlugin = __webpackgi_exports__.Me$,
    __webpackgi_exports__MaterialLoader = __webpackgi_exports__.u7G,
    __webpackgi_exports__MaterialManager = __webpackgi_exports__.PEk,
    __webpackgi_exports__MaterialPreviewGenerator = __webpackgi_exports__.BG4,
    __webpackgi_exports__MathUtils = __webpackgi_exports__.M8C,
    __webpackgi_exports__Matrix3 = __webpackgi_exports__.Vkp,
    __webpackgi_exports__Matrix4 = __webpackgi_exports__.yGw,
    __webpackgi_exports__MaxEquation = __webpackgi_exports__.Sm8,
    __webpackgi_exports__Mesh = __webpackgi_exports__.Kj0,
    __webpackgi_exports__MeshBasicMaterial = __webpackgi_exports__.vBJ,
    __webpackgi_exports__MeshDepthMaterial = __webpackgi_exports__.lRF,
    __webpackgi_exports__MeshDistanceMaterial = __webpackgi_exports__.Lun,
    __webpackgi_exports__MeshLambertMaterial = __webpackgi_exports__.YBo,
    __webpackgi_exports__MeshMatcapMaterial = __webpackgi_exports__.kaV,
    __webpackgi_exports__MeshNormalMaterial = __webpackgi_exports__.RSm,
    __webpackgi_exports__MeshPhongMaterial = __webpackgi_exports__.xoR,
    __webpackgi_exports__MeshPhysicalMaterial = __webpackgi_exports__.EJi,
    __webpackgi_exports__MeshStandardMaterial = __webpackgi_exports__.Wid,
    __webpackgi_exports__MeshStandardMaterial2 = __webpackgi_exports__.iuj,
    __webpackgi_exports__MeshToonMaterial = __webpackgi_exports__.IKL,
    __webpackgi_exports__MinEquation = __webpackgi_exports__.r_,
    __webpackgi_exports__MirroredRepeatWrapping = __webpackgi_exports__.OoA,
    __webpackgi_exports__MixOperation = __webpackgi_exports__.qhX,
    __webpackgi_exports__MultiFilterPlugin = __webpackgi_exports__.qPT,
    __webpackgi_exports__MultiplyBlending = __webpackgi_exports__.M5h,
    __webpackgi_exports__MultiplyOperation = __webpackgi_exports__.Ns1,
    __webpackgi_exports__NearestFilter = __webpackgi_exports__.TyD,
    __webpackgi_exports__NearestMipMapLinearFilter = __webpackgi_exports__.vZf,
    __webpackgi_exports__NearestMipMapNearestFilter = __webpackgi_exports__.HTd,
    __webpackgi_exports__NearestMipmapLinearFilter = __webpackgi_exports__.aH4,
    __webpackgi_exports__NearestMipmapNearestFilter = __webpackgi_exports__.YLQ,
    __webpackgi_exports__NeverDepth = __webpackgi_exports__.BVF,
    __webpackgi_exports__NeverStencilFunc = __webpackgi_exports__.MyG,
    __webpackgi_exports__NoBlending = __webpackgi_exports__.jFi,
    __webpackgi_exports__NoColorSpace = __webpackgi_exports__.aCh,
    __webpackgi_exports__NoToneMapping = __webpackgi_exports__.uL9,
    __webpackgi_exports__NoiseBumpMaterialPlugin = __webpackgi_exports__.TNj,
    __webpackgi_exports__NormalAnimationBlendMode = __webpackgi_exports__.IFH,
    __webpackgi_exports__NormalBlending = __webpackgi_exports__.bdR,
    __webpackgi_exports__NormalCaptureMaterial = __webpackgi_exports__.kM_,
    __webpackgi_exports__NotEqualDepth = __webpackgi_exports__.M6v,
    __webpackgi_exports__NotEqualStencilFunc = __webpackgi_exports__.RvT,
    __webpackgi_exports__NumberKeyframeTrack = __webpackgi_exports__.dUE,
    __webpackgi_exports__OBJLoader2 = __webpackgi_exports__.oe_,
    __webpackgi_exports__ObjMtlLoadPlugin = __webpackgi_exports__.BuN,
    __webpackgi_exports__Object3D = __webpackgi_exports__.Tme,
    __webpackgi_exports__Object3DModel = __webpackgi_exports__.N9P,
    __webpackgi_exports__ObjectLoader = __webpackgi_exports__.Gql,
    __webpackgi_exports__ObjectLoader2 = __webpackgi_exports__.$XY,
    __webpackgi_exports__ObjectPicker = __webpackgi_exports__.O9d,
    __webpackgi_exports__ObjectProcessorMap = __webpackgi_exports__.zEO,
    __webpackgi_exports__ObjectRotationPlugin = __webpackgi_exports__.qfx,
    __webpackgi_exports__ObjectSpaceNormalMap = __webpackgi_exports__.PA7,
    __webpackgi_exports__OctahedronBufferGeometry = __webpackgi_exports__.REq,
    __webpackgi_exports__OctahedronGeometry = __webpackgi_exports__.pQR,
    __webpackgi_exports__OneFactor = __webpackgi_exports__.ghN,
    __webpackgi_exports__OneMinusDstAlphaFactor = __webpackgi_exports__.Hy8,
    __webpackgi_exports__OneMinusDstColorFactor = __webpackgi_exports__.Wpd,
    __webpackgi_exports__OneMinusSrcAlphaFactor = __webpackgi_exports__.LgZ,
    __webpackgi_exports__OneMinusSrcColorFactor = __webpackgi_exports__.iWC,
    __webpackgi_exports__OrbitControls2 = __webpackgi_exports__.mqn,
    __webpackgi_exports__OrthographicCamera = __webpackgi_exports__.iKG,
    __webpackgi_exports__PCFShadowMap = __webpackgi_exports__._iA,
    __webpackgi_exports__PCFSoftShadowMap = __webpackgi_exports__.ntZ,
    __webpackgi_exports__PMREMGenerator = __webpackgi_exports__.anP,
    __webpackgi_exports__PMREMGeneratorPlugin = __webpackgi_exports__.X2e,
    __webpackgi_exports__ParallaxMappingPlugin = __webpackgi_exports__.FCo,
    __webpackgi_exports__ParametricGeometry = __webpackgi_exports__.jjw,
    __webpackgi_exports__Path = __webpackgi_exports__.y$t,
    __webpackgi_exports__PerspectiveCamera = __webpackgi_exports__.cPb,
    __webpackgi_exports__PickingPlugin = __webpackgi_exports__.lmx,
    __webpackgi_exports__Plane = __webpackgi_exports__.JOQ,
    __webpackgi_exports__PlaneBufferGeometry = __webpackgi_exports__.BKK,
    __webpackgi_exports__PlaneGeometry = __webpackgi_exports__._12,
    __webpackgi_exports__PlaneHelper = __webpackgi_exports__.tJx,
    __webpackgi_exports__PointLight = __webpackgi_exports__.cek,
    __webpackgi_exports__PointLightHelper = __webpackgi_exports__.xG9,
    __webpackgi_exports__Points = __webpackgi_exports__.woe,
    __webpackgi_exports__PointsMaterial = __webpackgi_exports__.UY4,
    __webpackgi_exports__PolarGridHelper = __webpackgi_exports__.aq0,
    __webpackgi_exports__PolyhedronBufferGeometry = __webpackgi_exports__.ujx,
    __webpackgi_exports__PolyhedronGeometry = __webpackgi_exports__.Uol,
    __webpackgi_exports__PopmotionPlugin = __webpackgi_exports__.JiH,
    __webpackgi_exports__PositionalAudio = __webpackgi_exports__.VYz,
    __webpackgi_exports__ProgressivePlugin = __webpackgi_exports__.EsW,
    __webpackgi_exports__PropertyBinding = __webpackgi_exports__.iUV,
    __webpackgi_exports__PropertyMixer = __webpackgi_exports__.tf,
    __webpackgi_exports__QuadraticBezierCurve = __webpackgi_exports__.ZQ6,
    __webpackgi_exports__QuadraticBezierCurve3 = __webpackgi_exports__.mXe,
    __webpackgi_exports__Quaternion = __webpackgi_exports__._fP,
    __webpackgi_exports__QuaternionKeyframeTrack = __webpackgi_exports__.iLg,
    __webpackgi_exports__QuaternionLinearInterpolant = __webpackgi_exports__.zbs,
    __webpackgi_exports__REVISION = __webpackgi_exports__.UZH,
    __webpackgi_exports__RGBADepthPacking = __webpackgi_exports__.mSO,
    __webpackgi_exports__RGBAFormat = __webpackgi_exports__.wk1,
    __webpackgi_exports__RGBAIntegerFormat = __webpackgi_exports__.E2K,
    __webpackgi_exports__RGBA_ASTC_10x10_Format = __webpackgi_exports__.FUD,
    __webpackgi_exports__RGBA_ASTC_10x5_Format = __webpackgi_exports__.pKu,
    __webpackgi_exports__RGBA_ASTC_10x6_Format = __webpackgi_exports__.GG6,
    __webpackgi_exports__RGBA_ASTC_10x8_Format = __webpackgi_exports__.Gih,
    __webpackgi_exports__RGBA_ASTC_12x10_Format = __webpackgi_exports__.iiP,
    __webpackgi_exports__RGBA_ASTC_12x12_Format = __webpackgi_exports__.SvJ,
    __webpackgi_exports__RGBA_ASTC_4x4_Format = __webpackgi_exports__.ptH,
    __webpackgi_exports__RGBA_ASTC_5x4_Format = __webpackgi_exports__.jZA,
    __webpackgi_exports__RGBA_ASTC_5x5_Format = __webpackgi_exports__.y2t,
    __webpackgi_exports__RGBA_ASTC_6x5_Format = __webpackgi_exports__.gi4,
    __webpackgi_exports__RGBA_ASTC_6x6_Format = __webpackgi_exports__.Djp,
    __webpackgi_exports__RGBA_ASTC_8x5_Format = __webpackgi_exports__.BG$,
    __webpackgi_exports__RGBA_ASTC_8x6_Format = __webpackgi_exports__.NYV,
    __webpackgi_exports__RGBA_ASTC_8x8_Format = __webpackgi_exports__.xJs,
    __webpackgi_exports__RGBA_BPTC_Format = __webpackgi_exports__.bsb,
    __webpackgi_exports__RGBA_ETC2_EAC_Format = __webpackgi_exports__.ekQ,
    __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__.CaW,
    __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__.eaV,
    __webpackgi_exports__RGBA_S3TC_DXT1_Format = __webpackgi_exports__.BFQ,
    __webpackgi_exports__RGBA_S3TC_DXT3_Format = __webpackgi_exports__.v3W,
    __webpackgi_exports__RGBA_S3TC_DXT5_Format = __webpackgi_exports__.ILR,
    __webpackgi_exports__RGBFormat = __webpackgi_exports__.UCm,
    __webpackgi_exports__RGBM16Encoding = __webpackgi_exports__.Inb,
    __webpackgi_exports__RGBM7Encoding = __webpackgi_exports__.LgE,
    __webpackgi_exports__RGB_ETC1_Format = __webpackgi_exports__.fto,
    __webpackgi_exports__RGB_ETC2_Format = __webpackgi_exports__.l0P,
    __webpackgi_exports__RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__.vCx,
    __webpackgi_exports__RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__._AM,
    __webpackgi_exports__RGB_S3TC_DXT1_Format = __webpackgi_exports__.wuA,
    __webpackgi_exports__RGFormat = __webpackgi_exports__.av9,
    __webpackgi_exports__RGIntegerFormat = __webpackgi_exports__.CtA,
    __webpackgi_exports__RandomizedDirectionalLight = __webpackgi_exports__.BvQ,
    __webpackgi_exports__RandomizedDirectionalLightPlugin = __webpackgi_exports__.FZJ,
    __webpackgi_exports__RawShaderMaterial = __webpackgi_exports__.FIo,
    __webpackgi_exports__Ray = __webpackgi_exports__.zHn,
    __webpackgi_exports__Raycaster = __webpackgi_exports__.iMs,
    __webpackgi_exports__RectAreaLight = __webpackgi_exports__.T_f,
    __webpackgi_exports__RedFormat = __webpackgi_exports__.hEm,
    __webpackgi_exports__RedIntegerFormat = __webpackgi_exports__.D9w,
    __webpackgi_exports__Reflector2 = __webpackgi_exports__.sHH,
    __webpackgi_exports__ReinhardToneMapping = __webpackgi_exports__.CdI,
    __webpackgi_exports__RepeatWrapping = __webpackgi_exports__.rpg,
    __webpackgi_exports__ReplaceStencilOp = __webpackgi_exports__.ce8,
    __webpackgi_exports__ReverseSubtractEquation = __webpackgi_exports__.rOj,
    __webpackgi_exports__Rhino3dmLoadPlugin = __webpackgi_exports__.P6m,
    __webpackgi_exports__Rhino3dmLoader2 = __webpackgi_exports__.JA6,
    __webpackgi_exports__RingBufferGeometry = __webpackgi_exports__.V4E,
    __webpackgi_exports__RingGeometry = __webpackgi_exports__.o8S,
    __webpackgi_exports__RootScene = __webpackgi_exports__.flB,
    __webpackgi_exports__SETTLING_TIME = __webpackgi_exports__.DUH,
    __webpackgi_exports__SRGBColorSpace = __webpackgi_exports__.KI_,
    __webpackgi_exports__SSAOPlugin = __webpackgi_exports__.iLN,
    __webpackgi_exports__SSContactShadows = __webpackgi_exports__.jsw,
    __webpackgi_exports__SSRPlugin = __webpackgi_exports__.i6Z,
    __webpackgi_exports__STLLoadPlugin = __webpackgi_exports__.vfv,
    __webpackgi_exports__Scene = __webpackgi_exports__.xsS,
    __webpackgi_exports__SelectionWidget = __webpackgi_exports__.ov0,
    __webpackgi_exports__SerializableOrbitControls = __webpackgi_exports__.cQH,
    __webpackgi_exports__ShaderChunk = __webpackgi_exports__.WdD,
    __webpackgi_exports__ShaderLib = __webpackgi_exports__.Vj0,
    __webpackgi_exports__ShaderMaterial = __webpackgi_exports__.jyz,
    __webpackgi_exports__ShaderMaterialEncodingSupport = __webpackgi_exports__.Mn1,
    __webpackgi_exports__ShaderPass2 = __webpackgi_exports__.Hlq,
    __webpackgi_exports__ShadowMapBaker = __webpackgi_exports__.Fi7,
    __webpackgi_exports__ShadowMaterial = __webpackgi_exports__.Tn7,
    __webpackgi_exports__Shape = __webpackgi_exports__.bnF,
    __webpackgi_exports__ShapeBufferGeometry = __webpackgi_exports__.HW6,
    __webpackgi_exports__ShapeGeometry = __webpackgi_exports__.oa8,
    __webpackgi_exports__ShapePath = __webpackgi_exports__.T_1,
    __webpackgi_exports__ShapeTubeExtrudePlugin = __webpackgi_exports__.zHJ,
    __webpackgi_exports__ShapeUtils = __webpackgi_exports__.iDF,
    __webpackgi_exports__ShortType = __webpackgi_exports__.iAb,
    __webpackgi_exports__SimpleAssetList = __webpackgi_exports__.d4E,
    __webpackgi_exports__SimpleBackgroundEnvUiPlugin = __webpackgi_exports__.lBg,
    __webpackgi_exports__SimpleDataSource = __webpackgi_exports__.JeJ,
    __webpackgi_exports__SimpleEventDispatcher = __webpackgi_exports__.FKY,
    __webpackgi_exports__SimpleJSONExporter = __webpackgi_exports__.zlZ,
    __webpackgi_exports__SimpleJSONLoader = __webpackgi_exports__.vkg,
    __webpackgi_exports__SimpleTextExporter = __webpackgi_exports__.brh,
    __webpackgi_exports__SimpleTextPlugin = __webpackgi_exports__.kZK,
    __webpackgi_exports__SimpleViewerUi = __webpackgi_exports__.puG,
    __webpackgi_exports__Skeleton = __webpackgi_exports__.OdW,
    __webpackgi_exports__SkeletonHelper = __webpackgi_exports__._YX,
    __webpackgi_exports__SkinnedMesh = __webpackgi_exports__.TUv,
    __webpackgi_exports__SmoothShading = __webpackgi_exports__.wcA,
    __webpackgi_exports__Source = __webpackgi_exports__.Hw6,
    __webpackgi_exports__Sphere = __webpackgi_exports__.aLr,
    __webpackgi_exports__SphereBufferGeometry = __webpackgi_exports__.Aip,
    __webpackgi_exports__SphereGeometry = __webpackgi_exports__.xo$,
    __webpackgi_exports__SphereSelectionWidget = __webpackgi_exports__.bIn,
    __webpackgi_exports__Spherical = __webpackgi_exports__.$V,
    __webpackgi_exports__SphericalHarmonics3 = __webpackgi_exports__.lDi,
    __webpackgi_exports__SplineCurve = __webpackgi_exports__.gti,
    __webpackgi_exports__SpotLight = __webpackgi_exports__.PMe,
    __webpackgi_exports__SpotLight2 = __webpackgi_exports__.iwP,
    __webpackgi_exports__SpotLightHelper = __webpackgi_exports__.FvO,
    __webpackgi_exports__Sprite = __webpackgi_exports__.jyi,
    __webpackgi_exports__SpriteMaterial = __webpackgi_exports__.xeV,
    __webpackgi_exports__SrcAlphaFactor = __webpackgi_exports__.k74,
    __webpackgi_exports__SrcAlphaSaturateFactor = __webpackgi_exports__.RlZ,
    __webpackgi_exports__SrcColorFactor = __webpackgi_exports__.KhW,
    __webpackgi_exports__StaticCopyUsage = __webpackgi_exports__.HgB,
    __webpackgi_exports__StaticDrawUsage = __webpackgi_exports__.W2J,
    __webpackgi_exports__StaticReadUsage = __webpackgi_exports__.JWc,
    __webpackgi_exports__StereoCamera = __webpackgi_exports__.u37,
    __webpackgi_exports__StreamCopyUsage = __webpackgi_exports__.Z6B,
    __webpackgi_exports__StreamDrawUsage = __webpackgi_exports__.QZ1,
    __webpackgi_exports__StreamReadUsage = __webpackgi_exports__.Ir4,
    __webpackgi_exports__StringKeyframeTrack = __webpackgi_exports__.NwF,
    __webpackgi_exports__SubtractEquation = __webpackgi_exports__.Wbm,
    __webpackgi_exports__SubtractiveBlending = __webpackgi_exports__.N4l,
    __webpackgi_exports__SwitchNodePlugin = __webpackgi_exports__.ej9,
    __webpackgi_exports__TOUCH = __webpackgi_exports__.QmN,
    __webpackgi_exports__TangentSpaceNormalMap = __webpackgi_exports__.IOt,
    __webpackgi_exports__TemporalAAPlugin = __webpackgi_exports__.NOD,
    __webpackgi_exports__TetrahedronBufferGeometry = __webpackgi_exports__.L5g,
    __webpackgi_exports__TetrahedronGeometry = __webpackgi_exports__.H$k,
    __webpackgi_exports__TextGeometry = __webpackgi_exports__.MP$,
    __webpackgi_exports__TextSVGOptions = __webpackgi_exports__.cuP,
    __webpackgi_exports__Texture = __webpackgi_exports__.xEZ,
    __webpackgi_exports__TextureLoader = __webpackgi_exports__.dpR,
    __webpackgi_exports__ThinFilmLayerPlugin = __webpackgi_exports__.wOD,
    __webpackgi_exports__ThreeMaterialLoader = __webpackgi_exports__.KNb,
    __webpackgi_exports__TonemapPass = __webpackgi_exports__.Rk2,
    __webpackgi_exports__TonemapPlugin = __webpackgi_exports__.IiN,
    __webpackgi_exports__TorusBufferGeometry = __webpackgi_exports__.Cne,
    __webpackgi_exports__TorusGeometry = __webpackgi_exports__.XvJ,
    __webpackgi_exports__TorusKnotBufferGeometry = __webpackgi_exports__.XZw,
    __webpackgi_exports__TorusKnotGeometry = __webpackgi_exports__.FE5,
    __webpackgi_exports__TransformControls2 = __webpackgi_exports__.lVp,
    __webpackgi_exports__Triangle = __webpackgi_exports__.CJI,
    __webpackgi_exports__TriangleFanDrawMode = __webpackgi_exports__.z$h,
    __webpackgi_exports__TriangleStripDrawMode = __webpackgi_exports__.UlW,
    __webpackgi_exports__TrianglesDrawMode = __webpackgi_exports__.WwZ,
    __webpackgi_exports__TubeBufferGeometry = __webpackgi_exports__.Lcc,
    __webpackgi_exports__TubeGeometry = __webpackgi_exports__.WXh,
    __webpackgi_exports__TubeShapeGeometry = __webpackgi_exports__.Vjr,
    __webpackgi_exports__TweakpaneUiPlugin = __webpackgi_exports__.LuM,
    __webpackgi_exports__TweakpaneWrapper = __webpackgi_exports__.LP5,
    __webpackgi_exports__UVMapping = __webpackgi_exports__.xfE,
    __webpackgi_exports__Uint16BufferAttribute = __webpackgi_exports__.qlB,
    __webpackgi_exports__Uint32BufferAttribute = __webpackgi_exports__.lCJ,
    __webpackgi_exports__Uint8BufferAttribute = __webpackgi_exports__.WTc,
    __webpackgi_exports__Uint8ClampedBufferAttribute = __webpackgi_exports__.rAo,
    __webpackgi_exports__Uncharted2Tonemapping = __webpackgi_exports__.LZj,
    __webpackgi_exports__Uniform = __webpackgi_exports__.xWb,
    __webpackgi_exports__UniformsGroup = __webpackgi_exports__.gH0,
    __webpackgi_exports__UniformsLib = __webpackgi_exports__.rBU,
    __webpackgi_exports__UniformsUtils = __webpackgi_exports__.rDY,
    __webpackgi_exports__UnsignedByteType = __webpackgi_exports__.ywz,
    __webpackgi_exports__UnsignedInt248Type = __webpackgi_exports__.wJv,
    __webpackgi_exports__UnsignedIntType = __webpackgi_exports__.JQ4,
    __webpackgi_exports__UnsignedShort4444Type = __webpackgi_exports__.k0A,
    __webpackgi_exports__UnsignedShort5551Type = __webpackgi_exports__.irR,
    __webpackgi_exports__UnsignedShortType = __webpackgi_exports__.LsT,
    __webpackgi_exports__Unzip = __webpackgi_exports__.q5h,
    __webpackgi_exports__UnzipInflate = __webpackgi_exports__.TKh,
    __webpackgi_exports__UnzipPassThrough = __webpackgi_exports__.tyg,
    __webpackgi_exports__Unzlib = __webpackgi_exports__.Ro5,
    __webpackgi_exports__VSMShadowMap = __webpackgi_exports__.dwk,
    __webpackgi_exports__Vector2 = __webpackgi_exports__.FM8,
    __webpackgi_exports__Vector3 = __webpackgi_exports__.Pa4,
    __webpackgi_exports__Vector4 = __webpackgi_exports__.Ltg,
    __webpackgi_exports__VectorKeyframeTrack = __webpackgi_exports__.yC1,
    __webpackgi_exports__VelocityBufferPlugin = __webpackgi_exports__.lHq,
    __webpackgi_exports__VideoTexture = __webpackgi_exports__.fO1,
    __webpackgi_exports__ViewerApp = __webpackgi_exports__.oMA,
    __webpackgi_exports__ViewerState = __webpackgi_exports__.JzW,
    __webpackgi_exports__WebGL1Renderer = __webpackgi_exports__.b5g,
    __webpackgi_exports__WebGL3DRenderTarget = __webpackgi_exports__.Ywn,
    __webpackgi_exports__WebGLArrayRenderTarget = __webpackgi_exports__.GVz,
    __webpackgi_exports__WebGLCubeRenderTarget = __webpackgi_exports__.oAp,
    __webpackgi_exports__WebGLMultipleRenderTargets = __webpackgi_exports__.kFz,
    __webpackgi_exports__WebGLMultisampleRenderTarget = __webpackgi_exports__.p7A,
    __webpackgi_exports__WebGLRenderTarget = __webpackgi_exports__.dd2,
    __webpackgi_exports__WebGLRenderer = __webpackgi_exports__.CP7,
    __webpackgi_exports__WebGLUtils = __webpackgi_exports__.fQK,
    __webpackgi_exports__WebGiViewerElement = __webpackgi_exports__.Wd$,
    __webpackgi_exports__WireframeGeometry = __webpackgi_exports__.Uk6,
    __webpackgi_exports__WrapAroundEnding = __webpackgi_exports__._sL,
    __webpackgi_exports__ZeroCurvatureEnding = __webpackgi_exports__.Pnf,
    __webpackgi_exports__ZeroFactor = __webpackgi_exports__.c8b,
    __webpackgi_exports__ZeroSlopeEnding = __webpackgi_exports__._lf,
    __webpackgi_exports__ZeroStencilOp = __webpackgi_exports__.ad5,
    __webpackgi_exports__Zip = __webpackgi_exports__.sZV,
    __webpackgi_exports__ZipDeflate = __webpackgi_exports__.TfA,
    __webpackgi_exports__ZipLoader = __webpackgi_exports__.sKX,
    __webpackgi_exports__ZipPassThrough = __webpackgi_exports__.UdM,
    __webpackgi_exports__Zlib = __webpackgi_exports__.P0y,
    __webpackgi_exports___SRGBAFormat = __webpackgi_exports__.L_r,
    __webpackgi_exports__addBasePlugins = __webpackgi_exports__.Bve,
    __webpackgi_exports__addDracoLoader = __webpackgi_exports__.UeO,
    __webpackgi_exports__addGLTFExporter = __webpackgi_exports__.$nx,
    __webpackgi_exports__addGLTFLoader = __webpackgi_exports__.Bk6,
    __webpackgi_exports__addRGBELoader = __webpackgi_exports__.y4l,
    __webpackgi_exports__addZipLoader = __webpackgi_exports__.pQ0,
    __webpackgi_exports__afterMain = __webpackgi_exports__.wXW,
    __webpackgi_exports__afterRead = __webpackgi_exports__.r5x,
    __webpackgi_exports__afterWrite = __webpackgi_exports__.MSI,
    __webpackgi_exports__animate = __webpackgi_exports__.jtH,
    __webpackgi_exports__animateAsync = __webpackgi_exports__.T0T,
    __webpackgi_exports__animateObject = __webpackgi_exports__.gAb,
    __webpackgi_exports__animatePromise = __webpackgi_exports__.iwT,
    __webpackgi_exports__animateSet = __webpackgi_exports__.je_,
    __webpackgi_exports__animateTarget = __webpackgi_exports__.wBP,
    __webpackgi_exports__applyStyles = __webpackgi_exports__.Zs7,
    __webpackgi_exports__arrow = __webpackgi_exports__.x7s,
    __webpackgi_exports__auto = __webpackgi_exports__.d73,
    __webpackgi_exports__autoScaleObject3D = __webpackgi_exports__.RG9,
    __webpackgi_exports__basePlacements = __webpackgi_exports__.mvg,
    __webpackgi_exports__beforeMain = __webpackgi_exports__.XMc,
    __webpackgi_exports__beforeRead = __webpackgi_exports__.N7M,
    __webpackgi_exports__beforeWrite = __webpackgi_exports__.iv,
    __webpackgi_exports__blobToDataURL = __webpackgi_exports__.n55,
    __webpackgi_exports__bottom = __webpackgi_exports__.IaC,
    __webpackgi_exports__cLinearToRGBM = __webpackgi_exports__.$MY,
    __webpackgi_exports__cRGBMToLinear = __webpackgi_exports__.wJl,
    __webpackgi_exports__clippingParents = __webpackgi_exports__.zVI,
    __webpackgi_exports__combineDofShader = __webpackgi_exports__.DpF,
    __webpackgi_exports__compress = __webpackgi_exports__.nNb,
    __webpackgi_exports__compressSync = __webpackgi_exports__.cqZ,
    __webpackgi_exports__computeOffsetMatrix = __webpackgi_exports__.KlC,
    __webpackgi_exports__computeScreenSpaceBoundingBox = __webpackgi_exports__.KVn,
    __webpackgi_exports__computeStyles = __webpackgi_exports__.oau,
    __webpackgi_exports__copyMaterialUserData = __webpackgi_exports__.aw9,
    __webpackgi_exports__copyObjectUserData = __webpackgi_exports__.leS,
    __webpackgi_exports__copyProps = __webpackgi_exports__.Dxg,
    __webpackgi_exports__createCanvasElement = __webpackgi_exports__.O5A,
    __webpackgi_exports__createDiv = __webpackgi_exports__.wCn,
    __webpackgi_exports__createImage = __webpackgi_exports__.Bi6,
    __webpackgi_exports__createPopper = __webpackgi_exports__.fi_,
    __webpackgi_exports__createPopperBase = __webpackgi_exports__.TT,
    __webpackgi_exports__createPopperLite = __webpackgi_exports__.q2Z,
    __webpackgi_exports__createRenderTargetKey = __webpackgi_exports__.NyK,
    __webpackgi_exports__createScriptFromURL = __webpackgi_exports__.bgu,
    __webpackgi_exports__createStyles = __webpackgi_exports__.kcS,
    __webpackgi_exports__css = __webpackgi_exports__.ivY,
    __webpackgi_exports__dataTextureFromColor = __webpackgi_exports__._HO,
    __webpackgi_exports__dataTextureFromVec4 = __webpackgi_exports__.tpL,
    __webpackgi_exports__decompress = __webpackgi_exports__.LjN,
    __webpackgi_exports__decompressSync = __webpackgi_exports__.iFs,
    __webpackgi_exports__deepAccessObject = __webpackgi_exports__.qTg,
    __webpackgi_exports__deflate = __webpackgi_exports__.Wtl,
    __webpackgi_exports__deflateSync = __webpackgi_exports__.DmK,
    __webpackgi_exports__deserializeObject = __webpackgi_exports__.Hx7,
    __webpackgi_exports__deserializers = __webpackgi_exports__.imt,
    __webpackgi_exports__detectOverflow = __webpackgi_exports__.US6,
    __webpackgi_exports__diamondMaterialPropList = __webpackgi_exports__.vZs,
    __webpackgi_exports__downloadBlob = __webpackgi_exports__.lmu,
    __webpackgi_exports__downloadFile = __webpackgi_exports__.SvO,
    __webpackgi_exports__embedUrlRefs = __webpackgi_exports__.omp,
    __webpackgi_exports__end = __webpackgi_exports__.utz,
    __webpackgi_exports__envMapBackground = __webpackgi_exports__.TFV,
    __webpackgi_exports__escapeRegExp = __webpackgi_exports__.hrz,
    __webpackgi_exports__eventListeners = __webpackgi_exports__.JKM,
    __webpackgi_exports__extractAnimationKey = __webpackgi_exports__.jZf,
    __webpackgi_exports__flattenUiConfig = __webpackgi_exports__.RjL,
    __webpackgi_exports__flip = __webpackgi_exports__.RRI,
    __webpackgi_exports__fontFormatExtensionMap = __webpackgi_exports__.RUq,
    __webpackgi_exports__generateUiConfig = __webpackgi_exports__._t4,
    __webpackgi_exports__generateUiFolder = __webpackgi_exports__.YHh,
    __webpackgi_exports__getEncodingComponents = __webpackgi_exports__.R8g,
    __webpackgi_exports__getFilenameFromPath = __webpackgi_exports__.Bbl,
    __webpackgi_exports__getKeyByValue = __webpackgi_exports__.V9r,
    __webpackgi_exports__getOrCall = __webpackgi_exports__.PZ2,
    __webpackgi_exports__getPropertyDescriptor = __webpackgi_exports__.w7A,
    __webpackgi_exports__getTexelDecoding = __webpackgi_exports__.N6S,
    __webpackgi_exports__getTexelDecoding2 = __webpackgi_exports__.Uxp,
    __webpackgi_exports__getTexelDecodingFunction = __webpackgi_exports__.tAz,
    __webpackgi_exports__getTexelEncoding = __webpackgi_exports__.R$F,
    __webpackgi_exports__getTexelEncodingFunction = __webpackgi_exports__.N33,
    __webpackgi_exports__getTextureDataType = __webpackgi_exports__.gw2,
    __webpackgi_exports__getTextureEncodingFromMap = __webpackgi_exports__.KlU,
    __webpackgi_exports__getUrlQueryParam = __webpackgi_exports__.wo6,
    __webpackgi_exports__glsl = __webpackgi_exports__.H4P,
    __webpackgi_exports__gunzip = __webpackgi_exports__.swA,
    __webpackgi_exports__gunzipSync = __webpackgi_exports__._Z3,
    __webpackgi_exports__gzip = __webpackgi_exports__.ivc,
    __webpackgi_exports__gzipSync = __webpackgi_exports__.rZ1,
    __webpackgi_exports__hide = __webpackgi_exports__.CpZ,
    __webpackgi_exports__html = __webpackgi_exports__.dyc,
    __webpackgi_exports__htmlToCanvas = __webpackgi_exports__.MxZ,
    __webpackgi_exports__htmlToPng = __webpackgi_exports__.btp,
    __webpackgi_exports__htmlToSvg = __webpackgi_exports__.mXy,
    __webpackgi_exports__iGeometryIgnoredUserData = __webpackgi_exports__.Ej0,
    __webpackgi_exports__iMaterialIgnoredUserData = __webpackgi_exports__.ep4,
    __webpackgi_exports__iModelIgnoredUserData = __webpackgi_exports__.DQP,
    __webpackgi_exports__imageBitmapToBase64 = __webpackgi_exports__.V7q,
    __webpackgi_exports__imageToCanvas = __webpackgi_exports__.zEk,
    __webpackgi_exports__imageUrlToImageData = __webpackgi_exports__.qfq,
    __webpackgi_exports__includesAll = __webpackgi_exports__.piB,
    __webpackgi_exports__inflate = __webpackgi_exports__.rrF,
    __webpackgi_exports__inflateSync = __webpackgi_exports__.naq,
    __webpackgi_exports__isAnimatableType = __webpackgi_exports__.p5I,
    __webpackgi_exports__isPropertyWritable = __webpackgi_exports__.GpE,
    __webpackgi_exports__left = __webpackgi_exports__.t$v,
    __webpackgi_exports__lerpAngle = __webpackgi_exports__.tdn,
    __webpackgi_exports__lerpAngle2 = __webpackgi_exports__.Y9t,
    __webpackgi_exports__main = __webpackgi_exports__.DH3,
    __webpackgi_exports__makeColorSvg = __webpackgi_exports__.uxM,
    __webpackgi_exports__makeColorSvgCircle = __webpackgi_exports__.zH3,
    __webpackgi_exports__makeFilter = __webpackgi_exports__.MLs,
    __webpackgi_exports__makeSetterFor = __webpackgi_exports__.YM4,
    __webpackgi_exports__makeSetterForAnimObject = __webpackgi_exports__.B3r,
    __webpackgi_exports__makeTextSvg = __webpackgi_exports__.iAx,
    __webpackgi_exports__matDefine = __webpackgi_exports__.lDn,
    __webpackgi_exports__mobileAndTabletCheck = __webpackgi_exports__.TIc,
    __webpackgi_exports__modifierPhases = __webpackgi_exports__.xsC,
    __webpackgi_exports__now = __webpackgi_exports__.zOc,
    __webpackgi_exports__offset = __webpackgi_exports__.r46,
    __webpackgi_exports__onChange = __webpackgi_exports__.z2C,
    __webpackgi_exports__parseFileExtension = __webpackgi_exports__._X$,
    __webpackgi_exports__patchShaderEncodingSupport = __webpackgi_exports__._yn,
    __webpackgi_exports__pathJoin = __webpackgi_exports__.Dyg,
    __webpackgi_exports__physicalMaterialPropList = __webpackgi_exports__.cUc,
    __webpackgi_exports__placements = __webpackgi_exports__.Ctq,
    __webpackgi_exports__popper = __webpackgi_exports__.k5b,
    __webpackgi_exports__popperGenerator = __webpackgi_exports__.kZl,
    __webpackgi_exports__popperOffsets = __webpackgi_exports__.OCg,
    __webpackgi_exports__preventOverflow = __webpackgi_exports__.YjH,
    __webpackgi_exports__processViewer = __webpackgi_exports__.Ui8,
    __webpackgi_exports__read = __webpackgi_exports__.ij3,
    __webpackgi_exports__reference = __webpackgi_exports__.YPW,
    __webpackgi_exports__removeDuplicateGeometries = __webpackgi_exports__.Bg1,
    __webpackgi_exports__replaceAll = __webpackgi_exports__.kon,
    __webpackgi_exports__right = __webpackgi_exports__.F2z,
    __webpackgi_exports__rotateDuplicatedMesh = __webpackgi_exports__.pJF,
    __webpackgi_exports__sRGBEncoding = __webpackgi_exports__.knz,
    __webpackgi_exports__safeSetProperty = __webpackgi_exports__.Ejo,
    __webpackgi_exports__serializable = __webpackgi_exports__.BgY,
    __webpackgi_exports__serialize = __webpackgi_exports__.qCG,
    __webpackgi_exports__serializeObject = __webpackgi_exports__.HD9,
    __webpackgi_exports__serializers = __webpackgi_exports__.fEB,
    __webpackgi_exports__setMeshGeometry = __webpackgi_exports__.Udc,
    __webpackgi_exports__setMeshMaterial = __webpackgi_exports__.ZQg,
    __webpackgi_exports__setThreeRendererMode = __webpackgi_exports__.ofC,
    __webpackgi_exports__setUrlQueryParam = __webpackgi_exports__.yRy,
    __webpackgi_exports__setupCoreWebGiViewer = __webpackgi_exports__._NL,
    __webpackgi_exports__setupIModel = __webpackgi_exports__.LCA,
    __webpackgi_exports__setupObject3dModel = __webpackgi_exports__.j1w,
    __webpackgi_exports__setupSandboxWebGiEditor = __webpackgi_exports__.i8J,
    __webpackgi_exports__shaderReplaceString = __webpackgi_exports__.p7C,
    __webpackgi_exports__slerp = __webpackgi_exports__.ZAS,
    __webpackgi_exports__snapObject = __webpackgi_exports__.VWG,
    __webpackgi_exports__sphericalFromObject = __webpackgi_exports__.pQ7,
    __webpackgi_exports__standardMaterialPropList = __webpackgi_exports__.jc8,
    __webpackgi_exports__start = __webpackgi_exports__.BL_,
    __webpackgi_exports__strFromU8 = __webpackgi_exports__.T8U,
    __webpackgi_exports__strToU8 = __webpackgi_exports__.TD6,
    __webpackgi_exports__svgToCanvas = __webpackgi_exports__.akS,
    __webpackgi_exports__svgToPng = __webpackgi_exports__.QKE,
    __webpackgi_exports__svgUrl = __webpackgi_exports__.dKx,
    __webpackgi_exports__syncAnimSetUi = __webpackgi_exports__.OvX,
    __webpackgi_exports__timeout = __webpackgi_exports__.VsW,
    __webpackgi_exports__toIndexedGeometry = __webpackgi_exports__.aPg,
    __webpackgi_exports__toTitleCase = __webpackgi_exports__.LFn,
    __webpackgi_exports__top = __webpackgi_exports__.wey,
    __webpackgi_exports__uiButton = __webpackgi_exports__.MaE,
    __webpackgi_exports__uiColor = __webpackgi_exports__.s4x,
    __webpackgi_exports__uiConfig = __webpackgi_exports__.FJA,
    __webpackgi_exports__uiDropdown = __webpackgi_exports__.vIA,
    __webpackgi_exports__uiFolder = __webpackgi_exports__.Spv,
    __webpackgi_exports__uiImage = __webpackgi_exports__.w8l,
    __webpackgi_exports__uiInput = __webpackgi_exports__.riG,
    __webpackgi_exports__uiMonitor = __webpackgi_exports__.Kbh,
    __webpackgi_exports__uiSlider = __webpackgi_exports__.t8K,
    __webpackgi_exports__uiToggle = __webpackgi_exports__.Q7n,
    __webpackgi_exports__uiVector = __webpackgi_exports__.KGF,
    __webpackgi_exports__uniform = __webpackgi_exports__.e5,
    __webpackgi_exports__unzip = __webpackgi_exports__.Rik,
    __webpackgi_exports__unzipSync = __webpackgi_exports__.GZo,
    __webpackgi_exports__unzlib = __webpackgi_exports__.Bds,
    __webpackgi_exports__unzlibSync = __webpackgi_exports__.HTu,
    __webpackgi_exports__uploadFile = __webpackgi_exports__.cTq,
    __webpackgi_exports__vLinearToRGBM = __webpackgi_exports__.X_Y,
    __webpackgi_exports__vRGBMToLinear = __webpackgi_exports__.dA8,
    __webpackgi_exports__variationPlacements = __webpackgi_exports__.bwS,
    __webpackgi_exports__verifyPermission = __webpackgi_exports__.P4F,
    __webpackgi_exports__viewerGLTFExtension = __webpackgi_exports__.Pd0,
    __webpackgi_exports__viewport = __webpackgi_exports__.Pjo,
    __webpackgi_exports__webgiLightExtrasExtension = __webpackgi_exports__.Tum,
    __webpackgi_exports__webgiMaterialExtrasExtension = __webpackgi_exports__.dRH,
    __webpackgi_exports__webgiObject3DExtrasExtension = __webpackgi_exports__.RX0,
    __webpackgi_exports__write = __webpackgi_exports__.cWm,
    __webpackgi_exports__writeFile = __webpackgi_exports__.NC9,
    __webpackgi_exports__zip = __webpackgi_exports__.$Re,
    __webpackgi_exports__zipSync = __webpackgi_exports__.Xo9,
    __webpackgi_exports__zlib = __webpackgi_exports__.LNO,
    __webpackgi_exports__zlibSync = __webpackgi_exports__.iZP;
exports.zlibSync = __webpackgi_exports__zlibSync;
exports.zlib = __webpackgi_exports__zlib;
exports.zipSync = __webpackgi_exports__zipSync;
exports.zip = __webpackgi_exports__zip;
exports.writeFile = __webpackgi_exports__writeFile;
exports.write = __webpackgi_exports__write;
exports.webgiObject3DExtrasExtension = __webpackgi_exports__webgiObject3DExtrasExtension;
exports.webgiMaterialExtrasExtension = __webpackgi_exports__webgiMaterialExtrasExtension;
exports.webgiLightExtrasExtension = __webpackgi_exports__webgiLightExtrasExtension;
exports.viewport = __webpackgi_exports__viewport;
exports.viewerGLTFExtension = __webpackgi_exports__viewerGLTFExtension;
exports.verifyPermission = __webpackgi_exports__verifyPermission;
exports.variationPlacements = __webpackgi_exports__variationPlacements;
exports.vRGBMToLinear = __webpackgi_exports__vRGBMToLinear;
exports.vLinearToRGBM = __webpackgi_exports__vLinearToRGBM;
exports.uploadFile = __webpackgi_exports__uploadFile;
exports.unzlibSync = __webpackgi_exports__unzlibSync;
exports.unzlib = __webpackgi_exports__unzlib;
exports.unzipSync = __webpackgi_exports__unzipSync;
exports.unzip = __webpackgi_exports__unzip;
exports.uniform = __webpackgi_exports__uniform;
exports.uiVector = __webpackgi_exports__uiVector;
exports.uiToggle = __webpackgi_exports__uiToggle;
exports.uiSlider = __webpackgi_exports__uiSlider;
exports.uiMonitor = __webpackgi_exports__uiMonitor;
exports.uiInput = __webpackgi_exports__uiInput;
exports.uiImage = __webpackgi_exports__uiImage;
exports.uiFolder = __webpackgi_exports__uiFolder;
exports.uiDropdown = __webpackgi_exports__uiDropdown;
exports.uiConfig = __webpackgi_exports__uiConfig;
exports.uiColor = __webpackgi_exports__uiColor;
exports.uiButton = __webpackgi_exports__uiButton;
exports.top = __webpackgi_exports__top;
exports.toTitleCase = __webpackgi_exports__toTitleCase;
exports.toIndexedGeometry = __webpackgi_exports__toIndexedGeometry;
exports.timeout = __webpackgi_exports__timeout;
exports.syncAnimSetUi = __webpackgi_exports__syncAnimSetUi;
exports.svgUrl = __webpackgi_exports__svgUrl;
exports.svgToPng = __webpackgi_exports__svgToPng;
exports.svgToCanvas = __webpackgi_exports__svgToCanvas;
exports.strToU8 = __webpackgi_exports__strToU8;
exports.strFromU8 = __webpackgi_exports__strFromU8;
exports.start = __webpackgi_exports__start;
exports.standardMaterialPropList = __webpackgi_exports__standardMaterialPropList;
exports.sphericalFromObject = __webpackgi_exports__sphericalFromObject;
exports.snapObject = __webpackgi_exports__snapObject;
exports.slerp = __webpackgi_exports__slerp;
exports.shaderReplaceString = __webpackgi_exports__shaderReplaceString;
exports.setupSandboxWebGiEditor = __webpackgi_exports__setupSandboxWebGiEditor;
exports.setupObject3dModel = __webpackgi_exports__setupObject3dModel;
exports.setupIModel = __webpackgi_exports__setupIModel;
exports.setupCoreWebGiViewer = __webpackgi_exports__setupCoreWebGiViewer;
exports.setUrlQueryParam = __webpackgi_exports__setUrlQueryParam;
exports.setThreeRendererMode = __webpackgi_exports__setThreeRendererMode;
exports.setMeshMaterial = __webpackgi_exports__setMeshMaterial;
exports.setMeshGeometry = __webpackgi_exports__setMeshGeometry;
exports.serializers = __webpackgi_exports__serializers;
exports.serializeObject = __webpackgi_exports__serializeObject;
exports.serialize = __webpackgi_exports__serialize;
exports.serializable = __webpackgi_exports__serializable;
exports.safeSetProperty = __webpackgi_exports__safeSetProperty;
exports.sRGBEncoding = __webpackgi_exports__sRGBEncoding;
exports.rotateDuplicatedMesh = __webpackgi_exports__rotateDuplicatedMesh;
exports.right = __webpackgi_exports__right;
exports.replaceAll = __webpackgi_exports__replaceAll;
exports.removeDuplicateGeometries = __webpackgi_exports__removeDuplicateGeometries;
exports.reference = __webpackgi_exports__reference;
exports.read = __webpackgi_exports__read;
exports.processViewer = __webpackgi_exports__processViewer;
exports.preventOverflow = __webpackgi_exports__preventOverflow;
exports.popperOffsets = __webpackgi_exports__popperOffsets;
exports.popperGenerator = __webpackgi_exports__popperGenerator;
exports.popper = __webpackgi_exports__popper;
exports.placements = __webpackgi_exports__placements;
exports.physicalMaterialPropList = __webpackgi_exports__physicalMaterialPropList;
exports.pathJoin = __webpackgi_exports__pathJoin;
exports.patchShaderEncodingSupport = __webpackgi_exports__patchShaderEncodingSupport;
exports.parseFileExtension = __webpackgi_exports__parseFileExtension;
exports.onChange = __webpackgi_exports__onChange;
exports.offset = __webpackgi_exports__offset;
exports.now = __webpackgi_exports__now;
exports.modifierPhases = __webpackgi_exports__modifierPhases;
exports.mobileAndTabletCheck = __webpackgi_exports__mobileAndTabletCheck;
exports.matDefine = __webpackgi_exports__matDefine;
exports.makeTextSvg = __webpackgi_exports__makeTextSvg;
exports.makeSetterForAnimObject = __webpackgi_exports__makeSetterForAnimObject;
exports.makeSetterFor = __webpackgi_exports__makeSetterFor;
exports.makeFilter = __webpackgi_exports__makeFilter;
exports.makeColorSvgCircle = __webpackgi_exports__makeColorSvgCircle;
exports.makeColorSvg = __webpackgi_exports__makeColorSvg;
exports.main = __webpackgi_exports__main;
exports.lerpAngle2 = __webpackgi_exports__lerpAngle2;
exports.lerpAngle = __webpackgi_exports__lerpAngle;
exports.left = __webpackgi_exports__left;
exports.isPropertyWritable = __webpackgi_exports__isPropertyWritable;
exports.isAnimatableType = __webpackgi_exports__isAnimatableType;
exports.inflateSync = __webpackgi_exports__inflateSync;
exports.inflate = __webpackgi_exports__inflate;
exports.includesAll = __webpackgi_exports__includesAll;
exports.imageUrlToImageData = __webpackgi_exports__imageUrlToImageData;
exports.imageToCanvas = __webpackgi_exports__imageToCanvas;
exports.imageBitmapToBase64 = __webpackgi_exports__imageBitmapToBase64;
exports.iModelIgnoredUserData = __webpackgi_exports__iModelIgnoredUserData;
exports.iMaterialIgnoredUserData = __webpackgi_exports__iMaterialIgnoredUserData;
exports.iGeometryIgnoredUserData = __webpackgi_exports__iGeometryIgnoredUserData;
exports.htmlToSvg = __webpackgi_exports__htmlToSvg;
exports.htmlToPng = __webpackgi_exports__htmlToPng;
exports.htmlToCanvas = __webpackgi_exports__htmlToCanvas;
exports.html = __webpackgi_exports__html;
exports.hide = __webpackgi_exports__hide;
exports.gzipSync = __webpackgi_exports__gzipSync;
exports.gzip = __webpackgi_exports__gzip;
exports.gunzipSync = __webpackgi_exports__gunzipSync;
exports.gunzip = __webpackgi_exports__gunzip;
exports.glsl = __webpackgi_exports__glsl;
exports.getUrlQueryParam = __webpackgi_exports__getUrlQueryParam;
exports.getTextureEncodingFromMap = __webpackgi_exports__getTextureEncodingFromMap;
exports.getTextureDataType = __webpackgi_exports__getTextureDataType;
exports.getTexelEncodingFunction = __webpackgi_exports__getTexelEncodingFunction;
exports.getTexelEncoding = __webpackgi_exports__getTexelEncoding;
exports.getTexelDecodingFunction = __webpackgi_exports__getTexelDecodingFunction;
exports.getTexelDecoding2 = __webpackgi_exports__getTexelDecoding2;
exports.getTexelDecoding = __webpackgi_exports__getTexelDecoding;
exports.getPropertyDescriptor = __webpackgi_exports__getPropertyDescriptor;
exports.getOrCall = __webpackgi_exports__getOrCall;
exports.getKeyByValue = __webpackgi_exports__getKeyByValue;
exports.getFilenameFromPath = __webpackgi_exports__getFilenameFromPath;
exports.getEncodingComponents = __webpackgi_exports__getEncodingComponents;
exports.generateUiFolder = __webpackgi_exports__generateUiFolder;
exports.generateUiConfig = __webpackgi_exports__generateUiConfig;
exports.fontFormatExtensionMap = __webpackgi_exports__fontFormatExtensionMap;
exports.flip = __webpackgi_exports__flip;
exports.flattenUiConfig = __webpackgi_exports__flattenUiConfig;
exports.extractAnimationKey = __webpackgi_exports__extractAnimationKey;
exports.eventListeners = __webpackgi_exports__eventListeners;
exports.escapeRegExp = __webpackgi_exports__escapeRegExp;
exports.envMapBackground = __webpackgi_exports__envMapBackground;
exports.end = __webpackgi_exports__end;
exports.embedUrlRefs = __webpackgi_exports__embedUrlRefs;
exports.downloadFile = __webpackgi_exports__downloadFile;
exports.downloadBlob = __webpackgi_exports__downloadBlob;
exports.diamondMaterialPropList = __webpackgi_exports__diamondMaterialPropList;
exports.detectOverflow = __webpackgi_exports__detectOverflow;
exports.deserializers = __webpackgi_exports__deserializers;
exports.deserializeObject = __webpackgi_exports__deserializeObject;
exports.deflateSync = __webpackgi_exports__deflateSync;
exports.deflate = __webpackgi_exports__deflate;
exports.deepAccessObject = __webpackgi_exports__deepAccessObject;
exports.decompressSync = __webpackgi_exports__decompressSync;
exports.decompress = __webpackgi_exports__decompress;
exports.dataTextureFromVec4 = __webpackgi_exports__dataTextureFromVec4;
exports.dataTextureFromColor = __webpackgi_exports__dataTextureFromColor;
exports.css = __webpackgi_exports__css;
exports.createStyles = __webpackgi_exports__createStyles;
exports.createScriptFromURL = __webpackgi_exports__createScriptFromURL;
exports.createRenderTargetKey = __webpackgi_exports__createRenderTargetKey;
exports.createPopperLite = __webpackgi_exports__createPopperLite;
exports.createPopperBase = __webpackgi_exports__createPopperBase;
exports.createPopper = __webpackgi_exports__createPopper;
exports.createImage = __webpackgi_exports__createImage;
exports.createDiv = __webpackgi_exports__createDiv;
exports.createCanvasElement = __webpackgi_exports__createCanvasElement;
exports.copyProps = __webpackgi_exports__copyProps;
exports.copyObjectUserData = __webpackgi_exports__copyObjectUserData;
exports.copyMaterialUserData = __webpackgi_exports__copyMaterialUserData;
exports.computeStyles = __webpackgi_exports__computeStyles;
exports.computeScreenSpaceBoundingBox = __webpackgi_exports__computeScreenSpaceBoundingBox;
exports.computeOffsetMatrix = __webpackgi_exports__computeOffsetMatrix;
exports.compressSync = __webpackgi_exports__compressSync;
exports.compress = __webpackgi_exports__compress;
exports.combineDofShader = __webpackgi_exports__combineDofShader;
exports.clippingParents = __webpackgi_exports__clippingParents;
exports.cRGBMToLinear = __webpackgi_exports__cRGBMToLinear;
exports.cLinearToRGBM = __webpackgi_exports__cLinearToRGBM;
exports.bottom = __webpackgi_exports__bottom;
exports.blobToDataURL = __webpackgi_exports__blobToDataURL;
exports.beforeWrite = __webpackgi_exports__beforeWrite;
exports.beforeRead = __webpackgi_exports__beforeRead;
exports.beforeMain = __webpackgi_exports__beforeMain;
exports.basePlacements = __webpackgi_exports__basePlacements;
exports.autoScaleObject3D = __webpackgi_exports__autoScaleObject3D;
exports.auto = __webpackgi_exports__auto;
exports.arrow = __webpackgi_exports__arrow;
exports.applyStyles = __webpackgi_exports__applyStyles;
exports.animateTarget = __webpackgi_exports__animateTarget;
exports.animateSet = __webpackgi_exports__animateSet;
exports.animatePromise = __webpackgi_exports__animatePromise;
exports.animateObject = __webpackgi_exports__animateObject;
exports.animateAsync = __webpackgi_exports__animateAsync;
exports.animate = __webpackgi_exports__animate;
exports.afterWrite = __webpackgi_exports__afterWrite;
exports.afterRead = __webpackgi_exports__afterRead;
exports.afterMain = __webpackgi_exports__afterMain;
exports.addZipLoader = __webpackgi_exports__addZipLoader;
exports.addRGBELoader = __webpackgi_exports__addRGBELoader;
exports.addGLTFLoader = __webpackgi_exports__addGLTFLoader;
exports.addGLTFExporter = __webpackgi_exports__addGLTFExporter;
exports.addDracoLoader = __webpackgi_exports__addDracoLoader;
exports.addBasePlugins = __webpackgi_exports__addBasePlugins;
exports._SRGBAFormat = __webpackgi_exports___SRGBAFormat;
exports.Zlib = __webpackgi_exports__Zlib;
exports.ZipPassThrough = __webpackgi_exports__ZipPassThrough;
exports.ZipLoader = __webpackgi_exports__ZipLoader;
exports.ZipDeflate = __webpackgi_exports__ZipDeflate;
exports.Zip = __webpackgi_exports__Zip;
exports.ZeroStencilOp = __webpackgi_exports__ZeroStencilOp;
exports.ZeroSlopeEnding = __webpackgi_exports__ZeroSlopeEnding;
exports.ZeroFactor = __webpackgi_exports__ZeroFactor;
exports.ZeroCurvatureEnding = __webpackgi_exports__ZeroCurvatureEnding;
exports.WrapAroundEnding = __webpackgi_exports__WrapAroundEnding;
exports.WireframeGeometry = __webpackgi_exports__WireframeGeometry;
exports.WebGiViewerElement = __webpackgi_exports__WebGiViewerElement;
exports.WebGLUtils = __webpackgi_exports__WebGLUtils;
exports.WebGLRenderer = __webpackgi_exports__WebGLRenderer;
exports.WebGLRenderTarget = __webpackgi_exports__WebGLRenderTarget;
exports.WebGLMultisampleRenderTarget = __webpackgi_exports__WebGLMultisampleRenderTarget;
exports.WebGLMultipleRenderTargets = __webpackgi_exports__WebGLMultipleRenderTargets;
exports.WebGLCubeRenderTarget = __webpackgi_exports__WebGLCubeRenderTarget;
exports.WebGLArrayRenderTarget = __webpackgi_exports__WebGLArrayRenderTarget;
exports.WebGL3DRenderTarget = __webpackgi_exports__WebGL3DRenderTarget;
exports.WebGL1Renderer = __webpackgi_exports__WebGL1Renderer;
exports.ViewerState = __webpackgi_exports__ViewerState;
exports.ViewerApp = __webpackgi_exports__ViewerApp;
exports.VideoTexture = __webpackgi_exports__VideoTexture;
exports.VelocityBufferPlugin = __webpackgi_exports__VelocityBufferPlugin;
exports.VectorKeyframeTrack = __webpackgi_exports__VectorKeyframeTrack;
exports.Vector4 = __webpackgi_exports__Vector4;
exports.Vector3 = __webpackgi_exports__Vector3;
exports.Vector2 = __webpackgi_exports__Vector2;
exports.VSMShadowMap = __webpackgi_exports__VSMShadowMap;
exports.Unzlib = __webpackgi_exports__Unzlib;
exports.UnzipPassThrough = __webpackgi_exports__UnzipPassThrough;
exports.UnzipInflate = __webpackgi_exports__UnzipInflate;
exports.Unzip = __webpackgi_exports__Unzip;
exports.UnsignedShortType = __webpackgi_exports__UnsignedShortType;
exports.UnsignedShort5551Type = __webpackgi_exports__UnsignedShort5551Type;
exports.UnsignedShort4444Type = __webpackgi_exports__UnsignedShort4444Type;
exports.UnsignedIntType = __webpackgi_exports__UnsignedIntType;
exports.UnsignedInt248Type = __webpackgi_exports__UnsignedInt248Type;
exports.UnsignedByteType = __webpackgi_exports__UnsignedByteType;
exports.UniformsUtils = __webpackgi_exports__UniformsUtils;
exports.UniformsLib = __webpackgi_exports__UniformsLib;
exports.UniformsGroup = __webpackgi_exports__UniformsGroup;
exports.Uniform = __webpackgi_exports__Uniform;
exports.Uncharted2Tonemapping = __webpackgi_exports__Uncharted2Tonemapping;
exports.Uint8ClampedBufferAttribute = __webpackgi_exports__Uint8ClampedBufferAttribute;
exports.Uint8BufferAttribute = __webpackgi_exports__Uint8BufferAttribute;
exports.Uint32BufferAttribute = __webpackgi_exports__Uint32BufferAttribute;
exports.Uint16BufferAttribute = __webpackgi_exports__Uint16BufferAttribute;
exports.UVMapping = __webpackgi_exports__UVMapping;
exports.TweakpaneWrapper = __webpackgi_exports__TweakpaneWrapper;
exports.TweakpaneUiPlugin = __webpackgi_exports__TweakpaneUiPlugin;
exports.TubeShapeGeometry = __webpackgi_exports__TubeShapeGeometry;
exports.TubeGeometry = __webpackgi_exports__TubeGeometry;
exports.TubeBufferGeometry = __webpackgi_exports__TubeBufferGeometry;
exports.TrianglesDrawMode = __webpackgi_exports__TrianglesDrawMode;
exports.TriangleStripDrawMode = __webpackgi_exports__TriangleStripDrawMode;
exports.TriangleFanDrawMode = __webpackgi_exports__TriangleFanDrawMode;
exports.Triangle = __webpackgi_exports__Triangle;
exports.TransformControls2 = __webpackgi_exports__TransformControls2;
exports.TorusKnotGeometry = __webpackgi_exports__TorusKnotGeometry;
exports.TorusKnotBufferGeometry = __webpackgi_exports__TorusKnotBufferGeometry;
exports.TorusGeometry = __webpackgi_exports__TorusGeometry;
exports.TorusBufferGeometry = __webpackgi_exports__TorusBufferGeometry;
exports.TonemapPlugin = __webpackgi_exports__TonemapPlugin;
exports.TonemapPass = __webpackgi_exports__TonemapPass;
exports.ThreeMaterialLoader = __webpackgi_exports__ThreeMaterialLoader;
exports.ThinFilmLayerPlugin = __webpackgi_exports__ThinFilmLayerPlugin;
exports.TextureLoader = __webpackgi_exports__TextureLoader;
exports.Texture = __webpackgi_exports__Texture;
exports.TextSVGOptions = __webpackgi_exports__TextSVGOptions;
exports.TextGeometry = __webpackgi_exports__TextGeometry;
exports.TetrahedronGeometry = __webpackgi_exports__TetrahedronGeometry;
exports.TetrahedronBufferGeometry = __webpackgi_exports__TetrahedronBufferGeometry;
exports.TemporalAAPlugin = __webpackgi_exports__TemporalAAPlugin;
exports.TangentSpaceNormalMap = __webpackgi_exports__TangentSpaceNormalMap;
exports.TOUCH = __webpackgi_exports__TOUCH;
exports.SwitchNodePlugin = __webpackgi_exports__SwitchNodePlugin;
exports.SubtractiveBlending = __webpackgi_exports__SubtractiveBlending;
exports.SubtractEquation = __webpackgi_exports__SubtractEquation;
exports.StringKeyframeTrack = __webpackgi_exports__StringKeyframeTrack;
exports.StreamReadUsage = __webpackgi_exports__StreamReadUsage;
exports.StreamDrawUsage = __webpackgi_exports__StreamDrawUsage;
exports.StreamCopyUsage = __webpackgi_exports__StreamCopyUsage;
exports.StereoCamera = __webpackgi_exports__StereoCamera;
exports.StaticReadUsage = __webpackgi_exports__StaticReadUsage;
exports.StaticDrawUsage = __webpackgi_exports__StaticDrawUsage;
exports.StaticCopyUsage = __webpackgi_exports__StaticCopyUsage;
exports.SrcColorFactor = __webpackgi_exports__SrcColorFactor;
exports.SrcAlphaSaturateFactor = __webpackgi_exports__SrcAlphaSaturateFactor;
exports.SrcAlphaFactor = __webpackgi_exports__SrcAlphaFactor;
exports.SpriteMaterial = __webpackgi_exports__SpriteMaterial;
exports.Sprite = __webpackgi_exports__Sprite;
exports.SpotLightHelper = __webpackgi_exports__SpotLightHelper;
exports.SpotLight2 = __webpackgi_exports__SpotLight2;
exports.SpotLight = __webpackgi_exports__SpotLight;
exports.SplineCurve = __webpackgi_exports__SplineCurve;
exports.SphericalHarmonics3 = __webpackgi_exports__SphericalHarmonics3;
exports.Spherical = __webpackgi_exports__Spherical;
exports.SphereSelectionWidget = __webpackgi_exports__SphereSelectionWidget;
exports.SphereGeometry = __webpackgi_exports__SphereGeometry;
exports.SphereBufferGeometry = __webpackgi_exports__SphereBufferGeometry;
exports.Sphere = __webpackgi_exports__Sphere;
exports.Source = __webpackgi_exports__Source;
exports.SmoothShading = __webpackgi_exports__SmoothShading;
exports.SkinnedMesh = __webpackgi_exports__SkinnedMesh;
exports.SkeletonHelper = __webpackgi_exports__SkeletonHelper;
exports.Skeleton = __webpackgi_exports__Skeleton;
exports.SimpleViewerUi = __webpackgi_exports__SimpleViewerUi;
exports.SimpleTextPlugin = __webpackgi_exports__SimpleTextPlugin;
exports.SimpleTextExporter = __webpackgi_exports__SimpleTextExporter;
exports.SimpleJSONLoader = __webpackgi_exports__SimpleJSONLoader;
exports.SimpleJSONExporter = __webpackgi_exports__SimpleJSONExporter;
exports.SimpleEventDispatcher = __webpackgi_exports__SimpleEventDispatcher;
exports.SimpleDataSource = __webpackgi_exports__SimpleDataSource;
exports.SimpleBackgroundEnvUiPlugin = __webpackgi_exports__SimpleBackgroundEnvUiPlugin;
exports.SimpleAssetList = __webpackgi_exports__SimpleAssetList;
exports.ShortType = __webpackgi_exports__ShortType;
exports.ShapeUtils = __webpackgi_exports__ShapeUtils;
exports.ShapeTubeExtrudePlugin = __webpackgi_exports__ShapeTubeExtrudePlugin;
exports.ShapePath = __webpackgi_exports__ShapePath;
exports.ShapeGeometry = __webpackgi_exports__ShapeGeometry;
exports.ShapeBufferGeometry = __webpackgi_exports__ShapeBufferGeometry;
exports.Shape = __webpackgi_exports__Shape;
exports.ShadowMaterial = __webpackgi_exports__ShadowMaterial;
exports.ShadowMapBaker = __webpackgi_exports__ShadowMapBaker;
exports.ShaderPass2 = __webpackgi_exports__ShaderPass2;
exports.ShaderMaterialEncodingSupport = __webpackgi_exports__ShaderMaterialEncodingSupport;
exports.ShaderMaterial = __webpackgi_exports__ShaderMaterial;
exports.ShaderLib = __webpackgi_exports__ShaderLib;
exports.ShaderChunk = __webpackgi_exports__ShaderChunk;
exports.SerializableOrbitControls = __webpackgi_exports__SerializableOrbitControls;
exports.SelectionWidget = __webpackgi_exports__SelectionWidget;
exports.Scene = __webpackgi_exports__Scene;
exports.STLLoadPlugin = __webpackgi_exports__STLLoadPlugin;
exports.SSRPlugin = __webpackgi_exports__SSRPlugin;
exports.SSContactShadows = __webpackgi_exports__SSContactShadows;
exports.SSAOPlugin = __webpackgi_exports__SSAOPlugin;
exports.SRGBColorSpace = __webpackgi_exports__SRGBColorSpace;
exports.SETTLING_TIME = __webpackgi_exports__SETTLING_TIME;
exports.RootScene = __webpackgi_exports__RootScene;
exports.RingGeometry = __webpackgi_exports__RingGeometry;
exports.RingBufferGeometry = __webpackgi_exports__RingBufferGeometry;
exports.Rhino3dmLoader2 = __webpackgi_exports__Rhino3dmLoader2;
exports.Rhino3dmLoadPlugin = __webpackgi_exports__Rhino3dmLoadPlugin;
exports.ReverseSubtractEquation = __webpackgi_exports__ReverseSubtractEquation;
exports.ReplaceStencilOp = __webpackgi_exports__ReplaceStencilOp;
exports.RepeatWrapping = __webpackgi_exports__RepeatWrapping;
exports.ReinhardToneMapping = __webpackgi_exports__ReinhardToneMapping;
exports.Reflector2 = __webpackgi_exports__Reflector2;
exports.RedIntegerFormat = __webpackgi_exports__RedIntegerFormat;
exports.RedFormat = __webpackgi_exports__RedFormat;
exports.RectAreaLight = __webpackgi_exports__RectAreaLight;
exports.Raycaster = __webpackgi_exports__Raycaster;
exports.Ray = __webpackgi_exports__Ray;
exports.RawShaderMaterial = __webpackgi_exports__RawShaderMaterial;
exports.RandomizedDirectionalLightPlugin = __webpackgi_exports__RandomizedDirectionalLightPlugin;
exports.RandomizedDirectionalLight = __webpackgi_exports__RandomizedDirectionalLight;
exports.RGIntegerFormat = __webpackgi_exports__RGIntegerFormat;
exports.RGFormat = __webpackgi_exports__RGFormat;
exports.RGB_S3TC_DXT1_Format = __webpackgi_exports__RGB_S3TC_DXT1_Format;
exports.RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__RGB_PVRTC_4BPPV1_Format;
exports.RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__RGB_PVRTC_2BPPV1_Format;
exports.RGB_ETC2_Format = __webpackgi_exports__RGB_ETC2_Format;
exports.RGB_ETC1_Format = __webpackgi_exports__RGB_ETC1_Format;
exports.RGBM7Encoding = __webpackgi_exports__RGBM7Encoding;
exports.RGBM16Encoding = __webpackgi_exports__RGBM16Encoding;
exports.RGBFormat = __webpackgi_exports__RGBFormat;
exports.RGBA_S3TC_DXT5_Format = __webpackgi_exports__RGBA_S3TC_DXT5_Format;
exports.RGBA_S3TC_DXT3_Format = __webpackgi_exports__RGBA_S3TC_DXT3_Format;
exports.RGBA_S3TC_DXT1_Format = __webpackgi_exports__RGBA_S3TC_DXT1_Format;
exports.RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format;
exports.RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format;
exports.RGBA_ETC2_EAC_Format = __webpackgi_exports__RGBA_ETC2_EAC_Format;
exports.RGBA_BPTC_Format = __webpackgi_exports__RGBA_BPTC_Format;
exports.RGBA_ASTC_8x8_Format = __webpackgi_exports__RGBA_ASTC_8x8_Format;
exports.RGBA_ASTC_8x6_Format = __webpackgi_exports__RGBA_ASTC_8x6_Format;
exports.RGBA_ASTC_8x5_Format = __webpackgi_exports__RGBA_ASTC_8x5_Format;
exports.RGBA_ASTC_6x6_Format = __webpackgi_exports__RGBA_ASTC_6x6_Format;
exports.RGBA_ASTC_6x5_Format = __webpackgi_exports__RGBA_ASTC_6x5_Format;
exports.RGBA_ASTC_5x5_Format = __webpackgi_exports__RGBA_ASTC_5x5_Format;
exports.RGBA_ASTC_5x4_Format = __webpackgi_exports__RGBA_ASTC_5x4_Format;
exports.RGBA_ASTC_4x4_Format = __webpackgi_exports__RGBA_ASTC_4x4_Format;
exports.RGBA_ASTC_12x12_Format = __webpackgi_exports__RGBA_ASTC_12x12_Format;
exports.RGBA_ASTC_12x10_Format = __webpackgi_exports__RGBA_ASTC_12x10_Format;
exports.RGBA_ASTC_10x8_Format = __webpackgi_exports__RGBA_ASTC_10x8_Format;
exports.RGBA_ASTC_10x6_Format = __webpackgi_exports__RGBA_ASTC_10x6_Format;
exports.RGBA_ASTC_10x5_Format = __webpackgi_exports__RGBA_ASTC_10x5_Format;
exports.RGBA_ASTC_10x10_Format = __webpackgi_exports__RGBA_ASTC_10x10_Format;
exports.RGBAIntegerFormat = __webpackgi_exports__RGBAIntegerFormat;
exports.RGBAFormat = __webpackgi_exports__RGBAFormat;
exports.RGBADepthPacking = __webpackgi_exports__RGBADepthPacking;
exports.REVISION = __webpackgi_exports__REVISION;
exports.QuaternionLinearInterpolant = __webpackgi_exports__QuaternionLinearInterpolant;
exports.QuaternionKeyframeTrack = __webpackgi_exports__QuaternionKeyframeTrack;
exports.Quaternion = __webpackgi_exports__Quaternion;
exports.QuadraticBezierCurve3 = __webpackgi_exports__QuadraticBezierCurve3;
exports.QuadraticBezierCurve = __webpackgi_exports__QuadraticBezierCurve;
exports.PropertyMixer = __webpackgi_exports__PropertyMixer;
exports.PropertyBinding = __webpackgi_exports__PropertyBinding;
exports.ProgressivePlugin = __webpackgi_exports__ProgressivePlugin;
exports.PositionalAudio = __webpackgi_exports__PositionalAudio;
exports.PopmotionPlugin = __webpackgi_exports__PopmotionPlugin;
exports.PolyhedronGeometry = __webpackgi_exports__PolyhedronGeometry;
exports.PolyhedronBufferGeometry = __webpackgi_exports__PolyhedronBufferGeometry;
exports.PolarGridHelper = __webpackgi_exports__PolarGridHelper;
exports.PointsMaterial = __webpackgi_exports__PointsMaterial;
exports.Points = __webpackgi_exports__Points;
exports.PointLightHelper = __webpackgi_exports__PointLightHelper;
exports.PointLight = __webpackgi_exports__PointLight;
exports.PlaneHelper = __webpackgi_exports__PlaneHelper;
exports.PlaneGeometry = __webpackgi_exports__PlaneGeometry;
exports.PlaneBufferGeometry = __webpackgi_exports__PlaneBufferGeometry;
exports.Plane = __webpackgi_exports__Plane;
exports.PickingPlugin = __webpackgi_exports__PickingPlugin;
exports.PerspectiveCamera = __webpackgi_exports__PerspectiveCamera;
exports.Path = __webpackgi_exports__Path;
exports.ParametricGeometry = __webpackgi_exports__ParametricGeometry;
exports.ParallaxMappingPlugin = __webpackgi_exports__ParallaxMappingPlugin;
exports.PMREMGeneratorPlugin = __webpackgi_exports__PMREMGeneratorPlugin;
exports.PMREMGenerator = __webpackgi_exports__PMREMGenerator;
exports.PCFSoftShadowMap = __webpackgi_exports__PCFSoftShadowMap;
exports.PCFShadowMap = __webpackgi_exports__PCFShadowMap;
exports.OrthographicCamera = __webpackgi_exports__OrthographicCamera;
exports.OrbitControls2 = __webpackgi_exports__OrbitControls2;
exports.OneMinusSrcColorFactor = __webpackgi_exports__OneMinusSrcColorFactor;
exports.OneMinusSrcAlphaFactor = __webpackgi_exports__OneMinusSrcAlphaFactor;
exports.OneMinusDstColorFactor = __webpackgi_exports__OneMinusDstColorFactor;
exports.OneMinusDstAlphaFactor = __webpackgi_exports__OneMinusDstAlphaFactor;
exports.OneFactor = __webpackgi_exports__OneFactor;
exports.OctahedronGeometry = __webpackgi_exports__OctahedronGeometry;
exports.OctahedronBufferGeometry = __webpackgi_exports__OctahedronBufferGeometry;
exports.ObjectSpaceNormalMap = __webpackgi_exports__ObjectSpaceNormalMap;
exports.ObjectRotationPlugin = __webpackgi_exports__ObjectRotationPlugin;
exports.ObjectProcessorMap = __webpackgi_exports__ObjectProcessorMap;
exports.ObjectPicker = __webpackgi_exports__ObjectPicker;
exports.ObjectLoader2 = __webpackgi_exports__ObjectLoader2;
exports.ObjectLoader = __webpackgi_exports__ObjectLoader;
exports.Object3DModel = __webpackgi_exports__Object3DModel;
exports.Object3D = __webpackgi_exports__Object3D;
exports.ObjMtlLoadPlugin = __webpackgi_exports__ObjMtlLoadPlugin;
exports.OBJLoader2 = __webpackgi_exports__OBJLoader2;
exports.NumberKeyframeTrack = __webpackgi_exports__NumberKeyframeTrack;
exports.NotEqualStencilFunc = __webpackgi_exports__NotEqualStencilFunc;
exports.NotEqualDepth = __webpackgi_exports__NotEqualDepth;
exports.NormalCaptureMaterial = __webpackgi_exports__NormalCaptureMaterial;
exports.NormalBlending = __webpackgi_exports__NormalBlending;
exports.NormalAnimationBlendMode = __webpackgi_exports__NormalAnimationBlendMode;
exports.NoiseBumpMaterialPlugin = __webpackgi_exports__NoiseBumpMaterialPlugin;
exports.NoToneMapping = __webpackgi_exports__NoToneMapping;
exports.NoColorSpace = __webpackgi_exports__NoColorSpace;
exports.NoBlending = __webpackgi_exports__NoBlending;
exports.NeverStencilFunc = __webpackgi_exports__NeverStencilFunc;
exports.NeverDepth = __webpackgi_exports__NeverDepth;
exports.NearestMipmapNearestFilter = __webpackgi_exports__NearestMipmapNearestFilter;
exports.NearestMipmapLinearFilter = __webpackgi_exports__NearestMipmapLinearFilter;
exports.NearestMipMapNearestFilter = __webpackgi_exports__NearestMipMapNearestFilter;
exports.NearestMipMapLinearFilter = __webpackgi_exports__NearestMipMapLinearFilter;
exports.NearestFilter = __webpackgi_exports__NearestFilter;
exports.MultiplyOperation = __webpackgi_exports__MultiplyOperation;
exports.MultiplyBlending = __webpackgi_exports__MultiplyBlending;
exports.MultiFilterPlugin = __webpackgi_exports__MultiFilterPlugin;
exports.MixOperation = __webpackgi_exports__MixOperation;
exports.MirroredRepeatWrapping = __webpackgi_exports__MirroredRepeatWrapping;
exports.MinEquation = __webpackgi_exports__MinEquation;
exports.MeshToonMaterial = __webpackgi_exports__MeshToonMaterial;
exports.MeshStandardMaterial2 = __webpackgi_exports__MeshStandardMaterial2;
exports.MeshStandardMaterial = __webpackgi_exports__MeshStandardMaterial;
exports.MeshPhysicalMaterial = __webpackgi_exports__MeshPhysicalMaterial;
exports.MeshPhongMaterial = __webpackgi_exports__MeshPhongMaterial;
exports.MeshNormalMaterial = __webpackgi_exports__MeshNormalMaterial;
exports.MeshMatcapMaterial = __webpackgi_exports__MeshMatcapMaterial;
exports.MeshLambertMaterial = __webpackgi_exports__MeshLambertMaterial;
exports.MeshDistanceMaterial = __webpackgi_exports__MeshDistanceMaterial;
exports.MeshDepthMaterial = __webpackgi_exports__MeshDepthMaterial;
exports.MeshBasicMaterial = __webpackgi_exports__MeshBasicMaterial;
exports.Mesh = __webpackgi_exports__Mesh;
exports.MaxEquation = __webpackgi_exports__MaxEquation;
exports.Matrix4 = __webpackgi_exports__Matrix4;
exports.Matrix3 = __webpackgi_exports__Matrix3;
exports.MathUtils = __webpackgi_exports__MathUtils;
exports.MaterialPreviewGenerator = __webpackgi_exports__MaterialPreviewGenerator;
exports.MaterialManager = __webpackgi_exports__MaterialManager;
exports.MaterialLoader = __webpackgi_exports__MaterialLoader;
exports.MaterialLibraryPlugin = __webpackgi_exports__MaterialLibraryPlugin;
exports.MaterialLibraryBasePlugin = __webpackgi_exports__MaterialLibraryBasePlugin;
exports.MaterialExtender = __webpackgi_exports__MaterialExtender;
exports.MaterialConfiguratorPlugin = __webpackgi_exports__MaterialConfiguratorPlugin;
exports.MaterialConfiguratorBasePlugin = __webpackgi_exports__MaterialConfiguratorBasePlugin;
exports.Material = __webpackgi_exports__Material;
exports.MTLLoader2 = __webpackgi_exports__MTLLoader2;
exports.MOUSE = __webpackgi_exports__MOUSE;
exports.LuminanceFormat = __webpackgi_exports__LuminanceFormat;
exports.LuminanceAlphaFormat = __webpackgi_exports__LuminanceAlphaFormat;
exports.LoopRepeat = __webpackgi_exports__LoopRepeat;
exports.LoopPingPong = __webpackgi_exports__LoopPingPong;
exports.LoopOnce = __webpackgi_exports__LoopOnce;
exports.LoadingManager = __webpackgi_exports__LoadingManager;
exports.LoaderUtils = __webpackgi_exports__LoaderUtils;
exports.Loader = __webpackgi_exports__Loader;
exports.LinearToneMapping = __webpackgi_exports__LinearToneMapping;
exports.LinearSRGBColorSpace = __webpackgi_exports__LinearSRGBColorSpace;
exports.LinearMipmapNearestFilter = __webpackgi_exports__LinearMipmapNearestFilter;
exports.LinearMipmapLinearFilter = __webpackgi_exports__LinearMipmapLinearFilter;
exports.LinearMipMapNearestFilter = __webpackgi_exports__LinearMipMapNearestFilter;
exports.LinearMipMapLinearFilter = __webpackgi_exports__LinearMipMapLinearFilter;
exports.LinearInterpolant = __webpackgi_exports__LinearInterpolant;
exports.LinearFilter = __webpackgi_exports__LinearFilter;
exports.LinearEncoding = __webpackgi_exports__LinearEncoding;
exports.LineSegments = __webpackgi_exports__LineSegments;
exports.LineLoop = __webpackgi_exports__LineLoop;
exports.LineDashedMaterial = __webpackgi_exports__LineDashedMaterial;
exports.LineCurve3 = __webpackgi_exports__LineCurve3;
exports.LineCurve = __webpackgi_exports__LineCurve;
exports.LineBasicMaterial = __webpackgi_exports__LineBasicMaterial;
exports.Line3 = __webpackgi_exports__Line3;
exports.Line = __webpackgi_exports__Line;
exports.LightProbe = __webpackgi_exports__LightProbe;
exports.Light = __webpackgi_exports__Light;
exports.LessStencilFunc = __webpackgi_exports__LessStencilFunc;
exports.LessEqualStencilFunc = __webpackgi_exports__LessEqualStencilFunc;
exports.LessEqualDepth = __webpackgi_exports__LessEqualDepth;
exports.LessDepth = __webpackgi_exports__LessDepth;
exports.Layers = __webpackgi_exports__Layers;
exports.LatheGeometry = __webpackgi_exports__LatheGeometry;
exports.LatheBufferGeometry = __webpackgi_exports__LatheBufferGeometry;
exports.LOD = __webpackgi_exports__LOD;
exports.KeyframeTrack = __webpackgi_exports__KeyframeTrack;
exports.KeepStencilOp = __webpackgi_exports__KeepStencilOp;
exports.KTXLoadPlugin = __webpackgi_exports__KTXLoadPlugin;
exports.KTX2LoadPlugin = __webpackgi_exports__KTX2LoadPlugin;
exports.KHR_TEXTURE_BASISU = __webpackgi_exports__KHR_TEXTURE_BASISU;
exports.InvertStencilOp = __webpackgi_exports__InvertStencilOp;
exports.InterpolateSmooth = __webpackgi_exports__InterpolateSmooth;
exports.InterpolateLinear = __webpackgi_exports__InterpolateLinear;
exports.InterpolateDiscrete = __webpackgi_exports__InterpolateDiscrete;
exports.Interpolant = __webpackgi_exports__Interpolant;
exports.InterleavedBufferAttribute = __webpackgi_exports__InterleavedBufferAttribute;
exports.InterleavedBuffer = __webpackgi_exports__InterleavedBuffer;
exports.IntType = __webpackgi_exports__IntType;
exports.Int8BufferAttribute = __webpackgi_exports__Int8BufferAttribute;
exports.Int32BufferAttribute = __webpackgi_exports__Int32BufferAttribute;
exports.Int16BufferAttribute = __webpackgi_exports__Int16BufferAttribute;
exports.InstancedMesh = __webpackgi_exports__InstancedMesh;
exports.InstancedInterleavedBuffer = __webpackgi_exports__InstancedInterleavedBuffer;
exports.InstancedBufferGeometry = __webpackgi_exports__InstancedBufferGeometry;
exports.InstancedBufferAttribute = __webpackgi_exports__InstancedBufferAttribute;
exports.Inflate = __webpackgi_exports__Inflate;
exports.IncrementWrapStencilOp = __webpackgi_exports__IncrementWrapStencilOp;
exports.IncrementStencilOp = __webpackgi_exports__IncrementStencilOp;
exports.Importer = __webpackgi_exports__Importer;
exports.ImmediateRenderObject = __webpackgi_exports__ImmediateRenderObject;
exports.ImageUtils = __webpackgi_exports__ImageUtils;
exports.ImageLoader = __webpackgi_exports__ImageLoader;
exports.ImageBitmapLoader = __webpackgi_exports__ImageBitmapLoader;
exports.IcosahedronGeometry = __webpackgi_exports__IcosahedronGeometry;
exports.IcosahedronBufferGeometry = __webpackgi_exports__IcosahedronBufferGeometry;
exports.HierarchyUiPlugin = __webpackgi_exports__HierarchyUiPlugin;
exports.HemisphereLightProbe = __webpackgi_exports__HemisphereLightProbe;
exports.HemisphereLightHelper = __webpackgi_exports__HemisphereLightHelper;
exports.HemisphereLight = __webpackgi_exports__HemisphereLight;
exports.HalfFloatType = __webpackgi_exports__HalfFloatType;
exports.HDRiGroundPlugin = __webpackgi_exports__HDRiGroundPlugin;
exports.Gzip = __webpackgi_exports__Gzip;
exports.Gunzip = __webpackgi_exports__Gunzip;
exports.Group = __webpackgi_exports__Group;
exports.GroundPlugin = __webpackgi_exports__GroundPlugin;
exports.GridHelper = __webpackgi_exports__GridHelper;
exports.GreaterStencilFunc = __webpackgi_exports__GreaterStencilFunc;
exports.GreaterEqualStencilFunc = __webpackgi_exports__GreaterEqualStencilFunc;
exports.GreaterEqualDepth = __webpackgi_exports__GreaterEqualDepth;
exports.GreaterDepth = __webpackgi_exports__GreaterDepth;
exports.GenericFilterPlugin = __webpackgi_exports__GenericFilterPlugin;
exports.GenericBlendTexturePass = __webpackgi_exports__GenericBlendTexturePass;
exports.GLTFWriter2 = __webpackgi_exports__GLTFWriter2;
exports.GLTFMeshOptPlugin = __webpackgi_exports__GLTFMeshOptPlugin;
exports.GLTFMaterialsLightMapExtensionName = __webpackgi_exports__GLTFMaterialsLightMapExtensionName;
exports.GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__GLTFMaterialsBumpMapExtensionName;
exports.GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName;
exports.GLTFLoader2 = __webpackgi_exports__GLTFLoader2;
exports.GLTFExporter2 = __webpackgi_exports__GLTFExporter2;
exports.GLTFDracoExporter = __webpackgi_exports__GLTFDracoExporter;
exports.GLTFDracoExportPlugin = __webpackgi_exports__GLTFDracoExportPlugin;
exports.GLTFAnimationPlugin = __webpackgi_exports__GLTFAnimationPlugin;
exports.GLSL3 = __webpackgi_exports__GLSL3;
exports.GLSL1 = __webpackgi_exports__GLSL1;
exports.GLBufferAttribute = __webpackgi_exports__GLBufferAttribute;
exports.GBufferPlugin = __webpackgi_exports__GBufferPlugin;
exports.FullScreenPlugin = __webpackgi_exports__FullScreenPlugin;
exports.Frustum = __webpackgi_exports__Frustum;
exports.FrontSide = __webpackgi_exports__FrontSide;
exports.FramebufferTexture = __webpackgi_exports__FramebufferTexture;
exports.FrameFadePlugin = __webpackgi_exports__FrameFadePlugin;
exports.FontLoader = __webpackgi_exports__FontLoader;
exports.Font = __webpackgi_exports__Font;
exports.FogExp2 = __webpackgi_exports__FogExp2;
exports.Fog = __webpackgi_exports__Fog;
exports.FloatType = __webpackgi_exports__FloatType;
exports.Float64BufferAttribute = __webpackgi_exports__Float64BufferAttribute;
exports.Float32BufferAttribute = __webpackgi_exports__Float32BufferAttribute;
exports.Float16BufferAttribute = __webpackgi_exports__Float16BufferAttribute;
exports.FlatShading = __webpackgi_exports__FlatShading;
exports.FileLoader = __webpackgi_exports__FileLoader;
exports.FSShadowMaterial = __webpackgi_exports__FSShadowMaterial;
exports.FBXLoadPlugin = __webpackgi_exports__FBXLoadPlugin;
exports.ExtrudeGeometry = __webpackgi_exports__ExtrudeGeometry;
exports.ExtrudeBufferGeometry = __webpackgi_exports__ExtrudeBufferGeometry;
exports.EventDispatcher = __webpackgi_exports__EventDispatcher;
exports.Euler = __webpackgi_exports__Euler;
exports.EquirectangularRefractionMapping = __webpackgi_exports__EquirectangularRefractionMapping;
exports.EquirectangularReflectionMapping = __webpackgi_exports__EquirectangularReflectionMapping;
exports.EqualStencilFunc = __webpackgi_exports__EqualStencilFunc;
exports.EqualDepth = __webpackgi_exports__EqualDepth;
exports.EncodeUTF8 = __webpackgi_exports__EncodeUTF8;
exports.EllipseCurve = __webpackgi_exports__EllipseCurve;
exports.EffectComposer2 = __webpackgi_exports__EffectComposer2;
exports.EdgesGeometry = __webpackgi_exports__EdgesGeometry;
exports.EasingFunctions = __webpackgi_exports__EasingFunctions;
exports.EXRLoadPlugin = __webpackgi_exports__EXRLoadPlugin;
exports.DynamicReadUsage = __webpackgi_exports__DynamicReadUsage;
exports.DynamicDrawUsage = __webpackgi_exports__DynamicDrawUsage;
exports.DynamicCopyUsage = __webpackgi_exports__DynamicCopyUsage;
exports.DstColorFactor = __webpackgi_exports__DstColorFactor;
exports.DstAlphaFactor = __webpackgi_exports__DstAlphaFactor;
exports.DropzonePlugin = __webpackgi_exports__DropzonePlugin;
exports.Dropzone = __webpackgi_exports__Dropzone;
exports.DoubleSide = __webpackgi_exports__DoubleSide;
exports.DodecahedronGeometry = __webpackgi_exports__DodecahedronGeometry;
exports.DodecahedronBufferGeometry = __webpackgi_exports__DodecahedronBufferGeometry;
exports.DiscreteInterpolant = __webpackgi_exports__DiscreteInterpolant;
exports.DirectionalLightHelper = __webpackgi_exports__DirectionalLightHelper;
exports.DirectionalLight2 = __webpackgi_exports__DirectionalLight2;
exports.DirectionalLight = __webpackgi_exports__DirectionalLight;
exports.DiamondPlugin = __webpackgi_exports__DiamondPlugin;
exports.DiamondMaterial = __webpackgi_exports__DiamondMaterial;
exports.DepthTexture = __webpackgi_exports__DepthTexture;
exports.DepthStencilFormat = __webpackgi_exports__DepthStencilFormat;
exports.DepthOfFieldPlugin = __webpackgi_exports__DepthOfFieldPlugin;
exports.DepthOfFieldPass = __webpackgi_exports__DepthOfFieldPass;
exports.DepthFormat = __webpackgi_exports__DepthFormat;
exports.Deflate = __webpackgi_exports__Deflate;
exports.DefaultLoadingManager = __webpackgi_exports__DefaultLoadingManager;
exports.DecrementWrapStencilOp = __webpackgi_exports__DecrementWrapStencilOp;
exports.DecrementStencilOp = __webpackgi_exports__DecrementStencilOp;
exports.Decompress = __webpackgi_exports__Decompress;
exports.DecodeUTF8 = __webpackgi_exports__DecodeUTF8;
exports.DebugPlugin = __webpackgi_exports__DebugPlugin;
exports.DataUtils = __webpackgi_exports__DataUtils;
exports.DataUrlLoader = __webpackgi_exports__DataUrlLoader;
exports.DataTextureLoader = __webpackgi_exports__DataTextureLoader;
exports.DataTexture3D = __webpackgi_exports__DataTexture3D;
exports.DataTexture2DArray = __webpackgi_exports__DataTexture2DArray;
exports.DataTexture = __webpackgi_exports__DataTexture;
exports.DataArrayTexture = __webpackgi_exports__DataArrayTexture;
exports.Data3DTexture = __webpackgi_exports__Data3DTexture;
exports.Damper = __webpackgi_exports__Damper;
exports.DRACOLoader2 = __webpackgi_exports__DRACOLoader2;
exports.DECAY_MILLISECONDS = __webpackgi_exports__DECAY_MILLISECONDS;
exports.Cylindrical = __webpackgi_exports__Cylindrical;
exports.CylinderGeometry = __webpackgi_exports__CylinderGeometry;
exports.CylinderBufferGeometry = __webpackgi_exports__CylinderBufferGeometry;
exports.CustomToneMapping = __webpackgi_exports__CustomToneMapping;
exports.CustomBumpMapPlugin = __webpackgi_exports__CustomBumpMapPlugin;
exports.CustomBlending = __webpackgi_exports__CustomBlending;
exports.CurvePath = __webpackgi_exports__CurvePath;
exports.Curve = __webpackgi_exports__Curve;
exports.CullFaceNone = __webpackgi_exports__CullFaceNone;
exports.CullFaceFrontBack = __webpackgi_exports__CullFaceFrontBack;
exports.CullFaceFront = __webpackgi_exports__CullFaceFront;
exports.CullFaceBack = __webpackgi_exports__CullFaceBack;
exports.CubicInterpolant = __webpackgi_exports__CubicInterpolant;
exports.CubicBezierCurve3 = __webpackgi_exports__CubicBezierCurve3;
exports.CubicBezierCurve = __webpackgi_exports__CubicBezierCurve;
exports.CubeUVReflectionMapping = __webpackgi_exports__CubeUVReflectionMapping;
exports.CubeTextureLoader = __webpackgi_exports__CubeTextureLoader;
exports.CubeTexture = __webpackgi_exports__CubeTexture;
exports.CubeRefractionMapping = __webpackgi_exports__CubeRefractionMapping;
exports.CubeReflectionMapping = __webpackgi_exports__CubeReflectionMapping;
exports.CubeNormalsCaptureHelper = __webpackgi_exports__CubeNormalsCaptureHelper;
exports.CubeCamera = __webpackgi_exports__CubeCamera;
exports.ContactShadowGroundPlugin = __webpackgi_exports__ContactShadowGroundPlugin;
exports.ConeGeometry = __webpackgi_exports__ConeGeometry;
exports.ConeBufferGeometry = __webpackgi_exports__ConeBufferGeometry;
exports.CompressedTextureLoader = __webpackgi_exports__CompressedTextureLoader;
exports.CompressedTexture = __webpackgi_exports__CompressedTexture;
exports.Compress = __webpackgi_exports__Compress;
exports.ColorManagement = __webpackgi_exports__ColorManagement;
exports.ColorKeyframeTrack = __webpackgi_exports__ColorKeyframeTrack;
exports.Color = __webpackgi_exports__Color;
exports.Clock = __webpackgi_exports__Clock;
exports.ClampToEdgeWrapping = __webpackgi_exports__ClampToEdgeWrapping;
exports.CircleGeometry = __webpackgi_exports__CircleGeometry;
exports.CircleBufferGeometry = __webpackgi_exports__CircleBufferGeometry;
exports.CineonToneMapping = __webpackgi_exports__CineonToneMapping;
exports.CatmullRomCurve3 = __webpackgi_exports__CatmullRomCurve3;
exports.CapsuleGeometry = __webpackgi_exports__CapsuleGeometry;
exports.CapsuleBufferGeometry = __webpackgi_exports__CapsuleBufferGeometry;
exports.CanvasTexture = __webpackgi_exports__CanvasTexture;
exports.CanvasSnipperPlugin = __webpackgi_exports__CanvasSnipperPlugin;
exports.CanvasSnipper = __webpackgi_exports__CanvasSnipper;
exports.CanvasRecorderPlugin = __webpackgi_exports__CanvasRecorderPlugin;
exports.CanvasRecorder = __webpackgi_exports__CanvasRecorder;
exports.CameraViewPlugin = __webpackgi_exports__CameraViewPlugin;
exports.CameraView = __webpackgi_exports__CameraView;
exports.CameraHelper = __webpackgi_exports__CameraHelper;
exports.CameraController = __webpackgi_exports__CameraController;
exports.Camera = __webpackgi_exports__Camera;
exports.Cache = __webpackgi_exports__Cache;
exports.ByteType = __webpackgi_exports__ByteType;
exports.BufferGeometryLoader = __webpackgi_exports__BufferGeometryLoader;
exports.BufferGeometry = __webpackgi_exports__BufferGeometry;
exports.BufferAttribute = __webpackgi_exports__BufferAttribute;
exports.BoxSelectionWidget = __webpackgi_exports__BoxSelectionWidget;
exports.BoxHelper = __webpackgi_exports__BoxHelper;
exports.BoxGeometry = __webpackgi_exports__BoxGeometry;
exports.BoxBufferGeometry = __webpackgi_exports__BoxBufferGeometry;
exports.Box3Helper = __webpackgi_exports__Box3Helper;
exports.Box3B = __webpackgi_exports__Box3B;
exports.Box3 = __webpackgi_exports__Box3;
exports.Box2 = __webpackgi_exports__Box2;
exports.BooleanKeyframeTrack = __webpackgi_exports__BooleanKeyframeTrack;
exports.Bone = __webpackgi_exports__Bone;
exports.BloomPlugin = __webpackgi_exports__BloomPlugin;
exports.BlobLoader = __webpackgi_exports__BlobLoader;
exports.BasicShadowMap = __webpackgi_exports__BasicShadowMap;
exports.BasicDepthPacking = __webpackgi_exports__BasicDepthPacking;
exports.BaseRenderer = __webpackgi_exports__BaseRenderer;
exports.BaseGroundPlugin = __webpackgi_exports__BaseGroundPlugin;
exports.BackSide = __webpackgi_exports__BackSide;
exports.AxesHelper = __webpackgi_exports__AxesHelper;
exports.AudioLoader = __webpackgi_exports__AudioLoader;
exports.AudioListener = __webpackgi_exports__AudioListener;
exports.AudioContext = __webpackgi_exports__AudioContext;
exports.AudioAnalyser = __webpackgi_exports__AudioAnalyser;
exports.Audio = __webpackgi_exports__Audio;
exports.AsyncZlib = __webpackgi_exports__AsyncZlib;
exports.AsyncZipDeflate = __webpackgi_exports__AsyncZipDeflate;
exports.AsyncUnzlib = __webpackgi_exports__AsyncUnzlib;
exports.AsyncUnzipInflate = __webpackgi_exports__AsyncUnzipInflate;
exports.AsyncInflate = __webpackgi_exports__AsyncInflate;
exports.AsyncGzip = __webpackgi_exports__AsyncGzip;
exports.AsyncGunzip = __webpackgi_exports__AsyncGunzip;
exports.AsyncDeflate = __webpackgi_exports__AsyncDeflate;
exports.AsyncDecompress = __webpackgi_exports__AsyncDecompress;
exports.AsyncCompress = __webpackgi_exports__AsyncCompress;
exports.AssetManagerPlugin = __webpackgi_exports__AssetManagerPlugin;
exports.AssetManagerBasicPopupPlugin = __webpackgi_exports__AssetManagerBasicPopupPlugin;
exports.AssetImporter = __webpackgi_exports__AssetImporter;
exports.AssetExporterPlugin = __webpackgi_exports__AssetExporterPlugin;
exports.AssetExporter = __webpackgi_exports__AssetExporter;
exports.ArrowHelper = __webpackgi_exports__ArrowHelper;
exports.ArrayCamera = __webpackgi_exports__ArrayCamera;
exports.ArcCurve = __webpackgi_exports__ArcCurve;
exports.AnisotropyPlugin = __webpackgi_exports__AnisotropyPlugin;
exports.AnimationUtils = __webpackgi_exports__AnimationUtils;
exports.AnimationObjectGroup = __webpackgi_exports__AnimationObjectGroup;
exports.AnimationMixer = __webpackgi_exports__AnimationMixer;
exports.AnimationLoader = __webpackgi_exports__AnimationLoader;
exports.AnimationClip = __webpackgi_exports__AnimationClip;
exports.AmbientLightProbe = __webpackgi_exports__AmbientLightProbe;
exports.AmbientLight2 = __webpackgi_exports__AmbientLight2;
exports.AmbientLight = __webpackgi_exports__AmbientLight;
exports.AlwaysStencilFunc = __webpackgi_exports__AlwaysStencilFunc;
exports.AlwaysDepth = __webpackgi_exports__AlwaysDepth;
exports.AlphaFormat = __webpackgi_exports__AlphaFormat;
exports.AdditiveBlending = __webpackgi_exports__AdditiveBlending;
exports.AdditiveAnimationBlendMode = __webpackgi_exports__AdditiveAnimationBlendMode;
exports.AddOperation = __webpackgi_exports__AddOperation;
exports.AddEquation = __webpackgi_exports__AddEquation;
exports.AddBlendPass = __webpackgi_exports__AddBlendPass;
exports.AViewerPlugin = __webpackgi_exports__AViewerPlugin;
exports.ARTouchInputHelper = __webpackgi_exports__ARTouchInputHelper;
exports.ARPlugin = __webpackgi_exports__ARPlugin;
exports.ARPlacementBox = __webpackgi_exports__ARPlacementBox;
exports.AMaterialManager = __webpackgi_exports__AMaterialManager;
exports.ACESFilmicToneMapping = __webpackgi_exports__ACESFilmicToneMapping;
},{"buffer":"node_modules/buffer/index.js"}],"node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"src/styles.css":[function(require,module,exports) {
var reloadCSS = require('_css_loader');

module.hot.dispose(reloadCSS);
module.hot.accept(reloadCSS);
},{"_css_loader":"node_modules/parcel-bundler/src/builtins/css-loader.js"}],"node_modules/gsap/gsap-core.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapYoyo = exports.wrap = exports.unitize = exports.toArray = exports.splitColor = exports.snap = exports.shuffle = exports.selector = exports.random = exports.pipe = exports.normalize = exports.mapRange = exports.interpolate = exports.gsap = exports.getUnit = exports.distribute = exports.default = exports.clamp = exports._ticker = exports._sortPropTweensByPriority = exports._setDefaults = exports._roundModifier = exports._round = exports._replaceRandom = exports._renderComplexString = exports._removeLinkedListItem = exports._relExp = exports._plugins = exports._parseRelative = exports._numWithUnitExp = exports._numExp = exports._missingPlugin = exports._isUndefined = exports._isString = exports._getSetter = exports._getProperty = exports._getCache = exports._forEachName = exports._config = exports._colorStringFilter = exports._colorExp = exports._checkPlugin = exports.TweenMax = exports.TweenLite = exports.Tween = exports.TimelineMax = exports.TimelineLite = exports.Timeline = exports.Strong = exports.SteppedEase = exports.Sine = exports.Quint = exports.Quart = exports.Quad = exports.PropTween = exports.Power4 = exports.Power3 = exports.Power2 = exports.Power1 = exports.Power0 = exports.Linear = exports.GSCache = exports.Expo = exports.Elastic = exports.Cubic = exports.Circ = exports.Bounce = exports.Back = exports.Animation = void 0;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _reverting,
    _context,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _startAtRevertConfig = {
  suppressEvents: true,
  isStart: true
},
    _revertConfig = {
  suppressEvents: true
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_parseRelative = function _parseRelative(start, value) {
  var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force || _reverting);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfig) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)

  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents && !_reverting) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);

    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      prevContext = _context,
      context = animation._ctx,
      params,
      scope,
      result;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  context && (_context = context);
  result = params ? callback.apply(scope, params) : callback.call(scope);
  _context = prevContext;
  return result;
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function (t, d, f, v) {
        callback(t, d, f, v);

        _self.remove(func);
      } : callback;

      _self.remove(callback);

      _listeners[prioritize ? "unshift" : "push"](func);

      _wake();

      return func;
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


exports._ticker = _ticker;
exports._colorStringFilter = _colorStringFilter;
exports._colorExp = _colorExp;
exports.splitColor = splitColor;
exports.interpolate = interpolate;
exports.mapRange = mapRange;
exports._replaceRandom = _replaceRandom;
exports.wrapYoyo = wrapYoyo;
exports.wrap = wrap;
exports.normalize = normalize;
exports.unitize = unitize;
exports.pipe = pipe;
exports.random = random;
exports.snap = snap;
exports._roundModifier = _roundModifier;
exports.distribute = distribute;
exports.shuffle = shuffle;
exports.selector = selector;
exports.toArray = toArray;
exports.clamp = clamp;
exports.getUnit = getUnit;
exports._removeLinkedListItem = _removeLinkedListItem;
exports._setDefaults = _setDefaults;
exports._parseRelative = _parseRelative;
exports._round = _round;
exports._forEachName = _forEachName;
exports._getProperty = _getProperty;
exports._getCache = _getCache;
exports._plugins = _plugins;
exports._missingPlugin = _missingPlugin;
exports._relExp = _relExp;
exports._numWithUnitExp = _numWithUnitExp;
exports._numExp = _numExp;
exports._isUndefined = _isUndefined;
exports._isString = _isString;
exports._config = _config;

_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */


exports.GSCache = GSCache;

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;

    if (_context) {
      this._ctx = _context;

      _context.data.push(this);
    }

    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return _recacheAncestors(this);
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.revert = function revert(config) {
    if (config === void 0) {
      config = _revertConfig;
    }

    var prevIsReverting = _reverting;
    _reverting = config;
    this.timeline && this.timeline.revert(config);
    this.totalTime(-0.01, config.suppressEvents);
    this.data !== "nested" && _removeFromParent(this);
    _reverting = prevIsReverting;
    return this;
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return !this.parent && this.vars.immediateRender ? -1 : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for Recording.revert())
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

exports.Animation = Animation;

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        force = force || _reverting; // if reverting, we should always force renders. If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.

        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

exports.TimelineLite = exports.TimelineMax = exports.Timeline = Timeline;

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (!optional || parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_forceAllPropTweens,
    _initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);

    if (prevStartAt) {
      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfig : _startAtRevertConfig); // if it's a "startAt" (not "from()" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)
      // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for "startAt" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.

      prevStartAt._lazy = 0;
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfig); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (!prevStartAt) {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && (_reverting ? tween._startAt.revert(_revertConfig) : tween._startAt.render(-1, true));
        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      rootPT,
      lookup,
      i;

  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;

    while (i--) {
      pt = lookup[i][property];

      if (pt && pt.d && pt.d._pt) {
        // it's a plugin, so find the nested PropTween
        pt = pt.d._pt;

        while (pt && pt.p !== property && pt.fp !== property) {
          // "fp" is functionParam for things like setting CSS variables which require .setProperty("--var-name", value)
          pt = pt._next;
        }
      }

      if (!pt) {
        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

        tween.vars[property] = "+=0";

        _initTween(tween, time);

        _forceAllPropTweens = 0;
        return 1;
      }

      ptCache.push(pt);
    }
  }

  i = ptCache.length;

  while (i--) {
    rootPT = ptCache[i];
    pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.

    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)

    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)
  }
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};

exports._checkPlugin = _checkPlugin;

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {},
        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.

      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        isNegative = totalTime < 0,
        tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && isNegative) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (prevTime !== this._time) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
      return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}


    _alignPlayhead(this, 0);

    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

exports.TweenLite = exports.TweenMax = exports.Tween = Tween;

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


exports._sortPropTweensByPriority = _sortPropTweensByPriority;
exports._renderComplexString = _renderComplexString;
exports._getSetter = _getSetter;

var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks


exports.PropTween = PropTween;

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;

var _media = [],
    _listeners = {},
    _emptyArray = [],
    _lastMediaTime = 0,
    _dispatch = function _dispatch(type) {
  return (_listeners[type] || _emptyArray).map(function (f) {
    return f();
  });
},
    _onMediaChange = function _onMediaChange() {
  var time = Date.now(),
      matches = [];

  if (time - _lastMediaTime > 2) {
    _dispatch("matchMediaInit");

    _media.forEach(function (c) {
      var queries = c.queries,
          conditions = c.conditions,
          match,
          p,
          anyMatch,
          toggled;

      for (p in queries) {
        match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.

        match && (anyMatch = 1);

        if (match !== conditions[p]) {
          conditions[p] = match;
          toggled = 1;
        }
      }

      if (toggled) {
        c.revert();
        anyMatch && matches.push(c);
      }
    });

    _dispatch("matchMediaRevert");

    matches.forEach(function (c) {
      return c.onMatch(c);
    });
    _lastMediaTime = time;

    _dispatch("matchMedia");
  }
};

var Context = /*#__PURE__*/function () {
  function Context(func, scope) {
    this.selector = scope && selector(scope);
    this.data = [];
    this._r = []; // returned/cleanup functions

    this.isReverted = false;
    func && this.add(func);
  }

  var _proto5 = Context.prototype;

  _proto5.add = function add(name, func, scope) {
    if (_isFunction(name)) {
      scope = func;
      func = name;
      name = _isFunction;
    }

    var self = this,
        f = function f() {
      var prev = _context,
          prevSelector = self.selector,
          result;
      prev && prev !== self && prev.data.push(self);
      scope && (self.selector = selector(scope));
      _context = self;
      result = func.apply(self, arguments);
      _isFunction(result) && self._r.push(result);
      _context = prev;
      self.selector = prevSelector;
      self.isReverted = false;
      return result;
    };

    self.last = f;
    return name === _isFunction ? f(self) : name ? self[name] = f : f;
  };

  _proto5.ignore = function ignore(func) {
    var prev = _context;
    _context = null;
    func(this);
    _context = prev;
  };

  _proto5.getTweens = function getTweens() {
    var a = [];
    this.data.forEach(function (e) {
      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && a.push(e);
    });
    return a;
  };

  _proto5.clear = function clear() {
    this._r.length = this.data.length = 0;
  };

  _proto5.kill = function kill(revert, matchMedia) {
    var _this4 = this;

    if (revert) {
      // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort
      this.getTweens().map(function (t) {
        return {
          g: t.globalTime(0),
          t: t
        };
      }).sort(function (a, b) {
        return b.g - a.g || -1;
      }).forEach(function (o) {
        return o.t.revert(revert);
      }); // note: all of the _startAt tweens should be reverted in reverse order that thy were created, and they'll all have the same globalTime (-1) so the " || -1" in the sort keeps the order properly.

      this.data.forEach(function (e) {
        return !(e instanceof Animation) && e.revert && e.revert(revert);
      });

      this._r.forEach(function (f) {
        return f(revert, _this4);
      });

      this.isReverted = true;
    } else {
      this.data.forEach(function (e) {
        return e.kill && e.kill();
      });
    }

    this.clear();

    if (matchMedia) {
      var i = _media.indexOf(this);

      !!~i && _media.splice(i, 1);
    }
  };

  _proto5.revert = function revert(config) {
    this.kill(config || {});
  };

  return Context;
}();

var MatchMedia = /*#__PURE__*/function () {
  function MatchMedia(scope) {
    this.contexts = [];
    this.scope = scope;
  }

  var _proto6 = MatchMedia.prototype;

  _proto6.add = function add(conditions, func, scope) {
    _isObject(conditions) || (conditions = {
      matches: conditions
    });
    var context = new Context(0, scope || this.scope),
        cond = context.conditions = {},
        mq,
        p,
        active;
    this.contexts.push(context);
    func = context.add("onMatch", func);
    context.queries = conditions;

    for (p in conditions) {
      if (p === "all") {
        active = 1;
      } else {
        mq = _win.matchMedia(conditions[p]);

        if (mq) {
          _media.indexOf(context) < 0 && _media.push(context);
          (cond[p] = mq.matches) && (active = 1);
          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
        }
      }
    }

    active && func(context);
    return this;
  } // refresh() {
  // 	let time = _lastMediaTime,
  // 		media = _media;
  // 	_lastMediaTime = -1;
  // 	_media = this.contexts;
  // 	_onMediaChange();
  // 	_lastMediaTime = time;
  // 	_media = media;
  // }
  ;

  _proto6.revert = function revert(config) {
    this.kill(config || {});
  };

  _proto6.kill = function kill(revert) {
    this.contexts.forEach(function (c) {
      return c.kill(revert, true);
    });
  };

  return MatchMedia;
}();
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */


var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge2;

    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
        func = function func(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };

    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  context: function context(func, scope) {
    return func ? new Context(func, scope) : _context;
  },
  matchMedia: function matchMedia(scope) {
    return new MatchMedia(scope);
  },
  matchMediaRefresh: function matchMediaRefresh() {
    return _media.forEach(function (c) {
      var cond = c.conditions,
          found,
          p;

      for (p in cond) {
        if (cond[p]) {
          cond[p] = false;
          found = 1;
        }
      }

      found && c.revert();
    }) || _onMediaChange();
  },
  addEventListener: function addEventListener(type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  },
  removeEventListener: function removeEventListener(type, callback) {
    var a = _listeners[type],
        i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    reverting: function reverting() {
      return _reverting;
    },
    context: function context(toAdd) {
      if (toAdd && _context) {
        _context.data.push(toAdd);

        toAdd._ctx = _context;
      }

      return _context;
    },
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt, v;
    this.tween = tween;

    for (p in vars) {
      v = target.getAttribute(p) || "";
      pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
      pt.op = p;
      pt.b = v; // record the beginning value so we can revert()

      this._props.push(p);
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt;

    while (pt) {
      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)

      pt = pt._next;
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.


exports.default = exports.gsap = gsap;
Tween.version = Timeline.version = gsap.version = "3.11.1";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;
exports.Circ = Circ;
exports.Expo = Expo;
exports.Sine = Sine;
exports.Bounce = Bounce;
exports.SteppedEase = SteppedEase;
exports.Back = Back;
exports.Elastic = Elastic;
exports.Strong = Strong;
exports.Quint = Quint;
exports.Quart = Quart;
exports.Cubic = Cubic;
exports.Quad = Quad;
exports.Linear = Linear;
exports.Power4 = Power4;
exports.Power3 = Power3;
exports.Power2 = Power2;
exports.Power1 = Power1;
exports.Power0 = Power0;
},{}],"node_modules/gsap/CSSPlugin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.checkPrefix = exports._getBBox = exports._createElement = exports.CSSPlugin = void 0;

var _gsapCore = require("./gsap-core.js");

/*!
 * CSSPlugin 3.11.1
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _reverting,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _saveStyle = function _saveStyle(property) {
  var _this = this;

  var target = this.target,
      style = target.style;

  if (property in _transformProps) {
    this.tfm = this.tfm || {};

    if (property !== "transform") {
      property = _propertyAliases[property] || property;
      ~property.indexOf(",") ? property.split(",").forEach(function (a) {
        return _this.tfm[a] = _get(target, a);
      }) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property); // note: scale would map to "scaleX,scaleY", thus we loop and apply them both.
    }

    if (this.props.indexOf(_transformProp) >= 0) {
      return;
    }

    if (target._gsap.svg) {
      this.svgo = target.getAttribute("data-svg-origin");
      this.props.push(_transformOriginProp, "");
    }

    property = _transformProp;
  }

  style && this.props.push(property, style[property]);
},
    _removeIndependentTransforms = function _removeIndependentTransforms(style) {
  if (style.translate) {
    style.removeProperty("translate");
    style.removeProperty("scale");
    style.removeProperty("rotate");
  }
},
    _revertStyle = function _revertStyle() {
  var props = this.props,
      target = this.target,
      style = target.style,
      cache = target._gsap,
      i,
      p;

  for (i = 0; i < props.length; i += 2) {
    props[i + 1] ? style[props[i]] = props[i + 1] : style.removeProperty(props[i].replace(_capsExp, "-$1").toLowerCase());
  }

  if (this.tfm) {
    for (p in this.tfm) {
      cache[p] = this.tfm[p];
    }

    if (cache.svg) {
      cache.renderTransform();
      target.setAttribute("data-svg-origin", this.svgo || "");
    }

    i = _reverting();

    if (i && !i.isStart && !style[_transformProp]) {
      _removeIndependentTransforms(style);

      cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.
    }
  }
},
    _getStyleSaver = function _getStyleSaver(target, properties) {
  var saver = {
    target: target,
    props: [],
    revert: _revertStyle,
    save: _saveStyle
  };
  properties && properties.split(",").forEach(function (p) {
    return saver.save(p);
  });
  return saver;
},
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _reverting = _gsapCore.gsap.core.reverting;
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsapCore.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    _nonStandardLayouts = {
  grid: 1,
  flex: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0, _gsapCore._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsapCore._ticker.time && !cache.uncache) {
    return (0, _gsapCore._round)(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = (0, _gsapCore._getCache)(parent);
      cache.time = _gsapCore._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0, _gsapCore._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0, _gsapCore._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsapCore.PropTween(this._pt, target.style, prop, 0, 1, _gsapCore._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; // ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];
  (0, _gsapCore._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().

  start = a[0];
  end = a[1];
  startValues = start.match(_gsapCore._numWithUnitExp) || [];
  endValues = end.match(_gsapCore._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsapCore._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = (0, _gsapCore._parseRelative)(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsapCore._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsapCore._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsapCore._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;

        _removeIndependentTransforms(style);
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsapCore.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsapCore._numExp).map(_gsapCore._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0, _gsapCore._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextElementSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsapCore.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      cs = getComputedStyle(target),
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));

  if (cs.translate) {
    // accommodate independent transforms by combining them into normal ones.
    if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
      style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + cs[_transformProp];
    }

    style.scale = style.rotate = style.translate = "none";
  }

  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    if (cache.uncache) {
      // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.
      t2 = target.getBBox();
      origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
      t1 = "";
    } else {
      t1 = !uncache && target.getAttribute("data-svg-origin"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
    }

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0, _gsapCore._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0, _gsapCore._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0, _gsapCore._round)(scaleX);
  cache.scaleY = (0, _gsapCore._round)(scaleY);
  cache.rotation = (0, _gsapCore._round)(rotation) + deg;
  cache.rotationX = (0, _gsapCore._round)(rotationX) + deg;
  cache.rotationY = (0, _gsapCore._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsapCore._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0, _gsapCore.getUnit)(start);
  return (0, _gsapCore._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0, _gsapCore._round)(a11);
    a21 = (0, _gsapCore._round)(a21);
    a12 = (0, _gsapCore._round)(a12);
    a22 = (0, _gsapCore._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0, _gsapCore._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0, _gsapCore._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0, _gsapCore._round)(tx + xPercent / 100 * temp.width);
    ty = (0, _gsapCore._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
  var cap = 360,
      isString = (0, _gsapCore._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsapCore.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0, _gsapCore.getUnit)(startValue);
      endUnit = (0, _gsapCore.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsapCore.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


exports._getBBox = _getBBox;
exports.checkPrefix = _checkPropPrefix;
exports._createElement = _createElement;
(0, _gsapCore._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});
var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority,
        inlineProps;
    _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps

    this.styles = this.styles || _getStyleSaver(target);
    inlineProps = this.styles.props;
    this.tween = tween;

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsapCore._plugins[p] && (0, _gsapCore._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0, _gsapCore._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsapCore._colorExp.lastIndex = 0;

        if (!_gsapCore._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0, _gsapCore.getUnit)(startValue);
          endUnit = (0, _gsapCore.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
        inlineProps.push(p, style[p]);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          (0, _gsapCore._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0, _gsapCore._replaceRandom)(startValue));
          (0, _gsapCore.getUnit)(startValue + "") || (startValue += _gsapCore._config.units[p] || (0, _gsapCore.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            inlineProps.push("visibility", style.visibility);

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          this.styles.save(p);

          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsapCore.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsapCore.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0, _gsapCore._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
            this._pt.u = 0;
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            inlineProps.push(_transformOriginProp, style[_transformOriginProp]);
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? (0, _gsapCore._parseRelative)(startNum, relative + endValue) : endValue);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0, _gsapCore.getUnit)(endValue) || (p in _gsapCore._config.units ? _gsapCore._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsapCore.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0, _gsapCore._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else {
            (0, _gsapCore._missingPlugin)(p, endValue);
            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }

        isTransformRelated || inlineProps.push(p, style[p]);
        props.push(p);
      }
    }

    hasPriority && (0, _gsapCore._sortPropTweensByPriority)(this);
  },
  render: function render(ratio, data) {
    if (data.tween._time || !_reverting()) {
      var pt = data._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    } else {
      data.styles.revert();
    }
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0, _gsapCore._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0, _gsapCore._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
exports.default = exports.CSSPlugin = CSSPlugin;
_gsapCore.gsap.utils.checkPrefix = _checkPropPrefix;
_gsapCore.gsap.core.getStyleSaver = _getStyleSaver;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0, _gsapCore._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });
  (0, _gsapCore._forEachName)(rotation, function (name) {
    _gsapCore._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });
  _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  (0, _gsapCore._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0, _gsapCore._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsapCore._config.units[name] = "px";
});

_gsapCore.gsap.registerPlugin(CSSPlugin);
},{"./gsap-core.js":"node_modules/gsap/gsap-core.js"}],"node_modules/gsap/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Back", {
  enumerable: true,
  get: function () {
    return _gsapCore.Back;
  }
});
Object.defineProperty(exports, "Bounce", {
  enumerable: true,
  get: function () {
    return _gsapCore.Bounce;
  }
});
Object.defineProperty(exports, "CSSPlugin", {
  enumerable: true,
  get: function () {
    return _CSSPlugin.CSSPlugin;
  }
});
Object.defineProperty(exports, "Circ", {
  enumerable: true,
  get: function () {
    return _gsapCore.Circ;
  }
});
Object.defineProperty(exports, "Cubic", {
  enumerable: true,
  get: function () {
    return _gsapCore.Cubic;
  }
});
Object.defineProperty(exports, "Elastic", {
  enumerable: true,
  get: function () {
    return _gsapCore.Elastic;
  }
});
Object.defineProperty(exports, "Expo", {
  enumerable: true,
  get: function () {
    return _gsapCore.Expo;
  }
});
Object.defineProperty(exports, "Linear", {
  enumerable: true,
  get: function () {
    return _gsapCore.Linear;
  }
});
Object.defineProperty(exports, "Power0", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power0;
  }
});
Object.defineProperty(exports, "Power1", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power1;
  }
});
Object.defineProperty(exports, "Power2", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power2;
  }
});
Object.defineProperty(exports, "Power3", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power3;
  }
});
Object.defineProperty(exports, "Power4", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power4;
  }
});
Object.defineProperty(exports, "Quad", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quad;
  }
});
Object.defineProperty(exports, "Quart", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quart;
  }
});
Object.defineProperty(exports, "Quint", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quint;
  }
});
Object.defineProperty(exports, "Sine", {
  enumerable: true,
  get: function () {
    return _gsapCore.Sine;
  }
});
Object.defineProperty(exports, "SteppedEase", {
  enumerable: true,
  get: function () {
    return _gsapCore.SteppedEase;
  }
});
Object.defineProperty(exports, "Strong", {
  enumerable: true,
  get: function () {
    return _gsapCore.Strong;
  }
});
Object.defineProperty(exports, "TimelineLite", {
  enumerable: true,
  get: function () {
    return _gsapCore.TimelineLite;
  }
});
Object.defineProperty(exports, "TimelineMax", {
  enumerable: true,
  get: function () {
    return _gsapCore.TimelineMax;
  }
});
Object.defineProperty(exports, "TweenLite", {
  enumerable: true,
  get: function () {
    return _gsapCore.TweenLite;
  }
});
exports.gsap = exports.default = exports.TweenMax = void 0;

var _gsapCore = require("./gsap-core.js");

var _CSSPlugin = require("./CSSPlugin.js");

var gsapWithCSS = _gsapCore.gsap.registerPlugin(_CSSPlugin.CSSPlugin) || _gsapCore.gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;

exports.TweenMax = TweenMaxWithCSS;
exports.default = exports.gsap = gsapWithCSS;
},{"./gsap-core.js":"node_modules/gsap/gsap-core.js","./CSSPlugin.js":"node_modules/gsap/CSSPlugin.js"}],"node_modules/gsap/Observer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports._vertical = exports._scrollers = exports._proxies = exports._isViewport = exports._horizontal = exports._getVelocityProp = exports._getTarget = exports._getScrollFunc = exports._getProxyProp = exports.Observer = void 0;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/*!
 * Observer 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var gsap,
    _coreInitted,
    _clamp,
    _win,
    _doc,
    _docEl,
    _body,
    _isTouch,
    _pointerType,
    ScrollTrigger,
    _root,
    _normalizer,
    _eventTypes,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _startup = 1,
    _observers = [],
    _scrollers = [],
    _proxies = [],
    _getTime = Date.now,
    _bridge = function _bridge(name, value) {
  return value;
},
    _integrate = function _integrate() {
  var core = ScrollTrigger.core,
      data = core.bridge || {},
      scrollers = core._scrollers,
      proxies = core._proxies;
  scrollers.push.apply(scrollers, _scrollers);
  proxies.push.apply(proxies, _proxies);
  exports._scrollers = _scrollers = scrollers;
  exports._proxies = _proxies = proxies;

  _bridge = function _bridge(name, value) {
    return data[name](value);
  };
},
    _getProxyProp = function _getProxyProp(element, property) {
  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
},
    _isViewport = function _isViewport(el) {
  return !!~_root.indexOf(el);
},
    _addListener = function _addListener(element, type, func, nonPassive, capture) {
  return element.addEventListener(type, func, {
    passive: !nonPassive,
    capture: !!capture
  });
},
    _removeListener = function _removeListener(element, type, func, capture) {
  return element.removeEventListener(type, func, !!capture);
},
    _scrollLeft = "scrollLeft",
    _scrollTop = "scrollTop",
    _onScroll = function _onScroll() {
  return _normalizer && _normalizer.isPressed || _scrollers.cache++;
},
    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
  var cachingFunc = function cachingFunc(value) {
    // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
    if (value || value === 0) {
      _startup && (_win.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

      var isNormalizing = _normalizer && _normalizer.isPressed;
      value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

      f(value);
      cachingFunc.cacheID = _scrollers.cache;
      isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
    } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
      cachingFunc.cacheID = _scrollers.cache;
      cachingFunc.v = f();
    }

    return cachingFunc.v + cachingFunc.offset;
  };

  cachingFunc.offset = 0;
  return f && cachingFunc;
},
    _horizontal = {
  s: _scrollLeft,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: _scrollCacheFunc(function (value) {
    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
  })
},
    _vertical = {
  s: _scrollTop,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: _horizontal,
  sc: _scrollCacheFunc(function (value) {
    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
  })
},
    _getTarget = function _getTarget(t) {
  return gsap.utils.toArray(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
},
    _getScrollFunc = function _getScrollFunc(element, _ref) {
  var s = _ref.s,
      sc = _ref.sc; // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.

  var i = _scrollers.indexOf(element),
      offset = sc === _vertical.sc ? 1 : 2;

  !~i && (i = _scrollers.push(element) - 1);
  return _scrollers[i + offset] || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {
    return arguments.length ? element[s] = value : element[s];
  })));
},
    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
  var v1 = value,
      v2 = value,
      t1 = _getTime(),
      t2 = t1,
      min = minTimeRefresh || 50,
      dropToZeroTime = Math.max(500, min * 3),
      update = function update(value, force) {
    var t = _getTime();

    if (force || t - t1 > min) {
      v2 = v1;
      v1 = value;
      t2 = t1;
      t1 = t;
    } else if (useDelta) {
      v1 += value;
    } else {
      // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
      v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
    }
  },
      reset = function reset() {
    v2 = v1 = useDelta ? 0 : v1;
    t2 = t1 = 0;
  },
      getVelocity = function getVelocity(latestValue) {
    var tOld = t2,
        vOld = v2,
        t = _getTime();

    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
  };

  return {
    update: update,
    reset: reset,
    getVelocity: getVelocity
  };
},
    _getEvent = function _getEvent(e, preventDefault) {
  preventDefault && !e._gsapAllow && e.preventDefault();
  return e.changedTouches ? e.changedTouches[0] : e;
},
    _getAbsoluteMax = function _getAbsoluteMax(a) {
  var max = Math.max.apply(Math, a),
      min = Math.min.apply(Math, a);
  return Math.abs(max) >= Math.abs(min) ? max : min;
},
    _setScrollTrigger = function _setScrollTrigger() {
  ScrollTrigger = gsap.core.globals().ScrollTrigger;
  ScrollTrigger && ScrollTrigger.core && _integrate();
},
    _initCore = function _initCore(core) {
  gsap = core || _getGSAP();

  if (gsap && typeof document !== "undefined" && document.body) {
    _win = window;
    _doc = document;
    _docEl = _doc.documentElement;
    _body = _doc.body;
    _root = [_win, _doc, _docEl, _body];
    _clamp = gsap.utils.clamp;
    _pointerType = "onpointerenter" in _body ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
    _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
    setTimeout(function () {
      return _startup = 0;
    }, 500);

    _setScrollTrigger();

    _coreInitted = 1;
  }

  return _coreInitted;
};

exports._getVelocityProp = _getVelocityProp;
exports._getScrollFunc = _getScrollFunc;
exports._getTarget = _getTarget;
exports._vertical = _vertical;
exports._horizontal = _horizontal;
exports._isViewport = _isViewport;
exports._getProxyProp = _getProxyProp;
exports._proxies = _proxies;
exports._scrollers = _scrollers;
_horizontal.op = _vertical;
_scrollers.cache = 0;

var Observer = /*#__PURE__*/function () {
  function Observer(vars) {
    this.init(vars);
  }

  var _proto = Observer.prototype;

  _proto.init = function init(vars) {
    _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
    ScrollTrigger || _setScrollTrigger();
    var tolerance = vars.tolerance,
        dragMinimum = vars.dragMinimum,
        type = vars.type,
        target = vars.target,
        lineHeight = vars.lineHeight,
        debounce = vars.debounce,
        preventDefault = vars.preventDefault,
        onStop = vars.onStop,
        onStopDelay = vars.onStopDelay,
        ignore = vars.ignore,
        wheelSpeed = vars.wheelSpeed,
        event = vars.event,
        onDragStart = vars.onDragStart,
        onDragEnd = vars.onDragEnd,
        onDrag = vars.onDrag,
        onPress = vars.onPress,
        onRelease = vars.onRelease,
        onRight = vars.onRight,
        onLeft = vars.onLeft,
        onUp = vars.onUp,
        onDown = vars.onDown,
        onChangeX = vars.onChangeX,
        onChangeY = vars.onChangeY,
        onChange = vars.onChange,
        onToggleX = vars.onToggleX,
        onToggleY = vars.onToggleY,
        onHover = vars.onHover,
        onHoverEnd = vars.onHoverEnd,
        onMove = vars.onMove,
        ignoreCheck = vars.ignoreCheck,
        isNormalizer = vars.isNormalizer,
        onGestureStart = vars.onGestureStart,
        onGestureEnd = vars.onGestureEnd,
        onWheel = vars.onWheel,
        onEnable = vars.onEnable,
        onDisable = vars.onDisable,
        onClick = vars.onClick,
        scrollSpeed = vars.scrollSpeed,
        capture = vars.capture,
        allowClicks = vars.allowClicks,
        lockAxis = vars.lockAxis,
        onLockAxis = vars.onLockAxis;
    this.target = target = _getTarget(target) || _docEl;
    this.vars = vars;
    ignore && (ignore = gsap.utils.toArray(ignore));
    tolerance = tolerance || 1e-9;
    dragMinimum = dragMinimum || 0;
    wheelSpeed = wheelSpeed || 1;
    scrollSpeed = scrollSpeed || 1;
    type = type || "wheel,touch,pointer";
    debounce = debounce !== false;
    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report "normal", so default to 22.

    var id,
        onStopDelayedCall,
        dragged,
        moved,
        wheeled,
        locked,
        axis,
        self = this,
        prevDeltaX = 0,
        prevDeltaY = 0,
        scrollFuncX = _getScrollFunc(target, _horizontal),
        scrollFuncY = _getScrollFunc(target, _vertical),
        scrollX = scrollFuncX(),
        scrollY = scrollFuncY(),
        limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
        // for devices that accommodate mouse events and touch events, we need to distinguish.
    isViewport = _isViewport(target),
        ownerDoc = target.ownerDocument || _doc,
        deltaX = [0, 0, 0],
        // wheel, scroll, pointer/touch
    deltaY = [0, 0, 0],
        onClickTime = 0,
        clickCapture = function clickCapture() {
      return onClickTime = _getTime();
    },
        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
      return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
    },
        onStopFunc = function onStopFunc() {
      self._vx.reset();

      self._vy.reset();

      onStopDelayedCall.pause();
      onStop && onStop(self);
    },
        update = function update() {
      var dx = self.deltaX = _getAbsoluteMax(deltaX),
          dy = self.deltaY = _getAbsoluteMax(deltaY),
          changedX = Math.abs(dx) >= tolerance,
          changedY = Math.abs(dy) >= tolerance;

      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

      if (changedX) {
        onRight && self.deltaX > 0 && onRight(self);
        onLeft && self.deltaX < 0 && onLeft(self);
        onChangeX && onChangeX(self);
        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
        prevDeltaX = self.deltaX;
        deltaX[0] = deltaX[1] = deltaX[2] = 0;
      }

      if (changedY) {
        onDown && self.deltaY > 0 && onDown(self);
        onUp && self.deltaY < 0 && onUp(self);
        onChangeY && onChangeY(self);
        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
        prevDeltaY = self.deltaY;
        deltaY[0] = deltaY[1] = deltaY[2] = 0;
      }

      if (moved || dragged) {
        onMove && onMove(self);

        if (dragged) {
          onDrag(self);
          dragged = false;
        }

        moved = false;
      }

      locked && !(locked = false) && onLockAxis && onLockAxis(self);

      if (wheeled) {
        onWheel(self);
        wheeled = false;
      }

      id = 0;
    },
        onDelta = function onDelta(x, y, index) {
      deltaX[index] += x;
      deltaY[index] += y;

      self._vx.update(x);

      self._vy.update(y);

      debounce ? id || (id = requestAnimationFrame(update)) : update();
    },
        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
      if (lockAxis && !axis) {
        self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
        locked = true;
      }

      if (axis !== "y") {
        deltaX[2] += x;

        self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.

      }

      if (axis !== "x") {
        deltaY[2] += y;

        self._vy.update(y, true);
      }

      debounce ? id || (id = requestAnimationFrame(update)) : update();
    },
        _onDrag = function _onDrag(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      e = _getEvent(e, preventDefault);
      var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y,
          isDragging = self.isDragging;
      self.x = x;
      self.y = y;

      if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
        onDrag && (dragged = true);
        isDragging || (self.isDragging = true);
        onTouchOrPointerDelta(dx, dy);
        isDragging || onDragStart && onDragStart(self);
      }
    },
        _onPress = self.onPress = function (e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      self.axis = axis = null;
      onStopDelayedCall.pause();
      self.isPressed = true;
      e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

      prevDeltaX = prevDeltaY = 0;
      self.startX = self.x = e.clientX;
      self.startY = self.y = e.clientY;

      self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.


      self._vy.reset();

      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);

      self.deltaX = self.deltaY = 0;
      onPress && onPress(self);
    },
        _onRelease = function _onRelease(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

      var wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
      eventData = _getEvent(e);

      if (!wasDragging) {
        self._vx.reset();

        self._vy.reset();

        if (preventDefault && allowClicks) {
          gsap.delayedCall(0.08, function () {
            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
              if (e.target.click) {
                //some browsers (like mobile Safari) don't properly trigger the click event
                e.target.click();
              } else if (ownerDoc.createEvent) {
                var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                e.target.dispatchEvent(syntheticEvent);
              }
            }
          });
        }
      }

      self.isDragging = self.isGesturing = self.isPressed = false;
      onStop && !isNormalizer && onStopDelayedCall.restart(true);
      onDragEnd && wasDragging && onDragEnd(self);
      onRelease && onRelease(self, wasDragging);
    },
        _onGestureStart = function _onGestureStart(e) {
      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
    },
        _onGestureEnd = function _onGestureEnd() {
      return (self.isGesturing = false) || onGestureEnd(self);
    },
        onScroll = function onScroll(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      var x = scrollFuncX(),
          y = scrollFuncY();
      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
      scrollX = x;
      scrollY = y;
      onStop && onStopDelayedCall.restart(true);
    },
        _onWheel = function _onWheel(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      e = _getEvent(e, preventDefault);
      onWheel && (wheeled = true);
      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
      onStop && !isNormalizer && onStopDelayedCall.restart(true);
    },
        _onMove = function _onMove(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y;
      self.x = x;
      self.y = y;
      moved = true;
      (dx || dy) && onTouchOrPointerDelta(dx, dy);
    },
        _onHover = function _onHover(e) {
      self.event = e;
      onHover(self);
    },
        _onHoverEnd = function _onHoverEnd(e) {
      self.event = e;
      onHoverEnd(self);
    },
        _onClick = function _onClick(e) {
      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
    };

    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
    self.deltaX = self.deltaY = 0;
    self._vx = _getVelocityProp(0, 50, true);
    self._vy = _getVelocityProp(0, 50, true);
    self.scrollX = scrollFuncX;
    self.scrollY = scrollFuncY;
    self.isDragging = self.isGesturing = self.isPressed = false;

    self.enable = function (e) {
      if (!self.isEnabled) {
        _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

        type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
        type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);

        if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
          _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);

          _addListener(ownerDoc, _eventTypes[2], _onRelease);

          _addListener(ownerDoc, _eventTypes[3], _onRelease);

          allowClicks && _addListener(target, "click", clickCapture, false, true);
          onClick && _addListener(target, "click", _onClick);
          onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
          onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
          onHover && _addListener(target, _pointerType + "enter", _onHover);
          onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
          onMove && _addListener(target, _pointerType + "move", _onMove);
        }

        self.isEnabled = true;
        e && e.type && _onPress(e);
        onEnable && onEnable(self);
      }

      return self;
    };

    self.disable = function () {
      if (self.isEnabled) {
        // only remove the _onScroll listener if there aren't any others that rely on the functionality.
        _observers.filter(function (o) {
          return o !== self && _isViewport(o.target);
        }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

        if (self.isPressed) {
          self._vx.reset();

          self._vy.reset();

          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        }

        _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

        _removeListener(target, "wheel", _onWheel, capture);

        _removeListener(target, _eventTypes[0], _onPress, capture);

        _removeListener(ownerDoc, _eventTypes[2], _onRelease);

        _removeListener(ownerDoc, _eventTypes[3], _onRelease);

        _removeListener(target, "click", clickCapture, true);

        _removeListener(target, "click", _onClick);

        _removeListener(ownerDoc, "gesturestart", _onGestureStart);

        _removeListener(ownerDoc, "gestureend", _onGestureEnd);

        _removeListener(target, _pointerType + "enter", _onHover);

        _removeListener(target, _pointerType + "leave", _onHoverEnd);

        _removeListener(target, _pointerType + "move", _onMove);

        self.isEnabled = self.isPressed = self.isDragging = false;
        onDisable && onDisable(self);
      }
    };

    self.kill = function () {
      self.disable();

      var i = _observers.indexOf(self);

      i >= 0 && _observers.splice(i, 1);
      _normalizer === self && (_normalizer = 0);
    };

    _observers.push(self);

    isNormalizer && _isViewport(target) && (_normalizer = self);
    self.enable(event);
  };

  _createClass(Observer, [{
    key: "velocityX",
    get: function get() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function get() {
      return this._vy.getVelocity();
    }
  }]);

  return Observer;
}();

exports.default = exports.Observer = Observer;
Observer.version = "3.11.1";

Observer.create = function (vars) {
  return new Observer(vars);
};

Observer.register = _initCore;

Observer.getAll = function () {
  return _observers.slice();
};

Observer.getById = function (id) {
  return _observers.filter(function (o) {
    return o.vars.id === id;
  })[0];
};

_getGSAP() && gsap.registerPlugin(Observer);
},{}],"node_modules/gsap/ScrollTrigger.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ScrollTrigger = void 0;

var _Observer = require("./Observer.js");

/*!
 * ScrollTrigger 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _coreInitted,
    _win,
    _doc,
    _docEl,
    _body,
    _root,
    _resizeDelay,
    _toArray,
    _clamp,
    _time2,
    _syncInterval,
    _refreshing,
    _pointerIsDown,
    _transformProp,
    _i,
    _prevWidth,
    _prevHeight,
    _autoRefresh,
    _sort,
    _suppressOverwrites,
    _ignoreResize,
    _normalizer,
    _ignoreMobileResize,
    _baseScreenHeight,
    _baseScreenWidth,
    _fixIOSBug,
    _context,
    _limitCallbacks,
    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
_startup = 1,
    _getTime = Date.now,
    _time1 = _getTime(),
    _lastScrollTime = 0,
    _enabled = 0,
    _pointerDownHandler = function _pointerDownHandler() {
  return _pointerIsDown = 1;
},
    _pointerUpHandler = function _pointerUpHandler() {
  return _pointerIsDown = 0;
},
    _passThrough = function _passThrough(v) {
  return v;
},
    _round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _isViewport = function _isViewport(e) {
  return !!~_root.indexOf(e);
},
    _getBoundsFunc = function _getBoundsFunc(element) {
  return (0, _Observer._getProxyProp)(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
    _winOffsets.width = _win.innerWidth;
    _winOffsets.height = _win.innerHeight;
    return _winOffsets;
  } : function () {
    return _getBounds(element);
  });
},
    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
  var d = _ref.d,
      d2 = _ref.d2,
      a = _ref.a;
  return (a = (0, _Observer._getProxyProp)(scroller, "getBoundingClientRect")) ? function () {
    return a()[d];
  } : function () {
    return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;
  };
},
    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
  return !isViewport || ~_Observer._proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
    return _winOffsets;
  };
},
    _maxScroll = function _maxScroll(element, _ref2) {
  var s = _ref2.s,
      d2 = _ref2.d2,
      d = _ref2.d,
      a = _ref2.a;
  return (s = "scroll" + d2) && (a = (0, _Observer._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];
},
    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
  for (var i = 0; i < _autoRefresh.length; i += 3) {
    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
  }
},
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _callIfFunc = function _callIfFunc(value) {
  return _isFunction(value) && value();
},
    _combineFunc = function _combineFunc(f1, f2) {
  return function () {
    var result1 = _callIfFunc(f1),
        result2 = _callIfFunc(f2);

    return function () {
      _callIfFunc(result1);

      _callIfFunc(result2);
    };
  };
},
    _endAnimation = function _endAnimation(animation, reversed, pause) {
  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
},
    _callback = function _callback(self, func) {
  if (self.enabled) {
    var result = func(self);
    result && result.totalTime && (self.callbackAnimation = result);
  }
},
    _abs = Math.abs,
    _scrollLeft = "scrollLeft",
    _scrollTop = "scrollTop",
    _left = "left",
    _top = "top",
    _right = "right",
    _bottom = "bottom",
    _width = "width",
    _height = "height",
    _Right = "Right",
    _Left = "Left",
    _Top = "Top",
    _Bottom = "Bottom",
    _padding = "padding",
    _margin = "margin",
    _Width = "Width",
    _Height = "Height",
    _px = "px",
    _getComputedStyle = function _getComputedStyle(element) {
  return _win.getComputedStyle(element);
},
    _makePositionable = function _makePositionable(element) {
  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
  var position = _getComputedStyle(element).position;

  element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _getBounds = function _getBounds(element, withoutTransforms) {
  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1),
      bounds = element.getBoundingClientRect();
  tween && tween.progress(0).kill();
  return bounds;
},
    _getSize = function _getSize(element, _ref3) {
  var d2 = _ref3.d2;
  return element["offset" + d2] || element["client" + d2] || 0;
},
    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
  var a = [],
      labels = timeline.labels,
      duration = timeline.duration(),
      p;

  for (p in labels) {
    a.push(labels[p] / duration);
  }

  return a;
},
    _getClosestLabel = function _getClosestLabel(animation) {
  return function (value) {
    return gsap.utils.snap(_getLabelRatioArray(animation), value);
  };
},
    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
  var snap = gsap.utils.snap(snapIncrementOrArray),
      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
    return a - b;
  });
  return a ? function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var i;

    if (!direction) {
      return snap(value);
    }

    if (direction > 0) {
      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

      for (i = 0; i < a.length; i++) {
        if (a[i] >= value) {
          return a[i];
        }
      }

      return a[i - 1];
    } else {
      i = a.length;
      value += threshold;

      while (i--) {
        if (a[i] <= value) {
          return a[i];
        }
      }
    }

    return a[0];
  } : function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var snapped = snap(value);
    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
  };
},
    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
  return function (value, st) {
    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
  };
},
    _multiListener = function _multiListener(func, element, types, callback) {
  return types.split(",").forEach(function (type) {
    return func(element, type, callback);
  });
},
    _addListener = function _addListener(element, type, func, nonPassive, capture) {
  return element.addEventListener(type, func, {
    passive: !nonPassive,
    capture: !!capture
  });
},
    _removeListener = function _removeListener(element, type, func, capture) {
  return element.removeEventListener(type, func, !!capture);
},
    _wheelListener = function _wheelListener(func, el, scrollFunc) {
  return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc);
},
    _markerDefaults = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
},
    _defaults = {
  toggleActions: "play",
  anticipatePin: 0
},
    _keywords = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
},
    _offsetToPx = function _offsetToPx(value, size) {
  if (_isString(value)) {
    var eqIndex = value.indexOf("="),
        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

    if (~eqIndex) {
      value.indexOf("%") > eqIndex && (relative *= size / 100);
      value = value.substr(0, eqIndex - 1);
    }

    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
  }

  return value;
},
    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
  var startColor = _ref4.startColor,
      endColor = _ref4.endColor,
      fontSize = _ref4.fontSize,
      indent = _ref4.indent,
      fontWeight = _ref4.fontWeight;

  var e = _doc.createElement("div"),
      useFixedPosition = _isViewport(container) || (0, _Observer._getProxyProp)(container, "pinType") === "fixed",
      isScroller = type.indexOf("scroller") !== -1,
      parent = useFixedPosition ? _body : container,
      isStart = type.indexOf("start") !== -1,
      color = isStart ? startColor : endColor,
      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

  css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer._vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
  matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
  e._isStart = isStart;
  e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
  e.style.cssText = css;
  e.innerText = name || name === 0 ? type + "-" + name : type;
  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
  e._offset = e["offset" + direction.op.d2];

  _positionMarker(e, 0, direction, isStart);

  return e;
},
    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
  var vars = {
    display: "block"
  },
      side = direction[flipped ? "os2" : "p2"],
      oppositeSide = direction[flipped ? "p2" : "os2"];
  marker._isFlipped = flipped;
  vars[direction.a + "Percent"] = flipped ? -100 : 0;
  vars[direction.a] = flipped ? "1px" : 0;
  vars["border" + side + _Width] = 1;
  vars["border" + oppositeSide + _Width] = 0;
  vars[direction.p] = start + "px";
  gsap.set(marker, vars);
},
    _triggers = [],
    _ids = {},
    _rafID,
    _sync = function _sync() {
  return _getTime() - _lastScrollTime > 34 && _updateAll();
},
    _onScroll = function _onScroll() {
  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
  if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {
    // if the user is dragging the scrollbar, allow it.
    _Observer._scrollers.cache++;
    _rafID || (_rafID = requestAnimationFrame(_updateAll));
    _lastScrollTime || _dispatch("scrollStart");
    _lastScrollTime = _getTime();
  }
},
    _setBaseDimensions = function _setBaseDimensions() {
  _baseScreenWidth = _win.innerWidth;
  _baseScreenHeight = _win.innerHeight;
},
    _onResize = function _onResize() {
  _Observer._scrollers.cache++;
  !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);
},
    // ignore resizes triggered by refresh()
_listeners = {},
    _emptyArray = [],
    _softRefresh = function _softRefresh() {
  return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
},
    _dispatch = function _dispatch(type) {
  return _listeners[type] && _listeners[type].map(function (f) {
    return f();
  }) || _emptyArray;
},
    _savedStyles = [],
    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
_revertRecorded = function _revertRecorded(media) {
  for (var i = 0; i < _savedStyles.length; i += 5) {
    if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
      _savedStyles[i].style.cssText = _savedStyles[i + 1];
      _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
      _savedStyles[i + 3].uncache = 1;
    }
  }
},
    _revertAll = function _revertAll(kill, media) {
  var trigger;

  for (_i = 0; _i < _triggers.length; _i++) {
    trigger = _triggers[_i];

    if (trigger && (!media || trigger._ctx === media)) {
      if (kill) {
        trigger.kill(1);
      } else {
        trigger.revert(true, true);
      }
    }
  }

  media && _revertRecorded(media);
  media || _dispatch("revert");
},
    _clearScrollMemory = function _clearScrollMemory() {
  return _Observer._scrollers.cache++ && _Observer._scrollers.forEach(function (obj) {
    return typeof obj === "function" && (obj.rec = 0);
  });
},
    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
_refreshingAll,
    _refreshID = 0,
    _refreshAll = function _refreshAll(force, skipRevert) {
  if (_lastScrollTime && !force) {
    _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

    return;
  }

  _refreshingAll = true;

  var refreshInits = _dispatch("refreshInit");

  _sort && ScrollTrigger.sort();
  skipRevert || _revertAll();

  _triggers.slice(0).forEach(function (t) {
    return t.refresh();
  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


  _triggers.forEach(function (t) {
    return t.vars.end === "max" && t.setPositions(t.start, Math.max(t.start + 1, _maxScroll(t.scroller, t._dir)));
  }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max".


  refreshInits.forEach(function (result) {
    return result && result.render && result.render(-1);
  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

  _Observer._scrollers.forEach(function (obj) {
    return typeof obj === "function" && obj(obj.rec);
  });

  _clearScrollMemory();

  _resizeDelay.pause();

  _refreshID++;
  _refreshingAll = false;

  _dispatch("refresh");
},
    _lastScroll = 0,
    _direction = 1,
    _primary,
    _updateAll = function _updateAll() {
  if (!_refreshingAll) {
    ScrollTrigger.isUpdating = true;
    _primary && _primary.update(0); // ScrollSmoother users refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

    var l = _triggers.length,
        time = _getTime(),
        recordVelocity = time - _time1 >= 50,
        scroll = l && _triggers[0].scroll();

    _direction = _lastScroll > scroll ? -1 : 1;
    _lastScroll = scroll;

    if (recordVelocity) {
      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
        _lastScrollTime = 0;

        _dispatch("scrollEnd");
      }

      _time2 = _time1;
      _time1 = time;
    }

    if (_direction < 0) {
      _i = l;

      while (_i-- > 0) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }

      _direction = 1;
    } else {
      for (_i = 0; _i < l; _i++) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }
    }

    ScrollTrigger.isUpdating = false;
  }

  _rafID = 0;
},
    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
    _swapPinOut = function _swapPinOut(pin, spacer, state) {
  _setState(state);

  var cache = pin._gsap;

  if (cache.spacerIsNative) {
    _setState(cache.spacerState);
  } else if (pin._gsap.swappedIn) {
    var parent = spacer.parentNode;

    if (parent) {
      parent.insertBefore(pin, spacer);
      parent.removeChild(spacer);
    }
  }

  pin._gsap.swappedIn = false;
},
    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
  if (!pin._gsap.swappedIn) {
    var i = _propNamesToCopy.length,
        spacerStyle = spacer.style,
        pinStyle = pin.style,
        p;

    while (i--) {
      p = _propNamesToCopy[i];
      spacerStyle[p] = cs[p];
    }

    spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
    cs.display === "inline" && (spacerStyle.display = "inline-block");
    pinStyle[_bottom] = pinStyle[_right] = "auto";
    spacerStyle.flexBasis = cs.flexBasis || "auto";
    spacerStyle.overflow = "visible";
    spacerStyle.boxSizing = "border-box";
    spacerStyle[_width] = _getSize(pin, _Observer._horizontal) + _px;
    spacerStyle[_height] = _getSize(pin, _Observer._vertical) + _px;
    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

    _setState(spacerState);

    pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
    pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
    pinStyle[_padding] = cs[_padding];

    if (pin.parentNode !== spacer) {
      pin.parentNode.insertBefore(spacer, pin);
      spacer.appendChild(pin);
    }

    pin._gsap.swappedIn = true;
  }
},
    _capsExp = /([A-Z])/g,
    _setState = function _setState(state) {
  if (state) {
    var style = state.t.style,
        l = state.length,
        i = 0,
        p,
        value;
    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

    for (; i < l; i += 2) {
      value = state[i + 1];
      p = state[i];

      if (value) {
        style[p] = value;
      } else if (style[p]) {
        style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
      }
    }
  }
},
    _getState = function _getState(element) {
  // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
  var l = _stateProps.length,
      style = element.style,
      state = [],
      i = 0;

  for (; i < l; i++) {
    state.push(_stateProps[i], style[_stateProps[i]]);
  }

  state.t = element;
  return state;
},
    _copyState = function _copyState(state, override, omitOffsets) {
  var result = [],
      l = state.length,
      i = omitOffsets ? 8 : 0,
      // skip top, left, right, bottom if omitOffsets is true
  p;

  for (; i < l; i += 2) {
    p = state[i];
    result.push(p, p in override ? override[p] : state[i + 1]);
  }

  result.t = state.t;
  return result;
},
    _winOffsets = {
  left: 0,
  top: 0
},
    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
// 	scroller = _getTarget(scroller || _win);
// 	let direction = horizontal ? _horizontal : _vertical,
// 		isViewport = _isViewport(scroller);
// 	_getSizeFunc(scroller, isViewport, direction);
// 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
// },
_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
  _isFunction(value) && (value = value(self));

  if (_isString(value) && value.substr(0, 3) === "max") {
    value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
  }

  var time = containerAnimation ? containerAnimation.time() : 0,
      p1,
      p2,
      element;
  containerAnimation && containerAnimation.seek(0);

  if (!_isNumber(value)) {
    _isFunction(trigger) && (trigger = trigger(self));
    var offsets = (value || "0").split(" "),
        bounds,
        localOffset,
        globalOffset,
        display;
    element = (0, _Observer._getTarget)(trigger) || _body;
    bounds = _getBounds(element) || {};

    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
      // if display is "none", it won't report getBoundingClientRect() properly
      display = element.style.display;
      element.style.display = "block";
      bounds = _getBounds(element);
      display ? element.style.display = display : element.style.removeProperty("display");
    }

    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
    globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
  } else if (markerScroller) {
    _positionMarker(markerScroller, scrollerSize, direction, true);
  }

  if (marker) {
    var position = value + scrollerSize,
        isStart = marker._isStart;
    p1 = "scroll" + direction.d2;

    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);

    if (useFixedPosition) {
      scrollerBounds = _getBounds(markerScroller);
      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
    }
  }

  if (containerAnimation && element) {
    p1 = _getBounds(element);
    containerAnimation.seek(scrollerMax);
    p2 = _getBounds(element);
    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
    value = value / containerAnimation._caScrollDist * scrollerMax;
  }

  containerAnimation && containerAnimation.seek(time);
  return containerAnimation ? value : Math.round(value);
},
    _prefixExp = /(webkit|moz|length|cssText|inset)/i,
    _reparent = function _reparent(element, parent, top, left) {
  if (element.parentNode !== parent) {
    var style = element.style,
        p,
        cs;

    if (parent === _body) {
      element._stOrig = style.cssText; // record original inline styles so we can revert them later

      cs = _getComputedStyle(element);

      for (p in cs) {
        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
          style[p] = cs[p];
        }
      }

      style.top = top;
      style.left = left;
    } else {
      style.cssText = element._stOrig;
    }

    gsap.core.getCache(element).uncache = 1;
    parent.appendChild(element);
  }
},
    // _mergeAnimations = animations => {
// 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
// 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
// 	tl.smoothChildTiming = false;
// 	return tl;
// },
// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
_getTweenCreator = function _getTweenCreator(scroller, direction) {
  var getScroll = (0, _Observer._getScrollFunc)(scroller, direction),
      prop = "_scroll" + direction.p2,
      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
  lastScroll1,
      lastScroll2,
      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
    var tween = getTween.tween,
        onComplete = vars.onComplete,
        modifiers = {};
    initialValue = initialValue || getScroll();
    change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

    change1 = change1 || scrollTo - initialValue;
    tween && tween.kill();
    lastScroll1 = Math.round(initialValue);
    vars[prop] = scrollTo;
    vars.modifiers = modifiers;

    modifiers[prop] = function (value) {
      value = Math.round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.

      if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 3 && Math.abs(value - lastScroll2) > 3) {
        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
        tween.kill();
        getTween.tween = 0;
      } else {
        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
      }

      lastScroll2 = lastScroll1;
      return lastScroll1 = Math.round(value);
    };

    vars.onComplete = function () {
      getTween.tween = 0;
      onComplete && onComplete.call(tween);
    };

    tween = getTween.tween = gsap.to(scroller, vars);
    return tween;
  };

  scroller[prop] = getScroll;

  getScroll.wheelHandler = function () {
    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
  };

  _addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


  return getTween;
};

var ScrollTrigger = /*#__PURE__*/function () {
  function ScrollTrigger(vars, animation) {
    _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
    this.init(vars, animation);
  }

  var _proto = ScrollTrigger.prototype;

  _proto.init = function init(vars, animation) {
    this.progress = this.start = 0;
    this.vars && this.kill(true, true); // in case it's being initted again

    if (!_enabled) {
      this.update = this.refresh = this.kill = _passThrough;
      return;
    }

    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
      trigger: vars
    } : vars, _defaults);

    var _vars = vars,
        onUpdate = _vars.onUpdate,
        toggleClass = _vars.toggleClass,
        id = _vars.id,
        onToggle = _vars.onToggle,
        onRefresh = _vars.onRefresh,
        scrub = _vars.scrub,
        trigger = _vars.trigger,
        pin = _vars.pin,
        pinSpacing = _vars.pinSpacing,
        invalidateOnRefresh = _vars.invalidateOnRefresh,
        anticipatePin = _vars.anticipatePin,
        onScrubComplete = _vars.onScrubComplete,
        onSnapComplete = _vars.onSnapComplete,
        once = _vars.once,
        snap = _vars.snap,
        pinReparent = _vars.pinReparent,
        pinSpacer = _vars.pinSpacer,
        containerAnimation = _vars.containerAnimation,
        fastScrollEnd = _vars.fastScrollEnd,
        preventOverlaps = _vars.preventOverlaps,
        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer._horizontal : _Observer._vertical,
        isToggle = !scrub && scrub !== 0,
        scroller = (0, _Observer._getTarget)(vars.scroller || _win),
        scrollerCache = gsap.core.getCache(scroller),
        isViewport = _isViewport(scroller),
        useFixedPosition = ("pinType" in vars ? vars.pinType : (0, _Observer._getProxyProp)(scroller, "pinType") || isViewport && "fixed") === "fixed",
        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
        toggleActions = isToggle && vars.toggleActions.split(" "),
        markers = "markers" in vars ? vars.markers : _defaults.markers,
        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
        self = this,
        onRefreshInit = vars.onRefreshInit && function () {
      return vars.onRefreshInit(self);
    },
        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
        lastSnap = 0,
        lastRefresh = 0,
        scrollFunc = (0, _Observer._getScrollFunc)(scroller, direction),
        tweenTo,
        pinCache,
        snapFunc,
        scroll1,
        scroll2,
        start,
        end,
        markerStart,
        markerEnd,
        markerStartTrigger,
        markerEndTrigger,
        markerVars,
        change,
        pinOriginalState,
        pinActiveState,
        pinState,
        spacer,
        offset,
        pinGetter,
        pinSetter,
        pinStart,
        pinChange,
        spacingStart,
        spacerState,
        markerStartSetter,
        markerEndSetter,
        cs,
        snap1,
        snap2,
        scrubTween,
        scrubSmooth,
        snapDurClamp,
        snapDelayedCall,
        prevProgress,
        prevScroll,
        prevAnimProgress,
        caMarkerSetter,
        customRevertReturn;

    _context(self);

    self._dir = direction;
    anticipatePin *= 45;
    self.scroller = scroller;
    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
    scroll1 = scrollFunc();
    self.vars = vars;
    animation = animation || vars.animation;

    if ("refreshPriority" in vars) {
      _sort = 1;
      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
    }

    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
      top: _getTweenCreator(scroller, _Observer._vertical),
      left: _getTweenCreator(scroller, _Observer._horizontal)
    };
    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

    self.scrubDuration = function (value) {
      scrubSmooth = _isNumber(value) && value;

      if (!scrubSmooth) {
        scrubTween && scrubTween.progress(1).kill();
        scrubTween = 0;
      } else {
        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {
          ease: "expo",
          totalProgress: "+=0.001",
          duration: scrubSmooth,
          paused: true,
          onComplete: function onComplete() {
            return onScrubComplete && onScrubComplete(self);
          }
        });
      }
    };

    if (animation) {
      animation.vars.lazy = false;
      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
      self.animation = animation.pause();
      animation.scrollTrigger = self;
      self.scrubDuration(scrub);
      snap1 = 0;
      id || (id = animation.vars.id);
    }

    _triggers.push(self);

    if (snap) {
      // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.
      if (!_isObject(snap) || snap.push) {
        snap = {
          snapTo: snap
        };
      }

      "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
        scrollBehavior: "auto"
      }); // smooth scrolling doesn't work with snap.

      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);
      } : gsap.utils.snap(snap.snapTo);
      snapDurClamp = snap.duration || {
        min: 0.1,
        max: 2
      };
      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
        var scroll = scrollFunc(),
            refreshedRecently = _getTime() - lastRefresh < 500,
            tween = tweenTo.tween;

        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
          var progress = (scroll - start) / change,
              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
              change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
              naturalEnd = progress + (snap.inertia === false ? 0 : change1),
              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
              endScroll = Math.round(start + endValue * change),
              _snap = snap,
              onStart = _snap.onStart,
              _onInterrupt = _snap.onInterrupt,
              _onComplete = _snap.onComplete;

          if (scroll <= end && scroll >= start && endScroll !== scroll) {
            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
              return;
            }

            if (snap.inertia === false) {
              change1 = endValue - progress;
            }

            tweenTo(endScroll, {
              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
              ease: snap.ease || "power3",
              data: _abs(endScroll - scroll),
              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
              onInterrupt: function onInterrupt() {
                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
              },
              onComplete: function onComplete() {
                self.update();
                lastSnap = scrollFunc();
                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                onSnapComplete && onSnapComplete(self);
                _onComplete && _onComplete(self);
              }
            }, scroll, change1 * change, endScroll - scroll - change1 * change);
            onStart && onStart(self, tweenTo.tween);
          }
        } else if (self.isActive && lastSnap !== scroll) {
          snapDelayedCall.restart(true);
        }
      }).pause();
    }

    id && (_ids[id] = self);
    trigger = self.trigger = (0, _Observer._getTarget)(trigger || pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
    customRevertReturn && (customRevertReturn = customRevertReturn(self));
    pin = pin === true ? trigger : (0, _Observer._getTarget)(pin);
    _isString(toggleClass) && (toggleClass = {
      targets: trigger,
      className: toggleClass
    });

    if (pin) {
      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.

      self.pin = pin;
      vars.force3D !== false && gsap.set(pin, {
        force3D: true
      });
      pinCache = gsap.core.getCache(pin);

      if (!pinCache.spacer) {
        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
        if (pinSpacer) {
          pinSpacer = (0, _Observer._getTarget)(pinSpacer);
          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

          pinCache.spacerIsNative = !!pinSpacer;
          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
        }

        pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
        spacer.classList.add("pin-spacer");
        id && spacer.classList.add("pin-spacer-" + id);
        pinCache.pinState = pinOriginalState = _getState(pin);
      } else {
        pinOriginalState = pinCache.pinState;
      }

      self.spacer = spacer = pinCache.spacer;
      cs = _getComputedStyle(pin);
      spacingStart = cs[pinSpacing + direction.os2];
      pinGetter = gsap.getProperty(pin);
      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

      _swapPinIn(pin, spacer, cs);

      pinState = _getState(pin);
    }

    if (markers) {
      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
      offset = markerStartTrigger["offset" + direction.op.d2];
      var content = (0, _Observer._getTarget)((0, _Observer._getProxyProp)(scroller, "content") || scroller);
      markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
      markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));

      if (!useFixedPosition && !(_Observer._proxies.length && (0, _Observer._getProxyProp)(scroller, "fixedMarkers") === true)) {
        _makePositionable(isViewport ? _body : scroller);

        gsap.set([markerStartTrigger, markerEndTrigger], {
          force3D: true
        });
        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
      }
    }

    if (containerAnimation) {
      var oldOnUpdate = containerAnimation.vars.onUpdate,
          oldParams = containerAnimation.vars.onUpdateParams;
      containerAnimation.eventCallback("onUpdate", function () {
        self.update(0, 0, 1);
        oldOnUpdate && oldOnUpdate.apply(oldParams || []);
      });
    }

    self.previous = function () {
      return _triggers[_triggers.indexOf(self) - 1];
    };

    self.next = function () {
      return _triggers[_triggers.indexOf(self) + 1];
    };

    self.revert = function (revert, temp) {
      if (!temp) {
        return self.kill(true);
      } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()


      var r = revert !== false || !self.enabled,
          prevRefreshing = _refreshing;

      if (r !== self.isReverted) {
        if (r) {
          if (!self.scroll.rec && (_refreshing || _refreshingAll)) {
            self.scroll.rec = scrollFunc();
            _refreshingAll && scrollFunc(0);
          }

          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

          prevProgress = self.progress;
          prevAnimProgress = animation && animation.progress();
        }

        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.style.display = r ? "none" : "block";
        });
        r && (_refreshing = 1);
        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.

        _refreshing = prevRefreshing;
        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
        self.isReverted = r;
      }
    };

    self.refresh = function (soft, force) {
      if ((_refreshing || !self.enabled) && !force) {
        return;
      }

      if (pin && soft && _lastScrollTime) {
        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

        return;
      }

      !_refreshingAll && onRefreshInit && onRefreshInit(self);
      _refreshing = 1;
      lastRefresh = _getTime();

      if (tweenTo.tween) {
        tweenTo.tween.kill();
        tweenTo.tween = 0;
      }

      scrubTween && scrubTween.pause();
      invalidateOnRefresh && animation && animation.revert().invalidate();
      self.isReverted || self.revert(true, true);
      var size = getScrollerSize(),
          scrollerBounds = getScrollerOffsets(),
          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
          offset = 0,
          otherPinOffset = 0,
          parsedEnd = vars.end,
          parsedEndTrigger = vars.endTrigger || trigger,
          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0, _Observer._getTarget)(vars.pinnedContainer),
          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
          i = triggerIndex,
          cs,
          bounds,
          scroll,
          isVertical,
          override,
          curTrigger,
          curPin,
          oppositeScroll,
          initted,
          revertedPins;

      while (i--) {
        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
        curTrigger = _triggers[i];
        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

        curPin = curTrigger.pin;

        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
          revertedPins || (revertedPins = []);
          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

          curTrigger.revert(true, true);
        }

        if (curTrigger !== _triggers[i]) {
          // in case it got removed.
          triggerIndex--;
          i--;
        }
      }

      _isFunction(parsedStart) && (parsedStart = parsedStart(self));
      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));

      if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
        if (~parsedEnd.indexOf(" ")) {
          parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
        } else {
          offset = _offsetToPx(parsedEnd.substr(2), size);
          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

          parsedEndTrigger = trigger;
        }
      }

      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
      change = end - start || (start -= 0.01) && 0.001;
      offset = 0;
      i = triggerIndex;

      while (i--) {
        curTrigger = _triggers[i];
        curPin = curTrigger.pin;

        if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation && curTrigger.end > 0) {
          cs = curTrigger.end - curTrigger.start;

          if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
            // numeric start values shouldn't be offset at all - treat them as absolute
            offset += cs * (1 - curTrigger.progress);
          }

          curPin === pin && (otherPinOffset += cs);
        }
      }

      start += offset;
      end += offset;
      self._pinPush = otherPinOffset;

      if (markerStart && offset) {
        // offset the markers if necessary
        cs = {};
        cs[direction.a] = "+=" + offset;
        pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
        gsap.set([markerStart, markerEnd], cs);
      }

      if (pin) {
        cs = _getComputedStyle(pin);
        isVertical = direction === _Observer._vertical;
        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
        !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/

        _swapPinIn(pin, spacer, cs);

        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

        bounds = _getBounds(pin, true);
        oppositeScroll = useFixedPosition && (0, _Observer._getScrollFunc)(scroller, isVertical ? _Observer._horizontal : _Observer._vertical)();

        if (pinSpacing) {
          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
          spacerState.t = spacer;
          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

          _setState(spacerState);

          useFixedPosition && scrollFunc(prevScroll);
        }

        if (useFixedPosition) {
          override = {
            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
            boxSizing: "border-box",
            position: "fixed"
          };
          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
          override[_padding] = cs[_padding];
          override[_padding + _Top] = cs[_padding + _Top];
          override[_padding + _Right] = cs[_padding + _Right];
          override[_padding + _Bottom] = cs[_padding + _Bottom];
          override[_padding + _Left] = cs[_padding + _Left];
          pinActiveState = _copyState(pinOriginalState, override, pinReparent);
          _refreshingAll && scrollFunc(0);
        }

        if (animation) {
          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

          _suppressOverwrites(1);

          animation.render(animation.duration(), true, true);
          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
          change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

          animation.render(0, true, true);
          initted || animation.invalidate();

          _suppressOverwrites(0);
        } else {
          pinChange = change;
        }
      } else if (trigger && scrollFunc() && !containerAnimation) {
        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
        bounds = trigger.parentNode;

        while (bounds && bounds !== _body) {
          if (bounds._pinOffset) {
            start -= bounds._pinOffset;
            end -= bounds._pinOffset;
          }

          bounds = bounds.parentNode;
        }
      }

      revertedPins && revertedPins.forEach(function (t) {
        return t.revert(false, true);
      });
      self.start = start;
      self.end = end;
      scroll1 = scroll2 = scrollFunc(); // reset velocity

      if (!containerAnimation && !_refreshingAll) {
        scroll1 < prevScroll && scrollFunc(prevScroll);
        self.scroll.rec = 0;
      }

      self.revert(false, true);

      if (snapDelayedCall) {
        lastSnap = -1;
        self.isActive && scrollFunc(start + change * prevProgress); // just so snapping gets re-enabled, clear out any recorded last value

        snapDelayedCall.restart(true);
      }

      _refreshing = 0;
      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

      if (prevProgress !== self.progress || containerAnimation) {
        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
        animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

        self.progress = (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        self.update(0, 0, 1);
      }

      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)); //			scrubTween && scrubTween.invalidate();

      onRefresh && onRefresh(self);
    };

    self.getVelocity = function () {
      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;
    };

    self.endAnimation = function () {
      _endAnimation(self.callbackAnimation);

      if (animation) {
        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
      }
    };

    self.labelToScroll = function (label) {
      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
    };

    self.getTrailing = function (name) {
      var i = _triggers.indexOf(self),
          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

      return (_isString(name) ? a.filter(function (t) {
        return t.vars.preventOverlaps === name;
      }) : a).filter(function (t) {
        return self.direction > 0 ? t.end <= start : t.start >= end;
      });
    };

    self.update = function (reset, recordVelocity, forceFake) {
      if (containerAnimation && !forceFake && !reset) {
        return;
      }

      var scroll = self.scroll(),
          p = reset ? 0 : (scroll - start) / change,
          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
          prevProgress = self.progress,
          isActive,
          wasActive,
          toggleState,
          action,
          stateChanged,
          toggled,
          isAtMax,
          isTakingAction;

      if (recordVelocity) {
        scroll2 = scroll1;
        scroll1 = containerAnimation ? scrollFunc() : scroll;

        if (snap) {
          snap2 = snap1;
          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
        }
      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);

      if (clipped !== prevProgress && self.enabled) {
        isActive = self.isActive = !!clipped && clipped < 1;
        wasActive = !!prevProgress && prevProgress < 1;
        toggled = isActive !== wasActive;
        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

        self.direction = clipped > prevProgress ? 1 : -1;
        self.progress = clipped;

        if (stateChanged && !_refreshing) {
          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

          if (isToggle) {
            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

            isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
          }
        }

        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
          return t.endAnimation();
        }));

        if (!isToggle) {
          if (scrubTween && !_refreshing && !_startup) {
            (containerAnimation || _primary && _primary !== self) && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

            if (scrubTween.resetTo) {
              scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
            } else {
              // legacy support (courtesy), before 3.10.0
              scrubTween.vars.totalProgress = clipped;
              scrubTween.invalidate().restart();
            }
          } else if (animation) {
            animation.totalProgress(clipped, !!_refreshing);
          }
        }

        if (pin) {
          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

          if (!useFixedPosition) {
            pinSetter(_round(pinStart + pinChange * clipped));
          } else if (stateChanged) {
            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

            if (pinReparent) {
              if (!reset && (isActive || isAtMax)) {
                var bounds = _getBounds(pin, true),
                    _offset = scroll - start;

                _reparent(pin, _body, bounds.top + (direction === _Observer._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer._vertical ? 0 : _offset) + _px);
              } else {
                _reparent(pin, spacer);
              }
            }

            _setState(isActive || isAtMax ? pinActiveState : pinState);

            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
          }
        }

        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
          return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
        }); // classes could affect positioning, so do it even if reset or refreshing is true.

        onUpdate && !isToggle && !reset && onUpdate(self);

        if (stateChanged && !_refreshing) {
          if (isToggle) {
            if (isTakingAction) {
              if (action === "complete") {
                animation.pause().totalProgress(1);
              } else if (action === "reset") {
                animation.restart(true).pause();
              } else if (action === "restart") {
                animation.restart(true);
              } else {
                animation[action]();
              }
            }

            onUpdate && onUpdate(self);
          }

          if (toggled || !_limitCallbacks) {
            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
            onToggle && toggled && _callback(self, onToggle);
            callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

            if (!toggled) {
              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
              toggleState = clipped === 1 ? 1 : 3;
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            }
          }

          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
            _endAnimation(self.callbackAnimation);

            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
          }
        } else if (isToggle && onUpdate && !_refreshing) {
          onUpdate(self);
        }
      } // update absolutely-positioned markers (only if the scroller isn't the viewport)


      if (markerEndSetter) {
        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
        markerEndSetter(n);
      }

      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
    };

    self.enable = function (reset, refresh) {
      if (!self.enabled) {
        self.enabled = true;

        _addListener(scroller, "resize", _onResize);

        _addListener(isViewport ? _doc : scroller, "scroll", _onScroll);

        onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (reset !== false) {
          self.progress = prevProgress = 0;
          scroll1 = scroll2 = lastSnap = scrollFunc();
        }

        refresh !== false && self.refresh();
      }
    };

    self.getTween = function (snap) {
      return snap && tweenTo ? tweenTo.tween : scrubTween;
    };

    self.setPositions = function (newStart, newEnd) {
      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
      if (pin) {
        pinStart += newStart - start;
        pinChange += newEnd - newStart - change;
      }

      self.start = start = newStart;
      self.end = end = newEnd;
      change = newEnd - newStart;
      self.update();
    };

    self.disable = function (reset, allowAnimation) {
      if (self.enabled) {
        reset !== false && self.revert(true, true);
        self.enabled = self.isActive = false;
        allowAnimation || scrubTween && scrubTween.pause();
        prevScroll = 0;
        pinCache && (pinCache.uncache = 1);
        onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (snapDelayedCall) {
          snapDelayedCall.pause();
          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
        }

        if (!isViewport) {
          var i = _triggers.length;

          while (i--) {
            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
              return; //don't remove the listeners if there are still other triggers referencing it.
            }
          }

          _removeListener(scroller, "resize", _onResize);

          _removeListener(scroller, "scroll", _onScroll);
        }
      }
    };

    self.kill = function (revert, allowAnimation) {
      self.disable(revert, allowAnimation);
      scrubTween && !allowAnimation && scrubTween.kill();
      id && delete _ids[id];

      var i = _triggers.indexOf(self);

      i >= 0 && _triggers.splice(i, 1);
      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

      i = 0;

      _triggers.forEach(function (t) {
        return t.scroller === self.scroller && (i = 1);
      });

      i || _refreshingAll || (self.scroll.rec = 0);

      if (animation) {
        animation.scrollTrigger = null;
        revert && animation.render(-1);
        allowAnimation || animation.kill();
      }

      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
        return m.parentNode && m.parentNode.removeChild(m);
      });
      _primary === self && (_primary = 0);

      if (pin) {
        pinCache && (pinCache.uncache = 1);
        i = 0;

        _triggers.forEach(function (t) {
          return t.pin === pin && i++;
        });

        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
      }

      vars.onKill && vars.onKill(self);
    };

    self.enable(false, false);
    customRevertReturn && customRevertReturn(self);
    !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {
      return start || end || self.refresh();
    }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
  };

  ScrollTrigger.register = function register(core) {
    if (!_coreInitted) {
      gsap = core || _getGSAP();
      _windowExists() && window.document && ScrollTrigger.enable();
      _coreInitted = _enabled;
    }

    return _coreInitted;
  };

  ScrollTrigger.defaults = function defaults(config) {
    if (config) {
      for (var p in config) {
        _defaults[p] = config[p];
      }
    }

    return _defaults;
  };

  ScrollTrigger.disable = function disable(reset, kill) {
    _enabled = 0;

    _triggers.forEach(function (trigger) {
      return trigger[kill ? "kill" : "disable"](reset);
    });

    _removeListener(_win, "wheel", _onScroll);

    _removeListener(_doc, "scroll", _onScroll);

    clearInterval(_syncInterval);

    _removeListener(_doc, "touchcancel", _passThrough);

    _removeListener(_body, "touchstart", _passThrough);

    _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

    _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

    _resizeDelay.kill();

    _iterateAutoRefresh(_removeListener);

    for (var i = 0; i < _Observer._scrollers.length; i += 3) {
      _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 1]);

      _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 2]);
    }
  };

  ScrollTrigger.enable = function enable() {
    _win = window;
    _doc = document;
    _docEl = _doc.documentElement;
    _body = _doc.body;

    if (gsap) {
      _toArray = gsap.utils.toArray;
      _clamp = gsap.utils.clamp;
      _context = gsap.core.context || _passThrough;
      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
      gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

      if (_body) {
        _enabled = 1;

        _Observer.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.


        ScrollTrigger.isTouch = _Observer.Observer.isTouch;
        _fixIOSBug = _Observer.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

        _addListener(_win, "wheel", _onScroll); // mostly for 3rd party smooth scrolling libraries.


        _root = [_win, _doc, _docEl, _body];

        if (gsap.matchMedia) {
          ScrollTrigger.matchMedia = function (vars) {
            var mm = gsap.matchMedia(),
                p;

            for (p in vars) {
              mm.add(p, vars[p]);
            }

            return mm;
          };

          gsap.addEventListener("matchMediaInit", function () {
            return _revertAll();
          });
          gsap.addEventListener("matchMediaRevert", function () {
            return _revertRecorded();
          });
          gsap.addEventListener("matchMedia", function () {
            _refreshAll(0, 1);

            _dispatch("matchMedia");
          });
          gsap.matchMedia("(orientation: portrait)", function () {
            // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
            _setBaseDimensions();

            return _setBaseDimensions;
          });
        } else {
          console.warn("Requires GSAP 3.11.0 or later");
        }

        _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


        var bodyStyle = _body.style,
            border = bodyStyle.borderTopStyle,
            AnimationProto = gsap.core.Animation.prototype,
            bounds,
            i;
        AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
          value: function value() {
            return this.time(-0.01, true);
          }
        }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)

        bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

        bounds = _getBounds(_body);
        _Observer._vertical.m = Math.round(bounds.top + _Observer._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

        _Observer._horizontal.m = Math.round(bounds.left + _Observer._horizontal.sc()) || 0;
        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.

        _syncInterval = setInterval(_sync, 250);
        gsap.delayedCall(0.5, function () {
          return _startup = 0;
        });

        _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


        _addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


        _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

        _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

        _transformProp = gsap.utils.checkPrefix("transform");

        _stateProps.push(_transformProp);

        _coreInitted = _getTime();
        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
        _autoRefresh = [_doc, "visibilitychange", function () {
          var w = _win.innerWidth,
              h = _win.innerHeight;

          if (_doc.hidden) {
            _prevWidth = w;
            _prevHeight = h;
          } else if (_prevWidth !== w || _prevHeight !== h) {
            _onResize();
          }
        }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize];

        _iterateAutoRefresh(_addListener);

        _triggers.forEach(function (trigger) {
          return trigger.enable(0, 1);
        });

        for (i = 0; i < _Observer._scrollers.length; i += 3) {
          _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 1]);

          _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 2]);
        }
      }
    }
  };

  ScrollTrigger.config = function config(vars) {
    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
    var ms = vars.syncInterval;
    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
    "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);

    if ("autoRefreshEvents" in vars) {
      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
      _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
    }
  };

  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
    var t = (0, _Observer._getTarget)(target),
        i = _Observer._scrollers.indexOf(t),
        isViewport = _isViewport(t);

    if (~i) {
      _Observer._scrollers.splice(i, isViewport ? 6 : 2);
    }

    if (vars) {
      isViewport ? _Observer._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer._proxies.unshift(t, vars);
    }
  };

  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
    _triggers.forEach(function (t) {
      return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
    });
  };

  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
    var bounds = (_isString(element) ? (0, _Observer._getTarget)(element) : element).getBoundingClientRect(),
        offset = bounds[horizontal ? _width : _height] * ratio || 0;
    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;
  };

  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
    _isString(element) && (element = (0, _Observer._getTarget)(element));
    var bounds = element.getBoundingClientRect(),
        size = bounds[horizontal ? _width : _height],
        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;
  };

  ScrollTrigger.killAll = function killAll(allowListeners) {
    _triggers.forEach(function (t) {
      return t.vars.id !== "ScrollSmoother" && t.kill();
    });

    if (allowListeners !== true) {
      var listeners = _listeners.killAll || [];
      _listeners = {};
      listeners.forEach(function (f) {
        return f();
      });
    }
  };

  return ScrollTrigger;
}();

exports.default = exports.ScrollTrigger = ScrollTrigger;
ScrollTrigger.version = "3.11.1";

ScrollTrigger.saveStyles = function (targets) {
  return targets ? _toArray(targets).forEach(function (target) {
    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
    if (target && target.style) {
      var i = _savedStyles.indexOf(target);

      i >= 0 && _savedStyles.splice(i, 5);

      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _context());
    }
  }) : _savedStyles;
};

ScrollTrigger.revert = function (soft, media) {
  return _revertAll(!soft, media);
};

ScrollTrigger.create = function (vars, animation) {
  return new ScrollTrigger(vars, animation);
};

ScrollTrigger.refresh = function (safe) {
  return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);
};

ScrollTrigger.update = _updateAll;
ScrollTrigger.clearScrollMemory = _clearScrollMemory;

ScrollTrigger.maxScroll = function (element, horizontal) {
  return _maxScroll(element, horizontal ? _Observer._horizontal : _Observer._vertical);
};

ScrollTrigger.getScrollFunc = function (element, horizontal) {
  return (0, _Observer._getScrollFunc)((0, _Observer._getTarget)(element), horizontal ? _Observer._horizontal : _Observer._vertical);
};

ScrollTrigger.getById = function (id) {
  return _ids[id];
};

ScrollTrigger.getAll = function () {
  return _triggers.filter(function (t) {
    return t.vars.id !== "ScrollSmoother";
  });
}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.


ScrollTrigger.isScrolling = function () {
  return !!_lastScrollTime;
};

ScrollTrigger.snapDirectional = _snapDirectional;

ScrollTrigger.addEventListener = function (type, callback) {
  var a = _listeners[type] || (_listeners[type] = []);
  ~a.indexOf(callback) || a.push(callback);
};

ScrollTrigger.removeEventListener = function (type, callback) {
  var a = _listeners[type],
      i = a && a.indexOf(callback);
  i >= 0 && a.splice(i, 1);
};

ScrollTrigger.batch = function (targets, vars) {
  var result = [],
      varsCopy = {},
      interval = vars.interval || 0.016,
      batchMax = vars.batchMax || 1e9,
      proxyCallback = function proxyCallback(type, callback) {
    var elements = [],
        triggers = [],
        delay = gsap.delayedCall(interval, function () {
      callback(elements, triggers);
      elements = [];
      triggers = [];
    }).pause();
    return function (self) {
      elements.length || delay.restart(true);
      elements.push(self.trigger);
      triggers.push(self);
      batchMax <= elements.length && delay.progress(1);
    };
  },
      p;

  for (p in vars) {
    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
  }

  if (_isFunction(batchMax)) {
    batchMax = batchMax();

    _addListener(ScrollTrigger, "refresh", function () {
      return batchMax = vars.batchMax();
    });
  }

  _toArray(targets).forEach(function (target) {
    var config = {};

    for (p in varsCopy) {
      config[p] = varsCopy[p];
    }

    config.trigger = target;
    result.push(ScrollTrigger.create(config));
  });

  return result;
}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).


var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
},
    _allowNativePanning = function _allowNativePanning(target, direction) {
  if (direction === true) {
    target.style.removeProperty("touch-action");
  } else {
    target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (_Observer.Observer.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
  }

  target === _docEl && _allowNativePanning(_body, direction);
},
    _overflow = {
  auto: 1,
  scroll: 1
},
    _nestedScroll = function _nestedScroll(_ref5) {
  var event = _ref5.event,
      target = _ref5.target,
      axis = _ref5.axis;

  var node = (event.changedTouches ? event.changedTouches[0] : event).target,
      cache = node._gsap || gsap.core.getCache(node),
      time = _getTime(),
      cs;

  if (!cache._isScrollT || time - cache._isScrollT > 2000) {
    // cache for 2 seconds to improve performance.
    while (node && node.scrollHeight <= node.clientHeight) {
      node = node.parentNode;
    }

    cache._isScroll = node && !_isViewport(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
    cache._isScrollT = time;
  }

  if (cache._isScroll || axis === "x") {
    event.stopPropagation();
    event._gsapAllow = true;
  }
},
    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
_inputObserver = function _inputObserver(target, type, inputs, nested) {
  return _Observer.Observer.create({
    target: target,
    capture: true,
    debounce: false,
    lockAxis: true,
    type: type,
    onWheel: nested = nested && _nestedScroll,
    onPress: nested,
    onDrag: nested,
    onScroll: nested,
    onEnable: function onEnable() {
      return inputs && _addListener(_doc, _Observer.Observer.eventTypes[0], _captureInputs, false, true);
    },
    onDisable: function onDisable() {
      return _removeListener(_doc, _Observer.Observer.eventTypes[0], _captureInputs, true);
    }
  });
},
    _inputExp = /(input|label|select|textarea)/i,
    _inputIsFocused,
    _captureInputs = function _captureInputs(e) {
  var isInput = _inputExp.test(e.target.tagName);

  if (isInput || _inputIsFocused) {
    e._gsapAllow = true;
    _inputIsFocused = isInput;
  }
},
    _getScrollNormalizer = function _getScrollNormalizer(vars) {
  _isObject(vars) || (vars = {});
  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
  vars.type || (vars.type = "wheel,touch");
  vars.debounce = !!vars.debounce;
  vars.id = vars.id || "normalizer";

  var _vars2 = vars,
      normalizeScrollX = _vars2.normalizeScrollX,
      momentum = _vars2.momentum,
      allowNestedScroll = _vars2.allowNestedScroll,
      self,
      maxY,
      target = (0, _Observer._getTarget)(vars.target) || _docEl,
      smoother = gsap.core.globals().ScrollSmoother,
      smootherInstance = smoother && smoother.get(),
      content = _fixIOSBug && (vars.content && (0, _Observer._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),
      scrollFuncY = (0, _Observer._getScrollFunc)(target, _Observer._vertical),
      scrollFuncX = (0, _Observer._getScrollFunc)(target, _Observer._horizontal),
      scale = 1,
      initialScale = (_Observer.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,
      wheelRefresh = 0,
      resolveMomentumDuration = _isFunction(momentum) ? function () {
    return momentum(self);
  } : function () {
    return momentum || 2.8;
  },
      lastRefreshID,
      skipTouchMove,
      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
      resumeTouchMove = function resumeTouchMove() {
    return skipTouchMove = false;
  },
      scrollClampX = _passThrough,
      scrollClampY = _passThrough,
      updateClamps = function updateClamps() {
    maxY = _maxScroll(target, _Observer._vertical);
    scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);
    normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer._horizontal)));
    lastRefreshID = _refreshID;
  },
      removeContentOffset = function removeContentOffset() {
    content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
    content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
    scrollFuncY.offset = scrollFuncY.cacheID = 0;
  },
      ignoreDrag = function ignoreDrag() {
    if (skipTouchMove) {
      requestAnimationFrame(resumeTouchMove);

      var offset = _round(self.deltaY / 2),
          scroll = scrollClampY(scrollFuncY.v - offset);

      if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
        scrollFuncY.offset = scroll - scrollFuncY.v;

        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);

        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
        content._gsap.y = y + "px";
        scrollFuncY.cacheID = _Observer._scrollers.cache;

        _updateAll();
      }

      return true;
    }

    scrollFuncY.offset && removeContentOffset();
    skipTouchMove = true;
  },
      tween,
      startScrollX,
      startScrollY,
      onStopDelayedCall,
      onResize = function onResize() {
    // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
    updateClamps();

    if (tween.isActive() && tween.vars.scrollY > maxY) {
      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
    }
  };

  content && gsap.set(content, {
    y: "+=0"
  }); // to ensure there's a cache (element._gsap)

  vars.ignoreCheck = function (e) {
    return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
  };

  vars.onPress = function () {
    var prevScale = scale;
    scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);
    tween.pause();
    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
    startScrollX = scrollFuncX();
    startScrollY = scrollFuncY();
    updateClamps();
    lastRefreshID = _refreshID;
  };

  vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
    scrollFuncY.offset && removeContentOffset();

    if (!wasDragging) {
      onStopDelayedCall.restart(true);
    } else {
      _Observer._scrollers.cache++; // make sure we're pulling the non-cached value
      // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

      var dur = resolveMomentumDuration(),
          currentScroll,
          endScroll;

      if (normalizeScrollX) {
        currentScroll = scrollFuncX();
        endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer._horizontal));
        tween.vars.scrollX = scrollClampX(endScroll);
      }

      currentScroll = scrollFuncY();
      endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer._vertical));
      tween.vars.scrollY = scrollClampY(endScroll);
      tween.invalidate().duration(dur).play(0.01);

      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
        // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
        gsap.to({}, {
          onUpdate: onResize,
          duration: dur
        });
      }
    }
  };

  vars.onWheel = function () {
    tween._ts && tween.pause();

    if (_getTime() - wheelRefresh > 1000) {
      // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
      lastRefreshID = 0;
      wheelRefresh = _getTime();
    }
  };

  vars.onChange = function (self, dx, dy, xArray, yArray) {
    _refreshID !== lastRefreshID && updateClamps();
    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

    if (dy) {
      scrollFuncY.offset && removeContentOffset();
      var isTouch = yArray[2] === dy,
          y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
          yClamped = scrollClampY(y);
      isTouch && y !== yClamped && (startScrollY += yClamped - y);
      scrollFuncY(yClamped);
    }

    (dy || dx) && _updateAll();
  };

  vars.onEnable = function () {
    _allowNativePanning(target, normalizeScrollX ? false : "x");

    _addListener(_win, "resize", onResize);

    inputObserver.enable();
  };

  vars.onDisable = function () {
    _allowNativePanning(target, true);

    _removeListener(_win, "resize", onResize);

    inputObserver.kill();
  };

  vars.lockAxis = vars.lockAxis !== false;
  self = new _Observer.Observer(vars);
  self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

  _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

  _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping

  onStopDelayedCall = self._dc;
  tween = gsap.to(self, {
    ease: "power4",
    paused: true,
    scrollX: normalizeScrollX ? "+=0.1" : "+=0",
    scrollY: "+=0.1",
    onComplete: onStopDelayedCall.vars.onComplete
  });
  return self;
};

ScrollTrigger.sort = function (func) {
  return _triggers.sort(func || function (a, b) {
    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
  });
};

ScrollTrigger.observe = function (vars) {
  return new _Observer.Observer(vars);
};

ScrollTrigger.normalizeScroll = function (vars) {
  if (typeof vars === "undefined") {
    return _normalizer;
  }

  if (vars === true && _normalizer) {
    return _normalizer.enable();
  }

  if (vars === false) {
    return _normalizer && _normalizer.kill();
  }

  var normalizer = vars instanceof _Observer.Observer ? vars : _getScrollNormalizer(vars);
  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();
  _isViewport(normalizer.target) && (_normalizer = normalizer);
  return normalizer;
};

ScrollTrigger.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: _Observer._getVelocityProp,
  _inputObserver: _inputObserver,
  _scrollers: _Observer._scrollers,
  _proxies: _Observer._proxies,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function ss() {
      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = _getTime();
    },
    // a way to get the _refreshing value in Observer
    ref: function ref() {
      return _refreshing;
    }
  }
};
_getGSAP() && gsap.registerPlugin(ScrollTrigger);
},{"./Observer.js":"node_modules/gsap/Observer.js"}],"node_modules/tweakpane/dist/tweakpane.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/*! Tweakpane 3.1.0 (c) 2016 cocopon, licensed under the MIT license. */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Tweakpane = {}));
})(this, (function (exports) { 'use strict';

    /***
     * A simple semantic versioning perser.
     */
    class Semver {
        /**
         * @hidden
         */
        constructor(text) {
            const [core, prerelease] = text.split('-');
            const coreComps = core.split('.');
            this.major = parseInt(coreComps[0], 10);
            this.minor = parseInt(coreComps[1], 10);
            this.patch = parseInt(coreComps[2], 10);
            this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
        }
        toString() {
            const core = [this.major, this.minor, this.patch].join('.');
            return this.prerelease !== null ? [core, this.prerelease].join('-') : core;
        }
    }

    class BladeApi {
        constructor(controller) {
            this.controller_ = controller;
        }
        get element() {
            return this.controller_.view.element;
        }
        get disabled() {
            return this.controller_.viewProps.get('disabled');
        }
        set disabled(disabled) {
            this.controller_.viewProps.set('disabled', disabled);
        }
        get hidden() {
            return this.controller_.viewProps.get('hidden');
        }
        set hidden(hidden) {
            this.controller_.viewProps.set('hidden', hidden);
        }
        dispose() {
            this.controller_.viewProps.set('disposed', true);
        }
    }

    class TpEvent {
        constructor(target) {
            this.target = target;
        }
    }
    class TpChangeEvent extends TpEvent {
        constructor(target, value, presetKey, last) {
            super(target);
            this.value = value;
            this.presetKey = presetKey;
            this.last = last !== null && last !== void 0 ? last : true;
        }
    }
    class TpUpdateEvent extends TpEvent {
        constructor(target, value, presetKey) {
            super(target);
            this.value = value;
            this.presetKey = presetKey;
        }
    }
    class TpFoldEvent extends TpEvent {
        constructor(target, expanded) {
            super(target);
            this.expanded = expanded;
        }
    }
    class TpTabSelectEvent extends TpEvent {
        constructor(target, index) {
            super(target);
            this.index = index;
        }
    }

    function forceCast(v) {
        return v;
    }
    function isEmpty(value) {
        return value === null || value === undefined;
    }
    function deepEqualsArray(a1, a2) {
        if (a1.length !== a2.length) {
            return false;
        }
        for (let i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }

    const CREATE_MESSAGE_MAP = {
        alreadydisposed: () => 'View has been already disposed',
        invalidparams: (context) => `Invalid parameters for '${context.name}'`,
        nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,
        nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,
        notbindable: () => `Value is not bindable`,
        propertynotfound: (context) => `Property '${context.name}' not found`,
        shouldneverhappen: () => 'This error should never happen',
    };
    class TpError {
        constructor(config) {
            var _a;
            this.message =
                (_a = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a !== void 0 ? _a : 'Unexpected error';
            this.name = this.constructor.name;
            this.stack = new Error(this.message).stack;
            this.type = config.type;
        }
        static alreadyDisposed() {
            return new TpError({ type: 'alreadydisposed' });
        }
        static notBindable() {
            return new TpError({
                type: 'notbindable',
            });
        }
        static propertyNotFound(name) {
            return new TpError({
                type: 'propertynotfound',
                context: {
                    name: name,
                },
            });
        }
        static shouldNeverHappen() {
            return new TpError({ type: 'shouldneverhappen' });
        }
    }

    class BindingTarget {
        constructor(obj, key, opt_id) {
            this.obj_ = obj;
            this.key_ = key;
            this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key;
        }
        static isBindable(obj) {
            if (obj === null) {
                return false;
            }
            if (typeof obj !== 'object') {
                return false;
            }
            return true;
        }
        get key() {
            return this.key_;
        }
        get presetKey() {
            return this.presetKey_;
        }
        read() {
            return this.obj_[this.key_];
        }
        write(value) {
            this.obj_[this.key_] = value;
        }
        writeProperty(name, value) {
            const valueObj = this.read();
            if (!BindingTarget.isBindable(valueObj)) {
                throw TpError.notBindable();
            }
            if (!(name in valueObj)) {
                throw TpError.propertyNotFound(name);
            }
            valueObj[name] = value;
        }
    }

    class ButtonApi extends BladeApi {
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get title() {
            var _a;
            return (_a = this.controller_.valueController.props.get('title')) !== null && _a !== void 0 ? _a : '';
        }
        set title(title) {
            this.controller_.valueController.props.set('title', title);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            const emitter = this.controller_.valueController.emitter;
            emitter.on(eventName, () => {
                bh(new TpEvent(this));
            });
            return this;
        }
    }

    class Emitter {
        constructor() {
            this.observers_ = {};
        }
        on(eventName, handler) {
            let observers = this.observers_[eventName];
            if (!observers) {
                observers = this.observers_[eventName] = [];
            }
            observers.push({
                handler: handler,
            });
            return this;
        }
        off(eventName, handler) {
            const observers = this.observers_[eventName];
            if (observers) {
                this.observers_[eventName] = observers.filter((observer) => {
                    return observer.handler !== handler;
                });
            }
            return this;
        }
        emit(eventName, event) {
            const observers = this.observers_[eventName];
            if (!observers) {
                return;
            }
            observers.forEach((observer) => {
                observer.handler(event);
            });
        }
    }

    const PREFIX = 'tp';
    function ClassName(viewName) {
        const fn = (opt_elementName, opt_modifier) => {
            return [
                PREFIX,
                '-',
                viewName,
                'v',
                opt_elementName ? `_${opt_elementName}` : '',
                opt_modifier ? `-${opt_modifier}` : '',
            ].join('');
        };
        return fn;
    }

    function compose(h1, h2) {
        return (input) => h2(h1(input));
    }
    function extractValue(ev) {
        return ev.rawValue;
    }
    function bindValue(value, applyValue) {
        value.emitter.on('change', compose(extractValue, applyValue));
        applyValue(value.rawValue);
    }
    function bindValueMap(valueMap, key, applyValue) {
        bindValue(valueMap.value(key), applyValue);
    }

    function applyClass(elem, className, active) {
        if (active) {
            elem.classList.add(className);
        }
        else {
            elem.classList.remove(className);
        }
    }
    function valueToClassName(elem, className) {
        return (value) => {
            applyClass(elem, className, value);
        };
    }
    function bindValueToTextContent(value, elem) {
        bindValue(value, (text) => {
            elem.textContent = text !== null && text !== void 0 ? text : '';
        });
    }

    const className$q = ClassName('btn');
    class ButtonView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$q());
            config.viewProps.bindClassModifiers(this.element);
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$q('b'));
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement('div');
            titleElem.classList.add(className$q('t'));
            bindValueToTextContent(config.props.value('title'), titleElem);
            this.buttonElement.appendChild(titleElem);
        }
    }

    class ButtonController {
        constructor(doc, config) {
            this.emitter = new Emitter();
            this.onClick_ = this.onClick_.bind(this);
            this.props = config.props;
            this.viewProps = config.viewProps;
            this.view = new ButtonView(doc, {
                props: this.props,
                viewProps: this.viewProps,
            });
            this.view.buttonElement.addEventListener('click', this.onClick_);
        }
        onClick_() {
            this.emitter.emit('click', {
                sender: this,
            });
        }
    }

    class BoundValue {
        constructor(initialValue, config) {
            var _a;
            this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
            this.equals_ = (_a = config === null || config === void 0 ? void 0 : config.equals) !== null && _a !== void 0 ? _a : ((v1, v2) => v1 === v2);
            this.emitter = new Emitter();
            this.rawValue_ = initialValue;
        }
        get constraint() {
            return this.constraint_;
        }
        get rawValue() {
            return this.rawValue_;
        }
        set rawValue(rawValue) {
            this.setRawValue(rawValue, {
                forceEmit: false,
                last: true,
            });
        }
        setRawValue(rawValue, options) {
            const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true,
            };
            const constrainedValue = this.constraint_
                ? this.constraint_.constrain(rawValue)
                : rawValue;
            const changed = !this.equals_(this.rawValue_, constrainedValue);
            if (!changed && !opts.forceEmit) {
                return;
            }
            this.emitter.emit('beforechange', {
                sender: this,
            });
            this.rawValue_ = constrainedValue;
            this.emitter.emit('change', {
                options: opts,
                rawValue: constrainedValue,
                sender: this,
            });
        }
    }

    class PrimitiveValue {
        constructor(initialValue) {
            this.emitter = new Emitter();
            this.value_ = initialValue;
        }
        get rawValue() {
            return this.value_;
        }
        set rawValue(value) {
            this.setRawValue(value, {
                forceEmit: false,
                last: true,
            });
        }
        setRawValue(value, options) {
            const opts = options !== null && options !== void 0 ? options : {
                forceEmit: false,
                last: true,
            };
            if (this.value_ === value && !opts.forceEmit) {
                return;
            }
            this.emitter.emit('beforechange', {
                sender: this,
            });
            this.value_ = value;
            this.emitter.emit('change', {
                options: opts,
                rawValue: this.value_,
                sender: this,
            });
        }
    }

    function createValue(initialValue, config) {
        const constraint = config === null || config === void 0 ? void 0 : config.constraint;
        const equals = config === null || config === void 0 ? void 0 : config.equals;
        if (!constraint && !equals) {
            return new PrimitiveValue(initialValue);
        }
        return new BoundValue(initialValue, config);
    }

    class ValueMap {
        constructor(valueMap) {
            this.emitter = new Emitter();
            this.valMap_ = valueMap;
            for (const key in this.valMap_) {
                const v = this.valMap_[key];
                v.emitter.on('change', () => {
                    this.emitter.emit('change', {
                        key: key,
                        sender: this,
                    });
                });
            }
        }
        static createCore(initialValue) {
            const keys = Object.keys(initialValue);
            return keys.reduce((o, key) => {
                return Object.assign(o, {
                    [key]: createValue(initialValue[key]),
                });
            }, {});
        }
        static fromObject(initialValue) {
            const core = this.createCore(initialValue);
            return new ValueMap(core);
        }
        get(key) {
            return this.valMap_[key].rawValue;
        }
        set(key, value) {
            this.valMap_[key].rawValue = value;
        }
        value(key) {
            return this.valMap_[key];
        }
    }

    function parseObject(value, keyToParserMap) {
        const keys = Object.keys(keyToParserMap);
        const result = keys.reduce((tmp, key) => {
            if (tmp === undefined) {
                return undefined;
            }
            const parser = keyToParserMap[key];
            const result = parser(value[key]);
            return result.succeeded
                ? Object.assign(Object.assign({}, tmp), { [key]: result.value }) : undefined;
        }, {});
        return forceCast(result);
    }
    function parseArray(value, parseItem) {
        return value.reduce((tmp, item) => {
            if (tmp === undefined) {
                return undefined;
            }
            const result = parseItem(item);
            if (!result.succeeded || result.value === undefined) {
                return undefined;
            }
            return [...tmp, result.value];
        }, []);
    }
    function isObject(value) {
        if (value === null) {
            return false;
        }
        return typeof value === 'object';
    }
    function createParamsParserBuilder(parse) {
        return (optional) => (v) => {
            if (!optional && v === undefined) {
                return {
                    succeeded: false,
                    value: undefined,
                };
            }
            if (optional && v === undefined) {
                return {
                    succeeded: true,
                    value: undefined,
                };
            }
            const result = parse(v);
            return result !== undefined
                ? {
                    succeeded: true,
                    value: result,
                }
                : {
                    succeeded: false,
                    value: undefined,
                };
        };
    }
    function createParamsParserBuilders(optional) {
        return {
            custom: (parse) => createParamsParserBuilder(parse)(optional),
            boolean: createParamsParserBuilder((v) => typeof v === 'boolean' ? v : undefined)(optional),
            number: createParamsParserBuilder((v) => typeof v === 'number' ? v : undefined)(optional),
            string: createParamsParserBuilder((v) => typeof v === 'string' ? v : undefined)(optional),
            function: createParamsParserBuilder((v) =>
            typeof v === 'function' ? v : undefined)(optional),
            constant: (value) => createParamsParserBuilder((v) => (v === value ? value : undefined))(optional),
            raw: createParamsParserBuilder((v) => v)(optional),
            object: (keyToParserMap) => createParamsParserBuilder((v) => {
                if (!isObject(v)) {
                    return undefined;
                }
                return parseObject(v, keyToParserMap);
            })(optional),
            array: (itemParser) => createParamsParserBuilder((v) => {
                if (!Array.isArray(v)) {
                    return undefined;
                }
                return parseArray(v, itemParser);
            })(optional),
        };
    }
    const ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false),
    };
    function parseParams(value, keyToParserMap) {
        const result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : undefined;
    }

    function disposeElement(elem) {
        if (elem && elem.parentElement) {
            elem.parentElement.removeChild(elem);
        }
        return null;
    }

    function getAllBladePositions() {
        return ['veryfirst', 'first', 'last', 'verylast'];
    }

    const className$p = ClassName('');
    const POS_TO_CLASS_NAME_MAP = {
        veryfirst: 'vfst',
        first: 'fst',
        last: 'lst',
        verylast: 'vlst',
    };
    class BladeController {
        constructor(config) {
            this.parent_ = null;
            this.blade = config.blade;
            this.view = config.view;
            this.viewProps = config.viewProps;
            const elem = this.view.element;
            this.blade.value('positions').emitter.on('change', () => {
                getAllBladePositions().forEach((pos) => {
                    elem.classList.remove(className$p(undefined, POS_TO_CLASS_NAME_MAP[pos]));
                });
                this.blade.get('positions').forEach((pos) => {
                    elem.classList.add(className$p(undefined, POS_TO_CLASS_NAME_MAP[pos]));
                });
            });
            this.viewProps.handleDispose(() => {
                disposeElement(elem);
            });
        }
        get parent() {
            return this.parent_;
        }
    }

    const SVG_NS = 'http://www.w3.org/2000/svg';
    function forceReflow(element) {
        element.offsetHeight;
    }
    function disableTransitionTemporarily(element, callback) {
        const t = element.style.transition;
        element.style.transition = 'none';
        callback();
        element.style.transition = t;
    }
    function supportsTouch(doc) {
        return doc.ontouchstart !== undefined;
    }
    function getGlobalObject() {
        return new Function('return this')();
    }
    function getWindowDocument() {
        const globalObj = forceCast(getGlobalObject());
        return globalObj.document;
    }
    function getCanvasContext(canvasElement) {
        const win = canvasElement.ownerDocument.defaultView;
        if (!win) {
            return null;
        }
        const isBrowser = 'document' in win;
        return isBrowser ? canvasElement.getContext('2d') : null;
    }
    const ICON_ID_TO_INNER_HTML_MAP = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
    };
    function createSvgIconElement(document, iconId) {
        const elem = document.createElementNS(SVG_NS, 'svg');
        elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
        return elem;
    }
    function insertElementAt(parentElement, element, index) {
        parentElement.insertBefore(element, parentElement.children[index]);
    }
    function removeElement(element) {
        if (element.parentElement) {
            element.parentElement.removeChild(element);
        }
    }
    function removeChildElements(element) {
        while (element.children.length > 0) {
            element.removeChild(element.children[0]);
        }
    }
    function removeChildNodes(element) {
        while (element.childNodes.length > 0) {
            element.removeChild(element.childNodes[0]);
        }
    }
    function findNextTarget(ev) {
        if (ev.relatedTarget) {
            return forceCast(ev.relatedTarget);
        }
        if ('explicitOriginalTarget' in ev) {
            return ev.explicitOriginalTarget;
        }
        return null;
    }

    const className$o = ClassName('lbl');
    function createLabelNode(doc, label) {
        const frag = doc.createDocumentFragment();
        const lineNodes = label.split('\n').map((line) => {
            return doc.createTextNode(line);
        });
        lineNodes.forEach((lineNode, index) => {
            if (index > 0) {
                frag.appendChild(doc.createElement('br'));
            }
            frag.appendChild(lineNode);
        });
        return frag;
    }
    class LabelView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$o());
            config.viewProps.bindClassModifiers(this.element);
            const labelElem = doc.createElement('div');
            labelElem.classList.add(className$o('l'));
            bindValueMap(config.props, 'label', (value) => {
                if (isEmpty(value)) {
                    this.element.classList.add(className$o(undefined, 'nol'));
                }
                else {
                    this.element.classList.remove(className$o(undefined, 'nol'));
                    removeChildNodes(labelElem);
                    labelElem.appendChild(createLabelNode(doc, value));
                }
            });
            this.element.appendChild(labelElem);
            this.labelElement = labelElem;
            const valueElem = doc.createElement('div');
            valueElem.classList.add(className$o('v'));
            this.element.appendChild(valueElem);
            this.valueElement = valueElem;
        }
    }

    class LabelController extends BladeController {
        constructor(doc, config) {
            const viewProps = config.valueController.viewProps;
            super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {
                    props: config.props,
                    viewProps: viewProps,
                }), viewProps: viewProps }));
            this.props = config.props;
            this.valueController = config.valueController;
            this.view.valueElement.appendChild(this.valueController.view.element);
        }
    }

    const ButtonBladePlugin = {
        id: 'button',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                title: p.required.string,
                view: p.required.constant('button'),
                label: p.optional.string,
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            return new LabelController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                    label: args.params.label,
                }),
                valueController: new ButtonController(args.document, {
                    props: ValueMap.fromObject({
                        title: args.params.title,
                    }),
                    viewProps: args.viewProps,
                }),
            });
        },
        api(args) {
            if (!(args.controller instanceof LabelController)) {
                return null;
            }
            if (!(args.controller.valueController instanceof ButtonController)) {
                return null;
            }
            return new ButtonApi(args.controller);
        },
    };

    class ValueBladeController extends BladeController {
        constructor(config) {
            super(config);
            this.value = config.value;
        }
    }

    function createBlade() {
        return new ValueMap({
            positions: createValue([], {
                equals: deepEqualsArray,
            }),
        });
    }

    class Foldable extends ValueMap {
        constructor(valueMap) {
            super(valueMap);
        }
        static create(expanded) {
            const coreObj = {
                completed: true,
                expanded: expanded,
                expandedHeight: null,
                shouldFixHeight: false,
                temporaryExpanded: null,
            };
            const core = ValueMap.createCore(coreObj);
            return new Foldable(core);
        }
        get styleExpanded() {
            var _a;
            return (_a = this.get('temporaryExpanded')) !== null && _a !== void 0 ? _a : this.get('expanded');
        }
        get styleHeight() {
            if (!this.styleExpanded) {
                return '0';
            }
            const exHeight = this.get('expandedHeight');
            if (this.get('shouldFixHeight') && !isEmpty(exHeight)) {
                return `${exHeight}px`;
            }
            return 'auto';
        }
        bindExpandedClass(elem, expandedClassName) {
            const onExpand = () => {
                const expanded = this.styleExpanded;
                if (expanded) {
                    elem.classList.add(expandedClassName);
                }
                else {
                    elem.classList.remove(expandedClassName);
                }
            };
            bindValueMap(this, 'expanded', onExpand);
            bindValueMap(this, 'temporaryExpanded', onExpand);
        }
        cleanUpTransition() {
            this.set('shouldFixHeight', false);
            this.set('expandedHeight', null);
            this.set('completed', true);
        }
    }
    function computeExpandedFolderHeight(folder, containerElement) {
        let height = 0;
        disableTransitionTemporarily(containerElement, () => {
            folder.set('expandedHeight', null);
            folder.set('temporaryExpanded', true);
            forceReflow(containerElement);
            height = containerElement.clientHeight;
            folder.set('temporaryExpanded', null);
            forceReflow(containerElement);
        });
        return height;
    }
    function applyHeight(foldable, elem) {
        elem.style.height = foldable.styleHeight;
    }
    function bindFoldable(foldable, elem) {
        foldable.value('expanded').emitter.on('beforechange', () => {
            foldable.set('completed', false);
            if (isEmpty(foldable.get('expandedHeight'))) {
                foldable.set('expandedHeight', computeExpandedFolderHeight(foldable, elem));
            }
            foldable.set('shouldFixHeight', true);
            forceReflow(elem);
        });
        foldable.emitter.on('change', () => {
            applyHeight(foldable, elem);
        });
        applyHeight(foldable, elem);
        elem.addEventListener('transitionend', (ev) => {
            if (ev.propertyName !== 'height') {
                return;
            }
            foldable.cleanUpTransition();
        });
    }

    class RackLikeApi extends BladeApi {
        constructor(controller, rackApi) {
            super(controller);
            this.rackApi_ = rackApi;
        }
    }

    function addButtonAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'button' }));
    }
    function addFolderAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'folder' }));
    }
    function addSeparatorAsBlade(api, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'separator' }));
    }
    function addTabAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: 'tab' }));
    }

    class NestedOrderedSet {
        constructor(extract) {
            this.emitter = new Emitter();
            this.items_ = [];
            this.cache_ = new Set();
            this.onSubListAdd_ = this.onSubListAdd_.bind(this);
            this.onSubListRemove_ = this.onSubListRemove_.bind(this);
            this.extract_ = extract;
        }
        get items() {
            return this.items_;
        }
        allItems() {
            return Array.from(this.cache_);
        }
        find(callback) {
            for (const item of this.allItems()) {
                if (callback(item)) {
                    return item;
                }
            }
            return null;
        }
        includes(item) {
            return this.cache_.has(item);
        }
        add(item, opt_index) {
            if (this.includes(item)) {
                throw TpError.shouldNeverHappen();
            }
            const index = opt_index !== undefined ? opt_index : this.items_.length;
            this.items_.splice(index, 0, item);
            this.cache_.add(item);
            const subList = this.extract_(item);
            if (subList) {
                subList.emitter.on('add', this.onSubListAdd_);
                subList.emitter.on('remove', this.onSubListRemove_);
                subList.allItems().forEach((item) => {
                    this.cache_.add(item);
                });
            }
            this.emitter.emit('add', {
                index: index,
                item: item,
                root: this,
                target: this,
            });
        }
        remove(item) {
            const index = this.items_.indexOf(item);
            if (index < 0) {
                return;
            }
            this.items_.splice(index, 1);
            this.cache_.delete(item);
            const subList = this.extract_(item);
            if (subList) {
                subList.emitter.off('add', this.onSubListAdd_);
                subList.emitter.off('remove', this.onSubListRemove_);
            }
            this.emitter.emit('remove', {
                index: index,
                item: item,
                root: this,
                target: this,
            });
        }
        onSubListAdd_(ev) {
            this.cache_.add(ev.item);
            this.emitter.emit('add', {
                index: ev.index,
                item: ev.item,
                root: this,
                target: ev.target,
            });
        }
        onSubListRemove_(ev) {
            this.cache_.delete(ev.item);
            this.emitter.emit('remove', {
                index: ev.index,
                item: ev.item,
                root: this,
                target: ev.target,
            });
        }
    }

    class InputBindingApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.onBindingChange_ = this.onBindingChange_.bind(this);
            this.emitter_ = new Emitter();
            this.controller_.binding.emitter.on('change', this.onBindingChange_);
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        refresh() {
            this.controller_.binding.read();
        }
        onBindingChange_(ev) {
            const value = ev.sender.target.read();
            this.emitter_.emit('change', {
                event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last),
            });
        }
    }

    class InputBindingController extends LabelController {
        constructor(doc, config) {
            super(doc, config);
            this.binding = config.binding;
        }
    }

    class MonitorBindingApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
            this.emitter_ = new Emitter();
            this.controller_.binding.emitter.on('update', this.onBindingUpdate_);
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        refresh() {
            this.controller_.binding.read();
        }
        onBindingUpdate_(ev) {
            const value = ev.sender.target.read();
            this.emitter_.emit('update', {
                event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey),
            });
        }
    }

    class MonitorBindingController extends LabelController {
        constructor(doc, config) {
            super(doc, config);
            this.binding = config.binding;
            this.viewProps.bindDisabled(this.binding.ticker);
            this.viewProps.handleDispose(() => {
                this.binding.dispose();
            });
        }
    }

    function findSubBladeApiSet(api) {
        if (api instanceof RackApi) {
            return api['apiSet_'];
        }
        if (api instanceof RackLikeApi) {
            return api['rackApi_']['apiSet_'];
        }
        return null;
    }
    function getApiByController(apiSet, controller) {
        const api = apiSet.find((api) => api.controller_ === controller);
        if (!api) {
            throw TpError.shouldNeverHappen();
        }
        return api;
    }
    function createBindingTarget(obj, key, opt_id) {
        if (!BindingTarget.isBindable(obj)) {
            throw TpError.notBindable();
        }
        return new BindingTarget(obj, key, opt_id);
    }
    class RackApi extends BladeApi {
        constructor(controller, pool) {
            super(controller);
            this.onRackAdd_ = this.onRackAdd_.bind(this);
            this.onRackRemove_ = this.onRackRemove_.bind(this);
            this.onRackInputChange_ = this.onRackInputChange_.bind(this);
            this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
            this.emitter_ = new Emitter();
            this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
            this.pool_ = pool;
            const rack = this.controller_.rack;
            rack.emitter.on('add', this.onRackAdd_);
            rack.emitter.on('remove', this.onRackRemove_);
            rack.emitter.on('inputchange', this.onRackInputChange_);
            rack.emitter.on('monitorupdate', this.onRackMonitorUpdate_);
            rack.children.forEach((bc) => {
                this.setUpApi_(bc);
            });
        }
        get children() {
            return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
        }
        addInput(object, key, opt_params) {
            const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
            const api = new InputBindingApi(bc);
            return this.add(api, params.index);
        }
        addMonitor(object, key, opt_params) {
            const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
            const api = new MonitorBindingApi(bc);
            return forceCast(this.add(api, params.index));
        }
        addFolder(params) {
            return addFolderAsBlade(this, params);
        }
        addButton(params) {
            return addButtonAsBlade(this, params);
        }
        addSeparator(opt_params) {
            return addSeparatorAsBlade(this, opt_params);
        }
        addTab(params) {
            return addTabAsBlade(this, params);
        }
        add(api, opt_index) {
            this.controller_.rack.add(api.controller_, opt_index);
            const gapi = this.apiSet_.find((a) => a.controller_ === api.controller_);
            if (gapi) {
                this.apiSet_.remove(gapi);
            }
            this.apiSet_.add(api);
            return api;
        }
        remove(api) {
            this.controller_.rack.remove(api.controller_);
        }
        addBlade(params) {
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createBlade(doc, params);
            const api = this.pool_.createBladeApi(bc);
            return this.add(api, params.index);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        setUpApi_(bc) {
            const api = this.apiSet_.find((api) => api.controller_ === bc);
            if (!api) {
                this.apiSet_.add(this.pool_.createBladeApi(bc));
            }
        }
        onRackAdd_(ev) {
            this.setUpApi_(ev.bladeController);
        }
        onRackRemove_(ev) {
            if (ev.isRoot) {
                const api = getApiByController(this.apiSet_, ev.bladeController);
                this.apiSet_.remove(api);
            }
        }
        onRackInputChange_(ev) {
            const bc = ev.bladeController;
            if (bc instanceof InputBindingController) {
                const api = getApiByController(this.apiSet_, bc);
                const binding = bc.binding;
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last),
                });
            }
            else if (bc instanceof ValueBladeController) {
                const api = getApiByController(this.apiSet_, bc);
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(api, bc.value.rawValue, undefined, ev.options.last),
                });
            }
        }
        onRackMonitorUpdate_(ev) {
            if (!(ev.bladeController instanceof MonitorBindingController)) {
                throw TpError.shouldNeverHappen();
            }
            const api = getApiByController(this.apiSet_, ev.bladeController);
            const binding = ev.bladeController.binding;
            this.emitter_.emit('update', {
                event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey),
            });
        }
    }

    class FolderApi extends RackLikeApi {
        constructor(controller, pool) {
            super(controller, new RackApi(controller.rackController, pool));
            this.emitter_ = new Emitter();
            this.controller_.foldable
                .value('expanded')
                .emitter.on('change', (ev) => {
                this.emitter_.emit('fold', {
                    event: new TpFoldEvent(this, ev.sender.rawValue),
                });
            });
            this.rackApi_.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: ev,
                });
            });
            this.rackApi_.on('update', (ev) => {
                this.emitter_.emit('update', {
                    event: ev,
                });
            });
        }
        get expanded() {
            return this.controller_.foldable.get('expanded');
        }
        set expanded(expanded) {
            this.controller_.foldable.set('expanded', expanded);
        }
        get title() {
            return this.controller_.props.get('title');
        }
        set title(title) {
            this.controller_.props.set('title', title);
        }
        get children() {
            return this.rackApi_.children;
        }
        addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
        }
        addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
        }
        addFolder(params) {
            return this.rackApi_.addFolder(params);
        }
        addButton(params) {
            return this.rackApi_.addButton(params);
        }
        addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
            return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
            return this.rackApi_.add(api, opt_index);
        }
        remove(api) {
            this.rackApi_.remove(api);
        }
        addBlade(params) {
            return this.rackApi_.addBlade(params);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    class RackLikeController extends BladeController {
        constructor(config) {
            super({
                blade: config.blade,
                view: config.view,
                viewProps: config.rackController.viewProps,
            });
            this.rackController = config.rackController;
        }
    }

    class PlainView {
        constructor(doc, config) {
            const className = ClassName(config.viewName);
            this.element = doc.createElement('div');
            this.element.classList.add(className());
            config.viewProps.bindClassModifiers(this.element);
        }
    }

    function findInputBindingController(bcs, b) {
        for (let i = 0; i < bcs.length; i++) {
            const bc = bcs[i];
            if (bc instanceof InputBindingController && bc.binding === b) {
                return bc;
            }
        }
        return null;
    }
    function findMonitorBindingController(bcs, b) {
        for (let i = 0; i < bcs.length; i++) {
            const bc = bcs[i];
            if (bc instanceof MonitorBindingController && bc.binding === b) {
                return bc;
            }
        }
        return null;
    }
    function findValueBladeController(bcs, v) {
        for (let i = 0; i < bcs.length; i++) {
            const bc = bcs[i];
            if (bc instanceof ValueBladeController && bc.value === v) {
                return bc;
            }
        }
        return null;
    }
    function findSubRack(bc) {
        if (bc instanceof RackController) {
            return bc.rack;
        }
        if (bc instanceof RackLikeController) {
            return bc.rackController.rack;
        }
        return null;
    }
    function findSubBladeControllerSet(bc) {
        const rack = findSubRack(bc);
        return rack ? rack['bcSet_'] : null;
    }
    class BladeRack {
        constructor(blade) {
            var _a;
            this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
            this.onSetAdd_ = this.onSetAdd_.bind(this);
            this.onSetRemove_ = this.onSetRemove_.bind(this);
            this.onChildDispose_ = this.onChildDispose_.bind(this);
            this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
            this.onChildInputChange_ = this.onChildInputChange_.bind(this);
            this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
            this.onChildValueChange_ = this.onChildValueChange_.bind(this);
            this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
            this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
            this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
            this.onDescendantMonitorUpdate_ =
                this.onDescendantMonitorUpdate_.bind(this);
            this.emitter = new Emitter();
            this.blade_ = blade !== null && blade !== void 0 ? blade : null;
            (_a = this.blade_) === null || _a === void 0 ? void 0 : _a.value('positions').emitter.on('change', this.onBladePositionsChange_);
            this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
            this.bcSet_.emitter.on('add', this.onSetAdd_);
            this.bcSet_.emitter.on('remove', this.onSetRemove_);
        }
        get children() {
            return this.bcSet_.items;
        }
        add(bc, opt_index) {
            if (bc.parent) {
                bc.parent.remove(bc);
            }
            bc['parent_'] = this;
            this.bcSet_.add(bc, opt_index);
        }
        remove(bc) {
            bc['parent_'] = null;
            this.bcSet_.remove(bc);
        }
        find(controllerClass) {
            return forceCast(this.bcSet_.allItems().filter((bc) => {
                return bc instanceof controllerClass;
            }));
        }
        onSetAdd_(ev) {
            this.updatePositions_();
            const isRoot = ev.target === ev.root;
            this.emitter.emit('add', {
                bladeController: ev.item,
                index: ev.index,
                isRoot: isRoot,
                sender: this,
            });
            if (!isRoot) {
                return;
            }
            const bc = ev.item;
            bc.viewProps.emitter.on('change', this.onChildViewPropsChange_);
            bc.blade
                .value('positions')
                .emitter.on('change', this.onChildPositionsChange_);
            bc.viewProps.handleDispose(this.onChildDispose_);
            if (bc instanceof InputBindingController) {
                bc.binding.emitter.on('change', this.onChildInputChange_);
            }
            else if (bc instanceof MonitorBindingController) {
                bc.binding.emitter.on('update', this.onChildMonitorUpdate_);
            }
            else if (bc instanceof ValueBladeController) {
                bc.value.emitter.on('change', this.onChildValueChange_);
            }
            else {
                const rack = findSubRack(bc);
                if (rack) {
                    const emitter = rack.emitter;
                    emitter.on('layout', this.onDescendantLayout_);
                    emitter.on('inputchange', this.onDescendantInputChange_);
                    emitter.on('monitorupdate', this.onDescendantMonitorUpdate_);
                }
            }
        }
        onSetRemove_(ev) {
            this.updatePositions_();
            const isRoot = ev.target === ev.root;
            this.emitter.emit('remove', {
                bladeController: ev.item,
                isRoot: isRoot,
                sender: this,
            });
            if (!isRoot) {
                return;
            }
            const bc = ev.item;
            if (bc instanceof InputBindingController) {
                bc.binding.emitter.off('change', this.onChildInputChange_);
            }
            else if (bc instanceof MonitorBindingController) {
                bc.binding.emitter.off('update', this.onChildMonitorUpdate_);
            }
            else if (bc instanceof ValueBladeController) {
                bc.value.emitter.off('change', this.onChildValueChange_);
            }
            else {
                const rack = findSubRack(bc);
                if (rack) {
                    const emitter = rack.emitter;
                    emitter.off('layout', this.onDescendantLayout_);
                    emitter.off('inputchange', this.onDescendantInputChange_);
                    emitter.off('monitorupdate', this.onDescendantMonitorUpdate_);
                }
            }
        }
        updatePositions_() {
            const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get('hidden'));
            const firstVisibleItem = visibleItems[0];
            const lastVisibleItem = visibleItems[visibleItems.length - 1];
            this.bcSet_.items.forEach((bc) => {
                const ps = [];
                if (bc === firstVisibleItem) {
                    ps.push('first');
                    if (!this.blade_ ||
                        this.blade_.get('positions').includes('veryfirst')) {
                        ps.push('veryfirst');
                    }
                }
                if (bc === lastVisibleItem) {
                    ps.push('last');
                    if (!this.blade_ || this.blade_.get('positions').includes('verylast')) {
                        ps.push('verylast');
                    }
                }
                bc.blade.set('positions', ps);
            });
        }
        onChildPositionsChange_() {
            this.updatePositions_();
            this.emitter.emit('layout', {
                sender: this,
            });
        }
        onChildViewPropsChange_(_ev) {
            this.updatePositions_();
            this.emitter.emit('layout', {
                sender: this,
            });
        }
        onChildDispose_() {
            const disposedUcs = this.bcSet_.items.filter((bc) => {
                return bc.viewProps.get('disposed');
            });
            disposedUcs.forEach((bc) => {
                this.bcSet_.remove(bc);
            });
        }
        onChildInputChange_(ev) {
            const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
            if (!bc) {
                throw TpError.shouldNeverHappen();
            }
            this.emitter.emit('inputchange', {
                bladeController: bc,
                options: ev.options,
                sender: this,
            });
        }
        onChildMonitorUpdate_(ev) {
            const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
            if (!bc) {
                throw TpError.shouldNeverHappen();
            }
            this.emitter.emit('monitorupdate', {
                bladeController: bc,
                sender: this,
            });
        }
        onChildValueChange_(ev) {
            const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
            if (!bc) {
                throw TpError.shouldNeverHappen();
            }
            this.emitter.emit('inputchange', {
                bladeController: bc,
                options: ev.options,
                sender: this,
            });
        }
        onDescendantLayout_(_) {
            this.updatePositions_();
            this.emitter.emit('layout', {
                sender: this,
            });
        }
        onDescendantInputChange_(ev) {
            this.emitter.emit('inputchange', {
                bladeController: ev.bladeController,
                options: ev.options,
                sender: this,
            });
        }
        onDescendantMonitorUpdate_(ev) {
            this.emitter.emit('monitorupdate', {
                bladeController: ev.bladeController,
                sender: this,
            });
        }
        onBladePositionsChange_() {
            this.updatePositions_();
        }
    }

    class RackController extends BladeController {
        constructor(doc, config) {
            super(Object.assign(Object.assign({}, config), { view: new PlainView(doc, {
                    viewName: 'brk',
                    viewProps: config.viewProps,
                }) }));
            this.onRackAdd_ = this.onRackAdd_.bind(this);
            this.onRackRemove_ = this.onRackRemove_.bind(this);
            const rack = new BladeRack(config.root ? undefined : config.blade);
            rack.emitter.on('add', this.onRackAdd_);
            rack.emitter.on('remove', this.onRackRemove_);
            this.rack = rack;
            this.viewProps.handleDispose(() => {
                for (let i = this.rack.children.length - 1; i >= 0; i--) {
                    const bc = this.rack.children[i];
                    bc.viewProps.set('disposed', true);
                }
            });
        }
        onRackAdd_(ev) {
            if (!ev.isRoot) {
                return;
            }
            insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
        }
        onRackRemove_(ev) {
            if (!ev.isRoot) {
                return;
            }
            removeElement(ev.bladeController.view.element);
        }
    }

    const bladeContainerClassName = ClassName('cnt');

    class FolderView {
        constructor(doc, config) {
            var _a;
            this.className_ = ClassName((_a = config.viewName) !== null && _a !== void 0 ? _a : 'fld');
            this.element = doc.createElement('div');
            this.element.classList.add(this.className_(), bladeContainerClassName());
            config.viewProps.bindClassModifiers(this.element);
            this.foldable_ = config.foldable;
            this.foldable_.bindExpandedClass(this.element, this.className_(undefined, 'expanded'));
            bindValueMap(this.foldable_, 'completed', valueToClassName(this.element, this.className_(undefined, 'cpl')));
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(this.className_('b'));
            bindValueMap(config.props, 'title', (title) => {
                if (isEmpty(title)) {
                    this.element.classList.add(this.className_(undefined, 'not'));
                }
                else {
                    this.element.classList.remove(this.className_(undefined, 'not'));
                }
            });
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement('div');
            titleElem.classList.add(this.className_('t'));
            bindValueToTextContent(config.props.value('title'), titleElem);
            this.buttonElement.appendChild(titleElem);
            this.titleElement = titleElem;
            const markElem = doc.createElement('div');
            markElem.classList.add(this.className_('m'));
            this.buttonElement.appendChild(markElem);
            const containerElem = config.containerElement;
            containerElem.classList.add(this.className_('c'));
            this.element.appendChild(containerElem);
            this.containerElement = containerElem;
        }
    }

    class FolderController extends RackLikeController {
        constructor(doc, config) {
            var _a;
            const foldable = Foldable.create((_a = config.expanded) !== null && _a !== void 0 ? _a : true);
            const rc = new RackController(doc, {
                blade: config.blade,
                root: config.root,
                viewProps: config.viewProps,
            });
            super(Object.assign(Object.assign({}, config), { rackController: rc, view: new FolderView(doc, {
                    containerElement: rc.view.element,
                    foldable: foldable,
                    props: config.props,
                    viewName: config.root ? 'rot' : undefined,
                    viewProps: config.viewProps,
                }) }));
            this.onTitleClick_ = this.onTitleClick_.bind(this);
            this.props = config.props;
            this.foldable = foldable;
            bindFoldable(this.foldable, this.view.containerElement);
            this.rackController.rack.emitter.on('add', () => {
                this.foldable.cleanUpTransition();
            });
            this.rackController.rack.emitter.on('remove', () => {
                this.foldable.cleanUpTransition();
            });
            this.view.buttonElement.addEventListener('click', this.onTitleClick_);
        }
        get document() {
            return this.view.element.ownerDocument;
        }
        onTitleClick_() {
            this.foldable.set('expanded', !this.foldable.get('expanded'));
        }
    }

    const FolderBladePlugin = {
        id: 'folder',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                title: p.required.string,
                view: p.required.constant('folder'),
                expanded: p.optional.boolean,
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            return new FolderController(args.document, {
                blade: args.blade,
                expanded: args.params.expanded,
                props: ValueMap.fromObject({
                    title: args.params.title,
                }),
                viewProps: args.viewProps,
            });
        },
        api(args) {
            if (!(args.controller instanceof FolderController)) {
                return null;
            }
            return new FolderApi(args.controller, args.pool);
        },
    };

    class LabeledValueController extends ValueBladeController {
        constructor(doc, config) {
            const viewProps = config.valueController.viewProps;
            super(Object.assign(Object.assign({}, config), { value: config.valueController.value, view: new LabelView(doc, {
                    props: config.props,
                    viewProps: viewProps,
                }), viewProps: viewProps }));
            this.props = config.props;
            this.valueController = config.valueController;
            this.view.valueElement.appendChild(this.valueController.view.element);
        }
    }

    class SeparatorApi extends BladeApi {
    }

    const className$n = ClassName('spr');
    class SeparatorView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$n());
            config.viewProps.bindClassModifiers(this.element);
            const hrElem = doc.createElement('hr');
            hrElem.classList.add(className$n('r'));
            this.element.appendChild(hrElem);
        }
    }

    class SeparatorController extends BladeController {
        constructor(doc, config) {
            super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {
                    viewProps: config.viewProps,
                }) }));
        }
    }

    const SeparatorBladePlugin = {
        id: 'separator',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                view: p.required.constant('separator'),
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            return new SeparatorController(args.document, {
                blade: args.blade,
                viewProps: args.viewProps,
            });
        },
        api(args) {
            if (!(args.controller instanceof SeparatorController)) {
                return null;
            }
            return new SeparatorApi(args.controller);
        },
    };

    const className$m = ClassName('');
    function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$m(undefined, modifier));
    }
    class ViewProps extends ValueMap {
        constructor(valueMap) {
            super(valueMap);
        }
        static create(opt_initialValue) {
            var _a, _b;
            const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
            const coreObj = {
                disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
                disposed: false,
                hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
            };
            const core = ValueMap.createCore(coreObj);
            return new ViewProps(core);
        }
        bindClassModifiers(elem) {
            bindValueMap(this, 'disabled', valueToModifier(elem, 'disabled'));
            bindValueMap(this, 'hidden', valueToModifier(elem, 'hidden'));
        }
        bindDisabled(target) {
            bindValueMap(this, 'disabled', (disabled) => {
                target.disabled = disabled;
            });
        }
        bindTabIndex(elem) {
            bindValueMap(this, 'disabled', (disabled) => {
                elem.tabIndex = disabled ? -1 : 0;
            });
        }
        handleDispose(callback) {
            this.value('disposed').emitter.on('change', (disposed) => {
                if (disposed) {
                    callback();
                }
            });
        }
    }

    const className$l = ClassName('tbi');
    class TabItemView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$l());
            config.viewProps.bindClassModifiers(this.element);
            bindValueMap(config.props, 'selected', (selected) => {
                if (selected) {
                    this.element.classList.add(className$l(undefined, 'sel'));
                }
                else {
                    this.element.classList.remove(className$l(undefined, 'sel'));
                }
            });
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$l('b'));
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement('div');
            titleElem.classList.add(className$l('t'));
            bindValueToTextContent(config.props.value('title'), titleElem);
            this.buttonElement.appendChild(titleElem);
            this.titleElement = titleElem;
        }
    }

    class TabItemController {
        constructor(doc, config) {
            this.emitter = new Emitter();
            this.onClick_ = this.onClick_.bind(this);
            this.props = config.props;
            this.viewProps = config.viewProps;
            this.view = new TabItemView(doc, {
                props: config.props,
                viewProps: config.viewProps,
            });
            this.view.buttonElement.addEventListener('click', this.onClick_);
        }
        onClick_() {
            this.emitter.emit('click', {
                sender: this,
            });
        }
    }

    class TabPageController {
        constructor(doc, config) {
            this.onItemClick_ = this.onItemClick_.bind(this);
            this.ic_ = new TabItemController(doc, {
                props: config.itemProps,
                viewProps: ViewProps.create(),
            });
            this.ic_.emitter.on('click', this.onItemClick_);
            this.cc_ = new RackController(doc, {
                blade: createBlade(),
                viewProps: ViewProps.create(),
            });
            this.props = config.props;
            bindValueMap(this.props, 'selected', (selected) => {
                this.itemController.props.set('selected', selected);
                this.contentController.viewProps.set('hidden', !selected);
            });
        }
        get itemController() {
            return this.ic_;
        }
        get contentController() {
            return this.cc_;
        }
        onItemClick_() {
            this.props.set('selected', true);
        }
    }

    class TabPageApi {
        constructor(controller, contentRackApi) {
            this.controller_ = controller;
            this.rackApi_ = contentRackApi;
        }
        get title() {
            var _a;
            return (_a = this.controller_.itemController.props.get('title')) !== null && _a !== void 0 ? _a : '';
        }
        set title(title) {
            this.controller_.itemController.props.set('title', title);
        }
        get selected() {
            return this.controller_.props.get('selected');
        }
        set selected(selected) {
            this.controller_.props.set('selected', selected);
        }
        get children() {
            return this.rackApi_.children;
        }
        addButton(params) {
            return this.rackApi_.addButton(params);
        }
        addFolder(params) {
            return this.rackApi_.addFolder(params);
        }
        addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
            return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
            this.rackApi_.add(api, opt_index);
        }
        remove(api) {
            this.rackApi_.remove(api);
        }
        addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
        }
        addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
        }
        addBlade(params) {
            return this.rackApi_.addBlade(params);
        }
    }

    class TabApi extends RackLikeApi {
        constructor(controller, pool) {
            super(controller, new RackApi(controller.rackController, pool));
            this.onPageAdd_ = this.onPageAdd_.bind(this);
            this.onPageRemove_ = this.onPageRemove_.bind(this);
            this.onSelect_ = this.onSelect_.bind(this);
            this.emitter_ = new Emitter();
            this.pageApiMap_ = new Map();
            this.rackApi_.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: ev,
                });
            });
            this.rackApi_.on('update', (ev) => {
                this.emitter_.emit('update', {
                    event: ev,
                });
            });
            this.controller_.tab.selectedIndex.emitter.on('change', this.onSelect_);
            this.controller_.pageSet.emitter.on('add', this.onPageAdd_);
            this.controller_.pageSet.emitter.on('remove', this.onPageRemove_);
            this.controller_.pageSet.items.forEach((pc) => {
                this.setUpPageApi_(pc);
            });
        }
        get pages() {
            return this.controller_.pageSet.items.map((pc) => {
                const api = this.pageApiMap_.get(pc);
                if (!api) {
                    throw TpError.shouldNeverHappen();
                }
                return api;
            });
        }
        addPage(params) {
            const doc = this.controller_.view.element.ownerDocument;
            const pc = new TabPageController(doc, {
                itemProps: ValueMap.fromObject({
                    selected: false,
                    title: params.title,
                }),
                props: ValueMap.fromObject({
                    selected: false,
                }),
            });
            this.controller_.add(pc, params.index);
            const api = this.pageApiMap_.get(pc);
            if (!api) {
                throw TpError.shouldNeverHappen();
            }
            return api;
        }
        removePage(index) {
            this.controller_.remove(index);
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
        setUpPageApi_(pc) {
            const rackApi = this.rackApi_['apiSet_'].find((api) => api.controller_ === pc.contentController);
            if (!rackApi) {
                throw TpError.shouldNeverHappen();
            }
            const api = new TabPageApi(pc, rackApi);
            this.pageApiMap_.set(pc, api);
        }
        onPageAdd_(ev) {
            this.setUpPageApi_(ev.item);
        }
        onPageRemove_(ev) {
            const api = this.pageApiMap_.get(ev.item);
            if (!api) {
                throw TpError.shouldNeverHappen();
            }
            this.pageApiMap_.delete(ev.item);
        }
        onSelect_(ev) {
            this.emitter_.emit('select', {
                event: new TpTabSelectEvent(this, ev.rawValue),
            });
        }
    }

    const INDEX_NOT_SELECTED = -1;
    class Tab {
        constructor() {
            this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
            this.empty = createValue(true);
            this.selectedIndex = createValue(INDEX_NOT_SELECTED);
            this.items_ = [];
        }
        add(item, opt_index) {
            const index = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
            this.items_.splice(index, 0, item);
            item.emitter.on('change', this.onItemSelectedChange_);
            this.keepSelection_();
        }
        remove(item) {
            const index = this.items_.indexOf(item);
            if (index < 0) {
                return;
            }
            this.items_.splice(index, 1);
            item.emitter.off('change', this.onItemSelectedChange_);
            this.keepSelection_();
        }
        keepSelection_() {
            if (this.items_.length === 0) {
                this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
                this.empty.rawValue = true;
                return;
            }
            const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
            if (firstSelIndex < 0) {
                this.items_.forEach((s, i) => {
                    s.rawValue = i === 0;
                });
                this.selectedIndex.rawValue = 0;
            }
            else {
                this.items_.forEach((s, i) => {
                    s.rawValue = i === firstSelIndex;
                });
                this.selectedIndex.rawValue = firstSelIndex;
            }
            this.empty.rawValue = false;
        }
        onItemSelectedChange_(ev) {
            if (ev.rawValue) {
                const index = this.items_.findIndex((s) => s === ev.sender);
                this.items_.forEach((s, i) => {
                    s.rawValue = i === index;
                });
                this.selectedIndex.rawValue = index;
            }
            else {
                this.keepSelection_();
            }
        }
    }

    const className$k = ClassName('tab');
    class TabView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$k(), bladeContainerClassName());
            config.viewProps.bindClassModifiers(this.element);
            bindValue(config.empty, valueToClassName(this.element, className$k(undefined, 'nop')));
            const itemsElem = doc.createElement('div');
            itemsElem.classList.add(className$k('i'));
            this.element.appendChild(itemsElem);
            this.itemsElement = itemsElem;
            const contentsElem = config.contentsElement;
            contentsElem.classList.add(className$k('c'));
            this.element.appendChild(contentsElem);
            this.contentsElement = contentsElem;
        }
    }

    class TabController extends RackLikeController {
        constructor(doc, config) {
            const cr = new RackController(doc, {
                blade: config.blade,
                viewProps: config.viewProps,
            });
            const tab = new Tab();
            super({
                blade: config.blade,
                rackController: cr,
                view: new TabView(doc, {
                    contentsElement: cr.view.element,
                    empty: tab.empty,
                    viewProps: config.viewProps,
                }),
            });
            this.onPageAdd_ = this.onPageAdd_.bind(this);
            this.onPageRemove_ = this.onPageRemove_.bind(this);
            this.pageSet_ = new NestedOrderedSet(() => null);
            this.pageSet_.emitter.on('add', this.onPageAdd_);
            this.pageSet_.emitter.on('remove', this.onPageRemove_);
            this.tab = tab;
        }
        get pageSet() {
            return this.pageSet_;
        }
        add(pc, opt_index) {
            this.pageSet_.add(pc, opt_index);
        }
        remove(index) {
            this.pageSet_.remove(this.pageSet_.items[index]);
        }
        onPageAdd_(ev) {
            const pc = ev.item;
            insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
            this.rackController.rack.add(pc.contentController, ev.index);
            this.tab.add(pc.props.value('selected'));
        }
        onPageRemove_(ev) {
            const pc = ev.item;
            removeElement(pc.itemController.view.element);
            this.rackController.rack.remove(pc.contentController);
            this.tab.remove(pc.props.value('selected'));
        }
    }

    const TabBladePlugin = {
        id: 'tab',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                pages: p.required.array(p.required.object({ title: p.required.string })),
                view: p.required.constant('tab'),
            });
            if (!result || result.pages.length === 0) {
                return null;
            }
            return { params: result };
        },
        controller(args) {
            const c = new TabController(args.document, {
                blade: args.blade,
                viewProps: args.viewProps,
            });
            args.params.pages.forEach((p) => {
                const pc = new TabPageController(args.document, {
                    itemProps: ValueMap.fromObject({
                        selected: false,
                        title: p.title,
                    }),
                    props: ValueMap.fromObject({
                        selected: false,
                    }),
                });
                c.add(pc);
            });
            return c;
        },
        api(args) {
            if (!(args.controller instanceof TabController)) {
                return null;
            }
            return new TabApi(args.controller, args.pool);
        },
    };

    function createBladeController(plugin, args) {
        const ac = plugin.accept(args.params);
        if (!ac) {
            return null;
        }
        const disabled = ParamsParsers.optional.boolean(args.params['disabled']).value;
        const hidden = ParamsParsers.optional.boolean(args.params['hidden']).value;
        return plugin.controller({
            blade: createBlade(),
            document: args.document,
            params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled: disabled, hidden: hidden })),
            viewProps: ViewProps.create({
                disabled: disabled,
                hidden: hidden,
            }),
        });
    }

    class ManualTicker {
        constructor() {
            this.disabled = false;
            this.emitter = new Emitter();
        }
        dispose() { }
        tick() {
            if (this.disabled) {
                return;
            }
            this.emitter.emit('tick', {
                sender: this,
            });
        }
    }

    class IntervalTicker {
        constructor(doc, interval) {
            this.disabled_ = false;
            this.timerId_ = null;
            this.onTick_ = this.onTick_.bind(this);
            this.doc_ = doc;
            this.emitter = new Emitter();
            this.interval_ = interval;
            this.setTimer_();
        }
        get disabled() {
            return this.disabled_;
        }
        set disabled(inactive) {
            this.disabled_ = inactive;
            if (this.disabled_) {
                this.clearTimer_();
            }
            else {
                this.setTimer_();
            }
        }
        dispose() {
            this.clearTimer_();
        }
        clearTimer_() {
            if (this.timerId_ === null) {
                return;
            }
            const win = this.doc_.defaultView;
            if (win) {
                win.clearInterval(this.timerId_);
            }
            this.timerId_ = null;
        }
        setTimer_() {
            this.clearTimer_();
            if (this.interval_ <= 0) {
                return;
            }
            const win = this.doc_.defaultView;
            if (win) {
                this.timerId_ = win.setInterval(this.onTick_, this.interval_);
            }
        }
        onTick_() {
            if (this.disabled_) {
                return;
            }
            this.emitter.emit('tick', {
                sender: this,
            });
        }
    }

    class CompositeConstraint {
        constructor(constraints) {
            this.constraints = constraints;
        }
        constrain(value) {
            return this.constraints.reduce((result, c) => {
                return c.constrain(result);
            }, value);
        }
    }
    function findConstraint(c, constraintClass) {
        if (c instanceof constraintClass) {
            return c;
        }
        if (c instanceof CompositeConstraint) {
            const result = c.constraints.reduce((tmpResult, sc) => {
                if (tmpResult) {
                    return tmpResult;
                }
                return sc instanceof constraintClass ? sc : null;
            }, null);
            if (result) {
                return result;
            }
        }
        return null;
    }

    class ListConstraint {
        constructor(options) {
            this.options = options;
        }
        constrain(value) {
            const opts = this.options;
            if (opts.length === 0) {
                return value;
            }
            const matched = opts.filter((item) => {
                return item.value === value;
            }).length > 0;
            return matched ? value : opts[0].value;
        }
    }

    class RangeConstraint {
        constructor(config) {
            this.maxValue = config.max;
            this.minValue = config.min;
        }
        constrain(value) {
            let result = value;
            if (!isEmpty(this.minValue)) {
                result = Math.max(result, this.minValue);
            }
            if (!isEmpty(this.maxValue)) {
                result = Math.min(result, this.maxValue);
            }
            return result;
        }
    }

    class StepConstraint {
        constructor(step, origin = 0) {
            this.step = step;
            this.origin = origin;
        }
        constrain(value) {
            const o = this.origin % this.step;
            const r = Math.round((value - o) / this.step);
            return o + r * this.step;
        }
    }

    const className$j = ClassName('lst');
    class ListView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.props_ = config.props;
            this.element = doc.createElement('div');
            this.element.classList.add(className$j());
            config.viewProps.bindClassModifiers(this.element);
            const selectElem = doc.createElement('select');
            selectElem.classList.add(className$j('s'));
            bindValueMap(this.props_, 'options', (opts) => {
                removeChildElements(selectElem);
                opts.forEach((item, index) => {
                    const optionElem = doc.createElement('option');
                    optionElem.dataset.index = String(index);
                    optionElem.textContent = item.text;
                    optionElem.value = String(item.value);
                    selectElem.appendChild(optionElem);
                });
            });
            config.viewProps.bindDisabled(selectElem);
            this.element.appendChild(selectElem);
            this.selectElement = selectElem;
            const markElem = doc.createElement('div');
            markElem.classList.add(className$j('m'));
            markElem.appendChild(createSvgIconElement(doc, 'dropdown'));
            this.element.appendChild(markElem);
            config.value.emitter.on('change', this.onValueChange_);
            this.value_ = config.value;
            this.update_();
        }
        update_() {
            this.selectElement.value = String(this.value_.rawValue);
        }
        onValueChange_() {
            this.update_();
        }
    }

    class ListController {
        constructor(doc, config) {
            this.onSelectChange_ = this.onSelectChange_.bind(this);
            this.props = config.props;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new ListView(doc, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.selectElement.addEventListener('change', this.onSelectChange_);
        }
        onSelectChange_(e) {
            const selectElem = forceCast(e.currentTarget);
            const optElem = selectElem.selectedOptions.item(0);
            if (!optElem) {
                return;
            }
            const itemIndex = Number(optElem.dataset.index);
            this.value.rawValue = this.props.get('options')[itemIndex].value;
        }
    }

    const className$i = ClassName('pop');
    class PopupView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$i());
            config.viewProps.bindClassModifiers(this.element);
            bindValue(config.shows, valueToClassName(this.element, className$i(undefined, 'v')));
        }
    }

    class PopupController {
        constructor(doc, config) {
            this.shows = createValue(false);
            this.viewProps = config.viewProps;
            this.view = new PopupView(doc, {
                shows: this.shows,
                viewProps: this.viewProps,
            });
        }
    }

    const className$h = ClassName('txt');
    class TextView {
        constructor(doc, config) {
            this.onChange_ = this.onChange_.bind(this);
            this.element = doc.createElement('div');
            this.element.classList.add(className$h());
            config.viewProps.bindClassModifiers(this.element);
            this.props_ = config.props;
            this.props_.emitter.on('change', this.onChange_);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$h('i'));
            inputElem.type = 'text';
            config.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            config.value.emitter.on('change', this.onChange_);
            this.value_ = config.value;
            this.refresh();
        }
        refresh() {
            const formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value_.rawValue);
        }
        onChange_() {
            this.refresh();
        }
    }

    class TextController {
        constructor(doc, config) {
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.parser_ = config.parser;
            this.props = config.props;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new TextView(doc, {
                props: config.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.inputElement.addEventListener('change', this.onInputChange_);
        }
        onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            const value = inputElem.value;
            const parsedValue = this.parser_(value);
            if (!isEmpty(parsedValue)) {
                this.value.rawValue = parsedValue;
            }
            this.view.refresh();
        }
    }

    function boolToString(value) {
        return String(value);
    }
    function boolFromUnknown(value) {
        if (value === 'false') {
            return false;
        }
        return !!value;
    }
    function BooleanFormatter(value) {
        return boolToString(value);
    }

    class NumberLiteralNode {
        constructor(text) {
            this.text = text;
        }
        evaluate() {
            return Number(this.text);
        }
        toString() {
            return this.text;
        }
    }
    const BINARY_OPERATION_MAP = {
        '**': (v1, v2) => Math.pow(v1, v2),
        '*': (v1, v2) => v1 * v2,
        '/': (v1, v2) => v1 / v2,
        '%': (v1, v2) => v1 % v2,
        '+': (v1, v2) => v1 + v2,
        '-': (v1, v2) => v1 - v2,
        '<<': (v1, v2) => v1 << v2,
        '>>': (v1, v2) => v1 >> v2,
        '>>>': (v1, v2) => v1 >>> v2,
        '&': (v1, v2) => v1 & v2,
        '^': (v1, v2) => v1 ^ v2,
        '|': (v1, v2) => v1 | v2,
    };
    class BinaryOperationNode {
        constructor(operator, left, right) {
            this.left = left;
            this.operator = operator;
            this.right = right;
        }
        evaluate() {
            const op = BINARY_OPERATION_MAP[this.operator];
            if (!op) {
                throw new Error(`unexpected binary operator: '${this.operator}`);
            }
            return op(this.left.evaluate(), this.right.evaluate());
        }
        toString() {
            return [
                'b(',
                this.left.toString(),
                this.operator,
                this.right.toString(),
                ')',
            ].join(' ');
        }
    }
    const UNARY_OPERATION_MAP = {
        '+': (v) => v,
        '-': (v) => -v,
        '~': (v) => ~v,
    };
    class UnaryOperationNode {
        constructor(operator, expr) {
            this.operator = operator;
            this.expression = expr;
        }
        evaluate() {
            const op = UNARY_OPERATION_MAP[this.operator];
            if (!op) {
                throw new Error(`unexpected unary operator: '${this.operator}`);
            }
            return op(this.expression.evaluate());
        }
        toString() {
            return ['u(', this.operator, this.expression.toString(), ')'].join(' ');
        }
    }

    function combineReader(parsers) {
        return (text, cursor) => {
            for (let i = 0; i < parsers.length; i++) {
                const result = parsers[i](text, cursor);
                if (result !== '') {
                    return result;
                }
            }
            return '';
        };
    }
    function readWhitespace(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^\s+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readNonZeroDigit(text, cursor) {
        const ch = text.substr(cursor, 1);
        return ch.match(/^[1-9]$/) ? ch : '';
    }
    function readDecimalDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[0-9]+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readSignedInteger(text, cursor) {
        const ds = readDecimalDigits(text, cursor);
        if (ds !== '') {
            return ds;
        }
        const sign = text.substr(cursor, 1);
        cursor += 1;
        if (sign !== '-' && sign !== '+') {
            return '';
        }
        const sds = readDecimalDigits(text, cursor);
        if (sds === '') {
            return '';
        }
        return sign + sds;
    }
    function readExponentPart(text, cursor) {
        const e = text.substr(cursor, 1);
        cursor += 1;
        if (e.toLowerCase() !== 'e') {
            return '';
        }
        const si = readSignedInteger(text, cursor);
        if (si === '') {
            return '';
        }
        return e + si;
    }
    function readDecimalIntegerLiteral(text, cursor) {
        const ch = text.substr(cursor, 1);
        if (ch === '0') {
            return ch;
        }
        const nzd = readNonZeroDigit(text, cursor);
        cursor += nzd.length;
        if (nzd === '') {
            return '';
        }
        return nzd + readDecimalDigits(text, cursor);
    }
    function readDecimalLiteral1(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === '') {
            return '';
        }
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== '.') {
            return '';
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        return dil + dot + dds + readExponentPart(text, cursor);
    }
    function readDecimalLiteral2(text, cursor) {
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== '.') {
            return '';
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        if (dds === '') {
            return '';
        }
        return dot + dds + readExponentPart(text, cursor);
    }
    function readDecimalLiteral3(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === '') {
            return '';
        }
        return dil + readExponentPart(text, cursor);
    }
    const readDecimalLiteral = combineReader([
        readDecimalLiteral1,
        readDecimalLiteral2,
        readDecimalLiteral3,
    ]);
    function parseBinaryDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[01]+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readBinaryIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== '0b') {
            return '';
        }
        const bds = parseBinaryDigits(text, cursor);
        if (bds === '') {
            return '';
        }
        return prefix + bds;
    }
    function readOctalDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[0-7]+/);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readOctalIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== '0o') {
            return '';
        }
        const ods = readOctalDigits(text, cursor);
        if (ods === '') {
            return '';
        }
        return prefix + ods;
    }
    function readHexDigits(text, cursor) {
        var _a;
        const m = text.substr(cursor).match(/^[0-9a-f]+/i);
        return (_a = (m && m[0])) !== null && _a !== void 0 ? _a : '';
    }
    function readHexIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== '0x') {
            return '';
        }
        const hds = readHexDigits(text, cursor);
        if (hds === '') {
            return '';
        }
        return prefix + hds;
    }
    const readNonDecimalIntegerLiteral = combineReader([
        readBinaryIntegerLiteral,
        readOctalIntegerLiteral,
        readHexIntegerLiteral,
    ]);
    const readNumericLiteral = combineReader([
        readNonDecimalIntegerLiteral,
        readDecimalLiteral,
    ]);

    function parseLiteral(text, cursor) {
        const num = readNumericLiteral(text, cursor);
        cursor += num.length;
        if (num === '') {
            return null;
        }
        return {
            evaluable: new NumberLiteralNode(num),
            cursor: cursor,
        };
    }
    function parseParenthesizedExpression(text, cursor) {
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== '(') {
            return null;
        }
        const expr = parseExpression(text, cursor);
        if (!expr) {
            return null;
        }
        cursor = expr.cursor;
        cursor += readWhitespace(text, cursor).length;
        const cl = text.substr(cursor, 1);
        cursor += cl.length;
        if (cl !== ')') {
            return null;
        }
        return {
            evaluable: expr.evaluable,
            cursor: cursor,
        };
    }
    function parsePrimaryExpression(text, cursor) {
        var _a;
        return ((_a = parseLiteral(text, cursor)) !== null && _a !== void 0 ? _a : parseParenthesizedExpression(text, cursor));
    }
    function parseUnaryExpression(text, cursor) {
        const expr = parsePrimaryExpression(text, cursor);
        if (expr) {
            return expr;
        }
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== '+' && op !== '-' && op !== '~') {
            return null;
        }
        const num = parseUnaryExpression(text, cursor);
        if (!num) {
            return null;
        }
        cursor = num.cursor;
        return {
            cursor: cursor,
            evaluable: new UnaryOperationNode(op, num.evaluable),
        };
    }
    function readBinaryOperator(ops, text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        const op = ops.filter((op) => text.startsWith(op, cursor))[0];
        if (!op) {
            return null;
        }
        cursor += op.length;
        cursor += readWhitespace(text, cursor).length;
        return {
            cursor: cursor,
            operator: op,
        };
    }
    function createBinaryOperationExpressionParser(exprParser, ops) {
        return (text, cursor) => {
            const firstExpr = exprParser(text, cursor);
            if (!firstExpr) {
                return null;
            }
            cursor = firstExpr.cursor;
            let expr = firstExpr.evaluable;
            for (;;) {
                const op = readBinaryOperator(ops, text, cursor);
                if (!op) {
                    break;
                }
                cursor = op.cursor;
                const nextExpr = exprParser(text, cursor);
                if (!nextExpr) {
                    return null;
                }
                cursor = nextExpr.cursor;
                expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
            }
            return expr
                ? {
                    cursor: cursor,
                    evaluable: expr,
                }
                : null;
        };
    }
    const parseBinaryOperationExpression = [
        ['**'],
        ['*', '/', '%'],
        ['+', '-'],
        ['<<', '>>>', '>>'],
        ['&'],
        ['^'],
        ['|'],
    ].reduce((parser, ops) => {
        return createBinaryOperationExpressionParser(parser, ops);
    }, parseUnaryExpression);
    function parseExpression(text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        return parseBinaryOperationExpression(text, cursor);
    }
    function parseEcmaNumberExpression(text) {
        const expr = parseExpression(text, 0);
        if (!expr) {
            return null;
        }
        const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
        if (cursor !== text.length) {
            return null;
        }
        return expr.evaluable;
    }

    function parseNumber(text) {
        var _a;
        const r = parseEcmaNumberExpression(text);
        return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a !== void 0 ? _a : null;
    }
    function numberFromUnknown(value) {
        if (typeof value === 'number') {
            return value;
        }
        if (typeof value === 'string') {
            const pv = parseNumber(value);
            if (!isEmpty(pv)) {
                return pv;
            }
        }
        return 0;
    }
    function numberToString(value) {
        return String(value);
    }
    function createNumberFormatter(digits) {
        return (value) => {
            return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
    }

    const innerFormatter = createNumberFormatter(0);
    function formatPercentage(value) {
        return innerFormatter(value) + '%';
    }

    function stringFromUnknown(value) {
        return String(value);
    }
    function formatString(value) {
        return value;
    }

    function fillBuffer(buffer, bufferSize) {
        while (buffer.length < bufferSize) {
            buffer.push(undefined);
        }
    }
    function initializeBuffer(bufferSize) {
        const buffer = [];
        fillBuffer(buffer, bufferSize);
        return createValue(buffer);
    }
    function createTrimmedBuffer(buffer) {
        const index = buffer.indexOf(undefined);
        return forceCast(index < 0 ? buffer : buffer.slice(0, index));
    }
    function createPushedBuffer(buffer, newValue) {
        const newBuffer = [...createTrimmedBuffer(buffer), newValue];
        if (newBuffer.length > buffer.length) {
            newBuffer.splice(0, newBuffer.length - buffer.length);
        }
        else {
            fillBuffer(newBuffer, buffer.length);
        }
        return newBuffer;
    }

    function connectValues({ primary, secondary, forward, backward, }) {
        let changing = false;
        function preventFeedback(callback) {
            if (changing) {
                return;
            }
            changing = true;
            callback();
            changing = false;
        }
        primary.emitter.on('change', (ev) => {
            preventFeedback(() => {
                secondary.setRawValue(forward(primary, secondary), ev.options);
            });
        });
        secondary.emitter.on('change', (ev) => {
            preventFeedback(() => {
                primary.setRawValue(backward(primary, secondary), ev.options);
            });
            preventFeedback(() => {
                secondary.setRawValue(forward(primary, secondary), ev.options);
            });
        });
        preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), {
                forceEmit: false,
                last: true,
            });
        });
    }

    function getStepForKey(baseStep, keys) {
        const step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
        if (keys.upKey) {
            return +step;
        }
        else if (keys.downKey) {
            return -step;
        }
        return 0;
    }
    function getVerticalStepKeys(ev) {
        return {
            altKey: ev.altKey,
            downKey: ev.key === 'ArrowDown',
            shiftKey: ev.shiftKey,
            upKey: ev.key === 'ArrowUp',
        };
    }
    function getHorizontalStepKeys(ev) {
        return {
            altKey: ev.altKey,
            downKey: ev.key === 'ArrowLeft',
            shiftKey: ev.shiftKey,
            upKey: ev.key === 'ArrowRight',
        };
    }
    function isVerticalArrowKey(key) {
        return key === 'ArrowUp' || key === 'ArrowDown';
    }
    function isArrowKey(key) {
        return isVerticalArrowKey(key) || key === 'ArrowLeft' || key === 'ArrowRight';
    }

    function computeOffset$1(ev, elem) {
        var _a, _b;
        const win = elem.ownerDocument.defaultView;
        const rect = elem.getBoundingClientRect();
        return {
            x: ev.pageX - (((_a = (win && win.scrollX)) !== null && _a !== void 0 ? _a : 0) + rect.left),
            y: ev.pageY - (((_b = (win && win.scrollY)) !== null && _b !== void 0 ? _b : 0) + rect.top),
        };
    }
    class PointerHandler {
        constructor(element) {
            this.lastTouch_ = null;
            this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
            this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
            this.onMouseDown_ = this.onMouseDown_.bind(this);
            this.onTouchEnd_ = this.onTouchEnd_.bind(this);
            this.onTouchMove_ = this.onTouchMove_.bind(this);
            this.onTouchStart_ = this.onTouchStart_.bind(this);
            this.elem_ = element;
            this.emitter = new Emitter();
            element.addEventListener('touchstart', this.onTouchStart_, {
                passive: false,
            });
            element.addEventListener('touchmove', this.onTouchMove_, {
                passive: true,
            });
            element.addEventListener('touchend', this.onTouchEnd_);
            element.addEventListener('mousedown', this.onMouseDown_);
        }
        computePosition_(offset) {
            const rect = this.elem_.getBoundingClientRect();
            return {
                bounds: {
                    width: rect.width,
                    height: rect.height,
                },
                point: offset
                    ? {
                        x: offset.x,
                        y: offset.y,
                    }
                    : null,
            };
        }
        onMouseDown_(ev) {
            var _a;
            ev.preventDefault();
            (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
            const doc = this.elem_.ownerDocument;
            doc.addEventListener('mousemove', this.onDocumentMouseMove_);
            doc.addEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('down', {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
        onDocumentMouseMove_(ev) {
            this.emitter.emit('move', {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
        onDocumentMouseUp_(ev) {
            const doc = this.elem_.ownerDocument;
            doc.removeEventListener('mousemove', this.onDocumentMouseMove_);
            doc.removeEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('up', {
                altKey: ev.altKey,
                data: this.computePosition_(computeOffset$1(ev, this.elem_)),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
        onTouchStart_(ev) {
            ev.preventDefault();
            const touch = ev.targetTouches.item(0);
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('down', {
                altKey: ev.altKey,
                data: this.computePosition_(touch
                    ? {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top,
                    }
                    : undefined),
                sender: this,
                shiftKey: ev.shiftKey,
            });
            this.lastTouch_ = touch;
        }
        onTouchMove_(ev) {
            const touch = ev.targetTouches.item(0);
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('move', {
                altKey: ev.altKey,
                data: this.computePosition_(touch
                    ? {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top,
                    }
                    : undefined),
                sender: this,
                shiftKey: ev.shiftKey,
            });
            this.lastTouch_ = touch;
        }
        onTouchEnd_(ev) {
            var _a;
            const touch = (_a = ev.targetTouches.item(0)) !== null && _a !== void 0 ? _a : this.lastTouch_;
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('up', {
                altKey: ev.altKey,
                data: this.computePosition_(touch
                    ? {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top,
                    }
                    : undefined),
                sender: this,
                shiftKey: ev.shiftKey,
            });
        }
    }

    function mapRange(value, start1, end1, start2, end2) {
        const p = (value - start1) / (end1 - start1);
        return start2 + p * (end2 - start2);
    }
    function getDecimalDigits(value) {
        const text = String(value.toFixed(10));
        const frac = text.split('.')[1];
        return frac.replace(/0+$/, '').length;
    }
    function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
    function loopRange(value, max) {
        return ((value % max) + max) % max;
    }

    const className$g = ClassName('txt');
    class NumberTextView {
        constructor(doc, config) {
            this.onChange_ = this.onChange_.bind(this);
            this.props_ = config.props;
            this.props_.emitter.on('change', this.onChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$g(), className$g(undefined, 'num'));
            if (config.arrayPosition) {
                this.element.classList.add(className$g(undefined, config.arrayPosition));
            }
            config.viewProps.bindClassModifiers(this.element);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$g('i'));
            inputElem.type = 'text';
            config.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            this.onDraggingChange_ = this.onDraggingChange_.bind(this);
            this.dragging_ = config.dragging;
            this.dragging_.emitter.on('change', this.onDraggingChange_);
            this.element.classList.add(className$g());
            this.inputElement.classList.add(className$g('i'));
            const knobElem = doc.createElement('div');
            knobElem.classList.add(className$g('k'));
            this.element.appendChild(knobElem);
            this.knobElement = knobElem;
            const guideElem = doc.createElementNS(SVG_NS, 'svg');
            guideElem.classList.add(className$g('g'));
            this.knobElement.appendChild(guideElem);
            const bodyElem = doc.createElementNS(SVG_NS, 'path');
            bodyElem.classList.add(className$g('gb'));
            guideElem.appendChild(bodyElem);
            this.guideBodyElem_ = bodyElem;
            const headElem = doc.createElementNS(SVG_NS, 'path');
            headElem.classList.add(className$g('gh'));
            guideElem.appendChild(headElem);
            this.guideHeadElem_ = headElem;
            const tooltipElem = doc.createElement('div');
            tooltipElem.classList.add(ClassName('tt')());
            this.knobElement.appendChild(tooltipElem);
            this.tooltipElem_ = tooltipElem;
            config.value.emitter.on('change', this.onChange_);
            this.value = config.value;
            this.refresh();
        }
        onDraggingChange_(ev) {
            if (ev.rawValue === null) {
                this.element.classList.remove(className$g(undefined, 'drg'));
                return;
            }
            this.element.classList.add(className$g(undefined, 'drg'));
            const x = ev.rawValue / this.props_.get('draggingScale');
            const aox = x + (x > 0 ? -1 : x < 0 ? +1 : 0);
            const adx = constrainRange(-aox, -4, +4);
            this.guideHeadElem_.setAttributeNS(null, 'd', [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(' '));
            this.guideBodyElem_.setAttributeNS(null, 'd', `M 0,4 L${x},4`);
            const formatter = this.props_.get('formatter');
            this.tooltipElem_.textContent = formatter(this.value.rawValue);
            this.tooltipElem_.style.left = `${x}px`;
        }
        refresh() {
            const formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value.rawValue);
        }
        onChange_() {
            this.refresh();
        }
    }

    class NumberTextController {
        constructor(doc, config) {
            var _a;
            this.originRawValue_ = 0;
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
            this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.baseStep_ = config.baseStep;
            this.parser_ = config.parser;
            this.props = config.props;
            this.sliderProps_ = (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.dragging_ = createValue(null);
            this.view = new NumberTextView(doc, {
                arrayPosition: config.arrayPosition,
                dragging: this.dragging_,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.inputElement.addEventListener('change', this.onInputChange_);
            this.view.inputElement.addEventListener('keydown', this.onInputKeyDown_);
            this.view.inputElement.addEventListener('keyup', this.onInputKeyUp_);
            const ph = new PointerHandler(this.view.knobElement);
            ph.emitter.on('down', this.onPointerDown_);
            ph.emitter.on('move', this.onPointerMove_);
            ph.emitter.on('up', this.onPointerUp_);
        }
        constrainValue_(value) {
            var _a, _b;
            const min = (_a = this.sliderProps_) === null || _a === void 0 ? void 0 : _a.get('minValue');
            const max = (_b = this.sliderProps_) === null || _b === void 0 ? void 0 : _b.get('maxValue');
            let v = value;
            if (min !== undefined) {
                v = Math.max(v, min);
            }
            if (max !== undefined) {
                v = Math.min(v, max);
            }
            return v;
        }
        onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            const value = inputElem.value;
            const parsedValue = this.parser_(value);
            if (!isEmpty(parsedValue)) {
                this.value.rawValue = this.constrainValue_(parsedValue);
            }
            this.view.refresh();
        }
        onInputKeyDown_(ev) {
            const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
                forceEmit: false,
                last: false,
            });
        }
        onInputKeyUp_(ev) {
            const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
        onPointerDown_() {
            this.originRawValue_ = this.value.rawValue;
            this.dragging_.rawValue = 0;
        }
        computeDraggingValue_(data) {
            if (!data.point) {
                return null;
            }
            const dx = data.point.x - data.bounds.width / 2;
            return this.constrainValue_(this.originRawValue_ + dx * this.props.get('draggingScale'));
        }
        onPointerMove_(ev) {
            const v = this.computeDraggingValue_(ev.data);
            if (v === null) {
                return;
            }
            this.value.setRawValue(v, {
                forceEmit: false,
                last: false,
            });
            this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
        }
        onPointerUp_(ev) {
            const v = this.computeDraggingValue_(ev.data);
            if (v === null) {
                return;
            }
            this.value.setRawValue(v, {
                forceEmit: true,
                last: true,
            });
            this.dragging_.rawValue = null;
        }
    }

    const className$f = ClassName('sld');
    class SliderView {
        constructor(doc, config) {
            this.onChange_ = this.onChange_.bind(this);
            this.props_ = config.props;
            this.props_.emitter.on('change', this.onChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$f());
            config.viewProps.bindClassModifiers(this.element);
            const trackElem = doc.createElement('div');
            trackElem.classList.add(className$f('t'));
            config.viewProps.bindTabIndex(trackElem);
            this.element.appendChild(trackElem);
            this.trackElement = trackElem;
            const knobElem = doc.createElement('div');
            knobElem.classList.add(className$f('k'));
            this.trackElement.appendChild(knobElem);
            this.knobElement = knobElem;
            config.value.emitter.on('change', this.onChange_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            const p = constrainRange(mapRange(this.value.rawValue, this.props_.get('minValue'), this.props_.get('maxValue'), 0, 100), 0, 100);
            this.knobElement.style.width = `${p}%`;
        }
        onChange_() {
            this.update_();
        }
    }

    class SliderController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.baseStep_ = config.baseStep;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.props = config.props;
            this.view = new SliderView(doc, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.trackElement);
            this.ptHandler_.emitter.on('down', this.onPointerDownOrMove_);
            this.ptHandler_.emitter.on('move', this.onPointerDownOrMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.trackElement.addEventListener('keydown', this.onKeyDown_);
            this.view.trackElement.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            this.value.setRawValue(mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get('minValue'), this.props.get('maxValue')), opts);
        }
        onPointerDownOrMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue + step, {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    const className$e = ClassName('sldtxt');
    class SliderTextView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$e());
            const sliderElem = doc.createElement('div');
            sliderElem.classList.add(className$e('s'));
            this.sliderView_ = config.sliderView;
            sliderElem.appendChild(this.sliderView_.element);
            this.element.appendChild(sliderElem);
            const textElem = doc.createElement('div');
            textElem.classList.add(className$e('t'));
            this.textView_ = config.textView;
            textElem.appendChild(this.textView_.element);
            this.element.appendChild(textElem);
        }
    }

    class SliderTextController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.sliderC_ = new SliderController(doc, {
                baseStep: config.baseStep,
                props: config.sliderProps,
                value: config.value,
                viewProps: this.viewProps,
            });
            this.textC_ = new NumberTextController(doc, {
                baseStep: config.baseStep,
                parser: config.parser,
                props: config.textProps,
                sliderProps: config.sliderProps,
                value: config.value,
                viewProps: config.viewProps,
            });
            this.view = new SliderTextView(doc, {
                sliderView: this.sliderC_.view,
                textView: this.textC_.view,
            });
        }
        get sliderController() {
            return this.sliderC_;
        }
        get textController() {
            return this.textC_;
        }
    }

    function writePrimitive(target, value) {
        target.write(value);
    }

    function parseListOptions(value) {
        const p = ParamsParsers;
        if (Array.isArray(value)) {
            return p.required.array(p.required.object({
                text: p.required.string,
                value: p.required.raw,
            }))(value).value;
        }
        if (typeof value === 'object') {
            return p.required.raw(value)
                .value;
        }
        return undefined;
    }
    function parsePickerLayout(value) {
        if (value === 'inline' || value === 'popup') {
            return value;
        }
        return undefined;
    }
    function parsePointDimensionParams(value) {
        const p = ParamsParsers;
        return p.required.object({
            max: p.optional.number,
            min: p.optional.number,
            step: p.optional.number,
        })(value).value;
    }
    function normalizeListOptions(options) {
        if (Array.isArray(options)) {
            return options;
        }
        const items = [];
        Object.keys(options).forEach((text) => {
            items.push({ text: text, value: options[text] });
        });
        return items;
    }
    function createListConstraint(options) {
        return !isEmpty(options)
            ? new ListConstraint(normalizeListOptions(forceCast(options)))
            : null;
    }
    function findListItems(constraint) {
        const c = constraint
            ? findConstraint(constraint, ListConstraint)
            : null;
        if (!c) {
            return null;
        }
        return c.options;
    }
    function findStep(constraint) {
        const c = constraint ? findConstraint(constraint, StepConstraint) : null;
        if (!c) {
            return null;
        }
        return c.step;
    }
    function getSuitableDecimalDigits(constraint, rawValue) {
        const sc = constraint && findConstraint(constraint, StepConstraint);
        if (sc) {
            return getDecimalDigits(sc.step);
        }
        return Math.max(getDecimalDigits(rawValue), 2);
    }
    function getBaseStep(constraint) {
        const step = findStep(constraint);
        return step !== null && step !== void 0 ? step : 1;
    }
    function getSuitableDraggingScale(constraint, rawValue) {
        var _a;
        const sc = constraint && findConstraint(constraint, StepConstraint);
        const base = Math.abs((_a = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a !== void 0 ? _a : rawValue);
        return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
    }

    const className$d = ClassName('ckb');
    class CheckboxView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.element = doc.createElement('div');
            this.element.classList.add(className$d());
            config.viewProps.bindClassModifiers(this.element);
            const labelElem = doc.createElement('label');
            labelElem.classList.add(className$d('l'));
            this.element.appendChild(labelElem);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$d('i'));
            inputElem.type = 'checkbox';
            labelElem.appendChild(inputElem);
            this.inputElement = inputElem;
            config.viewProps.bindDisabled(this.inputElement);
            const wrapperElem = doc.createElement('div');
            wrapperElem.classList.add(className$d('w'));
            labelElem.appendChild(wrapperElem);
            const markElem = createSvgIconElement(doc, 'check');
            wrapperElem.appendChild(markElem);
            config.value.emitter.on('change', this.onValueChange_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            this.inputElement.checked = this.value.rawValue;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class CheckboxController {
        constructor(doc, config) {
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new CheckboxView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view.inputElement.addEventListener('change', this.onInputChange_);
        }
        onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            this.value.rawValue = inputElem.checked;
        }
    }

    function createConstraint$6(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
            constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
    }
    const BooleanInputPlugin = {
        id: 'input-bool',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'boolean') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                options: p.optional.custom(parseListOptions),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => boolFromUnknown,
            constraint: (args) => createConstraint$6(args.params),
            writer: (_args) => writePrimitive,
        },
        controller: (args) => {
            var _a;
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            if (c && findConstraint(c, ListConstraint)) {
                return new ListController(doc, {
                    props: ValueMap.fromObject({
                        options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : [],
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new CheckboxController(doc, {
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    const className$c = ClassName('col');
    class ColorView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$c());
            config.foldable.bindExpandedClass(this.element, className$c(undefined, 'expanded'));
            bindValueMap(config.foldable, 'completed', valueToClassName(this.element, className$c(undefined, 'cpl')));
            const headElem = doc.createElement('div');
            headElem.classList.add(className$c('h'));
            this.element.appendChild(headElem);
            const swatchElem = doc.createElement('div');
            swatchElem.classList.add(className$c('s'));
            headElem.appendChild(swatchElem);
            this.swatchElement = swatchElem;
            const textElem = doc.createElement('div');
            textElem.classList.add(className$c('t'));
            headElem.appendChild(textElem);
            this.textElement = textElem;
            if (config.pickerLayout === 'inline') {
                const pickerElem = doc.createElement('div');
                pickerElem.classList.add(className$c('p'));
                this.element.appendChild(pickerElem);
                this.pickerElement = pickerElem;
            }
            else {
                this.pickerElement = null;
            }
        }
    }

    function rgbToHslInt(r, g, b) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g / 255, 0, 1);
        const bp = constrainRange(b / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const c = cmax - cmin;
        let h = 0;
        let s = 0;
        const l = (cmin + cmax) / 2;
        if (c !== 0) {
            s = c / (1 - Math.abs(cmax + cmin - 1));
            if (rp === cmax) {
                h = (gp - bp) / c;
            }
            else if (gp === cmax) {
                h = 2 + (bp - rp) / c;
            }
            else {
                h = 4 + (rp - gp) / c;
            }
            h = h / 6 + (h < 0 ? 1 : 0);
        }
        return [h * 360, s * 100, l * 100];
    }
    function hslToRgbInt(h, s, l) {
        const hp = ((h % 360) + 360) % 360;
        const sp = constrainRange(s / 100, 0, 1);
        const lp = constrainRange(l / 100, 0, 1);
        const c = (1 - Math.abs(2 * lp - 1)) * sp;
        const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
        const m = lp - c / 2;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
            [rp, gp, bp] = [c, x, 0];
        }
        else if (hp >= 60 && hp < 120) {
            [rp, gp, bp] = [x, c, 0];
        }
        else if (hp >= 120 && hp < 180) {
            [rp, gp, bp] = [0, c, x];
        }
        else if (hp >= 180 && hp < 240) {
            [rp, gp, bp] = [0, x, c];
        }
        else if (hp >= 240 && hp < 300) {
            [rp, gp, bp] = [x, 0, c];
        }
        else {
            [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
    }
    function rgbToHsvInt(r, g, b) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g / 255, 0, 1);
        const bp = constrainRange(b / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const d = cmax - cmin;
        let h;
        if (d === 0) {
            h = 0;
        }
        else if (cmax === rp) {
            h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
        }
        else if (cmax === gp) {
            h = 60 * ((bp - rp) / d + 2);
        }
        else {
            h = 60 * ((rp - gp) / d + 4);
        }
        const s = cmax === 0 ? 0 : d / cmax;
        const v = cmax;
        return [h, s * 100, v * 100];
    }
    function hsvToRgbInt(h, s, v) {
        const hp = loopRange(h, 360);
        const sp = constrainRange(s / 100, 0, 1);
        const vp = constrainRange(v / 100, 0, 1);
        const c = vp * sp;
        const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
        const m = vp - c;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
            [rp, gp, bp] = [c, x, 0];
        }
        else if (hp >= 60 && hp < 120) {
            [rp, gp, bp] = [x, c, 0];
        }
        else if (hp >= 120 && hp < 180) {
            [rp, gp, bp] = [0, c, x];
        }
        else if (hp >= 180 && hp < 240) {
            [rp, gp, bp] = [0, x, c];
        }
        else if (hp >= 240 && hp < 300) {
            [rp, gp, bp] = [x, 0, c];
        }
        else {
            [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
    }
    function hslToHsvInt(h, s, l) {
        const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
        return [
            h,
            sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
            l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
        ];
    }
    function hsvToHslInt(h, s, v) {
        const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
        return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
    }
    function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
    }
    function appendAlphaComponent(comps, alpha) {
        return [comps[0], comps[1], comps[2], alpha];
    }
    const MODE_CONVERTER_MAP = {
        hsl: {
            hsl: (h, s, l) => [h, s, l],
            hsv: hslToHsvInt,
            rgb: hslToRgbInt,
        },
        hsv: {
            hsl: hsvToHslInt,
            hsv: (h, s, v) => [h, s, v],
            rgb: hsvToRgbInt,
        },
        rgb: {
            hsl: rgbToHslInt,
            hsv: rgbToHsvInt,
            rgb: (r, g, b) => [r, g, b],
        },
    };
    function getColorMaxComponents(mode, type) {
        return [
            type === 'float' ? 1 : mode === 'rgb' ? 255 : 360,
            type === 'float' ? 1 : mode === 'rgb' ? 255 : 100,
            type === 'float' ? 1 : mode === 'rgb' ? 255 : 100,
        ];
    }
    function constrainColorComponents(components, mode, type) {
        var _a;
        const ms = getColorMaxComponents(mode, type);
        return [
            mode === 'rgb'
                ? constrainRange(components[0], 0, ms[0])
                : loopRange(components[0], ms[0]),
            constrainRange(components[1], 0, ms[1]),
            constrainRange(components[2], 0, ms[2]),
            constrainRange((_a = components[3]) !== null && _a !== void 0 ? _a : 1, 0, 1),
        ];
    }
    function convertColorType(comps, mode, from, to) {
        const fms = getColorMaxComponents(mode, from);
        const tms = getColorMaxComponents(mode, to);
        return comps.map((c, index) => (c / fms[index]) * tms[index]);
    }
    function convertColor(components, from, to) {
        const intComps = convertColorType(components, from.mode, from.type, 'int');
        const result = MODE_CONVERTER_MAP[from.mode][to.mode](...intComps);
        return convertColorType(result, to.mode, 'int', to.type);
    }

    function isRgbColorComponent(obj, key) {
        if (typeof obj !== 'object' || isEmpty(obj)) {
            return false;
        }
        return key in obj && typeof obj[key] === 'number';
    }
    class Color {
        constructor(comps, mode, type = 'int') {
            this.mode = mode;
            this.type = type;
            this.comps_ = constrainColorComponents(comps, mode, type);
        }
        static black(type = 'int') {
            return new Color([0, 0, 0], 'rgb', type);
        }
        static fromObject(obj, type = 'int') {
            const comps = 'a' in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
            return new Color(comps, 'rgb', type);
        }
        static toRgbaObject(color, type = 'int') {
            return color.toRgbaObject(type);
        }
        static isRgbColorObject(obj) {
            return (isRgbColorComponent(obj, 'r') &&
                isRgbColorComponent(obj, 'g') &&
                isRgbColorComponent(obj, 'b'));
        }
        static isRgbaColorObject(obj) {
            return this.isRgbColorObject(obj) && isRgbColorComponent(obj, 'a');
        }
        static isColorObject(obj) {
            return this.isRgbColorObject(obj);
        }
        static equals(v1, v2) {
            if (v1.mode !== v2.mode) {
                return false;
            }
            const comps1 = v1.comps_;
            const comps2 = v2.comps_;
            for (let i = 0; i < comps1.length; i++) {
                if (comps1[i] !== comps2[i]) {
                    return false;
                }
            }
            return true;
        }
        getComponents(opt_mode, type = 'int') {
            return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type }), this.comps_[3]);
        }
        toRgbaObject(type = 'int') {
            const rgbComps = this.getComponents('rgb', type);
            return {
                r: rgbComps[0],
                g: rgbComps[1],
                b: rgbComps[2],
                a: rgbComps[3],
            };
        }
    }

    const className$b = ClassName('colp');
    class ColorPickerView {
        constructor(doc, config) {
            this.alphaViews_ = null;
            this.element = doc.createElement('div');
            this.element.classList.add(className$b());
            const hsvElem = doc.createElement('div');
            hsvElem.classList.add(className$b('hsv'));
            const svElem = doc.createElement('div');
            svElem.classList.add(className$b('sv'));
            this.svPaletteView_ = config.svPaletteView;
            svElem.appendChild(this.svPaletteView_.element);
            hsvElem.appendChild(svElem);
            const hElem = doc.createElement('div');
            hElem.classList.add(className$b('h'));
            this.hPaletteView_ = config.hPaletteView;
            hElem.appendChild(this.hPaletteView_.element);
            hsvElem.appendChild(hElem);
            this.element.appendChild(hsvElem);
            const rgbElem = doc.createElement('div');
            rgbElem.classList.add(className$b('rgb'));
            this.textView_ = config.textView;
            rgbElem.appendChild(this.textView_.element);
            this.element.appendChild(rgbElem);
            if (config.alphaViews) {
                this.alphaViews_ = {
                    palette: config.alphaViews.palette,
                    text: config.alphaViews.text,
                };
                const aElem = doc.createElement('div');
                aElem.classList.add(className$b('a'));
                const apElem = doc.createElement('div');
                apElem.classList.add(className$b('ap'));
                apElem.appendChild(this.alphaViews_.palette.element);
                aElem.appendChild(apElem);
                const atElem = doc.createElement('div');
                atElem.classList.add(className$b('at'));
                atElem.appendChild(this.alphaViews_.text.element);
                aElem.appendChild(atElem);
                this.element.appendChild(aElem);
            }
        }
        get allFocusableElements() {
            const elems = [
                this.svPaletteView_.element,
                this.hPaletteView_.element,
                this.textView_.modeSelectElement,
                ...this.textView_.textViews.map((v) => v.inputElement),
            ];
            if (this.alphaViews_) {
                elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
            }
            return elems;
        }
    }

    function parseColorType(value) {
        return value === 'int' ? 'int' : value === 'float' ? 'float' : undefined;
    }
    function parseColorInputParams(params) {
        const p = ParamsParsers;
        return parseParams(params, {
            alpha: p.optional.boolean,
            color: p.optional.object({
                alpha: p.optional.boolean,
                type: p.optional.custom(parseColorType),
            }),
            expanded: p.optional.boolean,
            picker: p.optional.custom(parsePickerLayout),
        });
    }
    function getBaseStepForColor(forAlpha) {
        return forAlpha ? 0.1 : 1;
    }
    function extractColorType(params) {
        var _a;
        return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
    }

    function equalsStringColorFormat(f1, f2) {
        return (f1.alpha === f2.alpha &&
            f1.mode === f2.mode &&
            f1.notation === f2.notation &&
            f1.type === f2.type);
    }
    function parseCssNumberOrPercentage(text, maxValue) {
        const m = text.match(/^(.+)%$/);
        if (!m) {
            return Math.min(parseFloat(text), maxValue);
        }
        return Math.min(parseFloat(m[1]) * 0.01 * maxValue, maxValue);
    }
    const ANGLE_TO_DEG_MAP = {
        deg: (angle) => angle,
        grad: (angle) => (angle * 360) / 400,
        rad: (angle) => (angle * 360) / (2 * Math.PI),
        turn: (angle) => angle * 360,
    };
    function parseCssNumberOrAngle(text) {
        const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
        if (!m) {
            return parseFloat(text);
        }
        const angle = parseFloat(m[1]);
        const unit = m[2];
        return ANGLE_TO_DEG_MAP[unit](angle);
    }
    function parseFunctionalRgbColorComponents(text) {
        const m = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrPercentage(m[1], 255),
            parseCssNumberOrPercentage(m[2], 255),
            parseCssNumberOrPercentage(m[3], 255),
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
            return null;
        }
        return comps;
    }
    function createFunctionalRgbColorParser(type) {
        return (text) => {
            const comps = parseFunctionalRgbColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    function parseFunctionalRgbaColorComponents(text) {
        const m = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrPercentage(m[1], 255),
            parseCssNumberOrPercentage(m[2], 255),
            parseCssNumberOrPercentage(m[3], 255),
            parseCssNumberOrPercentage(m[4], 1),
        ];
        if (isNaN(comps[0]) ||
            isNaN(comps[1]) ||
            isNaN(comps[2]) ||
            isNaN(comps[3])) {
            return null;
        }
        return comps;
    }
    function createFunctionalRgbaColorParser(type) {
        return (text) => {
            const comps = parseFunctionalRgbaColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    function parseHslColorComponents(text) {
        const m = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrAngle(m[1]),
            parseCssNumberOrPercentage(m[2], 100),
            parseCssNumberOrPercentage(m[3], 100),
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
            return null;
        }
        return comps;
    }
    function createHslColorParser(type) {
        return (text) => {
            const comps = parseHslColorComponents(text);
            return comps ? new Color(comps, 'hsl', type) : null;
        };
    }
    function parseHslaColorComponents(text) {
        const m = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseCssNumberOrAngle(m[1]),
            parseCssNumberOrPercentage(m[2], 100),
            parseCssNumberOrPercentage(m[3], 100),
            parseCssNumberOrPercentage(m[4], 1),
        ];
        if (isNaN(comps[0]) ||
            isNaN(comps[1]) ||
            isNaN(comps[2]) ||
            isNaN(comps[3])) {
            return null;
        }
        return comps;
    }
    function createHslaColorParser(type) {
        return (text) => {
            const comps = parseHslaColorComponents(text);
            return comps ? new Color(comps, 'hsl', type) : null;
        };
    }
    function parseHexRgbColorComponents(text) {
        const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
            return [
                parseInt(mRgb[1] + mRgb[1], 16),
                parseInt(mRgb[2] + mRgb[2], 16),
                parseInt(mRgb[3] + mRgb[3], 16),
            ];
        }
        const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
            return [
                parseInt(mRrggbb[1], 16),
                parseInt(mRrggbb[2], 16),
                parseInt(mRrggbb[3], 16),
            ];
        }
        return null;
    }
    function parseHexRgbColor(text) {
        const comps = parseHexRgbColorComponents(text);
        return comps ? new Color(comps, 'rgb', 'int') : null;
    }
    function parseHexRgbaColorComponents(text) {
        const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
            return [
                parseInt(mRgb[1] + mRgb[1], 16),
                parseInt(mRgb[2] + mRgb[2], 16),
                parseInt(mRgb[3] + mRgb[3], 16),
                mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
            ];
        }
        const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
            return [
                parseInt(mRrggbb[1], 16),
                parseInt(mRrggbb[2], 16),
                parseInt(mRrggbb[3], 16),
                mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
            ];
        }
        return null;
    }
    function parseHexRgbaColor(text) {
        const comps = parseHexRgbaColorComponents(text);
        return comps ? new Color(comps, 'rgb', 'int') : null;
    }
    function parseObjectRgbColorComponents(text) {
        const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseFloat(m[1]),
            parseFloat(m[2]),
            parseFloat(m[3]),
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
            return null;
        }
        return comps;
    }
    function createObjectRgbColorParser(type) {
        return (text) => {
            const comps = parseObjectRgbColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    function parseObjectRgbaColorComponents(text) {
        const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m) {
            return null;
        }
        const comps = [
            parseFloat(m[1]),
            parseFloat(m[2]),
            parseFloat(m[3]),
            parseFloat(m[4]),
        ];
        if (isNaN(comps[0]) ||
            isNaN(comps[1]) ||
            isNaN(comps[2]) ||
            isNaN(comps[3])) {
            return null;
        }
        return comps;
    }
    function createObjectRgbaColorParser(type) {
        return (text) => {
            const comps = parseObjectRgbaColorComponents(text);
            return comps ? new Color(comps, 'rgb', type) : null;
        };
    }
    const PARSER_AND_RESULT = [
        {
            parser: parseHexRgbColorComponents,
            result: {
                alpha: false,
                mode: 'rgb',
                notation: 'hex',
            },
        },
        {
            parser: parseHexRgbaColorComponents,
            result: {
                alpha: true,
                mode: 'rgb',
                notation: 'hex',
            },
        },
        {
            parser: parseFunctionalRgbColorComponents,
            result: {
                alpha: false,
                mode: 'rgb',
                notation: 'func',
            },
        },
        {
            parser: parseFunctionalRgbaColorComponents,
            result: {
                alpha: true,
                mode: 'rgb',
                notation: 'func',
            },
        },
        {
            parser: parseHslColorComponents,
            result: {
                alpha: false,
                mode: 'hsl',
                notation: 'func',
            },
        },
        {
            parser: parseHslaColorComponents,
            result: {
                alpha: true,
                mode: 'hsl',
                notation: 'func',
            },
        },
        {
            parser: parseObjectRgbColorComponents,
            result: {
                alpha: false,
                mode: 'rgb',
                notation: 'object',
            },
        },
        {
            parser: parseObjectRgbaColorComponents,
            result: {
                alpha: true,
                mode: 'rgb',
                notation: 'object',
            },
        },
    ];
    function detectStringColor(text) {
        return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
            if (prev) {
                return prev;
            }
            return parser(text) ? detection : null;
        }, null);
    }
    function detectStringColorFormat(text, type = 'int') {
        const r = detectStringColor(text);
        if (!r) {
            return null;
        }
        if (r.notation === 'hex' && type !== 'float') {
            return Object.assign(Object.assign({}, r), { type: 'int' });
        }
        if (r.notation === 'func') {
            return Object.assign(Object.assign({}, r), { type: type });
        }
        return null;
    }
    const TYPE_TO_PARSERS = {
        int: [
            parseHexRgbColor,
            parseHexRgbaColor,
            createFunctionalRgbColorParser('int'),
            createFunctionalRgbaColorParser('int'),
            createHslColorParser('int'),
            createHslaColorParser('int'),
            createObjectRgbColorParser('int'),
            createObjectRgbaColorParser('int'),
        ],
        float: [
            createFunctionalRgbColorParser('float'),
            createFunctionalRgbaColorParser('float'),
            createHslColorParser('float'),
            createHslaColorParser('float'),
            createObjectRgbColorParser('float'),
            createObjectRgbaColorParser('float'),
        ],
    };
    function createColorStringBindingReader(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
            if (typeof value !== 'string') {
                return Color.black(type);
            }
            const result = parsers.reduce((prev, parser) => {
                if (prev) {
                    return prev;
                }
                return parser(value);
            }, null);
            return result !== null && result !== void 0 ? result : Color.black(type);
        };
    }
    function createColorStringParser(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
            return parsers.reduce((prev, parser) => {
                if (prev) {
                    return prev;
                }
                return parser(value);
            }, null);
        };
    }
    function zerofill(comp) {
        const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
    }
    function colorToHexRgbString(value, prefix = '#') {
        const hexes = removeAlphaComponent(value.getComponents('rgb'))
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToHexRgbaString(value, prefix = '#') {
        const rgbaComps = value.getComponents('rgb');
        const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToFunctionalRgbString(value, opt_type) {
        const formatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = removeAlphaComponent(value.getComponents('rgb', opt_type)).map((comp) => formatter(comp));
        return `rgb(${comps.join(', ')})`;
    }
    function createFunctionalRgbColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbString(value, type);
        };
    }
    function colorToFunctionalRgbaString(value, opt_type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = value.getComponents('rgb', opt_type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return formatter(comp);
        });
        return `rgba(${comps.join(', ')})`;
    }
    function createFunctionalRgbaColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbaString(value, type);
        };
    }
    function colorToFunctionalHslString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
        ];
        const comps = removeAlphaComponent(value.getComponents('hsl')).map((comp, index) => formatters[index](comp));
        return `hsl(${comps.join(', ')})`;
    }
    function colorToFunctionalHslaString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
            createNumberFormatter(2),
        ];
        const comps = value
            .getComponents('hsl')
            .map((comp, index) => formatters[index](comp));
        return `hsla(${comps.join(', ')})`;
    }
    function colorToObjectRgbString(value, type) {
        const formatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b'];
        const comps = removeAlphaComponent(value.getComponents('rgb', type)).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbColorFormatter(type) {
        return (value) => colorToObjectRgbString(value, type);
    }
    function colorToObjectRgbaString(value, type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b', 'a'];
        const comps = value.getComponents('rgb', type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return `${names[index]}: ${formatter(comp)}`;
        });
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbaColorFormatter(type) {
        return (value) => colorToObjectRgbaString(value, type);
    }
    const FORMAT_AND_STRINGIFIERS = [
        {
            format: {
                alpha: false,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbString,
        },
        {
            format: {
                alpha: true,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbaString,
        },
        {
            format: {
                alpha: false,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslString,
        },
        {
            format: {
                alpha: true,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslaString,
        },
        ...['int', 'float'].reduce((prev, type) => {
            return [
                ...prev,
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbaColorFormatter(type),
                },
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbaColorFormatter(type),
                },
            ];
        }, []),
    ];
    function findColorStringifier(format) {
        return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
            if (prev) {
                return prev;
            }
            return equalsStringColorFormat(fas.format, format)
                ? fas.stringifier
                : null;
        }, null);
    }

    const className$a = ClassName('apl');
    class APaletteView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$a());
            config.viewProps.bindTabIndex(this.element);
            const barElem = doc.createElement('div');
            barElem.classList.add(className$a('b'));
            this.element.appendChild(barElem);
            const colorElem = doc.createElement('div');
            colorElem.classList.add(className$a('c'));
            barElem.appendChild(colorElem);
            this.colorElem_ = colorElem;
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$a('m'));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            const previewElem = doc.createElement('div');
            previewElem.classList.add(className$a('p'));
            this.markerElem_.appendChild(previewElem);
            this.previewElem_ = previewElem;
            this.update_();
        }
        update_() {
            const c = this.value.rawValue;
            const rgbaComps = c.getComponents('rgb');
            const leftColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], 'rgb');
            const rightColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], 'rgb');
            const gradientComps = [
                'to right',
                colorToFunctionalRgbaString(leftColor),
                colorToFunctionalRgbaString(rightColor),
            ];
            this.colorElem_.style.background = `linear-gradient(${gradientComps.join(',')})`;
            this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
            const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
            this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class APaletteController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new APaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.element.addEventListener('keydown', this.onKeyDown_);
            this.view.element.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const alpha = d.point.x / d.bounds.width;
            const c = this.value.rawValue;
            const [h, s, v] = c.getComponents('hsv');
            this.value.setRawValue(new Color([h, s, v, alpha], 'hsv'), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            const c = this.value.rawValue;
            const [h, s, v, a] = c.getComponents('hsv');
            this.value.setRawValue(new Color([h, s, v, a + step], 'hsv'), {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    const className$9 = ClassName('coltxt');
    function createModeSelectElement(doc) {
        const selectElem = doc.createElement('select');
        const items = [
            { text: 'RGB', value: 'rgb' },
            { text: 'HSL', value: 'hsl' },
            { text: 'HSV', value: 'hsv' },
        ];
        selectElem.appendChild(items.reduce((frag, item) => {
            const optElem = doc.createElement('option');
            optElem.textContent = item.text;
            optElem.value = item.value;
            frag.appendChild(optElem);
            return frag;
        }, doc.createDocumentFragment()));
        return selectElem;
    }
    class ColorTextView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$9());
            const modeElem = doc.createElement('div');
            modeElem.classList.add(className$9('m'));
            this.modeElem_ = createModeSelectElement(doc);
            this.modeElem_.classList.add(className$9('ms'));
            modeElem.appendChild(this.modeSelectElement);
            const modeMarkerElem = doc.createElement('div');
            modeMarkerElem.classList.add(className$9('mm'));
            modeMarkerElem.appendChild(createSvgIconElement(doc, 'dropdown'));
            modeElem.appendChild(modeMarkerElem);
            this.element.appendChild(modeElem);
            const textsElem = doc.createElement('div');
            textsElem.classList.add(className$9('w'));
            this.element.appendChild(textsElem);
            this.textsElem_ = textsElem;
            this.textViews_ = config.textViews;
            this.applyTextViews_();
            bindValue(config.colorMode, (mode) => {
                this.modeElem_.value = mode;
            });
        }
        get modeSelectElement() {
            return this.modeElem_;
        }
        get textViews() {
            return this.textViews_;
        }
        set textViews(textViews) {
            this.textViews_ = textViews;
            this.applyTextViews_();
        }
        applyTextViews_() {
            removeChildElements(this.textsElem_);
            const doc = this.element.ownerDocument;
            this.textViews_.forEach((v) => {
                const compElem = doc.createElement('div');
                compElem.classList.add(className$9('c'));
                compElem.appendChild(v.element);
                this.textsElem_.appendChild(compElem);
            });
        }
    }

    function createFormatter$2(type) {
        return createNumberFormatter(type === 'float' ? 2 : 0);
    }
    function createConstraint$5(mode, type, index) {
        const max = getColorMaxComponents(mode, type)[index];
        return new RangeConstraint({
            min: 0,
            max: max,
        });
    }
    function createComponentController(doc, config, index) {
        return new NumberTextController(doc, {
            arrayPosition: index === 0 ? 'fst' : index === 3 - 1 ? 'lst' : 'mid',
            baseStep: getBaseStepForColor(false),
            parser: config.parser,
            props: ValueMap.fromObject({
                draggingScale: config.colorType === 'float' ? 0.01 : 1,
                formatter: createFormatter$2(config.colorType),
            }),
            value: createValue(0, {
                constraint: createConstraint$5(config.colorMode, config.colorType, index),
            }),
            viewProps: config.viewProps,
        });
    }
    class ColorTextController {
        constructor(doc, config) {
            this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
            this.colorType_ = config.colorType;
            this.parser_ = config.parser;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.colorMode = createValue(this.value.rawValue.mode);
            this.ccs_ = this.createComponentControllers_(doc);
            this.view = new ColorTextView(doc, {
                colorMode: this.colorMode,
                textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
            });
            this.view.modeSelectElement.addEventListener('change', this.onModeSelectChange_);
        }
        createComponentControllers_(doc) {
            const cc = {
                colorMode: this.colorMode.rawValue,
                colorType: this.colorType_,
                parser: this.parser_,
                viewProps: this.viewProps,
            };
            const ccs = [
                createComponentController(doc, cc, 0),
                createComponentController(doc, cc, 1),
                createComponentController(doc, cc, 2),
            ];
            ccs.forEach((cs, index) => {
                connectValues({
                    primary: this.value,
                    secondary: cs.value,
                    forward: (p) => {
                        return p.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[index];
                    },
                    backward: (p, s) => {
                        const pickedMode = this.colorMode.rawValue;
                        const comps = p.rawValue.getComponents(pickedMode, this.colorType_);
                        comps[index] = s.rawValue;
                        return new Color(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, this.colorType_);
                    },
                });
            });
            return ccs;
        }
        onModeSelectChange_(ev) {
            const selectElem = ev.currentTarget;
            this.colorMode.rawValue = selectElem.value;
            this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
            this.view.textViews = [
                this.ccs_[0].view,
                this.ccs_[1].view,
                this.ccs_[2].view,
            ];
        }
    }

    const className$8 = ClassName('hpl');
    class HPaletteView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$8());
            config.viewProps.bindTabIndex(this.element);
            const colorElem = doc.createElement('div');
            colorElem.classList.add(className$8('c'));
            this.element.appendChild(colorElem);
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$8('m'));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            this.update_();
        }
        update_() {
            const c = this.value.rawValue;
            const [h] = c.getComponents('hsv');
            this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color([h, 100, 100], 'hsv'));
            const left = mapRange(h, 0, 360, 0, 100);
            this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class HPaletteController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new HPaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.element.addEventListener('keydown', this.onKeyDown_);
            this.view.element.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const hue = mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, 0, 359);
            const c = this.value.rawValue;
            const [, s, v, a] = c.getComponents('hsv');
            this.value.setRawValue(new Color([hue, s, v, a], 'hsv'), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            const c = this.value.rawValue;
            const [h, s, v, a] = c.getComponents('hsv');
            this.value.setRawValue(new Color([h + step, s, v, a], 'hsv'), {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
            if (step === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    const className$7 = ClassName('svp');
    const CANVAS_RESOL = 64;
    class SvPaletteView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.element = doc.createElement('div');
            this.element.classList.add(className$7());
            config.viewProps.bindTabIndex(this.element);
            const canvasElem = doc.createElement('canvas');
            canvasElem.height = CANVAS_RESOL;
            canvasElem.width = CANVAS_RESOL;
            canvasElem.classList.add(className$7('c'));
            this.element.appendChild(canvasElem);
            this.canvasElement = canvasElem;
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$7('m'));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            this.update_();
        }
        update_() {
            const ctx = getCanvasContext(this.canvasElement);
            if (!ctx) {
                return;
            }
            const c = this.value.rawValue;
            const hsvComps = c.getComponents('hsv');
            const width = this.canvasElement.width;
            const height = this.canvasElement.height;
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            for (let iy = 0; iy < height; iy++) {
                for (let ix = 0; ix < width; ix++) {
                    const s = mapRange(ix, 0, width, 0, 100);
                    const v = mapRange(iy, 0, height, 100, 0);
                    const rgbComps = hsvToRgbInt(hsvComps[0], s, v);
                    const i = (iy * width + ix) * 4;
                    data[i] = rgbComps[0];
                    data[i + 1] = rgbComps[1];
                    data[i + 2] = rgbComps[2];
                    data[i + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
            const left = mapRange(hsvComps[1], 0, 100, 0, 100);
            this.markerElem_.style.left = `${left}%`;
            const top = mapRange(hsvComps[2], 0, 100, 100, 0);
            this.markerElem_.style.top = `${top}%`;
        }
        onValueChange_() {
            this.update_();
        }
    }

    class SvPaletteController {
        constructor(doc, config) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new SvPaletteView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.element.addEventListener('keydown', this.onKeyDown_);
            this.view.element.addEventListener('keyup', this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);
            const value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);
            const [h, , , a] = this.value.rawValue.getComponents('hsv');
            this.value.setRawValue(new Color([h, saturation, value, a], 'hsv'), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
                ev.preventDefault();
            }
            const [h, s, v, a] = this.value.rawValue.getComponents('hsv');
            const baseStep = getBaseStepForColor(false);
            const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
            if (ds === 0 && dv === 0) {
                return;
            }
            this.value.setRawValue(new Color([h, s + ds, v + dv, a], 'hsv'), {
                forceEmit: false,
                last: false,
            });
        }
        onKeyUp_(ev) {
            const baseStep = getBaseStepForColor(false);
            const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
            if (ds === 0 && dv === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    class ColorPickerController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.hPaletteC_ = new HPaletteController(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.svPaletteC_ = new SvPaletteController(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            this.alphaIcs_ = config.supportsAlpha
                ? {
                    palette: new APaletteController(doc, {
                        value: this.value,
                        viewProps: this.viewProps,
                    }),
                    text: new NumberTextController(doc, {
                        parser: parseNumber,
                        baseStep: 0.1,
                        props: ValueMap.fromObject({
                            draggingScale: 0.01,
                            formatter: createNumberFormatter(2),
                        }),
                        value: createValue(0, {
                            constraint: new RangeConstraint({ min: 0, max: 1 }),
                        }),
                        viewProps: this.viewProps,
                    }),
                }
                : null;
            if (this.alphaIcs_) {
                connectValues({
                    primary: this.value,
                    secondary: this.alphaIcs_.text.value,
                    forward: (p) => {
                        return p.rawValue.getComponents()[3];
                    },
                    backward: (p, s) => {
                        const comps = p.rawValue.getComponents();
                        comps[3] = s.rawValue;
                        return new Color(comps, p.rawValue.mode);
                    },
                });
            }
            this.textC_ = new ColorTextController(doc, {
                colorType: config.colorType,
                parser: parseNumber,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view = new ColorPickerView(doc, {
                alphaViews: this.alphaIcs_
                    ? {
                        palette: this.alphaIcs_.palette.view,
                        text: this.alphaIcs_.text.view,
                    }
                    : null,
                hPaletteView: this.hPaletteC_.view,
                supportsAlpha: config.supportsAlpha,
                svPaletteView: this.svPaletteC_.view,
                textView: this.textC_.view,
            });
        }
        get textController() {
            return this.textC_;
        }
    }

    const className$6 = ClassName('colsw');
    class ColorSwatchView {
        constructor(doc, config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            config.value.emitter.on('change', this.onValueChange_);
            this.value = config.value;
            this.element = doc.createElement('div');
            this.element.classList.add(className$6());
            config.viewProps.bindClassModifiers(this.element);
            const swatchElem = doc.createElement('div');
            swatchElem.classList.add(className$6('sw'));
            this.element.appendChild(swatchElem);
            this.swatchElem_ = swatchElem;
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$6('b'));
            config.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            this.update_();
        }
        update_() {
            const value = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
        }
        onValueChange_() {
            this.update_();
        }
    }

    class ColorSwatchController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new ColorSwatchView(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
        }
    }

    class ColorController {
        constructor(doc, config) {
            this.onButtonBlur_ = this.onButtonBlur_.bind(this);
            this.onButtonClick_ = this.onButtonClick_.bind(this);
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
            this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.foldable_ = Foldable.create(config.expanded);
            this.swatchC_ = new ColorSwatchController(doc, {
                value: this.value,
                viewProps: this.viewProps,
            });
            const buttonElem = this.swatchC_.view.buttonElement;
            buttonElem.addEventListener('blur', this.onButtonBlur_);
            buttonElem.addEventListener('click', this.onButtonClick_);
            this.textC_ = new TextController(doc, {
                parser: config.parser,
                props: ValueMap.fromObject({
                    formatter: config.formatter,
                }),
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view = new ColorView(doc, {
                foldable: this.foldable_,
                pickerLayout: config.pickerLayout,
            });
            this.view.swatchElement.appendChild(this.swatchC_.view.element);
            this.view.textElement.appendChild(this.textC_.view.element);
            this.popC_ =
                config.pickerLayout === 'popup'
                    ? new PopupController(doc, {
                        viewProps: this.viewProps,
                    })
                    : null;
            const pickerC = new ColorPickerController(doc, {
                colorType: config.colorType,
                supportsAlpha: config.supportsAlpha,
                value: this.value,
                viewProps: this.viewProps,
            });
            pickerC.view.allFocusableElements.forEach((elem) => {
                elem.addEventListener('blur', this.onPopupChildBlur_);
                elem.addEventListener('keydown', this.onPopupChildKeydown_);
            });
            this.pickerC_ = pickerC;
            if (this.popC_) {
                this.view.element.appendChild(this.popC_.view.element);
                this.popC_.view.element.appendChild(pickerC.view.element);
                connectValues({
                    primary: this.foldable_.value('expanded'),
                    secondary: this.popC_.shows,
                    forward: (p) => p.rawValue,
                    backward: (_, s) => s.rawValue,
                });
            }
            else if (this.view.pickerElement) {
                this.view.pickerElement.appendChild(this.pickerC_.view.element);
                bindFoldable(this.foldable_, this.view.pickerElement);
            }
        }
        get textController() {
            return this.textC_;
        }
        onButtonBlur_(e) {
            if (!this.popC_) {
                return;
            }
            const elem = this.view.element;
            const nextTarget = forceCast(e.relatedTarget);
            if (!nextTarget || !elem.contains(nextTarget)) {
                this.popC_.shows.rawValue = false;
            }
        }
        onButtonClick_() {
            this.foldable_.set('expanded', !this.foldable_.get('expanded'));
            if (this.foldable_.get('expanded')) {
                this.pickerC_.view.allFocusableElements[0].focus();
            }
        }
        onPopupChildBlur_(ev) {
            if (!this.popC_) {
                return;
            }
            const elem = this.popC_.view.element;
            const nextTarget = findNextTarget(ev);
            if (nextTarget && elem.contains(nextTarget)) {
                return;
            }
            if (nextTarget &&
                nextTarget === this.swatchC_.view.buttonElement &&
                !supportsTouch(elem.ownerDocument)) {
                return;
            }
            this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
            if (this.popC_) {
                if (ev.key === 'Escape') {
                    this.popC_.shows.rawValue = false;
                }
            }
            else if (this.view.pickerElement) {
                if (ev.key === 'Escape') {
                    this.swatchC_.view.buttonElement.focus();
                }
            }
        }
    }

    function colorFromObject(value, opt_type) {
        if (Color.isColorObject(value)) {
            return Color.fromObject(value, opt_type);
        }
        return Color.black(opt_type);
    }
    function colorToRgbNumber(value) {
        return removeAlphaComponent(value.getComponents('rgb')).reduce((result, comp) => {
            return (result << 8) | (Math.floor(comp) & 0xff);
        }, 0);
    }
    function colorToRgbaNumber(value) {
        return (value.getComponents('rgb').reduce((result, comp, index) => {
            const hex = Math.floor(index === 3 ? comp * 255 : comp) & 0xff;
            return (result << 8) | hex;
        }, 0) >>> 0);
    }
    function numberToRgbColor(num) {
        return new Color([(num >> 16) & 0xff, (num >> 8) & 0xff, num & 0xff], 'rgb');
    }
    function numberToRgbaColor(num) {
        return new Color([
            (num >> 24) & 0xff,
            (num >> 16) & 0xff,
            (num >> 8) & 0xff,
            mapRange(num & 0xff, 0, 255, 0, 1),
        ], 'rgb');
    }
    function colorFromRgbNumber(value) {
        if (typeof value !== 'number') {
            return Color.black();
        }
        return numberToRgbColor(value);
    }
    function colorFromRgbaNumber(value) {
        if (typeof value !== 'number') {
            return Color.black();
        }
        return numberToRgbaColor(value);
    }

    function createColorStringWriter(format) {
        const stringify = findColorStringifier(format);
        return stringify
            ? (target, value) => {
                writePrimitive(target, stringify(value));
            }
            : null;
    }
    function createColorNumberWriter(supportsAlpha) {
        const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
        return (target, value) => {
            writePrimitive(target, colorToNumber(value));
        };
    }
    function writeRgbaColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty('r', obj.r);
        target.writeProperty('g', obj.g);
        target.writeProperty('b', obj.b);
        target.writeProperty('a', obj.a);
    }
    function writeRgbColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty('r', obj.r);
        target.writeProperty('g', obj.g);
        target.writeProperty('b', obj.b);
    }
    function createColorObjectWriter(supportsAlpha, opt_type) {
        return (target, inValue) => {
            if (supportsAlpha) {
                writeRgbaColorObject(target, inValue, opt_type);
            }
            else {
                writeRgbColorObject(target, inValue, opt_type);
            }
        };
    }

    function shouldSupportAlpha$1(inputParams) {
        var _a;
        if ((inputParams === null || inputParams === void 0 ? void 0 : inputParams.alpha) || ((_a = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a === void 0 ? void 0 : _a.alpha)) {
            return true;
        }
        return false;
    }
    function createFormatter$1(supportsAlpha) {
        return supportsAlpha
            ? (v) => colorToHexRgbaString(v, '0x')
            : (v) => colorToHexRgbString(v, '0x');
    }
    function isForColor(params) {
        if ('color' in params) {
            return true;
        }
        if ('view' in params && params.view === 'color') {
            return true;
        }
        return false;
    }
    const NumberColorInputPlugin = {
        id: 'input-color-number',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'number') {
                return null;
            }
            if (!isForColor(params)) {
                return null;
            }
            const result = parseColorInputParams(params);
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (args) => {
                return shouldSupportAlpha$1(args.params)
                    ? colorFromRgbaNumber
                    : colorFromRgbNumber;
            },
            equals: Color.equals,
            writer: (args) => {
                return createColorNumberWriter(shouldSupportAlpha$1(args.params));
            },
        },
        controller: (args) => {
            const supportsAlpha = shouldSupportAlpha$1(args.params);
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            return new ColorController(args.document, {
                colorType: 'int',
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: createFormatter$1(supportsAlpha),
                parser: createColorStringParser('int'),
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                supportsAlpha: supportsAlpha,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    function shouldSupportAlpha(initialValue) {
        return Color.isRgbaColorObject(initialValue);
    }
    function createColorObjectReader(opt_type) {
        return (value) => {
            return colorFromObject(value, opt_type);
        };
    }
    function createColorObjectFormatter(supportsAlpha, type) {
        return (value) => {
            if (supportsAlpha) {
                return colorToObjectRgbaString(value, type);
            }
            return colorToObjectRgbString(value, type);
        };
    }
    const ObjectColorInputPlugin = {
        id: 'input-color-object',
        type: 'input',
        accept: (value, params) => {
            if (!Color.isColorObject(value)) {
                return null;
            }
            const result = parseColorInputParams(params);
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (args) => createColorObjectReader(extractColorType(args.params)),
            equals: Color.equals,
            writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), extractColorType(args.params)),
        },
        controller: (args) => {
            var _a;
            const supportsAlpha = Color.isRgbaColorObject(args.initialValue);
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            const type = (_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : 'int';
            return new ColorController(args.document, {
                colorType: type,
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: createColorObjectFormatter(supportsAlpha, type),
                parser: createColorStringParser(type),
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                supportsAlpha: supportsAlpha,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    const StringColorInputPlugin = {
        id: 'input-color-string',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'string') {
                return null;
            }
            if ('view' in params && params.view === 'text') {
                return null;
            }
            const format = detectStringColorFormat(value, extractColorType(params));
            if (!format) {
                return null;
            }
            const stringifier = findColorStringifier(format);
            if (!stringifier) {
                return null;
            }
            const result = parseColorInputParams(params);
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (args) => { var _a; return createColorStringBindingReader((_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : 'int'); },
            equals: Color.equals,
            writer: (args) => {
                const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
                if (!format) {
                    throw TpError.shouldNeverHappen();
                }
                const writer = createColorStringWriter(format);
                if (!writer) {
                    throw TpError.notBindable();
                }
                return writer;
            },
        },
        controller: (args) => {
            const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
            if (!format) {
                throw TpError.shouldNeverHappen();
            }
            const stringifier = findColorStringifier(format);
            if (!stringifier) {
                throw TpError.shouldNeverHappen();
            }
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            return new ColorController(args.document, {
                colorType: format.type,
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                formatter: stringifier,
                parser: createColorStringParser(format.type),
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                supportsAlpha: format.alpha,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    class PointNdConstraint {
        constructor(config) {
            this.components = config.components;
            this.asm_ = config.assembly;
        }
        constrain(value) {
            const comps = this.asm_
                .toComponents(value)
                .map((comp, index) => { var _a, _b; return (_b = (_a = this.components[index]) === null || _a === void 0 ? void 0 : _a.constrain(comp)) !== null && _b !== void 0 ? _b : comp; });
            return this.asm_.fromComponents(comps);
        }
    }

    const className$5 = ClassName('pndtxt');
    class PointNdTextView {
        constructor(doc, config) {
            this.textViews = config.textViews;
            this.element = doc.createElement('div');
            this.element.classList.add(className$5());
            this.textViews.forEach((v) => {
                const axisElem = doc.createElement('div');
                axisElem.classList.add(className$5('a'));
                axisElem.appendChild(v.element);
                this.element.appendChild(axisElem);
            });
        }
    }

    function createAxisController(doc, config, index) {
        return new NumberTextController(doc, {
            arrayPosition: index === 0 ? 'fst' : index === config.axes.length - 1 ? 'lst' : 'mid',
            baseStep: config.axes[index].baseStep,
            parser: config.parser,
            props: config.axes[index].textProps,
            value: createValue(0, {
                constraint: config.axes[index].constraint,
            }),
            viewProps: config.viewProps,
        });
    }
    class PointNdTextController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.acs_ = config.axes.map((_, index) => createAxisController(doc, config, index));
            this.acs_.forEach((c, index) => {
                connectValues({
                    primary: this.value,
                    secondary: c.value,
                    forward: (p) => {
                        return config.assembly.toComponents(p.rawValue)[index];
                    },
                    backward: (p, s) => {
                        const comps = config.assembly.toComponents(p.rawValue);
                        comps[index] = s.rawValue;
                        return config.assembly.fromComponents(comps);
                    },
                });
            });
            this.view = new PointNdTextView(doc, {
                textViews: this.acs_.map((ac) => ac.view),
            });
        }
    }

    function createStepConstraint(params, initialValue) {
        if ('step' in params && !isEmpty(params.step)) {
            return new StepConstraint(params.step, initialValue);
        }
        return null;
    }
    function createRangeConstraint(params) {
        if (('max' in params && !isEmpty(params.max)) ||
            ('min' in params && !isEmpty(params.min))) {
            return new RangeConstraint({
                max: params.max,
                min: params.min,
            });
        }
        return null;
    }
    function createConstraint$4(params,
    initialValue) {
        const constraints = [];
        const sc = createStepConstraint(params, initialValue);
        if (sc) {
            constraints.push(sc);
        }
        const rc = createRangeConstraint(params);
        if (rc) {
            constraints.push(rc);
        }
        const lc = createListConstraint(params.options);
        if (lc) {
            constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
    }
    function findRange(constraint) {
        const c = constraint ? findConstraint(constraint, RangeConstraint) : null;
        if (!c) {
            return [undefined, undefined];
        }
        return [c.minValue, c.maxValue];
    }
    function estimateSuitableRange(constraint) {
        const [min, max] = findRange(constraint);
        return [min !== null && min !== void 0 ? min : 0, max !== null && max !== void 0 ? max : 100];
    }
    const NumberInputPlugin = {
        id: 'input-number',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'number') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                format: p.optional.function,
                max: p.optional.number,
                min: p.optional.number,
                options: p.optional.custom(parseListOptions),
                step: p.optional.number,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => numberFromUnknown,
            constraint: (args) => createConstraint$4(args.params, args.initialValue),
            writer: (_args) => writePrimitive,
        },
        controller: (args) => {
            var _a, _b;
            const value = args.value;
            const c = args.constraint;
            if (c && findConstraint(c, ListConstraint)) {
                return new ListController(args.document, {
                    props: ValueMap.fromObject({
                        options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : [],
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            const formatter = (_b = ('format' in args.params ? args.params.format : undefined)) !== null && _b !== void 0 ? _b : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
            if (c && findConstraint(c, RangeConstraint)) {
                const [min, max] = estimateSuitableRange(c);
                return new SliderTextController(args.document, {
                    baseStep: getBaseStep(c),
                    parser: parseNumber,
                    sliderProps: ValueMap.fromObject({
                        maxValue: max,
                        minValue: min,
                    }),
                    textProps: ValueMap.fromObject({
                        draggingScale: getSuitableDraggingScale(c, value.rawValue),
                        formatter: formatter,
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new NumberTextController(args.document, {
                baseStep: getBaseStep(c),
                parser: parseNumber,
                props: ValueMap.fromObject({
                    draggingScale: getSuitableDraggingScale(c, value.rawValue),
                    formatter: formatter,
                }),
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    class Point2d {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        getComponents() {
            return [this.x, this.y];
        }
        static isObject(obj) {
            if (isEmpty(obj)) {
                return false;
            }
            const x = obj.x;
            const y = obj.y;
            if (typeof x !== 'number' || typeof y !== 'number') {
                return false;
            }
            return true;
        }
        static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y;
        }
        toObject() {
            return {
                x: this.x,
                y: this.y,
            };
        }
    }
    const Point2dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point2d(...comps),
    };

    const className$4 = ClassName('p2d');
    class Point2dView {
        constructor(doc, config) {
            this.element = doc.createElement('div');
            this.element.classList.add(className$4());
            config.viewProps.bindClassModifiers(this.element);
            bindValue(config.expanded, valueToClassName(this.element, className$4(undefined, 'expanded')));
            const headElem = doc.createElement('div');
            headElem.classList.add(className$4('h'));
            this.element.appendChild(headElem);
            const buttonElem = doc.createElement('button');
            buttonElem.classList.add(className$4('b'));
            buttonElem.appendChild(createSvgIconElement(doc, 'p2dpad'));
            config.viewProps.bindDisabled(buttonElem);
            headElem.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const textElem = doc.createElement('div');
            textElem.classList.add(className$4('t'));
            headElem.appendChild(textElem);
            this.textElement = textElem;
            if (config.pickerLayout === 'inline') {
                const pickerElem = doc.createElement('div');
                pickerElem.classList.add(className$4('p'));
                this.element.appendChild(pickerElem);
                this.pickerElement = pickerElem;
            }
            else {
                this.pickerElement = null;
            }
        }
    }

    const className$3 = ClassName('p2dp');
    class Point2dPickerView {
        constructor(doc, config) {
            this.onFoldableChange_ = this.onFoldableChange_.bind(this);
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.invertsY_ = config.invertsY;
            this.maxValue_ = config.maxValue;
            this.element = doc.createElement('div');
            this.element.classList.add(className$3());
            if (config.layout === 'popup') {
                this.element.classList.add(className$3(undefined, 'p'));
            }
            const padElem = doc.createElement('div');
            padElem.classList.add(className$3('p'));
            config.viewProps.bindTabIndex(padElem);
            this.element.appendChild(padElem);
            this.padElement = padElem;
            const svgElem = doc.createElementNS(SVG_NS, 'svg');
            svgElem.classList.add(className$3('g'));
            this.padElement.appendChild(svgElem);
            this.svgElem_ = svgElem;
            const xAxisElem = doc.createElementNS(SVG_NS, 'line');
            xAxisElem.classList.add(className$3('ax'));
            xAxisElem.setAttributeNS(null, 'x1', '0');
            xAxisElem.setAttributeNS(null, 'y1', '50%');
            xAxisElem.setAttributeNS(null, 'x2', '100%');
            xAxisElem.setAttributeNS(null, 'y2', '50%');
            this.svgElem_.appendChild(xAxisElem);
            const yAxisElem = doc.createElementNS(SVG_NS, 'line');
            yAxisElem.classList.add(className$3('ax'));
            yAxisElem.setAttributeNS(null, 'x1', '50%');
            yAxisElem.setAttributeNS(null, 'y1', '0');
            yAxisElem.setAttributeNS(null, 'x2', '50%');
            yAxisElem.setAttributeNS(null, 'y2', '100%');
            this.svgElem_.appendChild(yAxisElem);
            const lineElem = doc.createElementNS(SVG_NS, 'line');
            lineElem.classList.add(className$3('l'));
            lineElem.setAttributeNS(null, 'x1', '50%');
            lineElem.setAttributeNS(null, 'y1', '50%');
            this.svgElem_.appendChild(lineElem);
            this.lineElem_ = lineElem;
            const markerElem = doc.createElement('div');
            markerElem.classList.add(className$3('m'));
            this.padElement.appendChild(markerElem);
            this.markerElem_ = markerElem;
            config.value.emitter.on('change', this.onValueChange_);
            this.value = config.value;
            this.update_();
        }
        get allFocusableElements() {
            return [this.padElement];
        }
        update_() {
            const [x, y] = this.value.rawValue.getComponents();
            const max = this.maxValue_;
            const px = mapRange(x, -max, +max, 0, 100);
            const py = mapRange(y, -max, +max, 0, 100);
            const ipy = this.invertsY_ ? 100 - py : py;
            this.lineElem_.setAttributeNS(null, 'x2', `${px}%`);
            this.lineElem_.setAttributeNS(null, 'y2', `${ipy}%`);
            this.markerElem_.style.left = `${px}%`;
            this.markerElem_.style.top = `${ipy}%`;
        }
        onValueChange_() {
            this.update_();
        }
        onFoldableChange_() {
            this.update_();
        }
    }

    function computeOffset(ev, baseSteps, invertsY) {
        return [
            getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
            getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1),
        ];
    }
    class Point2dPickerController {
        constructor(doc, config) {
            this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
            this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.baseSteps_ = config.baseSteps;
            this.maxValue_ = config.maxValue;
            this.invertsY_ = config.invertsY;
            this.view = new Point2dPickerView(doc, {
                invertsY: this.invertsY_,
                layout: config.layout,
                maxValue: this.maxValue_,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.ptHandler_ = new PointerHandler(this.view.padElement);
            this.ptHandler_.emitter.on('down', this.onPointerDown_);
            this.ptHandler_.emitter.on('move', this.onPointerMove_);
            this.ptHandler_.emitter.on('up', this.onPointerUp_);
            this.view.padElement.addEventListener('keydown', this.onPadKeyDown_);
            this.view.padElement.addEventListener('keyup', this.onPadKeyUp_);
        }
        handlePointerEvent_(d, opts) {
            if (!d.point) {
                return;
            }
            const max = this.maxValue_;
            const px = mapRange(d.point.x, 0, d.bounds.width, -max, +max);
            const py = mapRange(this.invertsY_ ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);
            this.value.setRawValue(new Point2d(px, py), opts);
        }
        onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: false,
                last: false,
            });
        }
        onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
                forceEmit: true,
                last: true,
            });
        }
        onPadKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
                ev.preventDefault();
            }
            const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
            if (dx === 0 && dy === 0) {
                return;
            }
            this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
                forceEmit: false,
                last: false,
            });
        }
        onPadKeyUp_(ev) {
            const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
            if (dx === 0 && dy === 0) {
                return;
            }
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: true,
                last: true,
            });
        }
    }

    class Point2dController {
        constructor(doc, config) {
            var _a, _b;
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
            this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
            this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
            this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.foldable_ = Foldable.create(config.expanded);
            this.popC_ =
                config.pickerLayout === 'popup'
                    ? new PopupController(doc, {
                        viewProps: this.viewProps,
                    })
                    : null;
            const padC = new Point2dPickerController(doc, {
                baseSteps: [config.axes[0].baseStep, config.axes[1].baseStep],
                invertsY: config.invertsY,
                layout: config.pickerLayout,
                maxValue: config.maxValue,
                value: this.value,
                viewProps: this.viewProps,
            });
            padC.view.allFocusableElements.forEach((elem) => {
                elem.addEventListener('blur', this.onPopupChildBlur_);
                elem.addEventListener('keydown', this.onPopupChildKeydown_);
            });
            this.pickerC_ = padC;
            this.textC_ = new PointNdTextController(doc, {
                assembly: Point2dAssembly,
                axes: config.axes,
                parser: config.parser,
                value: this.value,
                viewProps: this.viewProps,
            });
            this.view = new Point2dView(doc, {
                expanded: this.foldable_.value('expanded'),
                pickerLayout: config.pickerLayout,
                viewProps: this.viewProps,
            });
            this.view.textElement.appendChild(this.textC_.view.element);
            (_a = this.view.buttonElement) === null || _a === void 0 ? void 0 : _a.addEventListener('blur', this.onPadButtonBlur_);
            (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener('click', this.onPadButtonClick_);
            if (this.popC_) {
                this.view.element.appendChild(this.popC_.view.element);
                this.popC_.view.element.appendChild(this.pickerC_.view.element);
                connectValues({
                    primary: this.foldable_.value('expanded'),
                    secondary: this.popC_.shows,
                    forward: (p) => p.rawValue,
                    backward: (_, s) => s.rawValue,
                });
            }
            else if (this.view.pickerElement) {
                this.view.pickerElement.appendChild(this.pickerC_.view.element);
                bindFoldable(this.foldable_, this.view.pickerElement);
            }
        }
        onPadButtonBlur_(e) {
            if (!this.popC_) {
                return;
            }
            const elem = this.view.element;
            const nextTarget = forceCast(e.relatedTarget);
            if (!nextTarget || !elem.contains(nextTarget)) {
                this.popC_.shows.rawValue = false;
            }
        }
        onPadButtonClick_() {
            this.foldable_.set('expanded', !this.foldable_.get('expanded'));
            if (this.foldable_.get('expanded')) {
                this.pickerC_.view.allFocusableElements[0].focus();
            }
        }
        onPopupChildBlur_(ev) {
            if (!this.popC_) {
                return;
            }
            const elem = this.popC_.view.element;
            const nextTarget = findNextTarget(ev);
            if (nextTarget && elem.contains(nextTarget)) {
                return;
            }
            if (nextTarget &&
                nextTarget === this.view.buttonElement &&
                !supportsTouch(elem.ownerDocument)) {
                return;
            }
            this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
            if (this.popC_) {
                if (ev.key === 'Escape') {
                    this.popC_.shows.rawValue = false;
                }
            }
            else if (this.view.pickerElement) {
                if (ev.key === 'Escape') {
                    this.view.buttonElement.focus();
                }
            }
        }
    }

    function point2dFromUnknown(value) {
        return Point2d.isObject(value)
            ? new Point2d(value.x, value.y)
            : new Point2d();
    }
    function writePoint2d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
    }

    function createDimensionConstraint(params, initialValue) {
        if (!params) {
            return undefined;
        }
        const constraints = [];
        const cs = createStepConstraint(params, initialValue);
        if (cs) {
            constraints.push(cs);
        }
        const rs = createRangeConstraint(params);
        if (rs) {
            constraints.push(rs);
        }
        return new CompositeConstraint(constraints);
    }
    function createConstraint$3(params, initialValue) {
        return new PointNdConstraint({
            assembly: Point2dAssembly,
            components: [
                createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x),
                createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y),
            ],
        });
    }
    function getSuitableMaxDimensionValue(constraint, rawValue) {
        var _a, _b;
        const rc = constraint && findConstraint(constraint, RangeConstraint);
        if (rc) {
            return Math.max(Math.abs((_a = rc.minValue) !== null && _a !== void 0 ? _a : 0), Math.abs((_b = rc.maxValue) !== null && _b !== void 0 ? _b : 0));
        }
        const step = getBaseStep(constraint);
        return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
    }
    function getSuitableMaxValue(initialValue, constraint) {
        const xc = constraint instanceof PointNdConstraint
            ? constraint.components[0]
            : undefined;
        const yc = constraint instanceof PointNdConstraint
            ? constraint.components[1]
            : undefined;
        const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
        const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
        return Math.max(xr, yr);
    }
    function createAxis$2(initialValue, constraint) {
        return {
            baseStep: getBaseStep(constraint),
            constraint: constraint,
            textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
            }),
        };
    }
    function shouldInvertY(params) {
        if (!('y' in params)) {
            return false;
        }
        const yParams = params.y;
        if (!yParams) {
            return false;
        }
        return 'inverted' in yParams ? !!yParams.inverted : false;
    }
    const Point2dInputPlugin = {
        id: 'input-point2d',
        type: 'input',
        accept: (value, params) => {
            if (!Point2d.isObject(value)) {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                expanded: p.optional.boolean,
                picker: p.optional.custom(parsePickerLayout),
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.object({
                    inverted: p.optional.boolean,
                    max: p.optional.number,
                    min: p.optional.number,
                    step: p.optional.number,
                }),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => point2dFromUnknown,
            constraint: (args) => createConstraint$3(args.params, args.initialValue),
            equals: Point2d.equals,
            writer: (_args) => writePoint2d,
        },
        controller: (args) => {
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
            }
            const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
            const picker = 'picker' in args.params ? args.params.picker : undefined;
            return new Point2dController(doc, {
                axes: [
                    createAxis$2(value.rawValue.x, c.components[0]),
                    createAxis$2(value.rawValue.y, c.components[1]),
                ],
                expanded: expanded !== null && expanded !== void 0 ? expanded : false,
                invertsY: shouldInvertY(args.params),
                maxValue: getSuitableMaxValue(value.rawValue, c),
                parser: parseNumber,
                pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    class Point3d {
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        getComponents() {
            return [this.x, this.y, this.z];
        }
        static isObject(obj) {
            if (isEmpty(obj)) {
                return false;
            }
            const x = obj.x;
            const y = obj.y;
            const z = obj.z;
            if (typeof x !== 'number' ||
                typeof y !== 'number' ||
                typeof z !== 'number') {
                return false;
            }
            return true;
        }
        static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
        }
        toObject() {
            return {
                x: this.x,
                y: this.y,
                z: this.z,
            };
        }
    }
    const Point3dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point3d(...comps),
    };

    function point3dFromUnknown(value) {
        return Point3d.isObject(value)
            ? new Point3d(value.x, value.y, value.z)
            : new Point3d();
    }
    function writePoint3d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
        target.writeProperty('z', value.z);
    }

    function createConstraint$2(params, initialValue) {
        return new PointNdConstraint({
            assembly: Point3dAssembly,
            components: [
                createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x),
                createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y),
                createDimensionConstraint('z' in params ? params.z : undefined, initialValue.z),
            ],
        });
    }
    function createAxis$1(initialValue, constraint) {
        return {
            baseStep: getBaseStep(constraint),
            constraint: constraint,
            textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
            }),
        };
    }
    const Point3dInputPlugin = {
        id: 'input-point3d',
        type: 'input',
        accept: (value, params) => {
            if (!Point3d.isObject(value)) {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.custom(parsePointDimensionParams),
                z: p.optional.custom(parsePointDimensionParams),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => point3dFromUnknown,
            constraint: (args) => createConstraint$2(args.params, args.initialValue),
            equals: Point3d.equals,
            writer: (_args) => writePoint3d,
        },
        controller: (args) => {
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
            }
            return new PointNdTextController(args.document, {
                assembly: Point3dAssembly,
                axes: [
                    createAxis$1(value.rawValue.x, c.components[0]),
                    createAxis$1(value.rawValue.y, c.components[1]),
                    createAxis$1(value.rawValue.z, c.components[2]),
                ],
                parser: parseNumber,
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    class Point4d {
        constructor(x = 0, y = 0, z = 0, w = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        getComponents() {
            return [this.x, this.y, this.z, this.w];
        }
        static isObject(obj) {
            if (isEmpty(obj)) {
                return false;
            }
            const x = obj.x;
            const y = obj.y;
            const z = obj.z;
            const w = obj.w;
            if (typeof x !== 'number' ||
                typeof y !== 'number' ||
                typeof z !== 'number' ||
                typeof w !== 'number') {
                return false;
            }
            return true;
        }
        static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
        }
        toObject() {
            return {
                x: this.x,
                y: this.y,
                z: this.z,
                w: this.w,
            };
        }
    }
    const Point4dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point4d(...comps),
    };

    function point4dFromUnknown(value) {
        return Point4d.isObject(value)
            ? new Point4d(value.x, value.y, value.z, value.w)
            : new Point4d();
    }
    function writePoint4d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
        target.writeProperty('z', value.z);
        target.writeProperty('w', value.w);
    }

    function createConstraint$1(params, initialValue) {
        return new PointNdConstraint({
            assembly: Point4dAssembly,
            components: [
                createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x),
                createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y),
                createDimensionConstraint('z' in params ? params.z : undefined, initialValue.z),
                createDimensionConstraint('w' in params ? params.w : undefined, initialValue.w),
            ],
        });
    }
    function createAxis(initialValue, constraint) {
        return {
            baseStep: getBaseStep(constraint),
            constraint: constraint,
            textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(constraint, initialValue),
                formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
            }),
        };
    }
    const Point4dInputPlugin = {
        id: 'input-point4d',
        type: 'input',
        accept: (value, params) => {
            if (!Point4d.isObject(value)) {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                x: p.optional.custom(parsePointDimensionParams),
                y: p.optional.custom(parsePointDimensionParams),
                z: p.optional.custom(parsePointDimensionParams),
                w: p.optional.custom(parsePointDimensionParams),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => point4dFromUnknown,
            constraint: (args) => createConstraint$1(args.params, args.initialValue),
            equals: Point4d.equals,
            writer: (_args) => writePoint4d,
        },
        controller: (args) => {
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
                throw TpError.shouldNeverHappen();
            }
            return new PointNdTextController(args.document, {
                assembly: Point4dAssembly,
                axes: value.rawValue
                    .getComponents()
                    .map((comp, index) => createAxis(comp, c.components[index])),
                parser: parseNumber,
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    function createConstraint(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
            constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
    }
    const StringInputPlugin = {
        id: 'input-string',
        type: 'input',
        accept: (value, params) => {
            if (typeof value !== 'string') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                options: p.optional.custom(parseListOptions),
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => stringFromUnknown,
            constraint: (args) => createConstraint(args.params),
            writer: (_args) => writePrimitive,
        },
        controller: (args) => {
            var _a;
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            if (c && findConstraint(c, ListConstraint)) {
                return new ListController(doc, {
                    props: ValueMap.fromObject({
                        options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : [],
                    }),
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new TextController(doc, {
                parser: (v) => v,
                props: ValueMap.fromObject({
                    formatter: formatString,
                }),
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    const Constants = {
        monitor: {
            defaultInterval: 200,
            defaultLineCount: 3,
        },
    };

    const className$2 = ClassName('mll');
    class MultiLogView {
        constructor(doc, config) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.formatter_ = config.formatter;
            this.element = doc.createElement('div');
            this.element.classList.add(className$2());
            config.viewProps.bindClassModifiers(this.element);
            const textareaElem = doc.createElement('textarea');
            textareaElem.classList.add(className$2('i'));
            textareaElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
            textareaElem.readOnly = true;
            config.viewProps.bindDisabled(textareaElem);
            this.element.appendChild(textareaElem);
            this.textareaElem_ = textareaElem;
            config.value.emitter.on('change', this.onValueUpdate_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            const elem = this.textareaElem_;
            const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
            const lines = [];
            this.value.rawValue.forEach((value) => {
                if (value !== undefined) {
                    lines.push(this.formatter_(value));
                }
            });
            elem.textContent = lines.join('\n');
            if (shouldScroll) {
                elem.scrollTop = elem.scrollHeight;
            }
        }
        onValueUpdate_() {
            this.update_();
        }
    }

    class MultiLogController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new MultiLogView(doc, {
                formatter: config.formatter,
                lineCount: config.lineCount,
                value: this.value,
                viewProps: this.viewProps,
            });
        }
    }

    const className$1 = ClassName('sgl');
    class SingleLogView {
        constructor(doc, config) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.formatter_ = config.formatter;
            this.element = doc.createElement('div');
            this.element.classList.add(className$1());
            config.viewProps.bindClassModifiers(this.element);
            const inputElem = doc.createElement('input');
            inputElem.classList.add(className$1('i'));
            inputElem.readOnly = true;
            inputElem.type = 'text';
            config.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            config.value.emitter.on('change', this.onValueUpdate_);
            this.value = config.value;
            this.update_();
        }
        update_() {
            const values = this.value.rawValue;
            const lastValue = values[values.length - 1];
            this.inputElement.value =
                lastValue !== undefined ? this.formatter_(lastValue) : '';
        }
        onValueUpdate_() {
            this.update_();
        }
    }

    class SingleLogController {
        constructor(doc, config) {
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.view = new SingleLogView(doc, {
                formatter: config.formatter,
                value: this.value,
                viewProps: this.viewProps,
            });
        }
    }

    const BooleanMonitorPlugin = {
        id: 'monitor-bool',
        type: 'monitor',
        accept: (value, params) => {
            if (typeof value !== 'boolean') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                lineCount: p.optional.number,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => boolFromUnknown,
        },
        controller: (args) => {
            var _a;
            if (args.value.rawValue.length === 1) {
                return new SingleLogController(args.document, {
                    formatter: BooleanFormatter,
                    value: args.value,
                    viewProps: args.viewProps,
                });
            }
            return new MultiLogController(args.document, {
                formatter: BooleanFormatter,
                lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
                value: args.value,
                viewProps: args.viewProps,
            });
        },
    };

    const className = ClassName('grl');
    class GraphLogView {
        constructor(doc, config) {
            this.onCursorChange_ = this.onCursorChange_.bind(this);
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.element = doc.createElement('div');
            this.element.classList.add(className());
            config.viewProps.bindClassModifiers(this.element);
            this.formatter_ = config.formatter;
            this.props_ = config.props;
            this.cursor_ = config.cursor;
            this.cursor_.emitter.on('change', this.onCursorChange_);
            const svgElem = doc.createElementNS(SVG_NS, 'svg');
            svgElem.classList.add(className('g'));
            svgElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
            this.element.appendChild(svgElem);
            this.svgElem_ = svgElem;
            const lineElem = doc.createElementNS(SVG_NS, 'polyline');
            this.svgElem_.appendChild(lineElem);
            this.lineElem_ = lineElem;
            const tooltipElem = doc.createElement('div');
            tooltipElem.classList.add(className('t'), ClassName('tt')());
            this.element.appendChild(tooltipElem);
            this.tooltipElem_ = tooltipElem;
            config.value.emitter.on('change', this.onValueUpdate_);
            this.value = config.value;
            this.update_();
        }
        get graphElement() {
            return this.svgElem_;
        }
        update_() {
            const bounds = this.svgElem_.getBoundingClientRect();
            const maxIndex = this.value.rawValue.length - 1;
            const min = this.props_.get('minValue');
            const max = this.props_.get('maxValue');
            const points = [];
            this.value.rawValue.forEach((v, index) => {
                if (v === undefined) {
                    return;
                }
                const x = mapRange(index, 0, maxIndex, 0, bounds.width);
                const y = mapRange(v, min, max, bounds.height, 0);
                points.push([x, y].join(','));
            });
            this.lineElem_.setAttributeNS(null, 'points', points.join(' '));
            const tooltipElem = this.tooltipElem_;
            const value = this.value.rawValue[this.cursor_.rawValue];
            if (value === undefined) {
                tooltipElem.classList.remove(className('t', 'a'));
                return;
            }
            const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
            const ty = mapRange(value, min, max, bounds.height, 0);
            tooltipElem.style.left = `${tx}px`;
            tooltipElem.style.top = `${ty}px`;
            tooltipElem.textContent = `${this.formatter_(value)}`;
            if (!tooltipElem.classList.contains(className('t', 'a'))) {
                tooltipElem.classList.add(className('t', 'a'), className('t', 'in'));
                forceReflow(tooltipElem);
                tooltipElem.classList.remove(className('t', 'in'));
            }
        }
        onValueUpdate_() {
            this.update_();
        }
        onCursorChange_() {
            this.update_();
        }
    }

    class GraphLogController {
        constructor(doc, config) {
            this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
            this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
            this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
            this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
            this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
            this.props_ = config.props;
            this.value = config.value;
            this.viewProps = config.viewProps;
            this.cursor_ = createValue(-1);
            this.view = new GraphLogView(doc, {
                cursor: this.cursor_,
                formatter: config.formatter,
                lineCount: config.lineCount,
                props: this.props_,
                value: this.value,
                viewProps: this.viewProps,
            });
            if (!supportsTouch(doc)) {
                this.view.element.addEventListener('mousemove', this.onGraphMouseMove_);
                this.view.element.addEventListener('mouseleave', this.onGraphMouseLeave_);
            }
            else {
                const ph = new PointerHandler(this.view.element);
                ph.emitter.on('down', this.onGraphPointerDown_);
                ph.emitter.on('move', this.onGraphPointerMove_);
                ph.emitter.on('up', this.onGraphPointerUp_);
            }
        }
        onGraphMouseLeave_() {
            this.cursor_.rawValue = -1;
        }
        onGraphMouseMove_(ev) {
            const bounds = this.view.element.getBoundingClientRect();
            this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerDown_(ev) {
            this.onGraphPointerMove_(ev);
        }
        onGraphPointerMove_(ev) {
            if (!ev.data.point) {
                this.cursor_.rawValue = -1;
                return;
            }
            this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerUp_() {
            this.cursor_.rawValue = -1;
        }
    }

    function createFormatter(params) {
        return 'format' in params && !isEmpty(params.format)
            ? params.format
            : createNumberFormatter(2);
    }
    function createTextMonitor(args) {
        var _a;
        if (args.value.rawValue.length === 1) {
            return new SingleLogController(args.document, {
                formatter: createFormatter(args.params),
                value: args.value,
                viewProps: args.viewProps,
            });
        }
        return new MultiLogController(args.document, {
            formatter: createFormatter(args.params),
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            value: args.value,
            viewProps: args.viewProps,
        });
    }
    function createGraphMonitor(args) {
        var _a, _b, _c;
        return new GraphLogController(args.document, {
            formatter: createFormatter(args.params),
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            props: ValueMap.fromObject({
                maxValue: (_b = ('max' in args.params ? args.params.max : null)) !== null && _b !== void 0 ? _b : 100,
                minValue: (_c = ('min' in args.params ? args.params.min : null)) !== null && _c !== void 0 ? _c : 0,
            }),
            value: args.value,
            viewProps: args.viewProps,
        });
    }
    function shouldShowGraph(params) {
        return 'view' in params && params.view === 'graph';
    }
    const NumberMonitorPlugin = {
        id: 'monitor-number',
        type: 'monitor',
        accept: (value, params) => {
            if (typeof value !== 'number') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                format: p.optional.function,
                lineCount: p.optional.number,
                max: p.optional.number,
                min: p.optional.number,
                view: p.optional.string,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            defaultBufferSize: (params) => (shouldShowGraph(params) ? 64 : 1),
            reader: (_args) => numberFromUnknown,
        },
        controller: (args) => {
            if (shouldShowGraph(args.params)) {
                return createGraphMonitor(args);
            }
            return createTextMonitor(args);
        },
    };

    const StringMonitorPlugin = {
        id: 'monitor-string',
        type: 'monitor',
        accept: (value, params) => {
            if (typeof value !== 'string') {
                return null;
            }
            const p = ParamsParsers;
            const result = parseParams(params, {
                lineCount: p.optional.number,
                multiline: p.optional.boolean,
            });
            return result
                ? {
                    initialValue: value,
                    params: result,
                }
                : null;
        },
        binding: {
            reader: (_args) => stringFromUnknown,
        },
        controller: (args) => {
            var _a;
            const value = args.value;
            const multiline = value.rawValue.length > 1 ||
                ('multiline' in args.params && args.params.multiline);
            if (multiline) {
                return new MultiLogController(args.document, {
                    formatter: formatString,
                    lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
                    value: value,
                    viewProps: args.viewProps,
                });
            }
            return new SingleLogController(args.document, {
                formatter: formatString,
                value: value,
                viewProps: args.viewProps,
            });
        },
    };

    class InputBinding {
        constructor(config) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.reader = config.reader;
            this.writer = config.writer;
            this.emitter = new Emitter();
            this.value = config.value;
            this.value.emitter.on('change', this.onValueChange_);
            this.target = config.target;
            this.read();
        }
        read() {
            const targetValue = this.target.read();
            if (targetValue !== undefined) {
                this.value.rawValue = this.reader(targetValue);
            }
        }
        write_(rawValue) {
            this.writer(this.target, rawValue);
        }
        onValueChange_(ev) {
            this.write_(ev.rawValue);
            this.emitter.emit('change', {
                options: ev.options,
                rawValue: ev.rawValue,
                sender: this,
            });
        }
    }

    function createInputBindingController(plugin, args) {
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
            return null;
        }
        const p = ParamsParsers;
        const valueArgs = {
            target: args.target,
            initialValue: result.initialValue,
            params: result.params,
        };
        const reader = plugin.binding.reader(valueArgs);
        const constraint = plugin.binding.constraint
            ? plugin.binding.constraint(valueArgs)
            : undefined;
        const value = createValue(reader(result.initialValue), {
            constraint: constraint,
            equals: plugin.binding.equals,
        });
        const binding = new InputBinding({
            reader: reader,
            target: args.target,
            value: value,
            writer: plugin.binding.writer(valueArgs),
        });
        const disabled = p.optional.boolean(args.params.disabled).value;
        const hidden = p.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
            constraint: constraint,
            document: args.document,
            initialValue: result.initialValue,
            params: result.params,
            value: binding.value,
            viewProps: ViewProps.create({
                disabled: disabled,
                hidden: hidden,
            }),
        });
        const label = p.optional.string(args.params.label).value;
        return new InputBindingController(args.document, {
            binding: binding,
            blade: createBlade(),
            props: ValueMap.fromObject({
                label: label !== null && label !== void 0 ? label : args.target.key,
            }),
            valueController: controller,
        });
    }

    class MonitorBinding {
        constructor(config) {
            this.onTick_ = this.onTick_.bind(this);
            this.reader_ = config.reader;
            this.target = config.target;
            this.emitter = new Emitter();
            this.value = config.value;
            this.ticker = config.ticker;
            this.ticker.emitter.on('tick', this.onTick_);
            this.read();
        }
        dispose() {
            this.ticker.dispose();
        }
        read() {
            const targetValue = this.target.read();
            if (targetValue === undefined) {
                return;
            }
            const buffer = this.value.rawValue;
            const newValue = this.reader_(targetValue);
            this.value.rawValue = createPushedBuffer(buffer, newValue);
            this.emitter.emit('update', {
                rawValue: newValue,
                sender: this,
            });
        }
        onTick_(_) {
            this.read();
        }
    }

    function createTicker(document, interval) {
        return interval === 0
            ? new ManualTicker()
            : new IntervalTicker(document, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
    }
    function createMonitorBindingController(plugin, args) {
        var _a, _b, _c;
        const P = ParamsParsers;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
            return null;
        }
        const bindingArgs = {
            target: args.target,
            initialValue: result.initialValue,
            params: result.params,
        };
        const reader = plugin.binding.reader(bindingArgs);
        const bufferSize = (_b = (_a = P.optional.number(args.params.bufferSize).value) !== null && _a !== void 0 ? _a : (plugin.binding.defaultBufferSize &&
            plugin.binding.defaultBufferSize(result.params))) !== null && _b !== void 0 ? _b : 1;
        const interval = P.optional.number(args.params.interval).value;
        const binding = new MonitorBinding({
            reader: reader,
            target: args.target,
            ticker: createTicker(args.document, interval),
            value: initializeBuffer(bufferSize),
        });
        const disabled = P.optional.boolean(args.params.disabled).value;
        const hidden = P.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
            document: args.document,
            params: result.params,
            value: binding.value,
            viewProps: ViewProps.create({
                disabled: disabled,
                hidden: hidden,
            }),
        });
        const label = (_c = P.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : args.target.key;
        return new MonitorBindingController(args.document, {
            binding: binding,
            blade: createBlade(),
            props: ValueMap.fromObject({
                label: label,
            }),
            valueController: controller,
        });
    }

    class PluginPool {
        constructor() {
            this.pluginsMap_ = {
                blades: [],
                inputs: [],
                monitors: [],
            };
        }
        getAll() {
            return [
                ...this.pluginsMap_.blades,
                ...this.pluginsMap_.inputs,
                ...this.pluginsMap_.monitors,
            ];
        }
        register(r) {
            if (r.type === 'blade') {
                this.pluginsMap_.blades.unshift(r);
            }
            else if (r.type === 'input') {
                this.pluginsMap_.inputs.unshift(r);
            }
            else if (r.type === 'monitor') {
                this.pluginsMap_.monitors.unshift(r);
            }
        }
        createInput(document, target, params) {
            const initialValue = target.read();
            if (isEmpty(initialValue)) {
                throw new TpError({
                    context: {
                        key: target.key,
                    },
                    type: 'nomatchingcontroller',
                });
            }
            const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
                document: document,
                target: target,
                params: params,
            }), null);
            if (bc) {
                return bc;
            }
            throw new TpError({
                context: {
                    key: target.key,
                },
                type: 'nomatchingcontroller',
            });
        }
        createMonitor(document, target, params) {
            const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
                document: document,
                params: params,
                target: target,
            }), null);
            if (bc) {
                return bc;
            }
            throw new TpError({
                context: {
                    key: target.key,
                },
                type: 'nomatchingcontroller',
            });
        }
        createBlade(document, params) {
            const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
                document: document,
                params: params,
            }), null);
            if (!bc) {
                throw new TpError({
                    type: 'nomatchingview',
                    context: {
                        params: params,
                    },
                });
            }
            return bc;
        }
        createBladeApi(bc) {
            if (bc instanceof InputBindingController) {
                return new InputBindingApi(bc);
            }
            if (bc instanceof MonitorBindingController) {
                return new MonitorBindingApi(bc);
            }
            if (bc instanceof RackController) {
                return new RackApi(bc, this);
            }
            const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
                controller: bc,
                pool: this,
            }), null);
            if (!api) {
                throw TpError.shouldNeverHappen();
            }
            return api;
        }
    }

    function createDefaultPluginPool() {
        const pool = new PluginPool();
        [
            Point2dInputPlugin,
            Point3dInputPlugin,
            Point4dInputPlugin,
            StringInputPlugin,
            NumberInputPlugin,
            StringColorInputPlugin,
            ObjectColorInputPlugin,
            NumberColorInputPlugin,
            BooleanInputPlugin,
            BooleanMonitorPlugin,
            StringMonitorPlugin,
            NumberMonitorPlugin,
            ButtonBladePlugin,
            FolderBladePlugin,
            SeparatorBladePlugin,
            TabBladePlugin,
        ].forEach((p) => {
            pool.register(p);
        });
        return pool;
    }

    class ListApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter();
            this.controller_.valueController.value.emitter.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(this, ev.rawValue),
                });
            });
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get options() {
            return this.controller_.valueController.props.get('options');
        }
        set options(options) {
            this.controller_.valueController.props.set('options', options);
        }
        get value() {
            return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
            this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    class SliderApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter();
            this.controller_.valueController.value.emitter.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(this, ev.rawValue),
                });
            });
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get maxValue() {
            return this.controller_.valueController.sliderController.props.get('maxValue');
        }
        set maxValue(maxValue) {
            this.controller_.valueController.sliderController.props.set('maxValue', maxValue);
        }
        get minValue() {
            return this.controller_.valueController.sliderController.props.get('minValue');
        }
        set minValue(minValue) {
            this.controller_.valueController.sliderController.props.set('minValue', minValue);
        }
        get value() {
            return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
            this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    class TextApi extends BladeApi {
        constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter();
            this.controller_.valueController.value.emitter.on('change', (ev) => {
                this.emitter_.emit('change', {
                    event: new TpChangeEvent(this, ev.rawValue),
                });
            });
        }
        get label() {
            return this.controller_.props.get('label');
        }
        set label(label) {
            this.controller_.props.set('label', label);
        }
        get formatter() {
            return this.controller_.valueController.props.get('formatter');
        }
        set formatter(formatter) {
            this.controller_.valueController.props.set('formatter', formatter);
        }
        get value() {
            return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
            this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
                bh(ev.event);
            });
            return this;
        }
    }

    const ListBladePlugin = (function () {
        return {
            id: 'list',
            type: 'blade',
            accept(params) {
                const p = ParamsParsers;
                const result = parseParams(params, {
                    options: p.required.custom(parseListOptions),
                    value: p.required.raw,
                    view: p.required.constant('list'),
                    label: p.optional.string,
                });
                return result ? { params: result } : null;
            },
            controller(args) {
                const ic = new ListController(args.document, {
                    props: ValueMap.fromObject({
                        options: normalizeListOptions(args.params.options),
                    }),
                    value: createValue(args.params.value),
                    viewProps: args.viewProps,
                });
                return new LabeledValueController(args.document, {
                    blade: args.blade,
                    props: ValueMap.fromObject({
                        label: args.params.label,
                    }),
                    valueController: ic,
                });
            },
            api(args) {
                if (!(args.controller instanceof LabeledValueController)) {
                    return null;
                }
                if (!(args.controller.valueController instanceof ListController)) {
                    return null;
                }
                return new ListApi(args.controller);
            },
        };
    })();

    /**
     * @hidden
     */
    function exportPresetJson(targets) {
        return targets.reduce((result, target) => {
            return Object.assign(result, {
                [target.presetKey]: target.read(),
            });
        }, {});
    }
    /**
     * @hidden
     */
    function importPresetJson(targets, preset) {
        targets.forEach((target) => {
            const value = preset[target.presetKey];
            if (value !== undefined) {
                target.write(value);
            }
        });
    }

    class RootApi extends FolderApi {
        /**
         * @hidden
         */
        constructor(controller, pool) {
            super(controller, pool);
        }
        get element() {
            return this.controller_.view.element;
        }
        /**
         * Imports a preset of all inputs.
         * @param preset The preset object to import.
         */
        importPreset(preset) {
            const targets = this.controller_.rackController.rack
                .find(InputBindingController)
                .map((ibc) => {
                return ibc.binding.target;
            });
            importPresetJson(targets, preset);
            this.refresh();
        }
        /**
         * Exports a preset of all inputs.
         * @return An exported preset object.
         */
        exportPreset() {
            const targets = this.controller_.rackController.rack
                .find(InputBindingController)
                .map((ibc) => {
                return ibc.binding.target;
            });
            return exportPresetJson(targets);
        }
        /**
         * Refreshes all bindings of the pane.
         */
        refresh() {
            // Force-read all input bindings
            this.controller_.rackController.rack
                .find(InputBindingController)
                .forEach((ibc) => {
                ibc.binding.read();
            });
            // Force-read all monitor bindings
            this.controller_.rackController.rack
                .find(MonitorBindingController)
                .forEach((mbc) => {
                mbc.binding.read();
            });
        }
    }

    class RootController extends FolderController {
        constructor(doc, config) {
            super(doc, {
                expanded: config.expanded,
                blade: config.blade,
                props: config.props,
                root: true,
                viewProps: config.viewProps,
            });
        }
    }

    const SliderBladePlugin = {
        id: 'slider',
        type: 'blade',
        accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
                max: p.required.number,
                min: p.required.number,
                view: p.required.constant('slider'),
                format: p.optional.function,
                label: p.optional.string,
                value: p.optional.number,
            });
            return result ? { params: result } : null;
        },
        controller(args) {
            var _a, _b;
            const v = (_a = args.params.value) !== null && _a !== void 0 ? _a : 0;
            const vc = new SliderTextController(args.document, {
                baseStep: 1,
                parser: parseNumber,
                sliderProps: ValueMap.fromObject({
                    maxValue: args.params.max,
                    minValue: args.params.min,
                }),
                textProps: ValueMap.fromObject({
                    draggingScale: getSuitableDraggingScale(undefined, v),
                    formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString,
                }),
                value: createValue(v),
                viewProps: args.viewProps,
            });
            return new LabeledValueController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                    label: args.params.label,
                }),
                valueController: vc,
            });
        },
        api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
                return null;
            }
            if (!(args.controller.valueController instanceof SliderTextController)) {
                return null;
            }
            return new SliderApi(args.controller);
        },
    };

    const TextBladePlugin = (function () {
        return {
            id: 'text',
            type: 'blade',
            accept(params) {
                const p = ParamsParsers;
                const result = parseParams(params, {
                    parse: p.required.function,
                    value: p.required.raw,
                    view: p.required.constant('text'),
                    format: p.optional.function,
                    label: p.optional.string,
                });
                return result ? { params: result } : null;
            },
            controller(args) {
                var _a;
                const ic = new TextController(args.document, {
                    parser: args.params.parse,
                    props: ValueMap.fromObject({
                        formatter: (_a = args.params.format) !== null && _a !== void 0 ? _a : ((v) => String(v)),
                    }),
                    value: createValue(args.params.value),
                    viewProps: args.viewProps,
                });
                return new LabeledValueController(args.document, {
                    blade: args.blade,
                    props: ValueMap.fromObject({
                        label: args.params.label,
                    }),
                    valueController: ic,
                });
            },
            api(args) {
                if (!(args.controller instanceof LabeledValueController)) {
                    return null;
                }
                if (!(args.controller.valueController instanceof TextController)) {
                    return null;
                }
                return new TextApi(args.controller);
            },
        };
    })();

    function createDefaultWrapperElement(doc) {
        const elem = doc.createElement('div');
        elem.classList.add(ClassName('dfw')());
        if (doc.body) {
            doc.body.appendChild(elem);
        }
        return elem;
    }
    function embedStyle(doc, id, css) {
        if (doc.querySelector(`style[data-tp-style=${id}]`)) {
            return;
        }
        const styleElem = doc.createElement('style');
        styleElem.dataset.tpStyle = id;
        styleElem.textContent = css;
        doc.head.appendChild(styleElem);
    }
    /**
     * The root pane of Tweakpane.
     */
    class Pane extends RootApi {
        constructor(opt_config) {
            var _a, _b;
            const config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
            const doc = (_a = config.document) !== null && _a !== void 0 ? _a : getWindowDocument();
            const pool = createDefaultPluginPool();
            const rootController = new RootController(doc, {
                expanded: config.expanded,
                blade: createBlade(),
                props: ValueMap.fromObject({
                    title: config.title,
                }),
                viewProps: ViewProps.create(),
            });
            super(rootController, pool);
            this.pool_ = pool;
            this.containerElem_ = (_b = config.container) !== null && _b !== void 0 ? _b : createDefaultWrapperElement(doc);
            this.containerElem_.appendChild(this.element);
            this.doc_ = doc;
            this.usesDefaultWrapper_ = !config.container;
            this.setUpDefaultPlugins_();
        }
        get document() {
            if (!this.doc_) {
                throw TpError.alreadyDisposed();
            }
            return this.doc_;
        }
        dispose() {
            const containerElem = this.containerElem_;
            if (!containerElem) {
                throw TpError.alreadyDisposed();
            }
            if (this.usesDefaultWrapper_) {
                const parentElem = containerElem.parentElement;
                if (parentElem) {
                    parentElem.removeChild(containerElem);
                }
            }
            this.containerElem_ = null;
            this.doc_ = null;
            super.dispose();
        }
        registerPlugin(bundle) {
            const plugins = 'plugin' in bundle
                ? [bundle.plugin]
                : 'plugins' in bundle
                    ? bundle.plugins
                    : [];
            plugins.forEach((p) => {
                this.pool_.register(p);
                this.embedPluginStyle_(p);
            });
        }
        embedPluginStyle_(plugin) {
            if (plugin.css) {
                embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
            }
        }
        setUpDefaultPlugins_() {
            // NOTE: This string literal will be replaced with the default CSS by Rollup at the compilation time
            embedStyle(this.document, 'default', '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}');
            this.pool_.getAll().forEach((plugin) => {
                this.embedPluginStyle_(plugin);
            });
            this.registerPlugin({
                plugins: [
                    SliderBladePlugin,
                    ListBladePlugin,
                    TabBladePlugin,
                    TextBladePlugin,
                ],
            });
        }
    }

    const VERSION = new Semver('3.1.0');

    exports.BladeApi = BladeApi;
    exports.ButtonApi = ButtonApi;
    exports.FolderApi = FolderApi;
    exports.InputBindingApi = InputBindingApi;
    exports.ListApi = ListApi;
    exports.MonitorBindingApi = MonitorBindingApi;
    exports.Pane = Pane;
    exports.SeparatorApi = SeparatorApi;
    exports.SliderApi = SliderApi;
    exports.TabApi = TabApi;
    exports.TabPageApi = TabPageApi;
    exports.TextApi = TextApi;
    exports.TpChangeEvent = TpChangeEvent;
    exports.VERSION = VERSION;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],"src/index.js":[function(require,module,exports) {
"use strict";

var _webgi = require("webgi");

require("./styles.css");

var _gsap = _interopRequireDefault(require("gsap"));

var _ScrollTrigger = require("gsap/ScrollTrigger");

var _tweakpane = require("tweakpane");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

_gsap.default.registerPlugin(_ScrollTrigger.ScrollTrigger);

_ScrollTrigger.ScrollTrigger.defaults({
  scroller: ".mainContainer"
});

function setupViewer() {
  return _setupViewer.apply(this, arguments);
}

function _setupViewer() {
  _setupViewer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _document$querySelect2;

    var viewer, manager, camera, importer, model, object3d, modelPosition, modelRotation, loaderElement, introAnimation, setupScrollanimation, needsUpdate, onUpdate;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            onUpdate = function _onUpdate() {
              needsUpdate = true;
              viewer.renderer.resetShadows();
              viewer.setDirty();
            };

            setupScrollanimation = function _setupScrollanimation() {
              document.body.removeChild(loaderElement);

              var tl = _gsap.default.timeline();

              tl.to(modelPosition, {
                x: -0.9,
                y: -0.43,
                z: 0,
                scrollTrigger: {
                  trigger: ".first",
                  start: "top top",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                },
                onUpdate: onUpdate
              }).to(modelPosition, {
                x: -1.36,
                y: -0.02,
                z: -0.22,
                scrollTrigger: {
                  trigger: ".second",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                },
                onUpdate: onUpdate
              }).to(modelRotation, {
                x: 0.0,
                y: 0,
                z: -1.57,
                scrollTrigger: {
                  trigger: ".second",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                }
              }).to(modelPosition, {
                x: 0.38,
                y: -0.11,
                z: -1.06,
                scrollTrigger: {
                  trigger: ".third",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                },
                onUpdate: onUpdate
              }).to(modelRotation, {
                x: 0.403,
                y: 0.957,
                z: -0.421,
                scrollTrigger: {
                  trigger: ".third",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                }
              }).to(modelPosition, {
                x: 0.92,
                y: -0.31,
                z: 0.66,
                scrollTrigger: {
                  trigger: ".four",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                },
                onUpdate: onUpdate
              }).to(modelRotation, {
                x: 0.0,
                y: 1.641,
                z: 0,
                scrollTrigger: {
                  trigger: ".four",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                }
              }).to(modelPosition, {
                x: -0.1,
                y: -0.11,
                z: 0.99,
                scrollTrigger: {
                  trigger: ".five",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                },
                onUpdate: onUpdate
              }).to(modelRotation, {
                x: -0.785,
                y: 2.329,
                z: 0.903,
                scrollTrigger: {
                  trigger: ".five",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                }
              }).to(modelPosition, {
                x: 0.16,
                y: -0.3,
                z: -0.56,
                scrollTrigger: {
                  trigger: ".six",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                },
                onUpdate: onUpdate
              }).to(modelRotation, {
                x: -0.261,
                y: 4.911,
                z: -0.277,
                scrollTrigger: {
                  trigger: ".six",
                  start: "top bottom",
                  end: "top top",
                  scrub: 0.2,
                  immediateRender: false
                }
              }).to(".section--one--container1", {
                opacity: 0,
                scrollTrigger: {
                  trigger: ".section--one--container1",
                  start: "top top",
                  end: "bottom top",
                  scrub: true,
                  immediateRender: false
                }
              }).to(".section--one--container2", {
                opacity: 0,
                scrollTrigger: {
                  trigger: ".second",
                  start: "top bottom",
                  end: "top center",
                  scrub: true,
                  immediateRender: false
                }
              }).to(".section--two--container1", {
                scrollTrigger: {
                  trigger: ".section--two--container1",
                  start: "top 80%",
                  end: "bottom center",
                  toggleClass: "activeRightSpecific",
                  scrub: true
                }
              }).to(".section--two--container2", {
                scrollTrigger: {
                  trigger: ".section--two--container2",
                  start: "top 80%",
                  end: "bottom center",
                  toggleClass: "resetPosition",
                  scrub: true
                }
              }).to(".section--three--container", {
                scrollTrigger: {
                  trigger: ".section--three--container",
                  start: "top 80%",
                  end: "bottom center",
                  toggleClass: "resetPosition",
                  scrub: true
                }
              }).to(".section--four--container", {
                scrollTrigger: {
                  trigger: ".section--four--container",
                  start: "top 80%",
                  end: "bottom center",
                  toggleClass: "resetPosition",
                  scrub: true
                }
              }).to(".section--five--container ", {
                scrollTrigger: {
                  trigger: ".section--five--container ",
                  start: "top 80%",
                  end: "bottom center",
                  toggleClass: "resetPosition",
                  scrub: true
                }
              }).to(".section--six--container ", {
                scrollTrigger: {
                  trigger: ".section--six--container ",
                  start: "top 80%",
                  end: "bottom center",
                  toggleClass: "resetPosition",
                  scrub: true
                }
              });
            };

            introAnimation = function _introAnimation() {
              var introTL = _gsap.default.timeline();

              introTL.to(".loader", {
                x: "150%",
                duration: 0.8,
                ease: "power4.inOut",
                delay: 1
              }).fromTo(".header--container", {
                opacity: 0,
                y: "-100%"
              }, {
                opacity: 1,
                y: "0%",
                ease: "power1.inOut",
                duration: 0.8
              }, "-=1").fromTo(".hero--scroller", {
                opacity: 0,
                y: "150%"
              }, {
                opacity: 1,
                y: "0%",
                ease: "power4.inOut",
                duration: 1
              }, "-=1").fromTo(".hero--content", {
                opacity: 0,
                x: "-50%"
              }, {
                opacity: 1,
                x: "0%",
                ease: "power4.inOut",
                duration: 1.8,
                onComplete: setupScrollanimation
              }, "-=1");
            };

            viewer = new _webgi.ViewerApp({
              canvas: document.getElementById("webgi-canvas"),
              useRgbm: false,
              isAntialiased: true
            });
            viewer.renderer.displayCanvasScaling = Math.min(window.devicePixelRatio, 1); // const data = {
            //   position: { x: 0, y: 0, z: 0 },
            //   rotation: { x: 0, y: 0, z: 0 },
            // };
            // const pane = new Pane();

            _context.next = 7;
            return viewer.addPlugin(_webgi.AssetManagerPlugin);

          case 7:
            manager = _context.sent;
            camera = viewer.scene.activeCamera; // Add plugins individually.

            _context.next = 11;
            return viewer.addPlugin(_webgi.GBufferPlugin);

          case 11:
            _context.next = 13;
            return viewer.addPlugin(new _webgi.ProgressivePlugin(32));

          case 13:
            _context.next = 15;
            return viewer.addPlugin(_webgi.SSRPlugin);

          case 15:
            _context.next = 17;
            return viewer.addPlugin(_webgi.SSAOPlugin);

          case 17:
            _context.next = 19;
            return viewer.addPlugin(_webgi.BloomPlugin);

          case 19:
            // or use this to add all main ones at once.
            // await addBasePlugins(viewer);
            // WEBGi loader
            importer = manager.importer;
            importer.addEventListener("onProgress", function (ev) {
              var _document$querySelect;

              var progressRatio = ev.loaded / ev.total;
              (_document$querySelect = document.querySelector(".progress")) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.setAttribute("style", "transform: scaleX(".concat(progressRatio, ")"));
            });
            importer.addEventListener("onLoad", function (ev) {
              introAnimation();
            });
            viewer.renderer.refreshPipeline();
            _context.next = 25;
            return manager.addFromPath("./assets/scene.glb");

          case 25:
            model = _context.sent;
            object3d = model[0].modelObject;
            modelPosition = object3d.position;
            modelRotation = object3d.rotation;
            loaderElement = document.querySelector(".loader");
            // WEBGI UPDATE
            needsUpdate = true;
            // viewer.addEventListener("preFrame", () => {
            //   if (needsUpdate) {
            //     camera.positionUpdated(true);
            //     camera.targetUpdated(true);
            //     needsUpdate = false;
            //   }
            // });
            // SCROLL TO TOP
            (_document$querySelect2 = document.querySelectorAll(".button--footer")) === null || _document$querySelect2 === void 0 ? void 0 : _document$querySelect2.forEach(function (item) {
              item.addEventListener("click", function () {
                var container = document.getElementsByClassName("mainContainer");
                container[0].scrollTo({
                  top: 0,
                  left: 0,
                  behavior: "smooth"
                });
              });
            });

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _setupViewer.apply(this, arguments);
}

setupViewer();
},{"webgi":"node_modules/webgi/dist/examples/runtime/bundle.m.js","./styles.css":"src/styles.css","gsap":"node_modules/gsap/index.js","gsap/ScrollTrigger":"node_modules/gsap/ScrollTrigger.js","tweakpane":"node_modules/tweakpane/dist/tweakpane.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "58731" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/index.js"], null)
//# sourceMappingURL=/src.a2b27638.js.map